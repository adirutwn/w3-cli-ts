#! /usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports) {
    var CommanderError2 = class extends Error {
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError2 = class extends CommanderError2 {
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports.CommanderError = CommanderError2;
    exports.InvalidArgumentError = InvalidArgumentError2;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Argument2 = class {
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      name() {
        return this._name;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      argRequired() {
        this.required = true;
        return this;
      }
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports.Argument = Argument2;
    exports.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports) {
    var { humanReadableArgName } = require_argument();
    var Help2 = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      compareOptions(a, b) {
        const getSortKey = (option) => {
          return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }
      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions)
          return [];
        const globalOptions = [];
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          const visibleOptions = parentCmd.options.filter((option) => !option.hidden);
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd._args.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd._args.find((argument) => argument.description)) {
          return cmd._args;
        }
        return [];
      }
      subcommandTerm(cmd) {
        const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
      }
      optionTerm(option) {
        return option.flags;
      }
      argumentTerm(argument) {
        return argument.name();
      }
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let parentCmdNames = "";
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          parentCmdNames = parentCmd.name() + " " + parentCmdNames;
        }
        return parentCmdNames + cmdName + " " + cmd.usage();
      }
      commandDescription(cmd) {
        return cmd.description();
      }
      subcommandDescription(cmd) {
        return cmd.summary() || cmd.description();
      }
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices) {
          extraInfo.push(
            `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (option.defaultValue !== void 0) {
          const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        if (option.presetArg !== void 0 && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
          );
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([commandDescription, ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        if (this.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {
            return formatItem(helper.optionTerm(option), helper.optionDescription(option));
          });
          if (globalOptionList.length > 0) {
            output = output.concat(["Global Options:", formatList(globalOptionList), ""]);
          }
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper)
        );
      }
      wrap(str, width, indent, minColumnWidth = 40) {
        if (str.match(/[\n]\s+/))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.slice(0, indent);
        const columnText = str.slice(indent);
        const indentString = " ".repeat(indent);
        const regex2 = new RegExp(".{1," + (columnWidth - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
        const lines = columnText.match(regex2) || [];
        return leadingStr + lines.map((line, i) => {
          if (line.slice(-1) === "\n") {
            line = line.slice(0, line.length - 1);
          }
          return (i > 0 ? indentString : "") + line.trimRight();
        }).join("\n");
      }
    };
    exports.Help = Help2;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports) {
    var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var Option2 = class {
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.presetArg = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
        this.conflictsWith = [];
        this.implied = void 0;
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      preset(arg) {
        this.presetArg = arg;
        return this;
      }
      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }
      implies(impliedOptionValues) {
        this.implied = Object.assign(this.implied || {}, impliedOptionValues);
        return this;
      }
      env(name) {
        this.envVar = name;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      is(arg) {
        return this.short === arg || this.long === arg;
      }
      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    };
    var DualOptions = class {
      constructor(options) {
        this.positiveOptions = /* @__PURE__ */ new Map();
        this.negativeOptions = /* @__PURE__ */ new Map();
        this.dualOptions = /* @__PURE__ */ new Set();
        options.forEach((option) => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey))
          return true;
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== void 0 ? preset : false;
        return option.negate === (negativeValue === value);
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports.Option = Option2;
    exports.splitOptionFlags = splitOptionFlags;
    exports.DualOptions = DualOptions;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1,
            d[i][j - 1] + 1,
            d[i - 1][j - 1] + cost
          );
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length3 = Math.max(word.length, candidate.length);
        const similarity = (length3 - distance) / length3;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports) {
    var EventEmitter2 = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path3 = require("path");
    var fs4 = require("fs");
    var process9 = require("process");
    var { Argument: Argument2, humanReadableArgName } = require_argument();
    var { CommanderError: CommanderError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command2 = class extends EventEmitter2 {
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this._args = [];
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._executableDir = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._summary = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._outputConfiguration = {
          writeOut: (str) => process9.stdout.write(str),
          writeErr: (str) => process9.stderr.write(str),
          getOutHelpWidth: () => process9.stdout.isTTY ? process9.stdout.columns : void 0,
          getErrHelpWidth: () => process9.stderr.isTTY ? process9.stderr.columns : void 0,
          outputError: (str, write2) => write2(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      createCommand(name) {
        return new Command2(name);
      }
      createHelp() {
        return Object.assign(new Help2(), this.configureHelp());
      }
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      createArgument(name, description) {
        return new Argument2(name, description);
      }
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      arguments(names) {
        names.split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      addArgument(argument) {
        const previousArgument = this._args.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this._args.push(argument);
        return this;
      }
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      hook(event, listener) {
        const allowedValues = ["preSubcommand", "preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError2(exitCode, code, message));
        }
        process9.exit(exitCode);
      }
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      createOption(flags, description) {
        return new Option2(flags, description);
      }
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        if (option.negate) {
          const positiveLongFlag = option.long.replace(/^--no-/, "--");
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
          }
        } else if (option.defaultValue !== void 0) {
          this.setOptionValueWithSource(name, option.defaultValue, "default");
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          if (val == null && option.presetArg !== void 0) {
            val = option.presetArg;
          }
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            try {
              val = option.parseArg(val, oldValue);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `${invalidValueMessage} ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = "";
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === "object" && flags instanceof Option2) {
          throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex2 = fn;
          fn = (val, def) => {
            const m = regex2.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
      }
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      storeOptionsAsProperties(storeAsProperties = true) {
        this._storeOptionsAsProperties = !!storeAsProperties;
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        return this;
      }
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, void 0);
      }
      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      getOptionValueSourceWithGlobals(key) {
        let source;
        getCommandAndParents(this).forEach((cmd) => {
          if (cmd.getOptionValueSource(key) !== void 0) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process9.argv;
          if (process9.versions && process9.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process9.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._name && this._scriptPath)
          this.nameFromFilename(this._scriptPath);
        this._name = this._name || "program";
        return userArgs;
      }
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      async parseAsync(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);
        return this;
      }
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        function findFile(baseDir, baseName) {
          const localBin = path3.resolve(baseDir, baseName);
          if (fs4.existsSync(localBin))
            return localBin;
          if (sourceExt.includes(path3.extname(baseName)))
            return void 0;
          const foundExt = sourceExt.find((ext) => fs4.existsSync(`${localBin}${ext}`));
          if (foundExt)
            return `${localBin}${foundExt}`;
          return void 0;
        }
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || "";
        if (this._scriptPath) {
          let resolvedScriptPath;
          try {
            resolvedScriptPath = fs4.realpathSync(this._scriptPath);
          } catch (err) {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path3.resolve(path3.dirname(resolvedScriptPath), executableDir);
        }
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path3.basename(this._scriptPath, path3.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }
        launchWithNode = sourceExt.includes(path3.extname(executableFile));
        let proc;
        if (process9.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process9.execArgv).concat(args);
            proc = childProcess.spawn(process9.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(executableFile);
          args = incrementNodeInspectorPort(process9.execArgv).concat(args);
          proc = childProcess.spawn(process9.execPath, args, { stdio: "inherit" });
        }
        if (!proc.killed) {
          const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
          signals.forEach((signal) => {
            process9.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                proc.kill(signal);
              }
            });
          });
        }
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process9.exit.bind(process9));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError2(process9.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
            const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process9.exit(1);
          } else {
            const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        let hookResult;
        hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, "preSubcommand");
        hookResult = this._chainOrCall(hookResult, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return hookResult;
      }
      _checkNumberOfArguments() {
        this._args.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
          return;
        }
        if (this.args.length > this._args.length) {
          this._excessArguments(this.args);
        }
      }
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            try {
              parsedValue = argument.parseArg(value, previous);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                this.error(message, { exitCode: err.exitCode, code: err.code });
              }
              throw err;
            }
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this._args.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== void 0) {
          this._lifeCycleHooks[event].forEach((hook) => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          if (operands.length === 1) {
            this.help();
          }
          return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let actionResult;
          actionResult = this._chainOrCallHooks(actionResult, "preAction");
          actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            actionResult = this._chainOrCall(actionResult, () => {
              this.parent.emit(commandEvent, operands, unknown);
            });
          }
          actionResult = this._chainOrCallHooks(actionResult, "postAction");
          return actionResult;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter(
          (option) => {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0) {
              return false;
            }
            return this.getOptionValueSource(optionKey) !== "default";
          }
        );
        const optionsWithConflicting = definedNonDefaultOptions.filter(
          (option) => option.conflictsWith.length > 0
        );
        optionsWithConflicting.forEach((option) => {
          const conflictingAndDefined = definedNonDefaultOptions.find(
            (defined) => option.conflictsWith.includes(defined.attributeName())
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }
      _checkForConflictingOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd._checkForConflictingLocalOptions();
        }
      }
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      optsWithGlobals() {
        return getCommandAndParents(this).reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {}
        );
      }
      error(message, errorOptions) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || "commander.error";
        this._exit(exitCode, code, message);
      }
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process9.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process9.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = (optionKey) => {
          return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
        };
        this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
          Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
          });
        });
      }
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: "commander.missingArgument" });
      }
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: "commander.optionMissingArgument" });
      }
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: "commander.missingMandatoryOptionValue" });
      }
      _conflictingOption(option, conflictingOption) {
        const findBestOptionFromValue = (option2) => {
          const optionKey = option2.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
          if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
            return negativeOption;
          }
          return positiveOption || option2;
        };
        const getErrorMessage = (option2) => {
          const bestOption = findBestOptionFromValue(option2);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === "env") {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };
        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: "commander.conflictingOption" });
      }
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: "commander.unknownOption" });
      }
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this._args.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: "commander.excessArguments" });
      }
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: "commander.unknownCommand" });
      }
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      summary(str) {
        if (str === void 0)
          return this._summary;
        this._summary = str;
        return this;
      }
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(
            this.options.length || this._hasHelpOption ? "[options]" : [],
            this.commands.length ? "[command]" : [],
            this._args.length ? args : []
          ).join(" ");
        }
        this._usage = str;
        return this;
      }
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      nameFromFilename(filename) {
        this._name = path3.basename(filename, path3.extname(filename));
        return this;
      }
      executableDir(path4) {
        if (path4 === void 0)
          return this._executableDir;
        this._executableDir = path4;
        return this;
      }
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write2;
        if (context.error) {
          write2 = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write2 = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write2;
        context.command = this;
        return context;
      }
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        this.emit(this._helpLongFlag);
        this.emit("afterHelp", context);
        getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context));
      }
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process9.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function getCommandAndParents(startCommand) {
      const result = [];
      for (let command = startCommand; command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    exports.Command = Command2;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports, module2) {
    var { Argument: Argument2 } = require_argument();
    var { Command: Command2 } = require_command();
    var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
    var { Help: Help2 } = require_help();
    var { Option: Option2 } = require_option();
    exports = module2.exports = new Command2();
    exports.program = exports;
    exports.Argument = Argument2;
    exports.Command = Command2;
    exports.CommanderError = CommanderError2;
    exports.Help = Help2;
    exports.InvalidArgumentError = InvalidArgumentError2;
    exports.InvalidOptionArgumentError = InvalidArgumentError2;
    exports.Option = Option2;
  }
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/mimic-fn/index.js"(exports, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// node_modules/onetime/index.js
var require_onetime = __commonJS({
  "node_modules/onetime/index.js"(exports, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions = /* @__PURE__ */ new WeakMap();
    var onetime2 = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime3 = function(...arguments_) {
        calledFunctions.set(onetime3, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime3, function_);
      calledFunctions.set(onetime3, callCount);
      return onetime3;
    };
    module2.exports = onetime2;
    module2.exports.default = onetime2;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports, module2) {
    var process9 = global.process;
    var processOk = function(process10) {
      return process10 && typeof process10 === "object" && typeof process10.removeListener === "function" && typeof process10.emit === "function" && typeof process10.reallyExit === "function" && typeof process10.listeners === "function" && typeof process10.kill === "function" && typeof process10.pid === "number" && typeof process10.on === "function";
    };
    if (!processOk(process9)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert2 = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process9.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process9.__signal_exit_emitter__) {
        emitter = process9.__signal_exit_emitter__;
      } else {
        emitter = process9.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert2.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process9.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process9.emit = originalProcessEmit;
        process9.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process9.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process9.kill(process9.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process9.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process9.emit = processEmit;
        process9.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process9.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process9.exitCode = code || 0;
        emit("exit", process9.exitCode, null);
        emit("afterexit", process9.exitCode, null);
        originalProcessReallyExit.call(process9, process9.exitCode);
      };
      originalProcessEmit = process9.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process9.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process9.exitCode, null);
          emit("afterexit", process9.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert2;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS({
  "node_modules/cli-spinners/spinners.json"(exports, module2) {
    module2.exports = {
      dots: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u2839",
          "\u2838",
          "\u283C",
          "\u2834",
          "\u2826",
          "\u2827",
          "\u2807",
          "\u280F"
        ]
      },
      dots2: {
        interval: 80,
        frames: [
          "\u28FE",
          "\u28FD",
          "\u28FB",
          "\u28BF",
          "\u287F",
          "\u28DF",
          "\u28EF",
          "\u28F7"
        ]
      },
      dots3: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u281A",
          "\u281E",
          "\u2816",
          "\u2826",
          "\u2834",
          "\u2832",
          "\u2833",
          "\u2813"
        ]
      },
      dots4: {
        interval: 80,
        frames: [
          "\u2804",
          "\u2806",
          "\u2807",
          "\u280B",
          "\u2819",
          "\u2838",
          "\u2830",
          "\u2820",
          "\u2830",
          "\u2838",
          "\u2819",
          "\u280B",
          "\u2807",
          "\u2806"
        ]
      },
      dots5: {
        interval: 80,
        frames: [
          "\u280B",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B"
        ]
      },
      dots6: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2809",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2824",
          "\u2804",
          "\u2804",
          "\u2824",
          "\u2834",
          "\u2832",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u281A",
          "\u2819",
          "\u2809",
          "\u2801"
        ]
      },
      dots7: {
        interval: 80,
        frames: [
          "\u2808",
          "\u2809",
          "\u280B",
          "\u2813",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2816",
          "\u2826",
          "\u2824",
          "\u2820",
          "\u2820",
          "\u2824",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B",
          "\u2809",
          "\u2808"
        ]
      },
      dots8: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2801",
          "\u2809",
          "\u2819",
          "\u281A",
          "\u2812",
          "\u2802",
          "\u2802",
          "\u2812",
          "\u2832",
          "\u2834",
          "\u2824",
          "\u2804",
          "\u2804",
          "\u2824",
          "\u2820",
          "\u2820",
          "\u2824",
          "\u2826",
          "\u2816",
          "\u2812",
          "\u2810",
          "\u2810",
          "\u2812",
          "\u2813",
          "\u280B",
          "\u2809",
          "\u2808",
          "\u2808"
        ]
      },
      dots9: {
        interval: 80,
        frames: [
          "\u28B9",
          "\u28BA",
          "\u28BC",
          "\u28F8",
          "\u28C7",
          "\u2867",
          "\u2857",
          "\u284F"
        ]
      },
      dots10: {
        interval: 80,
        frames: [
          "\u2884",
          "\u2882",
          "\u2881",
          "\u2841",
          "\u2848",
          "\u2850",
          "\u2860"
        ]
      },
      dots11: {
        interval: 100,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2840",
          "\u2880",
          "\u2820",
          "\u2810",
          "\u2808"
        ]
      },
      dots12: {
        interval: 80,
        frames: [
          "\u2880\u2800",
          "\u2840\u2800",
          "\u2804\u2800",
          "\u2882\u2800",
          "\u2842\u2800",
          "\u2805\u2800",
          "\u2883\u2800",
          "\u2843\u2800",
          "\u280D\u2800",
          "\u288B\u2800",
          "\u284B\u2800",
          "\u280D\u2801",
          "\u288B\u2801",
          "\u284B\u2801",
          "\u280D\u2809",
          "\u280B\u2809",
          "\u280B\u2809",
          "\u2809\u2819",
          "\u2809\u2819",
          "\u2809\u2829",
          "\u2808\u2899",
          "\u2808\u2859",
          "\u2888\u2829",
          "\u2840\u2899",
          "\u2804\u2859",
          "\u2882\u2829",
          "\u2842\u2898",
          "\u2805\u2858",
          "\u2883\u2828",
          "\u2843\u2890",
          "\u280D\u2850",
          "\u288B\u2820",
          "\u284B\u2880",
          "\u280D\u2841",
          "\u288B\u2801",
          "\u284B\u2801",
          "\u280D\u2809",
          "\u280B\u2809",
          "\u280B\u2809",
          "\u2809\u2819",
          "\u2809\u2819",
          "\u2809\u2829",
          "\u2808\u2899",
          "\u2808\u2859",
          "\u2808\u2829",
          "\u2800\u2899",
          "\u2800\u2859",
          "\u2800\u2829",
          "\u2800\u2898",
          "\u2800\u2858",
          "\u2800\u2828",
          "\u2800\u2890",
          "\u2800\u2850",
          "\u2800\u2820",
          "\u2800\u2880",
          "\u2800\u2840"
        ]
      },
      dots13: {
        interval: 80,
        frames: [
          "\u28FC",
          "\u28F9",
          "\u28BB",
          "\u283F",
          "\u285F",
          "\u28CF",
          "\u28E7",
          "\u28F6"
        ]
      },
      dots8Bit: {
        interval: 80,
        frames: [
          "\u2800",
          "\u2801",
          "\u2802",
          "\u2803",
          "\u2804",
          "\u2805",
          "\u2806",
          "\u2807",
          "\u2840",
          "\u2841",
          "\u2842",
          "\u2843",
          "\u2844",
          "\u2845",
          "\u2846",
          "\u2847",
          "\u2808",
          "\u2809",
          "\u280A",
          "\u280B",
          "\u280C",
          "\u280D",
          "\u280E",
          "\u280F",
          "\u2848",
          "\u2849",
          "\u284A",
          "\u284B",
          "\u284C",
          "\u284D",
          "\u284E",
          "\u284F",
          "\u2810",
          "\u2811",
          "\u2812",
          "\u2813",
          "\u2814",
          "\u2815",
          "\u2816",
          "\u2817",
          "\u2850",
          "\u2851",
          "\u2852",
          "\u2853",
          "\u2854",
          "\u2855",
          "\u2856",
          "\u2857",
          "\u2818",
          "\u2819",
          "\u281A",
          "\u281B",
          "\u281C",
          "\u281D",
          "\u281E",
          "\u281F",
          "\u2858",
          "\u2859",
          "\u285A",
          "\u285B",
          "\u285C",
          "\u285D",
          "\u285E",
          "\u285F",
          "\u2820",
          "\u2821",
          "\u2822",
          "\u2823",
          "\u2824",
          "\u2825",
          "\u2826",
          "\u2827",
          "\u2860",
          "\u2861",
          "\u2862",
          "\u2863",
          "\u2864",
          "\u2865",
          "\u2866",
          "\u2867",
          "\u2828",
          "\u2829",
          "\u282A",
          "\u282B",
          "\u282C",
          "\u282D",
          "\u282E",
          "\u282F",
          "\u2868",
          "\u2869",
          "\u286A",
          "\u286B",
          "\u286C",
          "\u286D",
          "\u286E",
          "\u286F",
          "\u2830",
          "\u2831",
          "\u2832",
          "\u2833",
          "\u2834",
          "\u2835",
          "\u2836",
          "\u2837",
          "\u2870",
          "\u2871",
          "\u2872",
          "\u2873",
          "\u2874",
          "\u2875",
          "\u2876",
          "\u2877",
          "\u2838",
          "\u2839",
          "\u283A",
          "\u283B",
          "\u283C",
          "\u283D",
          "\u283E",
          "\u283F",
          "\u2878",
          "\u2879",
          "\u287A",
          "\u287B",
          "\u287C",
          "\u287D",
          "\u287E",
          "\u287F",
          "\u2880",
          "\u2881",
          "\u2882",
          "\u2883",
          "\u2884",
          "\u2885",
          "\u2886",
          "\u2887",
          "\u28C0",
          "\u28C1",
          "\u28C2",
          "\u28C3",
          "\u28C4",
          "\u28C5",
          "\u28C6",
          "\u28C7",
          "\u2888",
          "\u2889",
          "\u288A",
          "\u288B",
          "\u288C",
          "\u288D",
          "\u288E",
          "\u288F",
          "\u28C8",
          "\u28C9",
          "\u28CA",
          "\u28CB",
          "\u28CC",
          "\u28CD",
          "\u28CE",
          "\u28CF",
          "\u2890",
          "\u2891",
          "\u2892",
          "\u2893",
          "\u2894",
          "\u2895",
          "\u2896",
          "\u2897",
          "\u28D0",
          "\u28D1",
          "\u28D2",
          "\u28D3",
          "\u28D4",
          "\u28D5",
          "\u28D6",
          "\u28D7",
          "\u2898",
          "\u2899",
          "\u289A",
          "\u289B",
          "\u289C",
          "\u289D",
          "\u289E",
          "\u289F",
          "\u28D8",
          "\u28D9",
          "\u28DA",
          "\u28DB",
          "\u28DC",
          "\u28DD",
          "\u28DE",
          "\u28DF",
          "\u28A0",
          "\u28A1",
          "\u28A2",
          "\u28A3",
          "\u28A4",
          "\u28A5",
          "\u28A6",
          "\u28A7",
          "\u28E0",
          "\u28E1",
          "\u28E2",
          "\u28E3",
          "\u28E4",
          "\u28E5",
          "\u28E6",
          "\u28E7",
          "\u28A8",
          "\u28A9",
          "\u28AA",
          "\u28AB",
          "\u28AC",
          "\u28AD",
          "\u28AE",
          "\u28AF",
          "\u28E8",
          "\u28E9",
          "\u28EA",
          "\u28EB",
          "\u28EC",
          "\u28ED",
          "\u28EE",
          "\u28EF",
          "\u28B0",
          "\u28B1",
          "\u28B2",
          "\u28B3",
          "\u28B4",
          "\u28B5",
          "\u28B6",
          "\u28B7",
          "\u28F0",
          "\u28F1",
          "\u28F2",
          "\u28F3",
          "\u28F4",
          "\u28F5",
          "\u28F6",
          "\u28F7",
          "\u28B8",
          "\u28B9",
          "\u28BA",
          "\u28BB",
          "\u28BC",
          "\u28BD",
          "\u28BE",
          "\u28BF",
          "\u28F8",
          "\u28F9",
          "\u28FA",
          "\u28FB",
          "\u28FC",
          "\u28FD",
          "\u28FE",
          "\u28FF"
        ]
      },
      sand: {
        interval: 80,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2840",
          "\u2848",
          "\u2850",
          "\u2860",
          "\u28C0",
          "\u28C1",
          "\u28C2",
          "\u28C4",
          "\u28CC",
          "\u28D4",
          "\u28E4",
          "\u28E5",
          "\u28E6",
          "\u28EE",
          "\u28F6",
          "\u28F7",
          "\u28FF",
          "\u287F",
          "\u283F",
          "\u289F",
          "\u281F",
          "\u285B",
          "\u281B",
          "\u282B",
          "\u288B",
          "\u280B",
          "\u280D",
          "\u2849",
          "\u2809",
          "\u2811",
          "\u2821",
          "\u2881"
        ]
      },
      line: {
        interval: 130,
        frames: [
          "-",
          "\\",
          "|",
          "/"
        ]
      },
      line2: {
        interval: 100,
        frames: [
          "\u2802",
          "-",
          "\u2013",
          "\u2014",
          "\u2013",
          "-"
        ]
      },
      pipe: {
        interval: 100,
        frames: [
          "\u2524",
          "\u2518",
          "\u2534",
          "\u2514",
          "\u251C",
          "\u250C",
          "\u252C",
          "\u2510"
        ]
      },
      simpleDots: {
        interval: 400,
        frames: [
          ".  ",
          ".. ",
          "...",
          "   "
        ]
      },
      simpleDotsScrolling: {
        interval: 200,
        frames: [
          ".  ",
          ".. ",
          "...",
          " ..",
          "  .",
          "   "
        ]
      },
      star: {
        interval: 70,
        frames: [
          "\u2736",
          "\u2738",
          "\u2739",
          "\u273A",
          "\u2739",
          "\u2737"
        ]
      },
      star2: {
        interval: 80,
        frames: [
          "+",
          "x",
          "*"
        ]
      },
      flip: {
        interval: 70,
        frames: [
          "_",
          "_",
          "_",
          "-",
          "`",
          "`",
          "'",
          "\xB4",
          "-",
          "_",
          "_",
          "_"
        ]
      },
      hamburger: {
        interval: 100,
        frames: [
          "\u2631",
          "\u2632",
          "\u2634"
        ]
      },
      growVertical: {
        interval: 120,
        frames: [
          "\u2581",
          "\u2583",
          "\u2584",
          "\u2585",
          "\u2586",
          "\u2587",
          "\u2586",
          "\u2585",
          "\u2584",
          "\u2583"
        ]
      },
      growHorizontal: {
        interval: 120,
        frames: [
          "\u258F",
          "\u258E",
          "\u258D",
          "\u258C",
          "\u258B",
          "\u258A",
          "\u2589",
          "\u258A",
          "\u258B",
          "\u258C",
          "\u258D",
          "\u258E"
        ]
      },
      balloon: {
        interval: 140,
        frames: [
          " ",
          ".",
          "o",
          "O",
          "@",
          "*",
          " "
        ]
      },
      balloon2: {
        interval: 120,
        frames: [
          ".",
          "o",
          "O",
          "\xB0",
          "O",
          "o",
          "."
        ]
      },
      noise: {
        interval: 100,
        frames: [
          "\u2593",
          "\u2592",
          "\u2591"
        ]
      },
      bounce: {
        interval: 120,
        frames: [
          "\u2801",
          "\u2802",
          "\u2804",
          "\u2802"
        ]
      },
      boxBounce: {
        interval: 120,
        frames: [
          "\u2596",
          "\u2598",
          "\u259D",
          "\u2597"
        ]
      },
      boxBounce2: {
        interval: 100,
        frames: [
          "\u258C",
          "\u2580",
          "\u2590",
          "\u2584"
        ]
      },
      triangle: {
        interval: 50,
        frames: [
          "\u25E2",
          "\u25E3",
          "\u25E4",
          "\u25E5"
        ]
      },
      binary: {
        interval: 80,
        frames: [
          "010010",
          "001100",
          "100101",
          "111010",
          "111101",
          "010111",
          "101011",
          "111000",
          "110011",
          "110101"
        ]
      },
      arc: {
        interval: 100,
        frames: [
          "\u25DC",
          "\u25E0",
          "\u25DD",
          "\u25DE",
          "\u25E1",
          "\u25DF"
        ]
      },
      circle: {
        interval: 120,
        frames: [
          "\u25E1",
          "\u2299",
          "\u25E0"
        ]
      },
      squareCorners: {
        interval: 180,
        frames: [
          "\u25F0",
          "\u25F3",
          "\u25F2",
          "\u25F1"
        ]
      },
      circleQuarters: {
        interval: 120,
        frames: [
          "\u25F4",
          "\u25F7",
          "\u25F6",
          "\u25F5"
        ]
      },
      circleHalves: {
        interval: 50,
        frames: [
          "\u25D0",
          "\u25D3",
          "\u25D1",
          "\u25D2"
        ]
      },
      squish: {
        interval: 100,
        frames: [
          "\u256B",
          "\u256A"
        ]
      },
      toggle: {
        interval: 250,
        frames: [
          "\u22B6",
          "\u22B7"
        ]
      },
      toggle2: {
        interval: 80,
        frames: [
          "\u25AB",
          "\u25AA"
        ]
      },
      toggle3: {
        interval: 120,
        frames: [
          "\u25A1",
          "\u25A0"
        ]
      },
      toggle4: {
        interval: 100,
        frames: [
          "\u25A0",
          "\u25A1",
          "\u25AA",
          "\u25AB"
        ]
      },
      toggle5: {
        interval: 100,
        frames: [
          "\u25AE",
          "\u25AF"
        ]
      },
      toggle6: {
        interval: 300,
        frames: [
          "\u101D",
          "\u1040"
        ]
      },
      toggle7: {
        interval: 80,
        frames: [
          "\u29BE",
          "\u29BF"
        ]
      },
      toggle8: {
        interval: 100,
        frames: [
          "\u25CD",
          "\u25CC"
        ]
      },
      toggle9: {
        interval: 100,
        frames: [
          "\u25C9",
          "\u25CE"
        ]
      },
      toggle10: {
        interval: 100,
        frames: [
          "\u3282",
          "\u3280",
          "\u3281"
        ]
      },
      toggle11: {
        interval: 50,
        frames: [
          "\u29C7",
          "\u29C6"
        ]
      },
      toggle12: {
        interval: 120,
        frames: [
          "\u2617",
          "\u2616"
        ]
      },
      toggle13: {
        interval: 80,
        frames: [
          "=",
          "*",
          "-"
        ]
      },
      arrow: {
        interval: 100,
        frames: [
          "\u2190",
          "\u2196",
          "\u2191",
          "\u2197",
          "\u2192",
          "\u2198",
          "\u2193",
          "\u2199"
        ]
      },
      arrow2: {
        interval: 80,
        frames: [
          "\u2B06\uFE0F ",
          "\u2197\uFE0F ",
          "\u27A1\uFE0F ",
          "\u2198\uFE0F ",
          "\u2B07\uFE0F ",
          "\u2199\uFE0F ",
          "\u2B05\uFE0F ",
          "\u2196\uFE0F "
        ]
      },
      arrow3: {
        interval: 120,
        frames: [
          "\u25B9\u25B9\u25B9\u25B9\u25B9",
          "\u25B8\u25B9\u25B9\u25B9\u25B9",
          "\u25B9\u25B8\u25B9\u25B9\u25B9",
          "\u25B9\u25B9\u25B8\u25B9\u25B9",
          "\u25B9\u25B9\u25B9\u25B8\u25B9",
          "\u25B9\u25B9\u25B9\u25B9\u25B8"
        ]
      },
      bouncingBar: {
        interval: 80,
        frames: [
          "[    ]",
          "[=   ]",
          "[==  ]",
          "[=== ]",
          "[ ===]",
          "[  ==]",
          "[   =]",
          "[    ]",
          "[   =]",
          "[  ==]",
          "[ ===]",
          "[====]",
          "[=== ]",
          "[==  ]",
          "[=   ]"
        ]
      },
      bouncingBall: {
        interval: 80,
        frames: [
          "( \u25CF    )",
          "(  \u25CF   )",
          "(   \u25CF  )",
          "(    \u25CF )",
          "(     \u25CF)",
          "(    \u25CF )",
          "(   \u25CF  )",
          "(  \u25CF   )",
          "( \u25CF    )",
          "(\u25CF     )"
        ]
      },
      smiley: {
        interval: 200,
        frames: [
          "\u{1F604} ",
          "\u{1F61D} "
        ]
      },
      monkey: {
        interval: 300,
        frames: [
          "\u{1F648} ",
          "\u{1F648} ",
          "\u{1F649} ",
          "\u{1F64A} "
        ]
      },
      hearts: {
        interval: 100,
        frames: [
          "\u{1F49B} ",
          "\u{1F499} ",
          "\u{1F49C} ",
          "\u{1F49A} ",
          "\u2764\uFE0F "
        ]
      },
      clock: {
        interval: 100,
        frames: [
          "\u{1F55B} ",
          "\u{1F550} ",
          "\u{1F551} ",
          "\u{1F552} ",
          "\u{1F553} ",
          "\u{1F554} ",
          "\u{1F555} ",
          "\u{1F556} ",
          "\u{1F557} ",
          "\u{1F558} ",
          "\u{1F559} ",
          "\u{1F55A} "
        ]
      },
      earth: {
        interval: 180,
        frames: [
          "\u{1F30D} ",
          "\u{1F30E} ",
          "\u{1F30F} "
        ]
      },
      material: {
        interval: 17,
        frames: [
          "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2588",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581",
          "\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581\u2581"
        ]
      },
      moon: {
        interval: 80,
        frames: [
          "\u{1F311} ",
          "\u{1F312} ",
          "\u{1F313} ",
          "\u{1F314} ",
          "\u{1F315} ",
          "\u{1F316} ",
          "\u{1F317} ",
          "\u{1F318} "
        ]
      },
      runner: {
        interval: 140,
        frames: [
          "\u{1F6B6} ",
          "\u{1F3C3} "
        ]
      },
      pong: {
        interval: 80,
        frames: [
          "\u2590\u2802       \u258C",
          "\u2590\u2808       \u258C",
          "\u2590 \u2802      \u258C",
          "\u2590 \u2820      \u258C",
          "\u2590  \u2840     \u258C",
          "\u2590  \u2820     \u258C",
          "\u2590   \u2802    \u258C",
          "\u2590   \u2808    \u258C",
          "\u2590    \u2802   \u258C",
          "\u2590    \u2820   \u258C",
          "\u2590     \u2840  \u258C",
          "\u2590     \u2820  \u258C",
          "\u2590      \u2802 \u258C",
          "\u2590      \u2808 \u258C",
          "\u2590       \u2802\u258C",
          "\u2590       \u2820\u258C",
          "\u2590       \u2840\u258C",
          "\u2590      \u2820 \u258C",
          "\u2590      \u2802 \u258C",
          "\u2590     \u2808  \u258C",
          "\u2590     \u2802  \u258C",
          "\u2590    \u2820   \u258C",
          "\u2590    \u2840   \u258C",
          "\u2590   \u2820    \u258C",
          "\u2590   \u2802    \u258C",
          "\u2590  \u2808     \u258C",
          "\u2590  \u2802     \u258C",
          "\u2590 \u2820      \u258C",
          "\u2590 \u2840      \u258C",
          "\u2590\u2820       \u258C"
        ]
      },
      shark: {
        interval: 120,
        frames: [
          "\u2590|\\____________\u258C",
          "\u2590_|\\___________\u258C",
          "\u2590__|\\__________\u258C",
          "\u2590___|\\_________\u258C",
          "\u2590____|\\________\u258C",
          "\u2590_____|\\_______\u258C",
          "\u2590______|\\______\u258C",
          "\u2590_______|\\_____\u258C",
          "\u2590________|\\____\u258C",
          "\u2590_________|\\___\u258C",
          "\u2590__________|\\__\u258C",
          "\u2590___________|\\_\u258C",
          "\u2590____________|\\\u258C",
          "\u2590____________/|\u258C",
          "\u2590___________/|_\u258C",
          "\u2590__________/|__\u258C",
          "\u2590_________/|___\u258C",
          "\u2590________/|____\u258C",
          "\u2590_______/|_____\u258C",
          "\u2590______/|______\u258C",
          "\u2590_____/|_______\u258C",
          "\u2590____/|________\u258C",
          "\u2590___/|_________\u258C",
          "\u2590__/|__________\u258C",
          "\u2590_/|___________\u258C",
          "\u2590/|____________\u258C"
        ]
      },
      dqpb: {
        interval: 100,
        frames: [
          "d",
          "q",
          "p",
          "b"
        ]
      },
      weather: {
        interval: 100,
        frames: [
          "\u2600\uFE0F ",
          "\u2600\uFE0F ",
          "\u2600\uFE0F ",
          "\u{1F324} ",
          "\u26C5\uFE0F ",
          "\u{1F325} ",
          "\u2601\uFE0F ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u26C8 ",
          "\u{1F328} ",
          "\u{1F327} ",
          "\u{1F328} ",
          "\u2601\uFE0F ",
          "\u{1F325} ",
          "\u26C5\uFE0F ",
          "\u{1F324} ",
          "\u2600\uFE0F ",
          "\u2600\uFE0F "
        ]
      },
      christmas: {
        interval: 400,
        frames: [
          "\u{1F332}",
          "\u{1F384}"
        ]
      },
      grenade: {
        interval: 80,
        frames: [
          "\u060C  ",
          "\u2032  ",
          " \xB4 ",
          " \u203E ",
          "  \u2E0C",
          "  \u2E0A",
          "  |",
          "  \u204E",
          "  \u2055",
          " \u0DF4 ",
          "  \u2053",
          "   ",
          "   ",
          "   "
        ]
      },
      point: {
        interval: 125,
        frames: [
          "\u2219\u2219\u2219",
          "\u25CF\u2219\u2219",
          "\u2219\u25CF\u2219",
          "\u2219\u2219\u25CF",
          "\u2219\u2219\u2219"
        ]
      },
      layer: {
        interval: 150,
        frames: [
          "-",
          "=",
          "\u2261"
        ]
      },
      betaWave: {
        interval: 80,
        frames: [
          "\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1\u03B2",
          "\u03B2\u03B2\u03B2\u03B2\u03B2\u03B2\u03C1"
        ]
      },
      fingerDance: {
        interval: 160,
        frames: [
          "\u{1F918} ",
          "\u{1F91F} ",
          "\u{1F596} ",
          "\u270B ",
          "\u{1F91A} ",
          "\u{1F446} "
        ]
      },
      fistBump: {
        interval: 80,
        frames: [
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u{1F91C}\u3000\u3000\u3000\u3000\u{1F91B} ",
          "\u3000\u{1F91C}\u3000\u3000\u{1F91B}\u3000 ",
          "\u3000\u3000\u{1F91C}\u{1F91B}\u3000\u3000 ",
          "\u3000\u{1F91C}\u2728\u{1F91B}\u3000\u3000 ",
          "\u{1F91C}\u3000\u2728\u3000\u{1F91B}\u3000 "
        ]
      },
      soccerHeader: {
        interval: 80,
        frames: [
          " \u{1F9D1}\u26BD\uFE0F       \u{1F9D1} ",
          "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} ",
          "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
          "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
          "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
          "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
          "\u{1F9D1}       \u26BD\uFE0F\u{1F9D1}  ",
          "\u{1F9D1}      \u26BD\uFE0F  \u{1F9D1} ",
          "\u{1F9D1}     \u26BD\uFE0F   \u{1F9D1} ",
          "\u{1F9D1}    \u26BD\uFE0F    \u{1F9D1} ",
          "\u{1F9D1}   \u26BD\uFE0F     \u{1F9D1} ",
          "\u{1F9D1}  \u26BD\uFE0F      \u{1F9D1} "
        ]
      },
      mindblown: {
        interval: 160,
        frames: [
          "\u{1F610} ",
          "\u{1F610} ",
          "\u{1F62E} ",
          "\u{1F62E} ",
          "\u{1F626} ",
          "\u{1F626} ",
          "\u{1F627} ",
          "\u{1F627} ",
          "\u{1F92F} ",
          "\u{1F4A5} ",
          "\u2728 ",
          "\u3000 ",
          "\u3000 ",
          "\u3000 "
        ]
      },
      speaker: {
        interval: 160,
        frames: [
          "\u{1F508} ",
          "\u{1F509} ",
          "\u{1F50A} ",
          "\u{1F509} "
        ]
      },
      orangePulse: {
        interval: 100,
        frames: [
          "\u{1F538} ",
          "\u{1F536} ",
          "\u{1F7E0} ",
          "\u{1F7E0} ",
          "\u{1F536} "
        ]
      },
      bluePulse: {
        interval: 100,
        frames: [
          "\u{1F539} ",
          "\u{1F537} ",
          "\u{1F535} ",
          "\u{1F535} ",
          "\u{1F537} "
        ]
      },
      orangeBluePulse: {
        interval: 100,
        frames: [
          "\u{1F538} ",
          "\u{1F536} ",
          "\u{1F7E0} ",
          "\u{1F7E0} ",
          "\u{1F536} ",
          "\u{1F539} ",
          "\u{1F537} ",
          "\u{1F535} ",
          "\u{1F535} ",
          "\u{1F537} "
        ]
      },
      timeTravel: {
        interval: 100,
        frames: [
          "\u{1F55B} ",
          "\u{1F55A} ",
          "\u{1F559} ",
          "\u{1F558} ",
          "\u{1F557} ",
          "\u{1F556} ",
          "\u{1F555} ",
          "\u{1F554} ",
          "\u{1F553} ",
          "\u{1F552} ",
          "\u{1F551} ",
          "\u{1F550} "
        ]
      },
      aesthetic: {
        interval: 80,
        frames: [
          "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1",
          "\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0",
          "\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1"
        ]
      },
      dwarfFortress: {
        interval: 80,
        frames: [
          " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A\u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "\u263A \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A\u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u263A \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A\u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u263A \u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2593\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2592\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A\u2591\u2588\u2588\xA3\xA3\xA3  ",
          "   \u263A \u2588\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2588\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2593\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2592\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
          "    \u263A\u2591\u2588\xA3\xA3\xA3  ",
          "    \u263A \u2588\xA3\xA3\xA3  ",
          "     \u263A\u2588\xA3\xA3\xA3  ",
          "     \u263A\u2588\xA3\xA3\xA3  ",
          "     \u263A\u2593\xA3\xA3\xA3  ",
          "     \u263A\u2593\xA3\xA3\xA3  ",
          "     \u263A\u2592\xA3\xA3\xA3  ",
          "     \u263A\u2592\xA3\xA3\xA3  ",
          "     \u263A\u2591\xA3\xA3\xA3  ",
          "     \u263A\u2591\xA3\xA3\xA3  ",
          "     \u263A \xA3\xA3\xA3  ",
          "      \u263A\xA3\xA3\xA3  ",
          "      \u263A\xA3\xA3\xA3  ",
          "      \u263A\u2593\xA3\xA3  ",
          "      \u263A\u2593\xA3\xA3  ",
          "      \u263A\u2592\xA3\xA3  ",
          "      \u263A\u2592\xA3\xA3  ",
          "      \u263A\u2591\xA3\xA3  ",
          "      \u263A\u2591\xA3\xA3  ",
          "      \u263A \xA3\xA3  ",
          "       \u263A\xA3\xA3  ",
          "       \u263A\xA3\xA3  ",
          "       \u263A\u2593\xA3  ",
          "       \u263A\u2593\xA3  ",
          "       \u263A\u2592\xA3  ",
          "       \u263A\u2592\xA3  ",
          "       \u263A\u2591\xA3  ",
          "       \u263A\u2591\xA3  ",
          "       \u263A \xA3  ",
          "        \u263A\xA3  ",
          "        \u263A\xA3  ",
          "        \u263A\u2593  ",
          "        \u263A\u2593  ",
          "        \u263A\u2592  ",
          "        \u263A\u2592  ",
          "        \u263A\u2591  ",
          "        \u263A\u2591  ",
          "        \u263A   ",
          "        \u263A  &",
          "        \u263A \u263C&",
          "       \u263A \u263C &",
          "       \u263A\u263C  &",
          "      \u263A\u263C  & ",
          "      \u203C   & ",
          "     \u263A   &  ",
          "    \u203C    &  ",
          "   \u263A    &   ",
          "  \u203C     &   ",
          " \u263A     &    ",
          "\u203C      &    ",
          "      &     ",
          "      &     ",
          "     &   \u2591  ",
          "     &   \u2592  ",
          "    &    \u2593  ",
          "    &    \xA3  ",
          "   &    \u2591\xA3  ",
          "   &    \u2592\xA3  ",
          "  &     \u2593\xA3  ",
          "  &     \xA3\xA3  ",
          " &     \u2591\xA3\xA3  ",
          " &     \u2592\xA3\xA3  ",
          "&      \u2593\xA3\xA3  ",
          "&      \xA3\xA3\xA3  ",
          "      \u2591\xA3\xA3\xA3  ",
          "      \u2592\xA3\xA3\xA3  ",
          "      \u2593\xA3\xA3\xA3  ",
          "      \u2588\xA3\xA3\xA3  ",
          "     \u2591\u2588\xA3\xA3\xA3  ",
          "     \u2592\u2588\xA3\xA3\xA3  ",
          "     \u2593\u2588\xA3\xA3\xA3  ",
          "     \u2588\u2588\xA3\xA3\xA3  ",
          "    \u2591\u2588\u2588\xA3\xA3\xA3  ",
          "    \u2592\u2588\u2588\xA3\xA3\xA3  ",
          "    \u2593\u2588\u2588\xA3\xA3\xA3  ",
          "    \u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2591\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2592\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2593\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "   \u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2591\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2592\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2593\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          "  \u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2591\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2592\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2593\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  ",
          " \u2588\u2588\u2588\u2588\u2588\u2588\xA3\xA3\xA3  "
        ]
      }
    };
  }
});

// node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS({
  "node_modules/cli-spinners/index.js"(exports, module2) {
    "use strict";
    var spinners = Object.assign({}, require_spinners());
    var spinnersList = Object.keys(spinners);
    Object.defineProperty(spinners, "random", {
      get() {
        const randomIndex = Math.floor(Math.random() * spinnersList.length);
        const spinnerName = spinnersList[randomIndex];
        return spinners[spinnerName];
      }
    });
    module2.exports = spinners;
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports, module2) {
    var clone = function() {
      "use strict";
      function clone2(parent, circular, depth, prototype3) {
        var filter2;
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype3 = circular.prototype;
          filter2 = circular.filter;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 == 0)
            return parent2;
          var child;
          var proto2;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else {
            if (typeof prototype3 == "undefined") {
              proto2 = Object.getPrototypeOf(parent2);
              child = Object.create(proto2);
            } else {
              child = Object.create(prototype3);
              proto2 = prototype3;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          for (var i in parent2) {
            var attrs;
            if (proto2) {
              attrs = Object.getOwnPropertyDescriptor(proto2, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c3 = function() {
        };
        c3.prototype = parent;
        return new c3();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      ;
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      ;
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      ;
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      ;
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      ;
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone;
    }
  }
});

// node_modules/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/defaults/index.js"(exports, module2) {
    var clone = require_clone();
    module2.exports = function(options, defaults2) {
      options = options || {};
      Object.keys(defaults2).forEach(function(key) {
        if (typeof options[key] === "undefined") {
          options[key] = clone(defaults2[key]);
        }
      });
      return options;
    };
  }
});

// node_modules/wcwidth/combining.js
var require_combining = __commonJS({
  "node_modules/wcwidth/combining.js"(exports, module2) {
    module2.exports = [
      [768, 879],
      [1155, 1158],
      [1160, 1161],
      [1425, 1469],
      [1471, 1471],
      [1473, 1474],
      [1476, 1477],
      [1479, 1479],
      [1536, 1539],
      [1552, 1557],
      [1611, 1630],
      [1648, 1648],
      [1750, 1764],
      [1767, 1768],
      [1770, 1773],
      [1807, 1807],
      [1809, 1809],
      [1840, 1866],
      [1958, 1968],
      [2027, 2035],
      [2305, 2306],
      [2364, 2364],
      [2369, 2376],
      [2381, 2381],
      [2385, 2388],
      [2402, 2403],
      [2433, 2433],
      [2492, 2492],
      [2497, 2500],
      [2509, 2509],
      [2530, 2531],
      [2561, 2562],
      [2620, 2620],
      [2625, 2626],
      [2631, 2632],
      [2635, 2637],
      [2672, 2673],
      [2689, 2690],
      [2748, 2748],
      [2753, 2757],
      [2759, 2760],
      [2765, 2765],
      [2786, 2787],
      [2817, 2817],
      [2876, 2876],
      [2879, 2879],
      [2881, 2883],
      [2893, 2893],
      [2902, 2902],
      [2946, 2946],
      [3008, 3008],
      [3021, 3021],
      [3134, 3136],
      [3142, 3144],
      [3146, 3149],
      [3157, 3158],
      [3260, 3260],
      [3263, 3263],
      [3270, 3270],
      [3276, 3277],
      [3298, 3299],
      [3393, 3395],
      [3405, 3405],
      [3530, 3530],
      [3538, 3540],
      [3542, 3542],
      [3633, 3633],
      [3636, 3642],
      [3655, 3662],
      [3761, 3761],
      [3764, 3769],
      [3771, 3772],
      [3784, 3789],
      [3864, 3865],
      [3893, 3893],
      [3895, 3895],
      [3897, 3897],
      [3953, 3966],
      [3968, 3972],
      [3974, 3975],
      [3984, 3991],
      [3993, 4028],
      [4038, 4038],
      [4141, 4144],
      [4146, 4146],
      [4150, 4151],
      [4153, 4153],
      [4184, 4185],
      [4448, 4607],
      [4959, 4959],
      [5906, 5908],
      [5938, 5940],
      [5970, 5971],
      [6002, 6003],
      [6068, 6069],
      [6071, 6077],
      [6086, 6086],
      [6089, 6099],
      [6109, 6109],
      [6155, 6157],
      [6313, 6313],
      [6432, 6434],
      [6439, 6440],
      [6450, 6450],
      [6457, 6459],
      [6679, 6680],
      [6912, 6915],
      [6964, 6964],
      [6966, 6970],
      [6972, 6972],
      [6978, 6978],
      [7019, 7027],
      [7616, 7626],
      [7678, 7679],
      [8203, 8207],
      [8234, 8238],
      [8288, 8291],
      [8298, 8303],
      [8400, 8431],
      [12330, 12335],
      [12441, 12442],
      [43014, 43014],
      [43019, 43019],
      [43045, 43046],
      [64286, 64286],
      [65024, 65039],
      [65056, 65059],
      [65279, 65279],
      [65529, 65531],
      [68097, 68099],
      [68101, 68102],
      [68108, 68111],
      [68152, 68154],
      [68159, 68159],
      [119143, 119145],
      [119155, 119170],
      [119173, 119179],
      [119210, 119213],
      [119362, 119364],
      [917505, 917505],
      [917536, 917631],
      [917760, 917999]
    ];
  }
});

// node_modules/wcwidth/index.js
var require_wcwidth = __commonJS({
  "node_modules/wcwidth/index.js"(exports, module2) {
    "use strict";
    var defaults2 = require_defaults();
    var combining = require_combining();
    var DEFAULTS = {
      nul: 0,
      control: 0
    };
    module2.exports = function wcwidth3(str) {
      return wcswidth(str, DEFAULTS);
    };
    module2.exports.config = function(opts) {
      opts = defaults2(opts || {}, DEFAULTS);
      return function wcwidth3(str) {
        return wcswidth(str, opts);
      };
    };
    function wcswidth(str, opts) {
      if (typeof str !== "string")
        return wcwidth2(str, opts);
      var s = 0;
      for (var i = 0; i < str.length; i++) {
        var n = wcwidth2(str.charCodeAt(i), opts);
        if (n < 0)
          return -1;
        s += n;
      }
      return s;
    }
    function wcwidth2(ucs, opts) {
      if (ucs === 0)
        return opts.nul;
      if (ucs < 32 || ucs >= 127 && ucs < 160)
        return opts.control;
      if (bisearch(ucs))
        return 0;
      return 1 + (ucs >= 4352 && (ucs <= 4447 || ucs == 9001 || ucs == 9002 || ucs >= 11904 && ucs <= 42191 && ucs != 12351 || ucs >= 44032 && ucs <= 55203 || ucs >= 63744 && ucs <= 64255 || ucs >= 65040 && ucs <= 65049 || ucs >= 65072 && ucs <= 65135 || ucs >= 65280 && ucs <= 65376 || ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
    }
    function bisearch(ucs) {
      var min = 0;
      var max = combining.length - 1;
      var mid;
      if (ucs < combining[0][0] || ucs > combining[max][1])
        return false;
      while (max >= min) {
        mid = Math.floor((min + max) / 2);
        if (ucs > combining[mid][1])
          min = mid + 1;
        else if (ucs < combining[mid][0])
          max = mid - 1;
        else
          return true;
      }
      return false;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c3 = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c3;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c3;
          }
          this.length -= c3;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c3 = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c3;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c3;
          }
          this.length -= c3;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream4, err) {
      var rState = stream4._readableState;
      var wState = stream4._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream4.destroy(err);
      else
        stream4.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  "node_modules/readable-stream/errors.js"(exports, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith2(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith2(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream4, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream4 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream4, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream4, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream4, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream4, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream4, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream4, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream4, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream4, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream4._writev(chunk, state.onwrite);
      else
        stream4._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream4, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream4, state);
        stream4._writableState.errorEmitted = true;
        errorOrDestroy(stream4, er);
      } else {
        cb(er);
        stream4._writableState.errorEmitted = true;
        errorOrDestroy(stream4, er);
        finishMaybe(stream4, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream4, er) {
      var state = stream4._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream4, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream4.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream4, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream4, state, finished, cb);
        } else {
          afterWrite(stream4, state, finished, cb);
        }
      }
    }
    function afterWrite(stream4, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream4, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream4, state);
    }
    function onwriteDrain(stream4, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream4.emit("drain");
      }
    }
    function clearBuffer(stream4, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream4._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream4, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream4, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream4, state) {
      stream4._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream4, err);
        }
        state.prefinished = true;
        stream4.emit("prefinish");
        finishMaybe(stream4, state);
      });
    }
    function prefinish(stream4, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream4._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream4, state);
        } else {
          state.prefinished = true;
          stream4.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream4, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream4, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream4.emit("finish");
          if (state.autoDestroy) {
            var rState = stream4._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream4.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream4, state, cb) {
      state.ending = true;
      finishMaybe(stream4, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream4.once("finish", cb);
      }
      state.ended = true;
      stream4.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length3) {
      return Buffer2(arg, encodingOrOffset, length3);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length3) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length3);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c3 = r.charCodeAt(r.length - 1);
          if (c3 >= 55296 && c3 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop5() {
    }
    function isRequest(stream4) {
      return stream4.setHeader && typeof stream4.abort === "function";
    }
    function eos(stream4, opts, callback) {
      if (typeof opts === "function")
        return eos(stream4, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop5);
      var readable = opts.readable || opts.readable !== false && stream4.readable;
      var writable = opts.writable || opts.writable !== false && stream4.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream4.writable)
          onfinish();
      };
      var writableEnded = stream4._writableState && stream4._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream4);
      };
      var readableEnded = stream4._readableState && stream4._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream4);
      };
      var onerror = function onerror2(err) {
        callback.call(stream4, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream4._readableState || !stream4._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream4, err);
        }
        if (writable && !writableEnded) {
          if (!stream4._writableState || !stream4._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream4, err);
        }
      };
      var onrequest = function onrequest2() {
        stream4.req.on("finish", onfinish);
      };
      if (isRequest(stream4)) {
        stream4.on("complete", onfinish);
        stream4.on("abort", onclose);
        if (stream4.req)
          onrequest();
        else
          stream4.on("request", onrequest);
      } else if (writable && !stream4._writableState) {
        stream4.on("end", onlegacyfinish);
        stream4.on("close", onlegacyfinish);
      }
      stream4.on("end", onend);
      stream4.on("finish", onfinish);
      if (opts.error !== false)
        stream4.on("error", onerror);
      stream4.on("close", onclose);
      return function() {
        stream4.removeListener("complete", onfinish);
        stream4.removeListener("abort", onclose);
        stream4.removeListener("request", onrequest);
        if (stream4.req)
          stream4.req.removeListener("finish", onfinish);
        stream4.removeListener("end", onlegacyfinish);
        stream4.removeListener("close", onlegacyfinish);
        stream4.removeListener("finish", onfinish);
        stream4.removeListener("end", onend);
        stream4.removeListener("error", onerror);
        stream4.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream4) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream4,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream4._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream4, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream4.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable2, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable2(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    module2.exports = Readable2;
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable2, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream4, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream4 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream4, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream4._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream4, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream4, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream4, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream4, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream4, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream4, state, chunk, false);
              else
                maybeReadMore(stream4, state);
            } else {
              addChunk(stream4, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream4, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream4, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream4.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream4);
      }
      maybeReadMore(stream4, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream4, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream4);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream4);
        }
      }
    }
    function emitReadable(stream4) {
      var state = stream4._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream4);
      }
    }
    function emitReadable_(stream4) {
      var state = stream4._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream4.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream4);
    }
    function maybeReadMore(stream4, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream4, state);
      }
    }
    function maybeReadMore_(stream4, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream4.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream4, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream4, state);
      }
    }
    function resume_(stream4, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream4.read(0);
      }
      state.resumeScheduled = false;
      stream4.emit("resume");
      flow(stream4);
      if (state.flowing && !state.reading)
        stream4.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream4) {
      var state = stream4._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream4.read() !== null)
        ;
    }
    Readable2.prototype.wrap = function(stream4) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream4.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream4.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream4.pause();
        }
      });
      for (var i in stream4) {
        if (this[i] === void 0 && typeof stream4[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream4[method].apply(stream4, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream4.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream4.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get2() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      enumerable: false,
      get: function get2() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      enumerable: false,
      get: function get2() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      enumerable: false,
      get: function get2() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream4) {
      var state = stream4._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream4);
      }
    }
    function endReadableNT(state, stream4) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream4.readable = false;
        stream4.emit("end");
        if (state.autoDestroy) {
          var wState = stream4._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream4.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream4, er, data) {
      if (er)
        return stream4.emit("error", er);
      if (data != null)
        stream4.push(data);
      if (stream4._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream4._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream4.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop5(err) {
      if (err)
        throw err;
    }
    function isRequest(stream4) {
      return stream4.setHeader && typeof stream4.abort === "function";
    }
    function destroyer(stream4, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream4.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream4, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream4))
          return stream4.abort();
        if (typeof stream4.destroy === "function")
          return stream4.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop5;
      if (typeof streams[streams.length - 1] !== "function")
        return noop5;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream4, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream4, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get2(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString3(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append2(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var inherits2 = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream2(callback) {
      if (!(this instanceof BufferListStream2)) {
        return new BufferListStream2(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits2(BufferListStream2, DuplexStream);
    Object.assign(BufferListStream2.prototype, BufferList.prototype);
    BufferListStream2.prototype._new = function _new(callback) {
      return new BufferListStream2(callback);
    };
    BufferListStream2.prototype._write = function _write2(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream2.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream2.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream2.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream2.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream2 || b instanceof BufferList || BufferListStream2.isBufferList(b);
    };
    BufferListStream2.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream2;
    module2.exports.BufferListStream = BufferListStream2;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFunction = void 0;
    function isFunction2(value) {
      return typeof value === "function";
    }
    exports.isFunction = isFunction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createErrorClass = void 0;
    function createErrorClass(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports.createErrorClass = createErrorClass;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrRemove = void 0;
    function arrRemove(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports.arrRemove = arrRemove;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty = new Subscription2();
        empty.closed = true;
        return empty;
      }();
      return Subscription2;
    }();
    exports.Subscription = Subscription;
    exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports.isSubscription = isSubscription;
    function execFinalizer(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.config = void 0;
    exports.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutProvider = void 0;
    exports.timeoutProvider = {
      setTimeout: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports.reportUnhandledError = reportUnhandledError;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noop = void 0;
    function noop5() {
    }
    exports.noop = noop5;
  }
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;
    exports.COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    function errorNotification(error) {
      return createNotification("E", void 0, error);
    }
    exports.errorNotification = errorNotification;
    function nextNotification(value) {
      return createNotification("N", value, void 0);
    }
    exports.nextNotification = nextNotification;
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error
      };
    }
    exports.createNotification = createNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.captureError = exports.errorContext = void 0;
    var config_1 = require_config();
    var context = null;
    function errorContext(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
          context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
          var _a = context, errorThrown = _a.errorThrown, error = _a.error;
          context = null;
          if (errorThrown) {
            throw error;
          }
        }
      } else {
        cb();
      }
    }
    exports.errorContext = errorContext;
    function captureError(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
      }
    }
    exports.captureError = captureError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports.Subscriber = Subscriber;
    var _bind = Function.prototype.bind;
    function bind2(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind2(observerOrNext.next, context_1),
              error: observerOrNext.error && bind2(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind2(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    exports.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error);
      } else {
        reportUnhandledError_1.reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observable = void 0;
    exports.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.identity = void 0;
    function identity(x) {
      return x;
    }
    exports.identity = identity;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pipeFromArray = exports.pipe = void 0;
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports.pipeFromArray = pipeFromArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction();
    var errorContext_1 = require_errorContext();
    var Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable = new Observable2();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
        errorContext_1.errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable2.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    exports.Observable = Observable;
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.operate = exports.hasLift = void 0;
    var isFunction_1 = require_isFunction();
    function hasLift(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports.hasLift = hasLift;
    function operate(init) {
      return function(source) {
        if (hasLift(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports.operate = operate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    exports.createOperatorSubscriber = createOperatorSubscriber;
    var OperatorSubscriber = function(_super) {
      __extends(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.OperatorSubscriber = OperatorSubscriber;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports.refCount = refCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports.ConnectableObservable = ConnectableObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.performanceTimestampProvider = void 0;
    exports.performanceTimestampProvider = {
      now: function() {
        return (exports.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports.animationFrameProvider = {
      schedule: function(callback) {
        var request2 = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports.animationFrameProvider.delegate;
        if (delegate) {
          request2 = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request2(function(timestamp) {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames(timestampProvider) {
      return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    exports.animationFrames = animationFrames;
    function animationFramesFactory(timestampProvider) {
      return new Observable_1.Observable(function(subscriber) {
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var id = 0;
        var run = function() {
          if (!subscriber.closed) {
            id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
              id = 0;
              var now = provider.now();
              subscriber.next({
                timestamp: timestampProvider ? now : timestamp,
                elapsed: now - start
              });
              run();
            });
          }
        };
        run();
        return function() {
          if (id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          }
        };
      });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousSubject = exports.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable_1.Observable);
    exports.Subject = Subject;
    var AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
    exports.AnonymousSubject = AnonymousSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject_1.Subject);
    exports.BehaviorSubject = BehaviorSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dateTimestampProvider = void 0;
    exports.dateTimestampProvider = {
      now: function() {
        return (exports.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last = i;
          }
          last && _buffer.splice(0, last + 1);
        }
      };
      return ReplaySubject2;
    }(Subject_1.Subject);
    exports.ReplaySubject = ReplaySubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject_1.Subject);
    exports.AsyncSubject = AsyncSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports.Action = Action;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intervalProvider = void 0;
    exports.intervalProvider = {
      setInterval: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncAction = void 0;
    var Action_1 = require_Action();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider_1.intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports.AsyncAction = AsyncAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestTools = exports.Immediate = void 0;
    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }
      return false;
    }
    exports.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
    exports.TestTools = {
      pending: function() {
        return Object.keys(activeHandles).length;
      }
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate2 = Immediate_1.Immediate.setImmediate;
    var clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray([], __read(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          if (scheduler._scheduled === id) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AsapAction = AsapAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      };
      Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler2;
    }();
    exports.Scheduler = Scheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports.AsyncScheduler = AsyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AsapScheduler = AsapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asap = exports.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports.asap = exports.asapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.async = exports.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports.async = exports.asyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay > 0) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && delay > 0 || delay == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction_1.AsyncAction);
    exports.QueueAction = QueueAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.QueueScheduler = QueueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queue = exports.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports.queue = exports.queueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AnimationFrameAction = AnimationFrameAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AnimationFrameScheduler = AnimationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrame = exports.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports.animationFrame = exports.animationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VirtualAction = exports.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.VirtualTimeScheduler = VirtualTimeScheduler;
    var VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (Number.isFinite(delay)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay);
        }
      };
      VirtualAction2.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction_1.AsyncAction);
    exports.VirtualAction = VirtualAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.empty = exports.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }
    exports.empty = empty;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isScheduler = void 0;
    var isFunction_1 = require_isFunction();
    function isScheduler(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports.isScheduler = isScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/args.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;
    var isFunction_1 = require_isFunction();
    var isScheduler_1 = require_isScheduler();
    function last(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector(args) {
      return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
    }
    exports.popResultSelector = popResultSelector;
    function popScheduler(args) {
      return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
    }
    exports.popScheduler = popScheduler;
    function popNumber(args, defaultValue) {
      return typeof last(args) === "number" ? args.pop() : defaultValue;
    }
    exports.popNumber = popNumber;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrayLike = void 0;
    exports.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromise = void 0;
    var isFunction_1 = require_isFunction();
    function isPromise(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports.isPromise = isPromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction();
    function isInteropObservable(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports.isInteropObservable = isInteropObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction();
    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iterator = exports.getSymbolIterator = void 0;
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports.getSymbolIterator = getSymbolIterator;
    exports.iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    function isIterable(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports.isIterable = isIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports) {
    "use strict";
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle2(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle2(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction();
    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              reader = readableStream.getReader();
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 9, 10]);
              _b.label = 2;
            case 2:
              if (false)
                return [3, 8];
              return [4, __await(reader.read())];
            case 3:
              _a = _b.sent(), value = _a.value, done = _a.done;
              if (!done)
                return [3, 5];
              return [4, __await(void 0)];
            case 4:
              return [2, _b.sent()];
            case 5:
              return [4, __await(value)];
            case 6:
              return [4, _b.sent()];
            case 7:
              _b.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
    function isReadableStreamLike(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports.isReadableStreamLike = isReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle2(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle2(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.innerFrom = innerFrom;
    function fromInteropObservable(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports.fromInteropObservable = fromInteropObservable;
    function fromArrayLike(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    exports.fromArrayLike = fromArrayLike;
    function fromPromise(promise) {
      return new Observable_1.Observable(function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports.fromPromise = fromPromise;
    function fromIterable(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a;
        try {
          for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
              _a.call(iterable_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports.fromIterable = fromIterable;
    function fromAsyncIterable(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process9(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports.fromAsyncIterable = fromAsyncIterable;
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports.fromReadableStreamLike = fromReadableStreamLike;
    function process9(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues(asyncIterable);
              _b.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
                return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b.sent();
              e_2 = { error: e_2_1 };
              return [3, 11];
            case 6:
              _b.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
                return [3, 8];
              return [4, _a.call(asyncIterable_1)];
            case 7:
              _b.sent();
              _b.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2)
                throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeSchedule = void 0;
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
      if (delay === void 0) {
        delay = 0;
      }
      if (repeat === void 0) {
        repeat = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) {
          parentSubscription.add(this.schedule(null, delay));
        } else {
          this.unsubscribe();
        }
      }, delay);
      parentSubscription.add(scheduleSubscription);
      if (!repeat) {
        return scheduleSubscription;
      }
    }
    exports.executeSchedule = executeSchedule;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay);
        }));
      });
    }
    exports.observeOn = observeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay));
      });
    }
    exports.subscribeOn = subscribeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.scheduleObservable = scheduleObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.schedulePromise = schedulePromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports.scheduleArray = scheduleArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a;
            var value;
            var done;
            try {
              _a = iterator.next(), value = _a.value, done = _a.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
      });
    }
    exports.scheduleIterable = scheduleIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator.next().then(function(result) {
              if (result.done) {
                subscriber.complete();
              } else {
                subscriber.next(result.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports.scheduleAsyncIterable = scheduleAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.scheduled = scheduled;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports.from = from;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from2();
    function of() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports.of = of;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function throwError(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
      } : init);
    }
    exports.throwError = throwError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Notification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction();
    var NotificationKind;
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
    exports.Notification = Notification;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports.observeNotification = observeNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function isObservable(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports.isObservable = isObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports.lastValueFrom = lastValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom(source, config) {
      var hasConfig = typeof config === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports.firstValueFrom = firstValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDate = void 0;
    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports.isValidDate = isValidDate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeout = exports.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout(config, schedulerArg) {
      var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
      });
    }
    exports.timeout = timeout;
    function timeoutErrorFactory(info) {
      throw new exports.TimeoutError(info);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map2(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports.map = map2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapOneOrManyArgs = void 0;
    var map_1 = require_map();
    var isArray2 = Array.isArray;
    function callOrApply(fn, args) {
      return isArray2(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map_1.map(function(args) {
        return callOrApply(fn, args);
      });
    }
    exports.mapOneOrManyArgs = mapOneOrManyArgs;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
              function() {
                var results = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  results[_i2] = arguments[_i2];
                }
                if (isNodeStyle) {
                  var err = results.shift();
                  if (err != null) {
                    subject.error(err);
                    return;
                  }
                }
                subject.next(1 < results.length ? results : results[0]);
                isComplete_1 = true;
                if (isAsync_1) {
                  subject.complete();
                }
              }
            ]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports.bindCallbackInternals = bindCallbackInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports.bindCallback = bindCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports.bindNodeCallback = bindNodeCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsArgArrayOrObject = void 0;
    var isArray2 = Array.isArray;
    var getPrototypeOf2 = Object.getPrototypeOf;
    var objectProto = Object.prototype;
    var getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray2(first_1)) {
          return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
          var keys = getKeys(first_1);
          return {
            args: keys.map(function(key) {
              return first_1[key];
            }),
            keys
          };
        }
      }
      return { args, keys: null };
    }
    exports.argsArgArrayOrObject = argsArgArrayOrObject;
    function isPOJO(obj) {
      return obj && typeof obj === "object" && getPrototypeOf2(obj) === objectProto;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createObject = void 0;
    function createObject(keys, values) {
      return keys.reduce(function(result, key, i) {
        return result[key] = values[i], result;
      }, {});
    }
    exports.createObject = createObject;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestInit = exports.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from2();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
        return createObject_1.createObject(keys, values);
      } : identity_1.identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.combineLatest = combineLatest;
    function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule(scheduler, function() {
          var length3 = observables.length;
          var values = new Array(length3);
          var active = length3;
          var remainingFirstValues = length3;
          var _loop_1 = function(i2) {
            maybeSchedule(scheduler, function() {
              var source = from_1.from(observables[i2], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values[i2] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i = 0; i < length3; i++) {
            _loop_1(i);
          }
        }, subscriber);
      };
    }
    exports.combineLatestInit = combineLatestInit;
    function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
      var buffer = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
      };
      var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports.mergeInternals = mergeInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap(function(a, i) {
          return map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          })(innerFrom_1.innerFrom(project(a, i)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports.mergeMap = mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports.mergeAll = mergeAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }
    exports.concatAll = concatAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from2();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer3(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports.defer = defer3;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable(source, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connection = null;
      var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
      var subject = connector();
      var result = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result;
    }
    exports.connectable = connectable;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
      var result = new Observable_1.Observable(function(subscriber) {
        var length3 = sources.length;
        if (!length3) {
          subscriber.complete();
          return;
        }
        var values = new Array(length3);
        var remainingCompletions = length3;
        var remainingEmissions = length3;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length3; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.forkJoin = forkJoin;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
      if (!add) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function() {
          return remove(handler);
        };
      });
    }
    exports.fromEvent = fromEvent;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e[_i] = arguments[_i];
          }
          return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports.fromEventPattern = fromEventPattern;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports) {
    "use strict";
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a, _b;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen() {
        var state;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              state = initialState;
              _a2.label = 1;
            case 1:
              if (!(!condition || condition(state)))
                return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen(), scheduler);
      } : gen);
    }
    exports.generate = generate;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iif = void 0;
    var defer_1 = require_defer();
    function iif(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports.iif = iif;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports.timer = timer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports.interval = interval;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from2();
    function merge2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports.merge = merge2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.never = exports.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop();
    exports.NEVER = new Observable_1.Observable(noop_1.noop);
    function never() {
      return exports.NEVER;
    }
    exports.never = never;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsOrArgArray = void 0;
    var isArray2 = Array.isArray;
    function argsOrArgArray(args) {
      return args.length === 1 && isArray2(args[0]) ? args[0] : args;
    }
    exports.argsOrArgArray = argsOrArgArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = void 0;
    var Observable_1 = require_Observable();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function onErrorResumeNext() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return new Observable_1.Observable(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
          if (sourceIndex < nextSources.length) {
            var nextSource = void 0;
            try {
              nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
            } catch (err) {
              subscribeNext();
              return;
            }
            var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
            nextSource.subscribe(innerSubscriber);
            innerSubscriber.add(subscribeNext);
          } else {
            subscriber.complete();
          }
        };
        subscribeNext();
      });
    }
    exports.onErrorResumeNext = onErrorResumeNext;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairs = void 0;
    var from_1 = require_from2();
    function pairs(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports.pairs = pairs;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.not = void 0;
    function not(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports.not = not;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter2(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports.filter = filter2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports.partition = partition;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceInit = exports.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
    }
    exports.race = race;
    function raceInit(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i2) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s = 0; s < subscriptions.length; s++) {
                s !== i2 && subscriptions[s].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
          _loop_1(i);
        }
      };
    }
    exports.raceInit = raceInit;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range(start, count, scheduler) {
      if (count == null) {
        count = start;
        start = 0;
      }
      if (count <= 0) {
        return empty_1.EMPTY;
      }
      var end = count + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports.range = range;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports.using = using;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer) {
              return buffer.length;
            })) {
              var result = buffers.map(function(buffer) {
                return buffer.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
              if (buffers.some(function(buffer, i) {
                return !buffer.length && completed[i];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports.audit = audit;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports.auditTime = auditTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function buffer(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports.buffer = buffer;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a, e_2, _b;
          var toEmit = null;
          if (count++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
              if (bufferSize <= buffer.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer);
                subscriber.next(buffer);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                  _b.call(toEmit_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a;
          try {
            for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer = buffers_2_1.value;
              subscriber.next(buffer);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
                _a.call(buffers_2);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports.bufferCount = bufferCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime(bufferTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxBufferSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer = [];
            var record_1 = {
              buffer,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer = record.buffer;
              buffer.push(value);
              maxBufferSize <= buffer.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
                _a2.call(recordsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports.bufferTime = bufferTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer = [];
          buffers.push(buffer);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer);
            subscriber.next(buffer);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports.bufferToggle = bufferToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer;
          buffer = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
          buffer && subscriber.next(buffer);
          subscriber.complete();
        }, void 0, function() {
          return buffer = closingSubscriber = null;
        }));
      });
    }
    exports.bufferWhen = bufferWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports.catchError = catchError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          state = hasState ? accumulator(state, value, i) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports.scanInternals = scanInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports.reduce = reduce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray2() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
      });
    }
    exports.toArray = toArray2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports.joinAllInternals = joinAllInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports.combineLatestAll = combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports.combineLatest = combineLatest;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports.combineLatestWith = combineLatestWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function concatMap(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports.concatMap = concatMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction();
    function concatMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports.concatMapTo = concatMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from2();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports.concatWith = concatWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports.fromSubscribable = fromSubscribable;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect2(selector, config) {
      if (config === void 0) {
        config = DEFAULT_CONFIG;
      }
      var connector = config.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports.connect = connect2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.count = void 0;
    var reduce_1 = require_reduce();
    function count(predicate) {
      return reduce_1.reduce(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
      }, 0);
    }
    exports.count = count;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports.debounce = debounce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports.debounceTime = debounceTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports.defaultIfEmpty = defaultIfEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count) {
            subscriber.next(value);
            if (count <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports.take = take;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function ignoreElements() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports.ignoreElements = ignoreElements;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapTo = void 0;
    var map_1 = require_map();
    function mapTo(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports.mapTo = mapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    var innerFrom_1 = require_innerFrom();
    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports.delayWhen = delayWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports.delay = delay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports.dematerialize = dematerialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function distinct(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports.distinct = distinct;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first || !comparator(previousKey, currentKey)) {
            first = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports.distinctUntilChanged = distinctUntilChanged;
    function defaultCompare(a, b) {
      return a === b;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    }
    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports.throwIfEmpty = throwIfEmpty;
    function defaultErrorFactory() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i) {
          return i === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports.elementAt = elementAt;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray([], __read(values))));
      };
    }
    exports.endWith = endWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.every = every;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap(function(a, i) {
            return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports.exhaustMap = exhaustMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports.exhaustAll = exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports.exhaust = exhaustAll_1.exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports.expand = expand;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.finalize = void 0;
    var lift_1 = require_lift();
    function finalize(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports.finalize = finalize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFind = exports.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find(predicate, thisArg) {
      return lift_1.operate(createFind(predicate, thisArg, "value"));
    }
    exports.find = find;
    function createFind(predicate, thisArg, emit) {
      var findIndex = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          if (predicate.call(thisArg, value, i, source)) {
            subscriber.next(findIndex ? i : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports.createFind = createFind;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports.findIndex = findIndex;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.first = first;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result.key = key;
          return result;
        }
      });
    }
    exports.groupBy = groupBy;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.isEmpty = isEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer.push(value);
          count < buffer.length && buffer.shift();
        }, function() {
          var e_1, _a;
          try {
            for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                _a.call(buffer_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer = null;
        }));
      });
    }
    exports.takeLast = takeLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.last = last;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports.materialize = materialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function max(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function(x, y) {
        return x > y ? x : y;
      });
    }
    exports.max = max;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports.flatMap = mergeMap_1.mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports.mergeMapTo = mergeMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports.mergeScan = mergeScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from2();
    function merge2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.merge = merge2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeWith = void 0;
    var merge_1 = require_merge2();
    function mergeWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray([], __read(otherSources)));
    }
    exports.mergeWith = mergeWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function min(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function(x, y) {
        return x < y ? x : y;
      });
    }
    exports.min = min;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction();
    var connect_1 = require_connect();
    function multicast(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports.multicast = multicast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = exports.onErrorResumeNextWith = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    function onErrorResumeNextWith() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return function(source) {
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources)));
      };
    }
    exports.onErrorResumeNextWith = onErrorResumeNextWith;
    exports.onErrorResumeNext = onErrorResumeNextWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports.pairwise = pairwise;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pluck = void 0;
    var map_1 = require_map();
    function pluck() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length3 = properties.length;
      if (length3 === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < length3; i++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports.pluck = pluck;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect();
    function publish(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports.publish = publish;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishBehavior = publishBehavior;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishLast = publishLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction();
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
      };
    }
    exports.publishReplay = publishReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
      });
    }
    exports.raceWith = raceWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat(countOrConfig) {
      var _a;
      var count = Infinity;
      var delay;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
        } else {
          count = countOrConfig;
        }
      }
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay != null) {
            var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports.repeat = repeat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeatWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports.repeatWhen = repeatWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config;
      if (configOrCount && typeof configOrCount === "object") {
        config = configOrCount;
      } else {
        config = {
          count: configOrCount
        };
      }
      var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
      return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay != null) {
                var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports.retry = retry;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports.retryWhen = retryWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sample = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports.sample = sample;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports.sampleTime = sampleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports.scan = scan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function sequenceEqual(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a, b) {
          return a === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
            var buffer = otherState.buffer, complete = otherState.complete;
            if (buffer.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a);
            } else {
              !comparator(a, buffer.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer = otherState.buffer;
            complete && emit(buffer.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
      });
    }
    exports.sequenceEqual = sequenceEqual;
    function createState() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.connector, connector = _a === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount--;
            if (refCount === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports.share = share;
    function handleReset(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      var _a, _b, _c;
      var bufferSize;
      var refCount = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
      });
    }
    exports.shareReplay = shareReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports.single = single;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skip = void 0;
    var filter_1 = require_filter();
    function skip(count) {
      return filter_1.filter(function(_, index) {
        return count <= index;
      });
    }
    exports.skip = skip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports.skipLast = skipLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function skipUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports.skipUntil = skipUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports.skipWhile = skipWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
      });
    }
    exports.startWith = startWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports.switchMap = switchMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports.switchAll = switchAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction();
    function switchMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports.switchMapTo = switchMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports.switchScan = switchScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function takeUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports.takeUntil = takeUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result = predicate(value, index++);
          (result || inclusive) && subscriber.next(value);
          !result && subscriber.complete();
        }));
      });
    }
    exports.takeWhile = takeWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tap = void 0;
    var isFunction_1 = require_isFunction();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap(observerOrNext, error, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a2;
          (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a2, _b;
          if (isUnsub) {
            (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          }
          (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports.tap = tap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttle = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function throttle2(durationSelector, config) {
      return lift_1.operate(function(source, subscriber) {
        var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports.throttle = throttle2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime(duration, scheduler, config) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config);
    }
    exports.throttleTime = throttleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeInterval = exports.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval = now - last;
          last = now;
          subscriber.next(new TimeInterval(value, interval));
        }));
      });
    }
    exports.timeInterval = timeInterval;
    var TimeInterval = function() {
      function TimeInterval2(value, interval) {
        this.value = value;
        this.interval = interval;
      }
      return TimeInterval2;
    }();
    exports.TimeInterval = TimeInterval;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith(due, withObservable, scheduler) {
      var first;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first,
        each,
        scheduler,
        with: _with
      });
    }
    exports.timeoutWith = timeoutWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map();
    function timestamp(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return { value, timestamp: timestampProvider.now() };
      });
    }
    exports.timestamp = timestamp;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function window2(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler));
        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports.window = window2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
                _a.call(windows_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          var c3 = count - windowSize + 1;
          if (c3 >= 0 && c3 % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports.windowCount = windowCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime(windowTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window2 = record.window, subs = record.subs;
          window2.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a2) {
            var window2 = _a2.window;
            return cb(window2);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports.windowTime = windowTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function windowToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window2 = new Subject_1.Subject();
          windows.push(window2);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window2);
            window2.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError(err);
            return;
          }
          subscriber.next(window2.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
                _a.call(windowsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports.windowToggle = windowToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window2;
        var closingSubscriber;
        var handleError = function(err) {
          window2.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 === null || window2 === void 0 ? void 0 : window2.complete();
          window2 = new Subject_1.Subject();
          subscriber.next(window2.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window2.next(value);
        }, function() {
          window2.complete();
          subscriber.complete();
        }, handleError, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 = null;
        }));
      });
    }
    exports.windowWhen = windowWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop();
    var args_1 = require_args();
    function withLatestFrom() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i2) {
          innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i2] = value;
            if (!ready && !hasValue[i2]) {
              hasValue[i2] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i = 0; i < len; i++) {
          _loop_1(i);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values = __spreadArray([value], __read(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
          }
        }));
      });
    }
    exports.withLatestFrom = withLatestFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports.zipAll = zipAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
      });
    }
    exports.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));
    }
    exports.zipWith = zipWith;
  }
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/rxjs/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
    exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
    exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
    exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = require_observable();
    Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = require_asap();
    Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_1 = require_async();
    Object.defineProperty(exports, "async", { enumerable: true, get: function() {
      return async_1.async;
    } });
    Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
      return async_1.asyncScheduler;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = require_noop();
    Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_1 = require_defer();
    Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
      return defer_1.defer;
    } });
    var empty_1 = require_empty();
    Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = require_from2();
    Object.defineProperty(exports, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = require_generate();
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = require_iif();
    Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = require_interval();
    Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = require_never();
    Object.defineProperty(exports, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = require_of();
    Object.defineProperty(exports, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = require_partition();
    Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = require_race();
    Object.defineProperty(exports, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = require_using();
    Object.defineProperty(exports, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = require_zip();
    Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = require_empty();
    Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = require_never();
    Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar(require_types(), exports);
    var config_1 = require_config();
    Object.defineProperty(exports, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = require_audit();
    Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length3) {
      for (let i = 0; i < length3; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length3 = buffer.length;
      for (let i = 0; i < length3; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length3) {
          if (length3 < 48)
            _mask(source, mask, output, offset, length3);
          else
            bu.mask(source, mask, output, offset, length3);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP: NOOP2 } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP2);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge2 = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge2 ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge2) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length3 = Buffer.byteLength(data);
          if (length3 > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length3);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 8,
            mask: mask2,
            readOnly: false
          }),
          cb
        );
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 9,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 10,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(buf, {
              fin: options.fin,
              rsv1: false,
              opcode,
              mask: options.mask,
              readOnly: toBuffer.readOnly
            }),
            cb
          );
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse2(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse2 };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https2 = require("https");
    var http3 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash: createHash2 } = require("crypto");
    var { Readable: Readable2 } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP: NOOP2
    } = require_constants();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format, parse: parse2 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter2 {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get onclose() {
        return void 0;
      }
      set onclose(listener) {
      }
      get onerror() {
        return void 0;
      }
      set onerror(listener) {
      }
      get onopen() {
        return void 0;
      }
      set onopen(listener) {
      }
      get onmessage() {
        return void 0;
      }
      set onmessage(listener) {
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this.binaryType,
          this._extensions,
          this._isServer,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get2 = isSecure ? https2.get : http3.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalUnixSocket = isUnixSocket;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else {
          const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
      }
      let req = websocket._req = get2(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse2(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream4, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream4.setHeader) {
        stream4.abort();
        if (stream4.socket && !stream4.socket.destroyed) {
          stream4.socket.destroy();
        }
        stream4.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream4.destroy(err);
        stream4.once("error", websocket.emit.bind(websocket, "error"));
        stream4.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length3 = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length3;
        else
          websocket._bufferedAmount += length3;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP2);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream4) {
      stream4.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP2);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream4) {
      stream4.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open2() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close2() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close2() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var http3 = require("http");
    var https2 = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash: createHash2 } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var { format, parse: parse2 } = require_extension();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter2 {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http3.createServer((req, res) => {
            const body = http3.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = /* @__PURE__ */ new Set();
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = parse2(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim2);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map2) {
      for (const event of Object.keys(map2))
        server.on(event, map2[event]);
      return function removeListeners() {
        for (const event of Object.keys(map2)) {
          server.removeListener(event, map2[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http3.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${http3.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim2(str) {
      return str.trim();
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream2();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// node_modules/unidecode/data/x00.js
var require_x00 = __commonJS({
  "node_modules/unidecode/data/x00.js"(exports, module2) {
    module2.exports = ["\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", " ", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "\x7F", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " ", "!", "C/", "PS", "$?", "Y=", "|", "SS", '"', "(c)", "a", "<<", "!", "", "(r)", "-", "deg", "+-", "2", "3", "'", "u", "P", "*", ",", "1", "o", ">>", "1/4", "1/2", "3/4", "?", "A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "U", "Th", "ss", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "/", "o", "u", "u", "u", "u", "y", "th", "y"];
  }
});

// node_modules/unidecode/data/x01.js
var require_x01 = __commonJS({
  "node_modules/unidecode/data/x01.js"(exports, module2) {
    module2.exports = ["A", "a", "A", "a", "A", "a", "C", "c", "C", "c", "C", "c", "C", "c", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "G", "g", "G", "g", "G", "g", "G", "g", "H", "h", "H", "h", "I", "i", "I", "i", "I", "i", "I", "i", "I", "i", "IJ", "", "J", "j", "K", "k", "k", "L", "l", "L", "l", "L", "l", "L", "l", "L", "l", "N", "n", "N", "n", "N", "n", "'n", "ng", "NG", "O", "o", "O", "o", "O", "o", "OE", "oe", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "W", "w", "Y", "y", "Y", "Z", "z", "Z", "z", "Z", "z", "s", "b", "B", "B", "b", "6", "6", "O", "C", "c", "D", "D", "D", "d", "d", "3", "@", "E", "F", "f", "G", "G", "hv", "I", "I", "K", "k", "l", "l", "W", "N", "n", "O", "O", "o", "OI", "oi", "P", "p", "YR", "2", "2", "SH", "sh", "t", "T", "t", "T", "U", "u", "Y", "V", "Y", "y", "Z", "z", "ZH", "ZH", "zh", "zh", "2", "5", "5", "ts", "w", "|", "||", "|=", "!", "DZ", "Dz", "dz", "LJ", "Lj", "lj", "NJ", "Nj", "nj", "A", "a", "I", "i", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "@", "A", "a", "A", "a", "AE", "ae", "G", "g", "G", "g", "K", "k", "O", "o", "O", "o", "ZH", "zh", "j", "DZ", "D", "dz", "G", "g", "HV", "W", "N", "n", "A", "a", "AE", "ae", "O", "o"];
  }
});

// node_modules/unidecode/data/x02.js
var require_x02 = __commonJS({
  "node_modules/unidecode/data/x02.js"(exports, module2) {
    module2.exports = ["A", "a", "A", "a", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "R", "r", "R", "r", "U", "u", "U", "u", "S", "s", "T", "t", "Y", "y", "H", "h", "[?]", "[?]", "OU", "ou", "Z", "z", "A", "a", "E", "e", "O", "o", "O", "o", "O", "o", "O", "o", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "a", "a", "b", "o", "c", "d", "d", "e", "@", "@", "e", "e", "e", "e", "j", "g", "g", "g", "g", "u", "Y", "h", "h", "i", "i", "I", "l", "l", "l", "lZ", "W", "W", "m", "n", "n", "n", "o", "OE", "O", "F", "R", "R", "R", "R", "r", "r", "R", "R", "R", "s", "S", "j", "S", "S", "t", "t", "U", "U", "v", "^", "W", "Y", "Y", "z", "z", "Z", "Z", "?", "?", "?", "C", "@", "B", "E", "G", "H", "j", "k", "L", "q", "?", "?", "dz", "dZ", "dz", "ts", "tS", "tC", "fN", "ls", "lz", "WW", "]]", "[?]", "[?]", "k", "h", "j", "r", "r", "r", "r", "w", "y", "'", '"', "`", "'", "`", "`", "'", "?", "?", "<", ">", "^", "V", "^", "V", "'", "-", "/", "\\", ",", "_", "\\", "/", ":", ".", "`", "'", "^", "V", "+", "-", "V", ".", "@", ",", "~", '"', "R", "X", "G", "l", "s", "x", "?", "", "", "", "", "", "", "", "V", "=", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x03.js
var require_x03 = __commonJS({
  "node_modules/unidecode/data/x03.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "'", ",", "[?]", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "?", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "A", ";", "E", "E", "I", "[?]", "O", "[?]", "U", "O", "I", "A", "B", "G", "D", "E", "Z", "E", "Th", "I", "K", "L", "M", "N", "Ks", "O", "P", "R", "[?]", "S", "T", "U", "Ph", "Kh", "Ps", "O", "I", "U", "a", "e", "e", "i", "u", "a", "b", "g", "d", "e", "z", "e", "th", "i", "k", "l", "m", "n", "x", "o", "p", "r", "s", "s", "t", "u", "ph", "kh", "ps", "o", "i", "u", "o", "u", "o", "[?]", "b", "th", "U", "U", "U", "ph", "p", "&", "[?]", "[?]", "St", "st", "W", "w", "Q", "q", "Sp", "sp", "Sh", "sh", "F", "f", "Kh", "kh", "H", "h", "G", "g", "CH", "ch", "Ti", "ti", "k", "r", "c", "j", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x04.js
var require_x04 = __commonJS({
  "node_modules/unidecode/data/x04.js"(exports, module2) {
    module2.exports = ["Ie", "Io", "Dj", "Gj", "Ie", "Dz", "I", "Yi", "J", "Lj", "Nj", "Tsh", "Kj", "I", "U", "Dzh", "A", "B", "V", "G", "D", "Ie", "Zh", "Z", "I", "I", "K", "L", "M", "N", "O", "P", "R", "S", "T", "U", "F", "Kh", "Ts", "Ch", "Sh", "Shch", "", "Y", "'", "E", "Iu", "Ia", "a", "b", "v", "gh", "d", "ie", "zh", "z", "i", "i", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "f", "kh", "ts", "ch", "sh", "shch", "", "y", "'", "e", "iu", "ia", "ie", "io", "dj", "gj", "ie", "dz", "i", "yi", "j", "lj", "nj", "tsh", "kj", "i", "u", "dzh", "O", "o", "E", "e", "Ie", "ie", "E", "e", "Ie", "ie", "O", "o", "Io", "io", "Ks", "ks", "Ps", "ps", "F", "f", "Y", "y", "Y", "y", "u", "u", "O", "o", "O", "o", "Ot", "ot", "Q", "q", "*1000*", "", "", "", "", "[?]", "*100.000*", "*1.000.000*", "[?]", "[?]", '"', '"', "R'", "r'", "G'", "g'", "G'", "g'", "G'", "g'", "Zh'", "zh'", "Z'", "z'", "K'", "k'", "K'", "k'", "K'", "k'", "K'", "k'", "N'", "n'", "Ng", "ng", "P'", "p'", "Kh", "kh", "S'", "s'", "T'", "t'", "U", "u", "U'", "u'", "Kh'", "kh'", "Tts", "tts", "Ch'", "ch'", "Ch'", "ch'", "H", "h", "Ch", "ch", "Ch'", "ch'", "`", "Zh", "zh", "K'", "k'", "[?]", "[?]", "N'", "n'", "[?]", "[?]", "Ch", "ch", "[?]", "[?]", "[?]", "a", "a", "A", "a", "Ae", "ae", "Ie", "ie", "@", "@", "@", "@", "Zh", "zh", "Z", "z", "Dz", "dz", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "E", "e", "U", "u", "U", "u", "U", "u", "Ch", "ch", "[?]", "[?]", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x05.js
var require_x05 = __commonJS({
  "node_modules/unidecode/data/x05.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "Z", "E", "E", "T`", "Zh", "I", "L", "Kh", "Ts", "K", "H", "Dz", "Gh", "Ch", "M", "Y", "N", "Sh", "O", "Ch`", "P", "J", "Rh", "S", "V", "T", "R", "Ts`", "W", "P`", "K`", "O", "F", "[?]", "[?]", "<", "'", "/", "!", ",", "?", ".", "[?]", "a", "b", "g", "d", "e", "z", "e", "e", "t`", "zh", "i", "l", "kh", "ts", "k", "h", "dz", "gh", "ch", "m", "y", "n", "sh", "o", "ch`", "p", "j", "rh", "s", "v", "t", "r", "ts`", "w", "p`", "k`", "o", "f", "ew", "[?]", ".", "-", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "@", "e", "a", "o", "i", "e", "e", "a", "a", "o", "[?]", "u", "'", "", "", "", "", "", "", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "b", "g", "d", "h", "v", "z", "kh", "t", "y", "k", "k", "l", "m", "m", "n", "n", "s", "`", "p", "p", "ts", "ts", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "[?]", "[?]", "V", "oy", "i", "'", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x06.js
var require_x06 = __commonJS({
  "node_modules/unidecode/data/x06.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ",", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ";", "[?]", "[?]", "[?]", "?", "[?]", "", "a", "'", "w'", "", "y'", "", "b", "@", "t", "th", "j", "H", "kh", "d", "dh", "r", "z", "s", "sh", "S", "D", "T", "Z", "aa", "G", "[?]", "[?]", "[?]", "[?]", "[?]", "", "f", "q", "k", "l", "m", "n", "h", "w", "~", "y", "an", "un", "in", "a", "u", "i", "W", "", "", "'", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%", ".", ",", "*", "[?]", "[?]", "", "'", "'", "'", "", "'", "'w", "'u", "'y", "tt", "tth", "b", "t", "T", "p", "th", "bh", "'h", "H", "ny", "dy", "H", "ch", "cch", "dd", "D", "D", "Dt", "dh", "ddh", "d", "D", "D", "rr", "R", "R", "R", "R", "R", "R", "j", "R", "S", "S", "S", "S", "S", "T", "GH", "F", "F", "F", "v", "f", "ph", "Q", "Q", "kh", "k", "K", "K", "ng", "K", "g", "G", "N", "G", "G", "G", "L", "L", "L", "L", "N", "N", "N", "N", "N", "h", "Ch", "hy", "h", "H", "@", "W", "oe", "oe", "u", "yu", "yu", "W", "v", "y", "Y", "Y", "W", "", "", "y", "y'", ".", "ae", "", "", "", "", "", "", "", "@", "#", "", "", "", "", "", "", "", "", "", "", "^", "", "", "", "", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Sh", "D", "Gh", "&", "+m"];
  }
});

// node_modules/unidecode/data/x07.js
var require_x07 = __commonJS({
  "node_modules/unidecode/data/x07.js"(exports, module2) {
    module2.exports = ["//", "/", ",", "!", "!", "-", ",", ",", ";", "?", "~", "{", "}", "*", "[?]", "", "'", "", "b", "g", "g", "d", "d", "h", "w", "z", "H", "t", "t", "y", "yh", "k", "l", "m", "n", "s", "s", "`", "p", "p", "S", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "a", "a", "a", "A", "A", "A", "e", "e", "e", "E", "i", "i", "u", "u", "u", "o", "", "`", "'", "", "", "X", "Q", "@", "@", "|", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "h", "sh", "n", "r", "b", "L", "k", "'", "v", "m", "f", "dh", "th", "l", "g", "ny", "s", "d", "z", "t", "y", "p", "j", "ch", "tt", "hh", "kh", "th", "z", "sh", "s", "d", "t", "z", "`", "gh", "q", "w", "a", "aa", "i", "ee", "u", "oo", "e", "ey", "o", "oa", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x09.js
var require_x09 = __commonJS({
  "node_modules/unidecode/data/x09.js"(exports, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "eN", "e", "e", "ai", "oN", "o", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "nnn", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "l", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "e", "e", "ai", "oN", "o", "o", "au", "", "[?]", "[?]", "AUM", "'", "'", "`", "'", "[?]", "[?]", "[?]", "q", "khh", "ghh", "z", "dddh", "rh", "f", "yy", "RR", "LL", "L", "LL", " / ", " // ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "[?]", "[?]", "[?]", "sh", "ss", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "L", "LL", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "r'", "r`", "Rs", "Rs", "1/", "2/", "3/", "4/", " 1 - 1/", "/16", "", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0a.js
var require_x0a = __commonJS({
  "node_modules/unidecode/data/x0a.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "N", "[?]", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bb", "m", "y", "r", "[?]", "l", "ll", "[?]", "v", "sh", "[?]", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "khh", "ghh", "z", "rr", "[?]", "f", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "N", "H", "", "", "G.E.O.", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "[?]", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "ya", "r", "[?]", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "", "[?]", "[?]", "AUM", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0b.js
var require_x0b = __commonJS({
  "node_modules/unidecode/data/x0b.js"(exports, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "ll", "[?]", "", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "[?]", "[?]", "[?]", "ng", "c", "[?]", "j", "[?]", "ny", "tt", "[?]", "[?]", "[?]", "nn", "t", "[?]", "[?]", "[?]", "n", "nnn", "p", "[?]", "[?]", "[?]", "m", "y", "r", "rr", "l", "ll", "lll", "v", "[?]", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+10+", "+100+", "+1000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0c.js
var require_x0c = __commonJS({
  "node_modules/unidecode/data/x0c.js"(exports, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "lll", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0d.js
var require_x0d = __commonJS({
  "node_modules/unidecode/data/x0d.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "e", "ee", "ai", "", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "ae", "aae", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "ai", "o", "oo", "au", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "nng", "c", "ch", "j", "jh", "ny", "jny", "nyj", "tt", "tth", "dd", "ddh", "nn", "nndd", "t", "th", "d", "dh", "n", "[?]", "nd", "p", "ph", "b", "bh", "m", "mb", "y", "r", "[?]", "l", "[?]", "[?]", "v", "sh", "ss", "s", "h", "ll", "f", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "aa", "ae", "aae", "i", "ii", "u", "[?]", "uu", "[?]", "R", "e", "ee", "ai", "o", "oo", "au", "L", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", " . ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0e.js
var require_x0e = __commonJS({
  "node_modules/unidecode/data/x0e.js"(exports, module2) {
    module2.exports = ["[?]", "k", "kh", "kh", "kh", "kh", "kh", "ng", "cch", "ch", "ch", "ch", "ch", "y", "d", "t", "th", "th", "th", "n", "d", "t", "th", "th", "th", "n", "b", "p", "ph", "f", "ph", "f", "ph", "m", "y", "r", "R", "l", "L", "w", "s", "s", "s", "h", "l", "`", "h", "~", "a", "a", "aa", "am", "i", "ii", "ue", "uue", "u", "uu", "'", "[?]", "[?]", "[?]", "[?]", "Bh.", "e", "ae", "o", "ai", "ai", "ao", "+", "", "", "", "", "", "", "M", "", " * ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " // ", " /// ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "[?]", "kh", "[?]", "[?]", "ng", "ch", "[?]", "s", "[?]", "[?]", "ny", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "d", "h", "th", "th", "[?]", "n", "b", "p", "ph", "f", "ph", "f", "[?]", "m", "y", "r", "[?]", "l", "[?]", "w", "[?]", "[?]", "s", "h", "[?]", "`", "", "~", "a", "", "aa", "am", "i", "ii", "y", "yy", "u", "uu", "[?]", "o", "l", "ny", "[?]", "[?]", "e", "ei", "o", "ay", "ai", "[?]", "+", "[?]", "", "", "", "", "", "M", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "hn", "hm", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0f.js
var require_x0f = __commonJS({
  "node_modules/unidecode/data/x0f.js"(exports, module2) {
    module2.exports = ["AUM", "", "", "", "", "", "", "", " // ", " * ", "", "-", " / ", " / ", " // ", " -/ ", " +/ ", " X/ ", " /XX/ ", " /X/ ", ", ", "", "", "", "", "", "", "", "", "", "", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".5", "1.5", "2.5", "3.5", "4.5", "5.5", "6.5", "7.5", "8.5", "-.5", "+", "*", "^", "_", "", "~", "[?]", "]", "[[", "]]", "", "", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ssh", "s", "h", "a", "kss", "r", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "o", "oo", "M", "H", "i", "ii", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ss", "s", "h", "a", "kss", "w", "y", "r", "[?]", "X", " :X: ", " /O/ ", " /o/ ", " \\o\\ ", " (O) ", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x10.js
var require_x10 = __commonJS({
  "node_modules/unidecode/data/x10.js"(exports, module2) {
    module2.exports = ["k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "nny", "tt", "tth", "dd", "ddh", "nn", "tt", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "w", "s", "h", "ll", "a", "[?]", "i", "ii", "u", "uu", "e", "[?]", "o", "au", "[?]", "aa", "i", "ii", "u", "uu", "e", "ai", "[?]", "[?]", "[?]", "N", "'", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " / ", " // ", "n*", "r*", "l*", "e*", "sh", "ss", "R", "RR", "L", "LL", "R", "RR", "L", "LL", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "V", "Z", "T`", "I", "K", "L", "M", "N", "O", "P", "Zh", "R", "S", "T", "U", "P`", "K`", "G'", "Q", "Sh", "Ch`", "C`", "Z'", "C", "Ch", "X", "J", "H", "E", "Y", "W", "Xh", "OE", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "b", "g", "d", "e", "v", "z", "t`", "i", "k", "l", "m", "n", "o", "p", "zh", "r", "s", "t", "u", "p`", "k`", "g'", "q", "sh", "ch`", "c`", "z'", "c", "ch", "x", "j", "h", "e", "y", "w", "xh", "oe", "f", "[?]", "[?]", "[?]", "[?]", " // ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x11.js
var require_x11 = __commonJS({
  "node_modules/unidecode/data/x11.js"(exports, module2) {
    module2.exports = ["g", "gg", "n", "d", "dd", "r", "m", "b", "bb", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "ng", "nn", "nd", "nb", "dg", "rn", "rr", "rh", "rN", "mb", "mN", "bg", "bn", "", "bs", "bsg", "bst", "bsb", "bss", "bsj", "bj", "bc", "bt", "bp", "bN", "bbN", "sg", "sn", "sd", "sr", "sm", "sb", "sbg", "sss", "s", "sj", "sc", "sk", "st", "sp", "sh", "", "", "", "", "Z", "g", "d", "m", "b", "s", "Z", "", "j", "c", "t", "p", "N", "j", "", "", "", "", "ck", "ch", "", "", "pb", "pN", "hh", "Q", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "a-o", "a-u", "ya-o", "ya-yo", "eo-o", "eo-u", "eo-eu", "yeo-o", "yeo-u", "o-eo", "o-e", "o-ye", "o-o", "o-u", "yo-ya", "yo-yae", "yo-yeo", "yo-o", "yo-i", "u-a", "u-ae", "u-eo-eu", "u-ye", "u-u", "yu-a", "yu-eo", "yu-e", "yu-yeo", "yu-ye", "yu-u", "yu-i", "eu-u", "eu-eu", "yi-u", "i-a", "i-ya", "i-o", "i-u", "i-eu", "i-U", "U", "U-eo", "U-u", "U-i", "UU", "[?]", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "l", "lg", "lm", "lb", "ls", "lt", "lp", "lh", "m", "b", "bs", "s", "ss", "ng", "j", "c", "k", "t", "p", "h", "gl", "gsg", "ng", "nd", "ns", "nZ", "nt", "dg", "tl", "lgs", "ln", "ld", "lth", "ll", "lmg", "lms", "lbs", "lbh", "rNp", "lss", "lZ", "lk", "lQ", "mg", "ml", "mb", "ms", "mss", "mZ", "mc", "mh", "mN", "bl", "bp", "ph", "pN", "sg", "sd", "sl", "sb", "Z", "g", "ss", "", "kh", "N", "Ns", "NZ", "pb", "pN", "hn", "hl", "hm", "hb", "Q", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x12.js
var require_x12 = __commonJS({
  "node_modules/unidecode/data/x12.js"(exports, module2) {
    module2.exports = ["ha", "hu", "hi", "haa", "hee", "he", "ho", "[?]", "la", "lu", "li", "laa", "lee", "le", "lo", "lwa", "hha", "hhu", "hhi", "hhaa", "hhee", "hhe", "hho", "hhwa", "ma", "mu", "mi", "maa", "mee", "me", "mo", "mwa", "sza", "szu", "szi", "szaa", "szee", "sze", "szo", "szwa", "ra", "ru", "ri", "raa", "ree", "re", "ro", "rwa", "sa", "su", "si", "saa", "see", "se", "so", "swa", "sha", "shu", "shi", "shaa", "shee", "she", "sho", "shwa", "qa", "qu", "qi", "qaa", "qee", "qe", "qo", "[?]", "qwa", "[?]", "qwi", "qwaa", "qwee", "qwe", "[?]", "[?]", "qha", "qhu", "qhi", "qhaa", "qhee", "qhe", "qho", "[?]", "qhwa", "[?]", "qhwi", "qhwaa", "qhwee", "qhwe", "[?]", "[?]", "ba", "bu", "bi", "baa", "bee", "be", "bo", "bwa", "va", "vu", "vi", "vaa", "vee", "ve", "vo", "vwa", "ta", "tu", "ti", "taa", "tee", "te", "to", "twa", "ca", "cu", "ci", "caa", "cee", "ce", "co", "cwa", "xa", "xu", "xi", "xaa", "xee", "xe", "xo", "[?]", "xwa", "[?]", "xwi", "xwaa", "xwee", "xwe", "[?]", "[?]", "na", "nu", "ni", "naa", "nee", "ne", "no", "nwa", "nya", "nyu", "nyi", "nyaa", "nyee", "nye", "nyo", "nywa", "'a", "'u", "[?]", "'aa", "'ee", "'e", "'o", "'wa", "ka", "ku", "ki", "kaa", "kee", "ke", "ko", "[?]", "kwa", "[?]", "kwi", "kwaa", "kwee", "kwe", "[?]", "[?]", "kxa", "kxu", "kxi", "kxaa", "kxee", "kxe", "kxo", "[?]", "kxwa", "[?]", "kxwi", "kxwaa", "kxwee", "kxwe", "[?]", "[?]", "wa", "wu", "wi", "waa", "wee", "we", "wo", "[?]", "`a", "`u", "`i", "`aa", "`ee", "`e", "`o", "[?]", "za", "zu", "zi", "zaa", "zee", "ze", "zo", "zwa", "zha", "zhu", "zhi", "zhaa", "zhee", "zhe", "zho", "zhwa", "ya", "yu", "yi", "yaa", "yee", "ye", "yo", "[?]", "da", "du", "di", "daa", "dee", "de", "do", "dwa", "dda", "ddu", "ddi", "ddaa", "ddee", "dde", "ddo", "ddwa"];
  }
});

// node_modules/unidecode/data/x13.js
var require_x13 = __commonJS({
  "node_modules/unidecode/data/x13.js"(exports, module2) {
    module2.exports = ["ja", "ju", "ji", "jaa", "jee", "je", "jo", "jwa", "ga", "gu", "gi", "gaa", "gee", "ge", "go", "[?]", "gwa", "[?]", "gwi", "gwaa", "gwee", "gwe", "[?]", "[?]", "gga", "ggu", "ggi", "ggaa", "ggee", "gge", "ggo", "[?]", "tha", "thu", "thi", "thaa", "thee", "the", "tho", "thwa", "cha", "chu", "chi", "chaa", "chee", "che", "cho", "chwa", "pha", "phu", "phi", "phaa", "phee", "phe", "pho", "phwa", "tsa", "tsu", "tsi", "tsaa", "tsee", "tse", "tso", "tswa", "tza", "tzu", "tzi", "tzaa", "tzee", "tze", "tzo", "[?]", "fa", "fu", "fi", "faa", "fee", "fe", "fo", "fwa", "pa", "pu", "pi", "paa", "pee", "pe", "po", "pwa", "rya", "mya", "fya", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", ".", ",", ";", ":", ":: ", "?", "//", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10+", "20+", "30+", "40+", "50+", "60+", "70+", "80+", "90+", "100+", "10,000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "v", "ga", "ka", "ge", "gi", "go", "gu", "gv", "ha", "he", "hi", "ho", "hu", "hv", "la", "le", "li", "lo", "lu", "lv", "ma", "me", "mi", "mo", "mu", "na", "hna", "nah", "ne", "ni", "no", "nu", "nv", "qua", "que", "qui", "quo", "quu", "quv", "sa", "s", "se", "si", "so", "su", "sv", "da", "ta", "de", "te", "di", "ti", "do", "du", "dv", "dla", "tla", "tle", "tli", "tlo", "tlu", "tlv", "tsa", "tse", "tsi", "tso", "tsu", "tsv", "wa", "we", "wi", "wo", "wu", "wv", "ya", "ye", "yi", "yo", "yu", "yv", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x14.js
var require_x14 = __commonJS({
  "node_modules/unidecode/data/x14.js"(exports, module2) {
    module2.exports = ["[?]", "e", "aai", "i", "ii", "o", "oo", "oo", "ee", "i", "a", "aa", "we", "we", "wi", "wi", "wii", "wii", "wo", "wo", "woo", "woo", "woo", "wa", "wa", "waa", "waa", "waa", "ai", "w", "'", "t", "k", "sh", "s", "n", "w", "n", "[?]", "w", "c", "?", "l", "en", "in", "on", "an", "pe", "paai", "pi", "pii", "po", "poo", "poo", "hee", "hi", "pa", "paa", "pwe", "pwe", "pwi", "pwi", "pwii", "pwii", "pwo", "pwo", "pwoo", "pwoo", "pwa", "pwa", "pwaa", "pwaa", "pwaa", "p", "p", "h", "te", "taai", "ti", "tii", "to", "too", "too", "dee", "di", "ta", "taa", "twe", "twe", "twi", "twi", "twii", "twii", "two", "two", "twoo", "twoo", "twa", "twa", "twaa", "twaa", "twaa", "t", "tte", "tti", "tto", "tta", "ke", "kaai", "ki", "kii", "ko", "koo", "koo", "ka", "kaa", "kwe", "kwe", "kwi", "kwi", "kwii", "kwii", "kwo", "kwo", "kwoo", "kwoo", "kwa", "kwa", "kwaa", "kwaa", "kwaa", "k", "kw", "keh", "kih", "koh", "kah", "ce", "caai", "ci", "cii", "co", "coo", "coo", "ca", "caa", "cwe", "cwe", "cwi", "cwi", "cwii", "cwii", "cwo", "cwo", "cwoo", "cwoo", "cwa", "cwa", "cwaa", "cwaa", "cwaa", "c", "th", "me", "maai", "mi", "mii", "mo", "moo", "moo", "ma", "maa", "mwe", "mwe", "mwi", "mwi", "mwii", "mwii", "mwo", "mwo", "mwoo", "mwoo", "mwa", "mwa", "mwaa", "mwaa", "mwaa", "m", "m", "mh", "m", "m", "ne", "naai", "ni", "nii", "no", "noo", "noo", "na", "naa", "nwe", "nwe", "nwa", "nwa", "nwaa", "nwaa", "nwaa", "n", "ng", "nh", "le", "laai", "li", "lii", "lo", "loo", "loo", "la", "laa", "lwe", "lwe", "lwi", "lwi", "lwii", "lwii", "lwo", "lwo", "lwoo", "lwoo", "lwa", "lwa", "lwaa", "lwaa", "l", "l", "l", "se", "saai", "si", "sii", "so", "soo", "soo", "sa", "saa", "swe", "swe", "swi", "swi", "swii", "swii", "swo", "swo", "swoo", "swoo"];
  }
});

// node_modules/unidecode/data/x15.js
var require_x15 = __commonJS({
  "node_modules/unidecode/data/x15.js"(exports, module2) {
    module2.exports = ["swa", "swa", "swaa", "swaa", "swaa", "s", "s", "sw", "s", "sk", "skw", "sW", "spwa", "stwa", "skwa", "scwa", "she", "shi", "shii", "sho", "shoo", "sha", "shaa", "shwe", "shwe", "shwi", "shwi", "shwii", "shwii", "shwo", "shwo", "shwoo", "shwoo", "shwa", "shwa", "shwaa", "shwaa", "sh", "ye", "yaai", "yi", "yii", "yo", "yoo", "yoo", "ya", "yaa", "ywe", "ywe", "ywi", "ywi", "ywii", "ywii", "ywo", "ywo", "ywoo", "ywoo", "ywa", "ywa", "ywaa", "ywaa", "ywaa", "y", "y", "y", "yi", "re", "re", "le", "raai", "ri", "rii", "ro", "roo", "lo", "ra", "raa", "la", "rwaa", "rwaa", "r", "r", "r", "fe", "faai", "fi", "fii", "fo", "foo", "fa", "faa", "fwaa", "fwaa", "f", "the", "the", "thi", "thi", "thii", "thii", "tho", "thoo", "tha", "thaa", "thwaa", "thwaa", "th", "tthe", "tthi", "ttho", "ttha", "tth", "tye", "tyi", "tyo", "tya", "he", "hi", "hii", "ho", "hoo", "ha", "haa", "h", "h", "hk", "qaai", "qi", "qii", "qo", "qoo", "qa", "qaa", "q", "tlhe", "tlhi", "tlho", "tlha", "re", "ri", "ro", "ra", "ngaai", "ngi", "ngii", "ngo", "ngoo", "nga", "ngaa", "ng", "nng", "she", "shi", "sho", "sha", "the", "thi", "tho", "tha", "th", "lhi", "lhii", "lho", "lhoo", "lha", "lhaa", "lh", "the", "thi", "thii", "tho", "thoo", "tha", "thaa", "th", "b", "e", "i", "o", "a", "we", "wi", "wo", "wa", "ne", "ni", "no", "na", "ke", "ki", "ko", "ka", "he", "hi", "ho", "ha", "ghu", "gho", "ghe", "ghee", "ghi", "gha", "ru", "ro", "re", "ree", "ri", "ra", "wu", "wo", "we", "wee", "wi", "wa", "hwu", "hwo", "hwe", "hwee", "hwi", "hwa", "thu", "tho", "the", "thee", "thi", "tha", "ttu", "tto", "tte", "ttee", "tti", "tta", "pu", "po", "pe", "pee", "pi", "pa", "p", "gu", "go", "ge", "gee", "gi", "ga", "khu", "kho", "khe", "khee", "khi", "kha", "kku", "kko", "kke", "kkee", "kki"];
  }
});

// node_modules/unidecode/data/x16.js
var require_x16 = __commonJS({
  "node_modules/unidecode/data/x16.js"(exports, module2) {
    module2.exports = ["kka", "kk", "nu", "no", "ne", "nee", "ni", "na", "mu", "mo", "me", "mee", "mi", "ma", "yu", "yo", "ye", "yee", "yi", "ya", "ju", "ju", "jo", "je", "jee", "ji", "ji", "ja", "jju", "jjo", "jje", "jjee", "jji", "jja", "lu", "lo", "le", "lee", "li", "la", "dlu", "dlo", "dle", "dlee", "dli", "dla", "lhu", "lho", "lhe", "lhee", "lhi", "lha", "tlhu", "tlho", "tlhe", "tlhee", "tlhi", "tlha", "tlu", "tlo", "tle", "tlee", "tli", "tla", "zu", "zo", "ze", "zee", "zi", "za", "z", "z", "dzu", "dzo", "dze", "dzee", "dzi", "dza", "su", "so", "se", "see", "si", "sa", "shu", "sho", "she", "shee", "shi", "sha", "sh", "tsu", "tso", "tse", "tsee", "tsi", "tsa", "chu", "cho", "che", "chee", "chi", "cha", "ttsu", "ttso", "ttse", "ttsee", "ttsi", "ttsa", "X", ".", "qai", "ngai", "nngi", "nngii", "nngo", "nngoo", "nnga", "nngaa", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", "b", "l", "f", "s", "n", "h", "d", "t", "c", "q", "m", "g", "ng", "z", "r", "a", "o", "u", "e", "i", "ch", "th", "ph", "p", "x", "p", "<", ">", "[?]", "[?]", "[?]", "f", "v", "u", "yr", "y", "w", "th", "th", "a", "o", "ac", "ae", "o", "o", "o", "oe", "on", "r", "k", "c", "k", "g", "ng", "g", "g", "w", "h", "h", "h", "h", "n", "n", "n", "i", "e", "j", "g", "ae", "a", "eo", "p", "z", "s", "s", "s", "c", "z", "t", "t", "d", "b", "b", "p", "p", "e", "m", "m", "m", "l", "l", "ng", "ng", "d", "o", "ear", "ior", "qu", "qu", "qu", "s", "yr", "yr", "yr", "q", "x", ".", ":", "+", "17", "18", "19", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x17.js
var require_x17 = __commonJS({
  "node_modules/unidecode/data/x17.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "t", "tth", "d", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "v", "sh", "ss", "s", "h", "l", "q", "a", "aa", "i", "ii", "u", "uk", "uu", "uuv", "ry", "ryy", "ly", "lyy", "e", "ai", "oo", "oo", "au", "a", "aa", "aa", "i", "ii", "y", "yy", "u", "uu", "ua", "oe", "ya", "ie", "e", "ae", "ai", "oo", "au", "M", "H", "a`", "", "", "", "r", "", "!", "", "", "", "", "", ".", " // ", ":", "+", "++", " * ", " /// ", "KR", "'", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x18.js
var require_x18 = __commonJS({
  "node_modules/unidecode/data/x18.js"(exports, module2) {
    module2.exports = [" @ ", " ... ", ", ", ". ", ": ", " // ", "", "-", ", ", ". ", "", "", "", "", "", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "O", "U", "ee", "n", "ng", "b", "p", "q", "g", "m", "l", "s", "sh", "t", "d", "ch", "j", "y", "r", "w", "f", "k", "kha", "ts", "z", "h", "zr", "lh", "zh", "ch", "-", "e", "i", "o", "u", "O", "U", "ng", "b", "p", "q", "g", "m", "t", "d", "ch", "j", "ts", "y", "w", "k", "g", "h", "jy", "ny", "dz", "e", "i", "iy", "U", "u", "ng", "k", "g", "h", "p", "sh", "t", "d", "j", "f", "g", "h", "ts", "z", "r", "ch", "zh", "i", "k", "r", "f", "zh", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "H", "X", "W", "M", " 3 ", " 333 ", "a", "i", "k", "ng", "c", "tt", "tth", "dd", "nn", "t", "d", "p", "ph", "ss", "zh", "z", "a", "t", "zh", "gh", "ng", "c", "jh", "tta", "ddh", "t", "dh", "ss", "cy", "zh", "z", "u", "y", "bh", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1e.js
var require_x1e = __commonJS({
  "node_modules/unidecode/data/x1e.js"(exports, module2) {
    module2.exports = ["A", "a", "B", "b", "B", "b", "B", "b", "C", "c", "D", "d", "D", "d", "D", "d", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "F", "f", "G", "g", "H", "h", "H", "h", "H", "h", "H", "h", "H", "h", "I", "i", "I", "i", "K", "k", "K", "k", "K", "k", "L", "l", "L", "l", "L", "l", "L", "l", "M", "m", "M", "m", "M", "m", "N", "n", "N", "n", "N", "n", "N", "n", "O", "o", "O", "o", "O", "o", "O", "o", "P", "p", "P", "p", "R", "r", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "V", "v", "V", "v", "W", "w", "W", "w", "W", "w", "W", "w", "W", "w", "X", "x", "X", "x", "Y", "y", "Z", "z", "Z", "z", "Z", "z", "h", "t", "w", "y", "a", "S", "[?]", "[?]", "[?]", "[?]", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "Y", "y", "Y", "y", "Y", "y", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1f.js
var require_x1f = __commonJS({
  "node_modules/unidecode/data/x1f.js"(exports, module2) {
    module2.exports = ["a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "[?]", "[?]", "E", "E", "E", "E", "E", "E", "[?]", "[?]", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "i", "i", "i", "i", "i", "i", "i", "i", "I", "I", "I", "I", "I", "I", "I", "I", "o", "o", "o", "o", "o", "o", "[?]", "[?]", "O", "O", "O", "O", "O", "O", "[?]", "[?]", "u", "u", "u", "u", "u", "u", "u", "u", "[?]", "U", "[?]", "U", "[?]", "U", "[?]", "U", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "e", "e", "e", "e", "i", "i", "o", "o", "u", "u", "o", "o", "[?]", "[?]", "a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "a", "a", "a", "[?]", "a", "a", "A", "A", "A", "A", "A", "'", "i", "'", "~", '"~', "e", "e", "e", "[?]", "e", "e", "E", "E", "E", "E", "E", "'`", "''", "'~", "i", "i", "i", "i", "[?]", "[?]", "i", "i", "I", "I", "I", "I", "[?]", "`'", "`'", "`~", "u", "u", "u", "u", "R", "R", "u", "u", "U", "U", "U", "U", "R", '"`', `"'`, "`", "[?]", "[?]", "o", "o", "o", "[?]", "o", "o", "O", "O", "O", "O", "O", "'", "`"];
  }
});

// node_modules/unidecode/data/x20.js
var require_x20 = __commonJS({
  "node_modules/unidecode/data/x20.js"(exports, module2) {
    module2.exports = [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "", "", "", "", "-", "-", "-", "-", "--", "--", "||", "_", "'", "'", ",", "'", '"', '"', ",,", '"', "+", "++", "*", "*>", ".", "..", "...", ".", "\n", "\n\n", "", "", "", "", "", " ", "%0", "%00", "'", "''", "'''", "`", "``", "```", "^", "<", ">", "*", "!!", "!?", "-", "_", "-", "^", "***", "--", "/", "-[", "]-", "[?]", "?!", "!?", "7", "PP", "(]", "[)", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "0", "", "", "", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "n", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "ECU", "CL", "Cr", "FF", "L", "mil", "N", "Pts", "Rs", "W", "NS", "D", "EU", "K", "T", "Dr", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x21.js
var require_x21 = __commonJS({
  "node_modules/unidecode/data/x21.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " 1/3 ", " 2/3 ", " 1/5 ", " 2/5 ", " 3/5 ", " 4/5 ", " 1/6 ", " 5/6 ", " 1/8 ", " 3/8 ", " 5/8 ", " 7/8 ", " 1/", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "L", "C", "D", "M", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix", "x", "xi", "xii", "l", "c", "d", "m", "(D", "D)", "((|))", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "-", "|", "-", "|", "-", "|", "\\", "/", "\\", "/", "-", "-", "~", "~", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "-", "-", "-", "-", "-", "-", "|", "|", "|", "|", "|", "|", "|", "^", "V", "\\", "=", "V", "^", "-", "-", "|", "|", "-", "-", "|", "|", "=", "|", "=", "=", "|", "=", "|", "=", "=", "=", "=", "=", "=", "|", "=", "|", "=", "|", "\\", "/", "\\", "/", "=", "=", "~", "~", "|", "|", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "|", "|", "|", "|", "|", "-", "\\", "\\", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x22.js
var require_x22 = __commonJS({
  "node_modules/unidecode/data/x22.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x23.js
var require_x23 = __commonJS({
  "node_modules/unidecode/data/x23.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x24.js
var require_x24 = __commonJS({
  "node_modules/unidecode/data/x24.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x25.js
var require_x25 = __commonJS({
  "node_modules/unidecode/data/x25.js"(exports, module2) {
    module2.exports = ["-", "-", "|", "|", "-", "-", "|", "|", "-", "-", "|", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-", "|", "|", "-", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "/", "\\", "X", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "-", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "^", "^", "^", "^", ">", ">", ">", ">", ">", ">", "V", "V", "V", "V", "<", "<", "<", "<", "<", "<", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "#", "#", "#", "#", "#", "^", "^", "^", "O", "#", "#", "#", "#", "#", "#", "#", "#", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x26.js
var require_x26 = __commonJS({
  "node_modules/unidecode/data/x26.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x27.js
var require_x27 = __commonJS({
  "node_modules/unidecode/data/x27.js"(exports, module2) {
    module2.exports = ["[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x28.js
var require_x28 = __commonJS({
  "node_modules/unidecode/data/x28.js"(exports, module2) {
    module2.exports = [" ", "a", "1", "b", "'", "k", "2", "l", "@", "c", "i", "f", "/", "m", "s", "p", '"', "e", "3", "h", "9", "o", "6", "r", "^", "d", "j", "g", ">", "n", "t", "q", ",", "*", "5", "<", "-", "u", "8", "v", ".", "%", "[", "$", "+", "x", "!", "&", ";", ":", "4", "\\", "0", "z", "7", "(", "_", "?", "w", "]", "#", "y", ")", "=", "[d7]", "[d17]", "[d27]", "[d127]", "[d37]", "[d137]", "[d237]", "[d1237]", "[d47]", "[d147]", "[d247]", "[d1247]", "[d347]", "[d1347]", "[d2347]", "[d12347]", "[d57]", "[d157]", "[d257]", "[d1257]", "[d357]", "[d1357]", "[d2357]", "[d12357]", "[d457]", "[d1457]", "[d2457]", "[d12457]", "[d3457]", "[d13457]", "[d23457]", "[d123457]", "[d67]", "[d167]", "[d267]", "[d1267]", "[d367]", "[d1367]", "[d2367]", "[d12367]", "[d467]", "[d1467]", "[d2467]", "[d12467]", "[d3467]", "[d13467]", "[d23467]", "[d123467]", "[d567]", "[d1567]", "[d2567]", "[d12567]", "[d3567]", "[d13567]", "[d23567]", "[d123567]", "[d4567]", "[d14567]", "[d24567]", "[d124567]", "[d34567]", "[d134567]", "[d234567]", "[d1234567]", "[d8]", "[d18]", "[d28]", "[d128]", "[d38]", "[d138]", "[d238]", "[d1238]", "[d48]", "[d148]", "[d248]", "[d1248]", "[d348]", "[d1348]", "[d2348]", "[d12348]", "[d58]", "[d158]", "[d258]", "[d1258]", "[d358]", "[d1358]", "[d2358]", "[d12358]", "[d458]", "[d1458]", "[d2458]", "[d12458]", "[d3458]", "[d13458]", "[d23458]", "[d123458]", "[d68]", "[d168]", "[d268]", "[d1268]", "[d368]", "[d1368]", "[d2368]", "[d12368]", "[d468]", "[d1468]", "[d2468]", "[d12468]", "[d3468]", "[d13468]", "[d23468]", "[d123468]", "[d568]", "[d1568]", "[d2568]", "[d12568]", "[d3568]", "[d13568]", "[d23568]", "[d123568]", "[d4568]", "[d14568]", "[d24568]", "[d124568]", "[d34568]", "[d134568]", "[d234568]", "[d1234568]", "[d78]", "[d178]", "[d278]", "[d1278]", "[d378]", "[d1378]", "[d2378]", "[d12378]", "[d478]", "[d1478]", "[d2478]", "[d12478]", "[d3478]", "[d13478]", "[d23478]", "[d123478]", "[d578]", "[d1578]", "[d2578]", "[d12578]", "[d3578]", "[d13578]", "[d23578]", "[d123578]", "[d4578]", "[d14578]", "[d24578]", "[d124578]", "[d34578]", "[d134578]", "[d234578]", "[d1234578]", "[d678]", "[d1678]", "[d2678]", "[d12678]", "[d3678]", "[d13678]", "[d23678]", "[d123678]", "[d4678]", "[d14678]", "[d24678]", "[d124678]", "[d34678]", "[d134678]", "[d234678]", "[d1234678]", "[d5678]", "[d15678]", "[d25678]", "[d125678]", "[d35678]", "[d135678]", "[d235678]", "[d1235678]", "[d45678]", "[d145678]", "[d245678]", "[d1245678]", "[d345678]", "[d1345678]", "[d2345678]", "[d12345678]"];
  }
});

// node_modules/unidecode/data/x2e.js
var require_x2e = __commonJS({
  "node_modules/unidecode/data/x2e.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x2f.js
var require_x2f = __commonJS({
  "node_modules/unidecode/data/x2f.js"(exports, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x30.js
var require_x30 = __commonJS({
  "node_modules/unidecode/data/x30.js"(exports, module2) {
    module2.exports = [" ", ", ", ". ", '"', "[JIS]", '"', "/", "0", "<", "> ", "<<", ">> ", "[", "] ", "{", "} ", "[(", ")] ", "@", "X ", "[", "] ", "[[", "]] ", "((", ")) ", "[[", "]] ", "~ ", "``", "''", ",,", "@", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "", "", "", "", "", "~", "+", "+", "+", "+", "", "@", " // ", "+10+", "+20+", "+30+", "[?]", "[?]", "[?]", "", "", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "[?]", "[?]", "[?]", "[?]", "", "", "", "", '"', '"', "[?]", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "ka", "ke", "va", "vi", "ve", "vo", "", "", '"', '"'];
  }
});

// node_modules/unidecode/data/x31.js
var require_x31 = __commonJS({
  "node_modules/unidecode/data/x31.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "B", "P", "M", "F", "D", "T", "N", "L", "G", "K", "H", "J", "Q", "X", "ZH", "CH", "SH", "R", "Z", "C", "S", "A", "O", "E", "EH", "AI", "EI", "AU", "OU", "AN", "EN", "ANG", "ENG", "ER", "I", "U", "IU", "V", "NG", "GN", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "", "nn", "nd", "ns", "nZ", "lgs", "ld", "lbs", "lZ", "lQ", "mb", "ms", "mZ", "mN", "bg", "", "bsg", "bst", "bj", "bt", "bN", "bbN", "sg", "sn", "sd", "sb", "sj", "Z", "", "N", "Ns", "NZ", "pN", "hh", "Q", "yo-ya", "yo-yae", "yo-i", "yu-yeo", "yu-ye", "yu-i", "U", "U-i", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BU", "ZI", "JI", "GU", "EE", "ENN", "OO", "ONN", "IR", "ANN", "INN", "UNN", "IM", "NGG", "AINN", "AUNN", "AM", "OM", "ONG", "INNN", "P", "T", "K", "H", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x32.js
var require_x32 = __commonJS({
  "node_modules/unidecode/data/x32.js"(exports, module2) {
    module2.exports = ["(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "(ju)", "[?]", "[?]", "[?]", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Dai) ", "(Hu) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ji) ", "(Xiu) ", "<<", ">>", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "[?]", "[?]", "[?]", "KIS ", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Mi) ", "(Nan) ", "(Nu) ", "(Shi) ", "(You) ", "(Yin) ", "(Zhu) ", "(Xiang) ", "(Xiu) ", "(Xie) ", "(Zheng) ", "(Shang) ", "(Zhong) ", "(Xia) ", "(Zuo) ", "(You) ", "(Yi) ", "(Zong) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ye) ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "1M", "2M", "3M", "4M", "5M", "6M", "7M", "8M", "9M", "10M", "11M", "12M", "[?]", "[?]", "[?]", "[?]", "a", "i", "u", "u", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wi", "we", "wo"];
  }
});

// node_modules/unidecode/data/x33.js
var require_x33 = __commonJS({
  "node_modules/unidecode/data/x33.js"(exports, module2) {
    module2.exports = ["apartment", "alpha", "ampere", "are", "inning", "inch", "won", "escudo", "acre", "ounce", "ohm", "kai-ri", "carat", "calorie", "gallon", "gamma", "giga", "guinea", "curie", "guilder", "kilo", "kilogram", "kilometer", "kilowatt", "gram", "gram ton", "cruzeiro", "krone", "case", "koruna", "co-op", "cycle", "centime", "shilling", "centi", "cent", "dozen", "desi", "dollar", "ton", "nano", "knot", "heights", "percent", "parts", "barrel", "piaster", "picul", "pico", "building", "farad", "feet", "bushel", "franc", "hectare", "peso", "pfennig", "hertz", "pence", "page", "beta", "point", "volt", "hon", "pound", "hall", "horn", "micro", "mile", "mach", "mark", "mansion", "micron", "milli", "millibar", "mega", "megaton", "meter", "yard", "yard", "yuan", "liter", "lira", "rupee", "ruble", "rem", "roentgen", "watt", "0h", "1h", "2h", "3h", "4h", "5h", "6h", "7h", "8h", "9h", "10h", "11h", "12h", "13h", "14h", "15h", "16h", "17h", "18h", "19h", "20h", "21h", "22h", "23h", "24h", "HPA", "da", "AU", "bar", "oV", "pc", "[?]", "[?]", "[?]", "[?]", "Heisei", "Syouwa", "Taisyou", "Meiji", "Inc.", "pA", "nA", "microamp", "mA", "kA", "kB", "MB", "GB", "cal", "kcal", "pF", "nF", "microFarad", "microgram", "mg", "kg", "Hz", "kHz", "MHz", "GHz", "THz", "microliter", "ml", "dl", "kl", "fm", "nm", "micrometer", "mm", "cm", "km", "mm^2", "cm^2", "m^2", "km^2", "mm^4", "cm^3", "m^3", "km^3", "m/s", "m/s^2", "Pa", "kPa", "MPa", "GPa", "rad", "rad/s", "rad/s^2", "ps", "ns", "microsecond", "ms", "pV", "nV", "microvolt", "mV", "kV", "MV", "pW", "nW", "microwatt", "mW", "kW", "MW", "kOhm", "MOhm", "a.m.", "Bq", "cc", "cd", "C/kg", "Co.", "dB", "Gy", "ha", "HP", "in", "K.K.", "KM", "kt", "lm", "ln", "log", "lx", "mb", "mil", "mol", "pH", "p.m.", "PPM", "PR", "sr", "Sv", "Wb", "[?]", "[?]", "1d", "2d", "3d", "4d", "5d", "6d", "7d", "8d", "9d", "10d", "11d", "12d", "13d", "14d", "15d", "16d", "17d", "18d", "19d", "20d", "21d", "22d", "23d", "24d", "25d", "26d", "27d", "28d", "29d", "30d", "31d"];
  }
});

// node_modules/unidecode/data/x4d.js
var require_x4d = __commonJS({
  "node_modules/unidecode/data/x4d.js"(exports, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x4e.js
var require_x4e = __commonJS({
  "node_modules/unidecode/data/x4e.js"(exports, module2) {
    module2.exports = ["Yi ", "Ding ", "Kao ", "Qi ", "Shang ", "Xia ", "[?] ", "Mo ", "Zhang ", "San ", "Shang ", "Xia ", "Ji ", "Bu ", "Yu ", "Mian ", "Gai ", "Chou ", "Chou ", "Zhuan ", "Qie ", "Pi ", "Shi ", "Shi ", "Qiu ", "Bing ", "Ye ", "Cong ", "Dong ", "Si ", "Cheng ", "Diu ", "Qiu ", "Liang ", "Diu ", "You ", "Liang ", "Yan ", "Bing ", "Sang ", "Gun ", "Jiu ", "Ge ", "Ya ", "Qiang ", "Zhong ", "Ji ", "Jie ", "Feng ", "Guan ", "Chuan ", "Chan ", "Lin ", "Zhuo ", "Zhu ", "Ha ", "Wan ", "Dan ", "Wei ", "Zhu ", "Jing ", "Li ", "Ju ", "Pie ", "Fu ", "Yi ", "Yi ", "Nai ", "Shime ", "Jiu ", "Jiu ", "Zhe ", "Yao ", "Yi ", "[?] ", "Zhi ", "Wu ", "Zha ", "Hu ", "Fa ", "Le ", "Zhong ", "Ping ", "Pang ", "Qiao ", "Hu ", "Guai ", "Cheng ", "Cheng ", "Yi ", "Yin ", "[?] ", "Mie ", "Jiu ", "Qi ", "Ye ", "Xi ", "Xiang ", "Gai ", "Diu ", "Hal ", "[?] ", "Shu ", "Twul ", "Shi ", "Ji ", "Nang ", "Jia ", "Kel ", "Shi ", "[?] ", "Ol ", "Mai ", "Luan ", "Cal ", "Ru ", "Xue ", "Yan ", "Fu ", "Sha ", "Na ", "Gan ", "Sol ", "El ", "Cwul ", "[?] ", "Gan ", "Chi ", "Gui ", "Gan ", "Luan ", "Lin ", "Yi ", "Jue ", "Liao ", "Ma ", "Yu ", "Zheng ", "Shi ", "Shi ", "Er ", "Chu ", "Yu ", "Yu ", "Yu ", "Yun ", "Hu ", "Qi ", "Wu ", "Jing ", "Si ", "Sui ", "Gen ", "Gen ", "Ya ", "Xie ", "Ya ", "Qi ", "Ya ", "Ji ", "Tou ", "Wang ", "Kang ", "Ta ", "Jiao ", "Hai ", "Yi ", "Chan ", "Heng ", "Mu ", "[?] ", "Xiang ", "Jing ", "Ting ", "Liang ", "Xiang ", "Jing ", "Ye ", "Qin ", "Bo ", "You ", "Xie ", "Dan ", "Lian ", "Duo ", "Wei ", "Ren ", "Ren ", "Ji ", "La ", "Wang ", "Yi ", "Shi ", "Ren ", "Le ", "Ding ", "Ze ", "Jin ", "Pu ", "Chou ", "Ba ", "Zhang ", "Jin ", "Jie ", "Bing ", "Reng ", "Cong ", "Fo ", "San ", "Lun ", "Sya ", "Cang ", "Zi ", "Shi ", "Ta ", "Zhang ", "Fu ", "Xian ", "Xian ", "Tuo ", "Hong ", "Tong ", "Ren ", "Qian ", "Gan ", "Yi ", "Di ", "Dai ", "Ling ", "Yi ", "Chao ", "Chang ", "Sa ", "[?] ", "Yi ", "Mu ", "Men ", "Ren ", "Jia ", "Chao ", "Yang ", "Qian ", "Zhong ", "Pi ", "Wan ", "Wu ", "Jian ", "Jie ", "Yao ", "Feng ", "Cang ", "Ren ", "Wang ", "Fen ", "Di ", "Fang "];
  }
});

// node_modules/unidecode/data/x4f.js
var require_x4f = __commonJS({
  "node_modules/unidecode/data/x4f.js"(exports, module2) {
    module2.exports = ["Zhong ", "Qi ", "Pei ", "Yu ", "Diao ", "Dun ", "Wen ", "Yi ", "Xin ", "Kang ", "Yi ", "Ji ", "Ai ", "Wu ", "Ji ", "Fu ", "Fa ", "Xiu ", "Jin ", "Bei ", "Dan ", "Fu ", "Tang ", "Zhong ", "You ", "Huo ", "Hui ", "Yu ", "Cui ", "Chuan ", "San ", "Wei ", "Chuan ", "Che ", "Ya ", "Xian ", "Shang ", "Chang ", "Lun ", "Cang ", "Xun ", "Xin ", "Wei ", "Zhu ", "[?] ", "Xuan ", "Nu ", "Bo ", "Gu ", "Ni ", "Ni ", "Xie ", "Ban ", "Xu ", "Ling ", "Zhou ", "Shen ", "Qu ", "Si ", "Beng ", "Si ", "Jia ", "Pi ", "Yi ", "Si ", "Ai ", "Zheng ", "Dian ", "Han ", "Mai ", "Dan ", "Zhu ", "Bu ", "Qu ", "Bi ", "Shao ", "Ci ", "Wei ", "Di ", "Zhu ", "Zuo ", "You ", "Yang ", "Ti ", "Zhan ", "He ", "Bi ", "Tuo ", "She ", "Yu ", "Yi ", "Fo ", "Zuo ", "Kou ", "Ning ", "Tong ", "Ni ", "Xuan ", "Qu ", "Yong ", "Wa ", "Qian ", "[?] ", "Ka ", "[?] ", "Pei ", "Huai ", "He ", "Lao ", "Xiang ", "Ge ", "Yang ", "Bai ", "Fa ", "Ming ", "Jia ", "Er ", "Bing ", "Ji ", "Hen ", "Huo ", "Gui ", "Quan ", "Tiao ", "Jiao ", "Ci ", "Yi ", "Shi ", "Xing ", "Shen ", "Tuo ", "Kan ", "Zhi ", "Gai ", "Lai ", "Yi ", "Chi ", "Kua ", "Guang ", "Li ", "Yin ", "Shi ", "Mi ", "Zhu ", "Xu ", "You ", "An ", "Lu ", "Mou ", "Er ", "Lun ", "Tong ", "Cha ", "Chi ", "Xun ", "Gong ", "Zhou ", "Yi ", "Ru ", "Jian ", "Xia ", "Jia ", "Zai ", "Lu ", "Ko ", "Jiao ", "Zhen ", "Ce ", "Qiao ", "Kuai ", "Chai ", "Ning ", "Nong ", "Jin ", "Wu ", "Hou ", "Jiong ", "Cheng ", "Zhen ", "Zuo ", "Chou ", "Qin ", "Lu ", "Ju ", "Shu ", "Ting ", "Shen ", "Tuo ", "Bo ", "Nan ", "Hao ", "Bian ", "Tui ", "Yu ", "Xi ", "Cu ", "E ", "Qiu ", "Xu ", "Kuang ", "Ku ", "Wu ", "Jun ", "Yi ", "Fu ", "Lang ", "Zu ", "Qiao ", "Li ", "Yong ", "Hun ", "Jing ", "Xian ", "San ", "Pai ", "Su ", "Fu ", "Xi ", "Li ", "Fu ", "Ping ", "Bao ", "Yu ", "Si ", "Xia ", "Xin ", "Xiu ", "Yu ", "Ti ", "Che ", "Chou ", "[?] ", "Yan ", "Lia ", "Li ", "Lai ", "[?] ", "Jian ", "Xiu ", "Fu ", "He ", "Ju ", "Xiao ", "Pai ", "Jian ", "Biao ", "Chu ", "Fei ", "Feng ", "Ya ", "An ", "Bei ", "Yu ", "Xin ", "Bi ", "Jian "];
  }
});

// node_modules/unidecode/data/x50.js
var require_x50 = __commonJS({
  "node_modules/unidecode/data/x50.js"(exports, module2) {
    module2.exports = ["Chang ", "Chi ", "Bing ", "Zan ", "Yao ", "Cui ", "Lia ", "Wan ", "Lai ", "Cang ", "Zong ", "Ge ", "Guan ", "Bei ", "Tian ", "Shu ", "Shu ", "Men ", "Dao ", "Tan ", "Jue ", "Chui ", "Xing ", "Peng ", "Tang ", "Hou ", "Yi ", "Qi ", "Ti ", "Gan ", "Jing ", "Jie ", "Sui ", "Chang ", "Jie ", "Fang ", "Zhi ", "Kong ", "Juan ", "Zong ", "Ju ", "Qian ", "Ni ", "Lun ", "Zhuo ", "Wei ", "Luo ", "Song ", "Leng ", "Hun ", "Dong ", "Zi ", "Ben ", "Wu ", "Ju ", "Nai ", "Cai ", "Jian ", "Zhai ", "Ye ", "Zhi ", "Sha ", "Qing ", "[?] ", "Ying ", "Cheng ", "Jian ", "Yan ", "Nuan ", "Zhong ", "Chun ", "Jia ", "Jie ", "Wei ", "Yu ", "Bing ", "Ruo ", "Ti ", "Wei ", "Pian ", "Yan ", "Feng ", "Tang ", "Wo ", "E ", "Xie ", "Che ", "Sheng ", "Kan ", "Di ", "Zuo ", "Cha ", "Ting ", "Bei ", "Ye ", "Huang ", "Yao ", "Zhan ", "Chou ", "Yan ", "You ", "Jian ", "Xu ", "Zha ", "Ci ", "Fu ", "Bi ", "Zhi ", "Zong ", "Mian ", "Ji ", "Yi ", "Xie ", "Xun ", "Si ", "Duan ", "Ce ", "Zhen ", "Ou ", "Tou ", "Tou ", "Bei ", "Za ", "Lu ", "Jie ", "Wei ", "Fen ", "Chang ", "Gui ", "Sou ", "Zhi ", "Su ", "Xia ", "Fu ", "Yuan ", "Rong ", "Li ", "Ru ", "Yun ", "Gou ", "Ma ", "Bang ", "Dian ", "Tang ", "Hao ", "Jie ", "Xi ", "Shan ", "Qian ", "Jue ", "Cang ", "Chu ", "San ", "Bei ", "Xiao ", "Yong ", "Yao ", "Tan ", "Suo ", "Yang ", "Fa ", "Bing ", "Jia ", "Dai ", "Zai ", "Tang ", "[?] ", "Bin ", "Chu ", "Nuo ", "Can ", "Lei ", "Cui ", "Yong ", "Zao ", "Zong ", "Peng ", "Song ", "Ao ", "Chuan ", "Yu ", "Zhai ", "Cou ", "Shang ", "Qiang ", "Jing ", "Chi ", "Sha ", "Han ", "Zhang ", "Qing ", "Yan ", "Di ", "Xi ", "Lu ", "Bei ", "Piao ", "Jin ", "Lian ", "Lu ", "Man ", "Qian ", "Xian ", "Tan ", "Ying ", "Dong ", "Zhuan ", "Xiang ", "Shan ", "Qiao ", "Jiong ", "Tui ", "Zun ", "Pu ", "Xi ", "Lao ", "Chang ", "Guang ", "Liao ", "Qi ", "Deng ", "Chan ", "Wei ", "Ji ", "Fan ", "Hui ", "Chuan ", "Jian ", "Dan ", "Jiao ", "Jiu ", "Seng ", "Fen ", "Xian ", "Jue ", "E ", "Jiao ", "Jian ", "Tong ", "Lin ", "Bo ", "Gu ", "[?] ", "Su ", "Xian ", "Jiang ", "Min ", "Ye ", "Jin ", "Jia ", "Qiao ", "Pi ", "Feng ", "Zhou ", "Ai ", "Sai "];
  }
});

// node_modules/unidecode/data/x51.js
var require_x51 = __commonJS({
  "node_modules/unidecode/data/x51.js"(exports, module2) {
    module2.exports = ["Yi ", "Jun ", "Nong ", "Chan ", "Yi ", "Dang ", "Jing ", "Xuan ", "Kuai ", "Jian ", "Chu ", "Dan ", "Jiao ", "Sha ", "Zai ", "[?] ", "Bin ", "An ", "Ru ", "Tai ", "Chou ", "Chai ", "Lan ", "Ni ", "Jin ", "Qian ", "Meng ", "Wu ", "Ning ", "Qiong ", "Ni ", "Chang ", "Lie ", "Lei ", "Lu ", "Kuang ", "Bao ", "Du ", "Biao ", "Zan ", "Zhi ", "Si ", "You ", "Hao ", "Chen ", "Chen ", "Li ", "Teng ", "Wei ", "Long ", "Chu ", "Chan ", "Rang ", "Shu ", "Hui ", "Li ", "Luo ", "Zan ", "Nuo ", "Tang ", "Yan ", "Lei ", "Nang ", "Er ", "Wu ", "Yun ", "Zan ", "Yuan ", "Xiong ", "Chong ", "Zhao ", "Xiong ", "Xian ", "Guang ", "Dui ", "Ke ", "Dui ", "Mian ", "Tu ", "Chang ", "Er ", "Dui ", "Er ", "Xin ", "Tu ", "Si ", "Yan ", "Yan ", "Shi ", "Shi ", "Dang ", "Qian ", "Dou ", "Fen ", "Mao ", "Shen ", "Dou ", "Bai ", "Jing ", "Li ", "Huang ", "Ru ", "Wang ", "Nei ", "Quan ", "Liang ", "Yu ", "Ba ", "Gong ", "Liu ", "Xi ", "[?] ", "Lan ", "Gong ", "Tian ", "Guan ", "Xing ", "Bing ", "Qi ", "Ju ", "Dian ", "Zi ", "Ppwun ", "Yang ", "Jian ", "Shou ", "Ji ", "Yi ", "Ji ", "Chan ", "Jiong ", "Mao ", "Ran ", "Nei ", "Yuan ", "Mao ", "Gang ", "Ran ", "Ce ", "Jiong ", "Ce ", "Zai ", "Gua ", "Jiong ", "Mao ", "Zhou ", "Mou ", "Gou ", "Xu ", "Mian ", "Mi ", "Rong ", "Yin ", "Xie ", "Kan ", "Jun ", "Nong ", "Yi ", "Mi ", "Shi ", "Guan ", "Meng ", "Zhong ", "Ju ", "Yuan ", "Ming ", "Kou ", "Lam ", "Fu ", "Xie ", "Mi ", "Bing ", "Dong ", "Tai ", "Gang ", "Feng ", "Bing ", "Hu ", "Chong ", "Jue ", "Hu ", "Kuang ", "Ye ", "Leng ", "Pan ", "Fu ", "Min ", "Dong ", "Xian ", "Lie ", "Xia ", "Jian ", "Jing ", "Shu ", "Mei ", "Tu ", "Qi ", "Gu ", "Zhun ", "Song ", "Jing ", "Liang ", "Qing ", "Diao ", "Ling ", "Dong ", "Gan ", "Jian ", "Yin ", "Cou ", "Yi ", "Li ", "Cang ", "Ming ", "Zhuen ", "Cui ", "Si ", "Duo ", "Jin ", "Lin ", "Lin ", "Ning ", "Xi ", "Du ", "Ji ", "Fan ", "Fan ", "Fan ", "Feng ", "Ju ", "Chu ", "Tako ", "Feng ", "Mok ", "Ci ", "Fu ", "Feng ", "Ping ", "Feng ", "Kai ", "Huang ", "Kai ", "Gan ", "Deng ", "Ping ", "Qu ", "Xiong ", "Kuai ", "Tu ", "Ao ", "Chu ", "Ji ", "Dang ", "Han ", "Han ", "Zao "];
  }
});

// node_modules/unidecode/data/x52.js
var require_x52 = __commonJS({
  "node_modules/unidecode/data/x52.js"(exports, module2) {
    module2.exports = ["Dao ", "Diao ", "Dao ", "Ren ", "Ren ", "Chuang ", "Fen ", "Qie ", "Yi ", "Ji ", "Kan ", "Qian ", "Cun ", "Chu ", "Wen ", "Ji ", "Dan ", "Xing ", "Hua ", "Wan ", "Jue ", "Li ", "Yue ", "Lie ", "Liu ", "Ze ", "Gang ", "Chuang ", "Fu ", "Chu ", "Qu ", "Ju ", "Shan ", "Min ", "Ling ", "Zhong ", "Pan ", "Bie ", "Jie ", "Jie ", "Bao ", "Li ", "Shan ", "Bie ", "Chan ", "Jing ", "Gua ", "Gen ", "Dao ", "Chuang ", "Kui ", "Ku ", "Duo ", "Er ", "Zhi ", "Shua ", "Quan ", "Cha ", "Ci ", "Ke ", "Jie ", "Gui ", "Ci ", "Gui ", "Kai ", "Duo ", "Ji ", "Ti ", "Jing ", "Lou ", "Gen ", "Ze ", "Yuan ", "Cuo ", "Xue ", "Ke ", "La ", "Qian ", "Cha ", "Chuang ", "Gua ", "Jian ", "Cuo ", "Li ", "Ti ", "Fei ", "Pou ", "Chan ", "Qi ", "Chuang ", "Zi ", "Gang ", "Wan ", "Bo ", "Ji ", "Duo ", "Qing ", "Yan ", "Zhuo ", "Jian ", "Ji ", "Bo ", "Yan ", "Ju ", "Huo ", "Sheng ", "Jian ", "Duo ", "Duan ", "Wu ", "Gua ", "Fu ", "Sheng ", "Jian ", "Ge ", "Zha ", "Kai ", "Chuang ", "Juan ", "Chan ", "Tuan ", "Lu ", "Li ", "Fou ", "Shan ", "Piao ", "Kou ", "Jiao ", "Gua ", "Qiao ", "Jue ", "Hua ", "Zha ", "Zhuo ", "Lian ", "Ju ", "Pi ", "Liu ", "Gui ", "Jiao ", "Gui ", "Jian ", "Jian ", "Tang ", "Huo ", "Ji ", "Jian ", "Yi ", "Jian ", "Zhi ", "Chan ", "Cuan ", "Mo ", "Li ", "Zhu ", "Li ", "Ya ", "Quan ", "Ban ", "Gong ", "Jia ", "Wu ", "Mai ", "Lie ", "Jin ", "Keng ", "Xie ", "Zhi ", "Dong ", "Zhu ", "Nu ", "Jie ", "Qu ", "Shao ", "Yi ", "Zhu ", "Miao ", "Li ", "Jing ", "Lao ", "Lao ", "Juan ", "Kou ", "Yang ", "Wa ", "Xiao ", "Mou ", "Kuang ", "Jie ", "Lie ", "He ", "Shi ", "Ke ", "Jing ", "Hao ", "Bo ", "Min ", "Chi ", "Lang ", "Yong ", "Yong ", "Mian ", "Ke ", "Xun ", "Juan ", "Qing ", "Lu ", "Pou ", "Meng ", "Lai ", "Le ", "Kai ", "Mian ", "Dong ", "Xu ", "Xu ", "Kan ", "Wu ", "Yi ", "Xun ", "Weng ", "Sheng ", "Lao ", "Mu ", "Lu ", "Piao ", "Shi ", "Ji ", "Qin ", "Qiang ", "Jiao ", "Quan ", "Yang ", "Yi ", "Jue ", "Fan ", "Juan ", "Tong ", "Ju ", "Dan ", "Xie ", "Mai ", "Xun ", "Xun ", "Lu ", "Li ", "Che ", "Rang ", "Quan ", "Bao ", "Shao ", "Yun ", "Jiu ", "Bao ", "Gou ", "Wu "];
  }
});

// node_modules/unidecode/data/x53.js
var require_x53 = __commonJS({
  "node_modules/unidecode/data/x53.js"(exports, module2) {
    module2.exports = ["Yun ", "Mwun ", "Nay ", "Gai ", "Gai ", "Bao ", "Cong ", "[?] ", "Xiong ", "Peng ", "Ju ", "Tao ", "Ge ", "Pu ", "An ", "Pao ", "Fu ", "Gong ", "Da ", "Jiu ", "Qiong ", "Bi ", "Hua ", "Bei ", "Nao ", "Chi ", "Fang ", "Jiu ", "Yi ", "Za ", "Jiang ", "Kang ", "Jiang ", "Kuang ", "Hu ", "Xia ", "Qu ", "Bian ", "Gui ", "Qie ", "Zang ", "Kuang ", "Fei ", "Hu ", "Tou ", "Gui ", "Gui ", "Hui ", "Dan ", "Gui ", "Lian ", "Lian ", "Suan ", "Du ", "Jiu ", "Qu ", "Xi ", "Pi ", "Qu ", "Yi ", "Qia ", "Yan ", "Bian ", "Ni ", "Qu ", "Shi ", "Xin ", "Qian ", "Nian ", "Sa ", "Zu ", "Sheng ", "Wu ", "Hui ", "Ban ", "Shi ", "Xi ", "Wan ", "Hua ", "Xie ", "Wan ", "Bei ", "Zu ", "Zhuo ", "Xie ", "Dan ", "Mai ", "Nan ", "Dan ", "Ji ", "Bo ", "Shuai ", "Bu ", "Kuang ", "Bian ", "Bu ", "Zhan ", "Qia ", "Lu ", "You ", "Lu ", "Xi ", "Gua ", "Wo ", "Xie ", "Jie ", "Jie ", "Wei ", "Ang ", "Qiong ", "Zhi ", "Mao ", "Yin ", "Wei ", "Shao ", "Ji ", "Que ", "Luan ", "Shi ", "Juan ", "Xie ", "Xu ", "Jin ", "Que ", "Wu ", "Ji ", "E ", "Qing ", "Xi ", "[?] ", "Han ", "Zhan ", "E ", "Ting ", "Li ", "Zhe ", "Han ", "Li ", "Ya ", "Ya ", "Yan ", "She ", "Zhi ", "Zha ", "Pang ", "[?] ", "He ", "Ya ", "Zhi ", "Ce ", "Pang ", "Ti ", "Li ", "She ", "Hou ", "Ting ", "Zui ", "Cuo ", "Fei ", "Yuan ", "Ce ", "Yuan ", "Xiang ", "Yan ", "Li ", "Jue ", "Sha ", "Dian ", "Chu ", "Jiu ", "Qin ", "Ao ", "Gui ", "Yan ", "Si ", "Li ", "Chang ", "Lan ", "Li ", "Yan ", "Yan ", "Yuan ", "Si ", "Gong ", "Lin ", "Qiu ", "Qu ", "Qu ", "Uk ", "Lei ", "Du ", "Xian ", "Zhuan ", "San ", "Can ", "Can ", "Can ", "Can ", "Ai ", "Dai ", "You ", "Cha ", "Ji ", "You ", "Shuang ", "Fan ", "Shou ", "Guai ", "Ba ", "Fa ", "Ruo ", "Shi ", "Shu ", "Zhuo ", "Qu ", "Shou ", "Bian ", "Xu ", "Jia ", "Pan ", "Sou ", "Gao ", "Wei ", "Sou ", "Die ", "Rui ", "Cong ", "Kou ", "Gu ", "Ju ", "Ling ", "Gua ", "Tao ", "Kou ", "Zhi ", "Jiao ", "Zhao ", "Ba ", "Ding ", "Ke ", "Tai ", "Chi ", "Shi ", "You ", "Qiu ", "Po ", "Xie ", "Hao ", "Si ", "Tan ", "Chi ", "Le ", "Diao ", "Ji ", "[?] ", "Hong "];
  }
});

// node_modules/unidecode/data/x54.js
var require_x54 = __commonJS({
  "node_modules/unidecode/data/x54.js"(exports, module2) {
    module2.exports = ["Mie ", "Xu ", "Mang ", "Chi ", "Ge ", "Xuan ", "Yao ", "Zi ", "He ", "Ji ", "Diao ", "Cun ", "Tong ", "Ming ", "Hou ", "Li ", "Tu ", "Xiang ", "Zha ", "Xia ", "Ye ", "Lu ", "A ", "Ma ", "Ou ", "Xue ", "Yi ", "Jun ", "Chou ", "Lin ", "Tun ", "Yin ", "Fei ", "Bi ", "Qin ", "Qin ", "Jie ", "Bu ", "Fou ", "Ba ", "Dun ", "Fen ", "E ", "Han ", "Ting ", "Hang ", "Shun ", "Qi ", "Hong ", "Zhi ", "Shen ", "Wu ", "Wu ", "Chao ", "Ne ", "Xue ", "Xi ", "Chui ", "Dou ", "Wen ", "Hou ", "Ou ", "Wu ", "Gao ", "Ya ", "Jun ", "Lu ", "E ", "Ge ", "Mei ", "Ai ", "Qi ", "Cheng ", "Wu ", "Gao ", "Fu ", "Jiao ", "Hong ", "Chi ", "Sheng ", "Ne ", "Tun ", "Fu ", "Yi ", "Dai ", "Ou ", "Li ", "Bai ", "Yuan ", "Kuai ", "[?] ", "Qiang ", "Wu ", "E ", "Shi ", "Quan ", "Pen ", "Wen ", "Ni ", "M ", "Ling ", "Ran ", "You ", "Di ", "Zhou ", "Shi ", "Zhou ", "Tie ", "Xi ", "Yi ", "Qi ", "Ping ", "Zi ", "Gu ", "Zi ", "Wei ", "Xu ", "He ", "Nao ", "Xia ", "Pei ", "Yi ", "Xiao ", "Shen ", "Hu ", "Ming ", "Da ", "Qu ", "Ju ", "Gem ", "Za ", "Tuo ", "Duo ", "Pou ", "Pao ", "Bi ", "Fu ", "Yang ", "He ", "Zha ", "He ", "Hai ", "Jiu ", "Yong ", "Fu ", "Que ", "Zhou ", "Wa ", "Ka ", "Gu ", "Ka ", "Zuo ", "Bu ", "Long ", "Dong ", "Ning ", "Tha ", "Si ", "Xian ", "Huo ", "Qi ", "Er ", "E ", "Guang ", "Zha ", "Xi ", "Yi ", "Lie ", "Zi ", "Mie ", "Mi ", "Zhi ", "Yao ", "Ji ", "Zhou ", "Ge ", "Shuai ", "Zan ", "Xiao ", "Ke ", "Hui ", "Kua ", "Huai ", "Tao ", "Xian ", "E ", "Xuan ", "Xiu ", "Wai ", "Yan ", "Lao ", "Yi ", "Ai ", "Pin ", "Shen ", "Tong ", "Hong ", "Xiong ", "Chi ", "Wa ", "Ha ", "Zai ", "Yu ", "Di ", "Pai ", "Xiang ", "Ai ", "Hen ", "Kuang ", "Ya ", "Da ", "Xiao ", "Bi ", "Yue ", "[?] ", "Hua ", "Sasou ", "Kuai ", "Duo ", "[?] ", "Ji ", "Nong ", "Mou ", "Yo ", "Hao ", "Yuan ", "Long ", "Pou ", "Mang ", "Ge ", "E ", "Chi ", "Shao ", "Li ", "Na ", "Zu ", "He ", "Ku ", "Xiao ", "Xian ", "Lao ", "Bo ", "Zhe ", "Zha ", "Liang ", "Ba ", "Mie ", "Le ", "Sui ", "Fou ", "Bu ", "Han ", "Heng ", "Geng ", "Shuo ", "Ge "];
  }
});

// node_modules/unidecode/data/x55.js
var require_x55 = __commonJS({
  "node_modules/unidecode/data/x55.js"(exports, module2) {
    module2.exports = ["You ", "Yan ", "Gu ", "Gu ", "Bai ", "Han ", "Suo ", "Chun ", "Yi ", "Ai ", "Jia ", "Tu ", "Xian ", "Huan ", "Li ", "Xi ", "Tang ", "Zuo ", "Qiu ", "Che ", "Wu ", "Zao ", "Ya ", "Dou ", "Qi ", "Di ", "Qin ", "Ma ", "Mal ", "Hong ", "Dou ", "Kes ", "Lao ", "Liang ", "Suo ", "Zao ", "Huan ", "Lang ", "Sha ", "Ji ", "Zuo ", "Wo ", "Feng ", "Yin ", "Hu ", "Qi ", "Shou ", "Wei ", "Shua ", "Chang ", "Er ", "Li ", "Qiang ", "An ", "Jie ", "Yo ", "Nian ", "Yu ", "Tian ", "Lai ", "Sha ", "Xi ", "Tuo ", "Hu ", "Ai ", "Zhou ", "Nou ", "Ken ", "Zhuo ", "Zhuo ", "Shang ", "Di ", "Heng ", "Lan ", "A ", "Xiao ", "Xiang ", "Tun ", "Wu ", "Wen ", "Cui ", "Sha ", "Hu ", "Qi ", "Qi ", "Tao ", "Dan ", "Dan ", "Ye ", "Zi ", "Bi ", "Cui ", "Chuo ", "He ", "Ya ", "Qi ", "Zhe ", "Pei ", "Liang ", "Xian ", "Pi ", "Sha ", "La ", "Ze ", "Qing ", "Gua ", "Pa ", "Zhe ", "Se ", "Zhuan ", "Nie ", "Guo ", "Luo ", "Yan ", "Di ", "Quan ", "Tan ", "Bo ", "Ding ", "Lang ", "Xiao ", "[?] ", "Tang ", "Chi ", "Ti ", "An ", "Jiu ", "Dan ", "Ke ", "Yong ", "Wei ", "Nan ", "Shan ", "Yu ", "Zhe ", "La ", "Jie ", "Hou ", "Han ", "Die ", "Zhou ", "Chai ", "Wai ", "Re ", "Yu ", "Yin ", "Zan ", "Yao ", "Wo ", "Mian ", "Hu ", "Yun ", "Chuan ", "Hui ", "Huan ", "Huan ", "Xi ", "He ", "Ji ", "Kui ", "Zhong ", "Wei ", "Sha ", "Xu ", "Huang ", "Du ", "Nie ", "Xuan ", "Liang ", "Yu ", "Sang ", "Chi ", "Qiao ", "Yan ", "Dan ", "Pen ", "Can ", "Li ", "Yo ", "Zha ", "Wei ", "Miao ", "Ying ", "Pen ", "Phos ", "Kui ", "Xi ", "Yu ", "Jie ", "Lou ", "Ku ", "Sao ", "Huo ", "Ti ", "Yao ", "He ", "A ", "Xiu ", "Qiang ", "Se ", "Yong ", "Su ", "Hong ", "Xie ", "Yi ", "Suo ", "Ma ", "Cha ", "Hai ", "Ke ", "Ta ", "Sang ", "Tian ", "Ru ", "Sou ", "Wa ", "Ji ", "Pang ", "Wu ", "Xian ", "Shi ", "Ge ", "Zi ", "Jie ", "Luo ", "Weng ", "Wa ", "Si ", "Chi ", "Hao ", "Suo ", "Jia ", "Hai ", "Suo ", "Qin ", "Nie ", "He ", "Cis ", "Sai ", "Ng ", "Ge ", "Na ", "Dia ", "Ai ", "[?] ", "Tong ", "Bi ", "Ao ", "Ao ", "Lian ", "Cui ", "Zhe ", "Mo ", "Sou ", "Sou ", "Tan "];
  }
});

// node_modules/unidecode/data/x56.js
var require_x56 = __commonJS({
  "node_modules/unidecode/data/x56.js"(exports, module2) {
    module2.exports = ["Di ", "Qi ", "Jiao ", "Chong ", "Jiao ", "Kai ", "Tan ", "San ", "Cao ", "Jia ", "Ai ", "Xiao ", "Piao ", "Lou ", "Ga ", "Gu ", "Xiao ", "Hu ", "Hui ", "Guo ", "Ou ", "Xian ", "Ze ", "Chang ", "Xu ", "Po ", "De ", "Ma ", "Ma ", "Hu ", "Lei ", "Du ", "Ga ", "Tang ", "Ye ", "Beng ", "Ying ", "Saai ", "Jiao ", "Mi ", "Xiao ", "Hua ", "Mai ", "Ran ", "Zuo ", "Peng ", "Lao ", "Xiao ", "Ji ", "Zhu ", "Chao ", "Kui ", "Zui ", "Xiao ", "Si ", "Hao ", "Fu ", "Liao ", "Qiao ", "Xi ", "Xiu ", "Tan ", "Tan ", "Mo ", "Xun ", "E ", "Zun ", "Fan ", "Chi ", "Hui ", "Zan ", "Chuang ", "Cu ", "Dan ", "Yu ", "Tun ", "Cheng ", "Jiao ", "Ye ", "Xi ", "Qi ", "Hao ", "Lian ", "Xu ", "Deng ", "Hui ", "Yin ", "Pu ", "Jue ", "Qin ", "Xun ", "Nie ", "Lu ", "Si ", "Yan ", "Ying ", "Da ", "Dan ", "Yu ", "Zhou ", "Jin ", "Nong ", "Yue ", "Hui ", "Qi ", "E ", "Zao ", "Yi ", "Shi ", "Jiao ", "Yuan ", "Ai ", "Yong ", "Jue ", "Kuai ", "Yu ", "Pen ", "Dao ", "Ge ", "Xin ", "Dun ", "Dang ", "Sin ", "Sai ", "Pi ", "Pi ", "Yin ", "Zui ", "Ning ", "Di ", "Lan ", "Ta ", "Huo ", "Ru ", "Hao ", "Xia ", "Ya ", "Duo ", "Xi ", "Chou ", "Ji ", "Jin ", "Hao ", "Ti ", "Chang ", "[?] ", "[?] ", "Ca ", "Ti ", "Lu ", "Hui ", "Bo ", "You ", "Nie ", "Yin ", "Hu ", "Mo ", "Huang ", "Zhe ", "Li ", "Liu ", "Haai ", "Nang ", "Xiao ", "Mo ", "Yan ", "Li ", "Lu ", "Long ", "Fu ", "Dan ", "Chen ", "Pin ", "Pi ", "Xiang ", "Huo ", "Mo ", "Xi ", "Duo ", "Ku ", "Yan ", "Chan ", "Ying ", "Rang ", "Dian ", "La ", "Ta ", "Xiao ", "Jiao ", "Chuo ", "Huan ", "Huo ", "Zhuan ", "Nie ", "Xiao ", "Ca ", "Li ", "Chan ", "Chai ", "Li ", "Yi ", "Luo ", "Nang ", "Zan ", "Su ", "Xi ", "So ", "Jian ", "Za ", "Zhu ", "Lan ", "Nie ", "Nang ", "[?] ", "[?] ", "Wei ", "Hui ", "Yin ", "Qiu ", "Si ", "Nin ", "Jian ", "Hui ", "Xin ", "Yin ", "Nan ", "Tuan ", "Tuan ", "Dun ", "Kang ", "Yuan ", "Jiong ", "Pian ", "Yun ", "Cong ", "Hu ", "Hui ", "Yuan ", "You ", "Guo ", "Kun ", "Cong ", "Wei ", "Tu ", "Wei ", "Lun ", "Guo ", "Qun ", "Ri ", "Ling ", "Gu ", "Guo ", "Tai ", "Guo ", "Tu ", "You "];
  }
});

// node_modules/unidecode/data/x57.js
var require_x57 = __commonJS({
  "node_modules/unidecode/data/x57.js"(exports, module2) {
    module2.exports = ["Guo ", "Yin ", "Hun ", "Pu ", "Yu ", "Han ", "Yuan ", "Lun ", "Quan ", "Yu ", "Qing ", "Guo ", "Chuan ", "Wei ", "Yuan ", "Quan ", "Ku ", "Fu ", "Yuan ", "Yuan ", "E ", "Tu ", "Tu ", "Tu ", "Tuan ", "Lue ", "Hui ", "Yi ", "Yuan ", "Luan ", "Luan ", "Tu ", "Ya ", "Tu ", "Ting ", "Sheng ", "Pu ", "Lu ", "Iri ", "Ya ", "Zai ", "Wei ", "Ge ", "Yu ", "Wu ", "Gui ", "Pi ", "Yi ", "Di ", "Qian ", "Qian ", "Zhen ", "Zhuo ", "Dang ", "Qia ", "Akutsu ", "Yama ", "Kuang ", "Chang ", "Qi ", "Nie ", "Mo ", "Ji ", "Jia ", "Zhi ", "Zhi ", "Ban ", "Xun ", "Tou ", "Qin ", "Fen ", "Jun ", "Keng ", "Tun ", "Fang ", "Fen ", "Ben ", "Tan ", "Kan ", "Pi ", "Zuo ", "Keng ", "Bi ", "Xing ", "Di ", "Jing ", "Ji ", "Kuai ", "Di ", "Jing ", "Jian ", "Tan ", "Li ", "Ba ", "Wu ", "Fen ", "Zhui ", "Po ", "Pan ", "Tang ", "Kun ", "Qu ", "Tan ", "Zhi ", "Tuo ", "Gan ", "Ping ", "Dian ", "Gua ", "Ni ", "Tai ", "Pi ", "Jiong ", "Yang ", "Fo ", "Ao ", "Liu ", "Qiu ", "Mu ", "Ke ", "Gou ", "Xue ", "Ba ", "Chi ", "Che ", "Ling ", "Zhu ", "Fu ", "Hu ", "Zhi ", "Chui ", "La ", "Long ", "Long ", "Lu ", "Ao ", "Tay ", "Pao ", "[?] ", "Xing ", "Dong ", "Ji ", "Ke ", "Lu ", "Ci ", "Chi ", "Lei ", "Gai ", "Yin ", "Hou ", "Dui ", "Zhao ", "Fu ", "Guang ", "Yao ", "Duo ", "Duo ", "Gui ", "Cha ", "Yang ", "Yin ", "Fa ", "Gou ", "Yuan ", "Die ", "Xie ", "Ken ", "Jiong ", "Shou ", "E ", "Ha ", "Dian ", "Hong ", "Wu ", "Kua ", "[?] ", "Tao ", "Dang ", "Kai ", "Gake ", "Nao ", "An ", "Xing ", "Xian ", "Huan ", "Bang ", "Pei ", "Ba ", "Yi ", "Yin ", "Han ", "Xu ", "Chui ", "Cen ", "Geng ", "Ai ", "Peng ", "Fang ", "Que ", "Yong ", "Xun ", "Jia ", "Di ", "Mai ", "Lang ", "Xuan ", "Cheng ", "Yan ", "Jin ", "Zhe ", "Lei ", "Lie ", "Bu ", "Cheng ", "Gomi ", "Bu ", "Shi ", "Xun ", "Guo ", "Jiong ", "Ye ", "Nian ", "Di ", "Yu ", "Bu ", "Ya ", "Juan ", "Sui ", "Pi ", "Cheng ", "Wan ", "Ju ", "Lun ", "Zheng ", "Kong ", "Chong ", "Dong ", "Dai ", "Tan ", "An ", "Cai ", "Shu ", "Beng ", "Kan ", "Zhi ", "Duo ", "Yi ", "Zhi ", "Yi ", "Pei ", "Ji ", "Zhun ", "Qi ", "Sao ", "Ju ", "Ni "];
  }
});

// node_modules/unidecode/data/x58.js
var require_x58 = __commonJS({
  "node_modules/unidecode/data/x58.js"(exports, module2) {
    module2.exports = ["Ku ", "Ke ", "Tang ", "Kun ", "Ni ", "Jian ", "Dui ", "Jin ", "Gang ", "Yu ", "E ", "Peng ", "Gu ", "Tu ", "Leng ", "[?] ", "Ya ", "Qian ", "[?] ", "An ", "[?] ", "Duo ", "Nao ", "Tu ", "Cheng ", "Yin ", "Hun ", "Bi ", "Lian ", "Guo ", "Die ", "Zhuan ", "Hou ", "Bao ", "Bao ", "Yu ", "Di ", "Mao ", "Jie ", "Ruan ", "E ", "Geng ", "Kan ", "Zong ", "Yu ", "Huang ", "E ", "Yao ", "Yan ", "Bao ", "Ji ", "Mei ", "Chang ", "Du ", "Tuo ", "Yin ", "Feng ", "Zhong ", "Jie ", "Zhen ", "Feng ", "Gang ", "Chuan ", "Jian ", "Pyeng ", "Toride ", "Xiang ", "Huang ", "Leng ", "Duan ", "[?] ", "Xuan ", "Ji ", "Ji ", "Kuai ", "Ying ", "Ta ", "Cheng ", "Yong ", "Kai ", "Su ", "Su ", "Shi ", "Mi ", "Ta ", "Weng ", "Cheng ", "Tu ", "Tang ", "Que ", "Zhong ", "Li ", "Peng ", "Bang ", "Sai ", "Zang ", "Dui ", "Tian ", "Wu ", "Cheng ", "Xun ", "Ge ", "Zhen ", "Ai ", "Gong ", "Yan ", "Kan ", "Tian ", "Yuan ", "Wen ", "Xie ", "Liu ", "Ama ", "Lang ", "Chang ", "Peng ", "Beng ", "Chen ", "Cu ", "Lu ", "Ou ", "Qian ", "Mei ", "Mo ", "Zhuan ", "Shuang ", "Shu ", "Lou ", "Chi ", "Man ", "Biao ", "Jing ", "Qi ", "Shu ", "Di ", "Zhang ", "Kan ", "Yong ", "Dian ", "Chen ", "Zhi ", "Xi ", "Guo ", "Qiang ", "Jin ", "Di ", "Shang ", "Mu ", "Cui ", "Yan ", "Ta ", "Zeng ", "Qi ", "Qiang ", "Liang ", "[?] ", "Zhui ", "Qiao ", "Zeng ", "Xu ", "Shan ", "Shan ", "Ba ", "Pu ", "Kuai ", "Dong ", "Fan ", "Que ", "Mo ", "Dun ", "Dun ", "Dun ", "Di ", "Sheng ", "Duo ", "Duo ", "Tan ", "Deng ", "Wu ", "Fen ", "Huang ", "Tan ", "Da ", "Ye ", "Sho ", "Mama ", "Yu ", "Qiang ", "Ji ", "Qiao ", "Ken ", "Yi ", "Pi ", "Bi ", "Dian ", "Jiang ", "Ye ", "Yong ", "Bo ", "Tan ", "Lan ", "Ju ", "Huai ", "Dang ", "Rang ", "Qian ", "Xun ", "Lan ", "Xi ", "He ", "Ai ", "Ya ", "Dao ", "Hao ", "Ruan ", "Mama ", "Lei ", "Kuang ", "Lu ", "Yan ", "Tan ", "Wei ", "Huai ", "Long ", "Long ", "Rui ", "Li ", "Lin ", "Rang ", "Ten ", "Xun ", "Yan ", "Lei ", "Ba ", "[?] ", "Shi ", "Ren ", "[?] ", "Zhuang ", "Zhuang ", "Sheng ", "Yi ", "Mai ", "Ke ", "Zhu ", "Zhuang ", "Hu ", "Hu ", "Kun ", "Yi ", "Hu ", "Xu ", "Kun ", "Shou ", "Mang ", "Zun "];
  }
});

// node_modules/unidecode/data/x59.js
var require_x59 = __commonJS({
  "node_modules/unidecode/data/x59.js"(exports, module2) {
    module2.exports = ["Shou ", "Yi ", "Zhi ", "Gu ", "Chu ", "Jiang ", "Feng ", "Bei ", "Cay ", "Bian ", "Sui ", "Qun ", "Ling ", "Fu ", "Zuo ", "Xia ", "Xiong ", "[?] ", "Nao ", "Xia ", "Kui ", "Xi ", "Wai ", "Yuan ", "Mao ", "Su ", "Duo ", "Duo ", "Ye ", "Qing ", "Uys ", "Gou ", "Gou ", "Qi ", "Meng ", "Meng ", "Yin ", "Huo ", "Chen ", "Da ", "Ze ", "Tian ", "Tai ", "Fu ", "Guai ", "Yao ", "Yang ", "Hang ", "Gao ", "Shi ", "Ben ", "Tai ", "Tou ", "Yan ", "Bi ", "Yi ", "Kua ", "Jia ", "Duo ", "Kwu ", "Kuang ", "Yun ", "Jia ", "Pa ", "En ", "Lian ", "Huan ", "Di ", "Yan ", "Pao ", "Quan ", "Qi ", "Nai ", "Feng ", "Xie ", "Fen ", "Dian ", "[?] ", "Kui ", "Zou ", "Huan ", "Qi ", "Kai ", "Zha ", "Ben ", "Yi ", "Jiang ", "Tao ", "Zang ", "Ben ", "Xi ", "Xiang ", "Fei ", "Diao ", "Xun ", "Keng ", "Dian ", "Ao ", "She ", "Weng ", "Pan ", "Ao ", "Wu ", "Ao ", "Jiang ", "Lian ", "Duo ", "Yun ", "Jiang ", "Shi ", "Fen ", "Huo ", "Bi ", "Lian ", "Duo ", "Nu ", "Nu ", "Ding ", "Nai ", "Qian ", "Jian ", "Ta ", "Jiu ", "Nan ", "Cha ", "Hao ", "Xian ", "Fan ", "Ji ", "Shuo ", "Ru ", "Fei ", "Wang ", "Hong ", "Zhuang ", "Fu ", "Ma ", "Dan ", "Ren ", "Fu ", "Jing ", "Yan ", "Xie ", "Wen ", "Zhong ", "Pa ", "Du ", "Ji ", "Keng ", "Zhong ", "Yao ", "Jin ", "Yun ", "Miao ", "Pei ", "Shi ", "Yue ", "Zhuang ", "Niu ", "Yan ", "Na ", "Xin ", "Fen ", "Bi ", "Yu ", "Tuo ", "Feng ", "Yuan ", "Fang ", "Wu ", "Yu ", "Gui ", "Du ", "Ba ", "Ni ", "Zhou ", "Zhuo ", "Zhao ", "Da ", "Nai ", "Yuan ", "Tou ", "Xuan ", "Zhi ", "E ", "Mei ", "Mo ", "Qi ", "Bi ", "Shen ", "Qie ", "E ", "He ", "Xu ", "Fa ", "Zheng ", "Min ", "Ban ", "Mu ", "Fu ", "Ling ", "Zi ", "Zi ", "Shi ", "Ran ", "Shan ", "Yang ", "Man ", "Jie ", "Gu ", "Si ", "Xing ", "Wei ", "Zi ", "Ju ", "Shan ", "Pin ", "Ren ", "Yao ", "Tong ", "Jiang ", "Shu ", "Ji ", "Gai ", "Shang ", "Kuo ", "Juan ", "Jiao ", "Gou ", "Mu ", "Jian ", "Jian ", "Yi ", "Nian ", "Zhi ", "Ji ", "Ji ", "Xian ", "Heng ", "Guang ", "Jun ", "Kua ", "Yan ", "Ming ", "Lie ", "Pei ", "Yan ", "You ", "Yan ", "Cha ", "Shen ", "Yin ", "Chi ", "Gui ", "Quan ", "Zi "];
  }
});

// node_modules/unidecode/data/x5a.js
var require_x5a = __commonJS({
  "node_modules/unidecode/data/x5a.js"(exports, module2) {
    module2.exports = ["Song ", "Wei ", "Hong ", "Wa ", "Lou ", "Ya ", "Rao ", "Jiao ", "Luan ", "Ping ", "Xian ", "Shao ", "Li ", "Cheng ", "Xiao ", "Mang ", "Fu ", "Suo ", "Wu ", "Wei ", "Ke ", "Lai ", "Chuo ", "Ding ", "Niang ", "Xing ", "Nan ", "Yu ", "Nuo ", "Pei ", "Nei ", "Juan ", "Shen ", "Zhi ", "Han ", "Di ", "Zhuang ", "E ", "Pin ", "Tui ", "Han ", "Mian ", "Wu ", "Yan ", "Wu ", "Xi ", "Yan ", "Yu ", "Si ", "Yu ", "Wa ", "[?] ", "Xian ", "Ju ", "Qu ", "Shui ", "Qi ", "Xian ", "Zhui ", "Dong ", "Chang ", "Lu ", "Ai ", "E ", "E ", "Lou ", "Mian ", "Cong ", "Pou ", "Ju ", "Po ", "Cai ", "Ding ", "Wan ", "Biao ", "Xiao ", "Shu ", "Qi ", "Hui ", "Fu ", "E ", "Wo ", "Tan ", "Fei ", "Wei ", "Jie ", "Tian ", "Ni ", "Quan ", "Jing ", "Hun ", "Jing ", "Qian ", "Dian ", "Xing ", "Hu ", "Wa ", "Lai ", "Bi ", "Yin ", "Chou ", "Chuo ", "Fu ", "Jing ", "Lun ", "Yan ", "Lan ", "Kun ", "Yin ", "Ya ", "Ju ", "Li ", "Dian ", "Xian ", "Hwa ", "Hua ", "Ying ", "Chan ", "Shen ", "Ting ", "Dang ", "Yao ", "Wu ", "Nan ", "Ruo ", "Jia ", "Tou ", "Xu ", "Yu ", "Wei ", "Ti ", "Rou ", "Mei ", "Dan ", "Ruan ", "Qin ", "Hui ", "Wu ", "Qian ", "Chun ", "Mao ", "Fu ", "Jie ", "Duan ", "Xi ", "Zhong ", "Mei ", "Huang ", "Mian ", "An ", "Ying ", "Xuan ", "Jie ", "Wei ", "Mei ", "Yuan ", "Zhen ", "Qiu ", "Ti ", "Xie ", "Tuo ", "Lian ", "Mao ", "Ran ", "Si ", "Pian ", "Wei ", "Wa ", "Jiu ", "Hu ", "Ao ", "[?] ", "Bou ", "Xu ", "Tou ", "Gui ", "Zou ", "Yao ", "Pi ", "Xi ", "Yuan ", "Ying ", "Rong ", "Ru ", "Chi ", "Liu ", "Mei ", "Pan ", "Ao ", "Ma ", "Gou ", "Kui ", "Qin ", "Jia ", "Sao ", "Zhen ", "Yuan ", "Cha ", "Yong ", "Ming ", "Ying ", "Ji ", "Su ", "Niao ", "Xian ", "Tao ", "Pang ", "Lang ", "Nao ", "Bao ", "Ai ", "Pi ", "Pin ", "Yi ", "Piao ", "Yu ", "Lei ", "Xuan ", "Man ", "Yi ", "Zhang ", "Kang ", "Yong ", "Ni ", "Li ", "Di ", "Gui ", "Yan ", "Jin ", "Zhuan ", "Chang ", "Ce ", "Han ", "Nen ", "Lao ", "Mo ", "Zhe ", "Hu ", "Hu ", "Ao ", "Nen ", "Qiang ", "Ma ", "Pie ", "Gu ", "Wu ", "Jiao ", "Tuo ", "Zhan ", "Mao ", "Xian ", "Xian ", "Mo ", "Liao ", "Lian ", "Hua "];
  }
});

// node_modules/unidecode/data/x5b.js
var require_x5b = __commonJS({
  "node_modules/unidecode/data/x5b.js"(exports, module2) {
    module2.exports = ["Gui ", "Deng ", "Zhi ", "Xu ", "Yi ", "Hua ", "Xi ", "Hui ", "Rao ", "Xi ", "Yan ", "Chan ", "Jiao ", "Mei ", "Fan ", "Fan ", "Xian ", "Yi ", "Wei ", "Jiao ", "Fu ", "Shi ", "Bi ", "Shan ", "Sui ", "Qiang ", "Lian ", "Huan ", "Xin ", "Niao ", "Dong ", "Yi ", "Can ", "Ai ", "Niang ", "Neng ", "Ma ", "Tiao ", "Chou ", "Jin ", "Ci ", "Yu ", "Pin ", "Yong ", "Xu ", "Nai ", "Yan ", "Tai ", "Ying ", "Can ", "Niao ", "Wo ", "Ying ", "Mian ", "Kaka ", "Ma ", "Shen ", "Xing ", "Ni ", "Du ", "Liu ", "Yuan ", "Lan ", "Yan ", "Shuang ", "Ling ", "Jiao ", "Niang ", "Lan ", "Xian ", "Ying ", "Shuang ", "Shuai ", "Quan ", "Mi ", "Li ", "Luan ", "Yan ", "Zhu ", "Lan ", "Zi ", "Jie ", "Jue ", "Jue ", "Kong ", "Yun ", "Zi ", "Zi ", "Cun ", "Sun ", "Fu ", "Bei ", "Zi ", "Xiao ", "Xin ", "Meng ", "Si ", "Tai ", "Bao ", "Ji ", "Gu ", "Nu ", "Xue ", "[?] ", "Zhuan ", "Hai ", "Luan ", "Sun ", "Huai ", "Mie ", "Cong ", "Qian ", "Shu ", "Chan ", "Ya ", "Zi ", "Ni ", "Fu ", "Zi ", "Li ", "Xue ", "Bo ", "Ru ", "Lai ", "Nie ", "Nie ", "Ying ", "Luan ", "Mian ", "Zhu ", "Rong ", "Ta ", "Gui ", "Zhai ", "Qiong ", "Yu ", "Shou ", "An ", "Tu ", "Song ", "Wan ", "Rou ", "Yao ", "Hong ", "Yi ", "Jing ", "Zhun ", "Mi ", "Zhu ", "Dang ", "Hong ", "Zong ", "Guan ", "Zhou ", "Ding ", "Wan ", "Yi ", "Bao ", "Shi ", "Shi ", "Chong ", "Shen ", "Ke ", "Xuan ", "Shi ", "You ", "Huan ", "Yi ", "Tiao ", "Shi ", "Xian ", "Gong ", "Cheng ", "Qun ", "Gong ", "Xiao ", "Zai ", "Zha ", "Bao ", "Hai ", "Yan ", "Xiao ", "Jia ", "Shen ", "Chen ", "Rong ", "Huang ", "Mi ", "Kou ", "Kuan ", "Bin ", "Su ", "Cai ", "Zan ", "Ji ", "Yuan ", "Ji ", "Yin ", "Mi ", "Kou ", "Qing ", "Que ", "Zhen ", "Jian ", "Fu ", "Ning ", "Bing ", "Huan ", "Mei ", "Qin ", "Han ", "Yu ", "Shi ", "Ning ", "Qin ", "Ning ", "Zhi ", "Yu ", "Bao ", "Kuan ", "Ning ", "Qin ", "Mo ", "Cha ", "Ju ", "Gua ", "Qin ", "Hu ", "Wu ", "Liao ", "Shi ", "Zhu ", "Zhai ", "Shen ", "Wei ", "Xie ", "Kuan ", "Hui ", "Liao ", "Jun ", "Huan ", "Yi ", "Yi ", "Bao ", "Qin ", "Chong ", "Bao ", "Feng ", "Cun ", "Dui ", "Si ", "Xun ", "Dao ", "Lu ", "Dui ", "Shou "];
  }
});

// node_modules/unidecode/data/x5c.js
var require_x5c = __commonJS({
  "node_modules/unidecode/data/x5c.js"(exports, module2) {
    module2.exports = ["Po ", "Feng ", "Zhuan ", "Fu ", "She ", "Ke ", "Jiang ", "Jiang ", "Zhuan ", "Wei ", "Zun ", "Xun ", "Shu ", "Dui ", "Dao ", "Xiao ", "Ji ", "Shao ", "Er ", "Er ", "Er ", "Ga ", "Jian ", "Shu ", "Chen ", "Shang ", "Shang ", "Mo ", "Ga ", "Chang ", "Liao ", "Xian ", "Xian ", "[?] ", "Wang ", "Wang ", "You ", "Liao ", "Liao ", "Yao ", "Mang ", "Wang ", "Wang ", "Wang ", "Ga ", "Yao ", "Duo ", "Kui ", "Zhong ", "Jiu ", "Gan ", "Gu ", "Gan ", "Tui ", "Gan ", "Gan ", "Shi ", "Yin ", "Chi ", "Kao ", "Ni ", "Jin ", "Wei ", "Niao ", "Ju ", "Pi ", "Ceng ", "Xi ", "Bi ", "Ju ", "Jie ", "Tian ", "Qu ", "Ti ", "Jie ", "Wu ", "Diao ", "Shi ", "Shi ", "Ping ", "Ji ", "Xie ", "Chen ", "Xi ", "Ni ", "Zhan ", "Xi ", "[?] ", "Man ", "E ", "Lou ", "Ping ", "Ti ", "Fei ", "Shu ", "Xie ", "Tu ", "Lu ", "Lu ", "Xi ", "Ceng ", "Lu ", "Ju ", "Xie ", "Ju ", "Jue ", "Liao ", "Jue ", "Shu ", "Xi ", "Che ", "Tun ", "Ni ", "Shan ", "[?] ", "Xian ", "Li ", "Xue ", "Nata ", "[?] ", "Long ", "Yi ", "Qi ", "Ren ", "Wu ", "Han ", "Shen ", "Yu ", "Chu ", "Sui ", "Qi ", "[?] ", "Yue ", "Ban ", "Yao ", "Ang ", "Ya ", "Wu ", "Jie ", "E ", "Ji ", "Qian ", "Fen ", "Yuan ", "Qi ", "Cen ", "Qian ", "Qi ", "Cha ", "Jie ", "Qu ", "Gang ", "Xian ", "Ao ", "Lan ", "Dao ", "Ba ", "Zuo ", "Zuo ", "Yang ", "Ju ", "Gang ", "Ke ", "Gou ", "Xue ", "Bei ", "Li ", "Tiao ", "Ju ", "Yan ", "Fu ", "Xiu ", "Jia ", "Ling ", "Tuo ", "Pei ", "You ", "Dai ", "Kuang ", "Yue ", "Qu ", "Hu ", "Po ", "Min ", "An ", "Tiao ", "Ling ", "Chi ", "Yuri ", "Dong ", "Cem ", "Kui ", "Xiu ", "Mao ", "Tong ", "Xue ", "Yi ", "Kura ", "He ", "Ke ", "Luo ", "E ", "Fu ", "Xun ", "Die ", "Lu ", "An ", "Er ", "Gai ", "Quan ", "Tong ", "Yi ", "Mu ", "Shi ", "An ", "Wei ", "Hu ", "Zhi ", "Mi ", "Li ", "Ji ", "Tong ", "Wei ", "You ", "Sang ", "Xia ", "Li ", "Yao ", "Jiao ", "Zheng ", "Luan ", "Jiao ", "E ", "E ", "Yu ", "Ye ", "Bu ", "Qiao ", "Qun ", "Feng ", "Feng ", "Nao ", "Li ", "You ", "Xian ", "Hong ", "Dao ", "Shen ", "Cheng ", "Tu ", "Geng ", "Jun ", "Hao ", "Xia ", "Yin ", "Yu "];
  }
});

// node_modules/unidecode/data/x5d.js
var require_x5d = __commonJS({
  "node_modules/unidecode/data/x5d.js"(exports, module2) {
    module2.exports = ["Lang ", "Kan ", "Lao ", "Lai ", "Xian ", "Que ", "Kong ", "Chong ", "Chong ", "Ta ", "Lin ", "Hua ", "Ju ", "Lai ", "Qi ", "Min ", "Kun ", "Kun ", "Zu ", "Gu ", "Cui ", "Ya ", "Ya ", "Gang ", "Lun ", "Lun ", "Leng ", "Jue ", "Duo ", "Zheng ", "Guo ", "Yin ", "Dong ", "Han ", "Zheng ", "Wei ", "Yao ", "Pi ", "Yan ", "Song ", "Jie ", "Beng ", "Zu ", "Jue ", "Dong ", "Zhan ", "Gu ", "Yin ", "[?] ", "Ze ", "Huang ", "Yu ", "Wei ", "Yang ", "Feng ", "Qiu ", "Dun ", "Ti ", "Yi ", "Zhi ", "Shi ", "Zai ", "Yao ", "E ", "Zhu ", "Kan ", "Lu ", "Yan ", "Mei ", "Gan ", "Ji ", "Ji ", "Huan ", "Ting ", "Sheng ", "Mei ", "Qian ", "Wu ", "Yu ", "Zong ", "Lan ", "Jue ", "Yan ", "Yan ", "Wei ", "Zong ", "Cha ", "Sui ", "Rong ", "Yamashina ", "Qin ", "Yu ", "Kewashii ", "Lou ", "Tu ", "Dui ", "Xi ", "Weng ", "Cang ", "Dang ", "Hong ", "Jie ", "Ai ", "Liu ", "Wu ", "Song ", "Qiao ", "Zi ", "Wei ", "Beng ", "Dian ", "Cuo ", "Qian ", "Yong ", "Nie ", "Cuo ", "Ji ", "[?] ", "Tao ", "Song ", "Zong ", "Jiang ", "Liao ", "Kang ", "Chan ", "Die ", "Cen ", "Ding ", "Tu ", "Lou ", "Zhang ", "Zhan ", "Zhan ", "Ao ", "Cao ", "Qu ", "Qiang ", "Zui ", "Zui ", "Dao ", "Dao ", "Xi ", "Yu ", "Bo ", "Long ", "Xiang ", "Ceng ", "Bo ", "Qin ", "Jiao ", "Yan ", "Lao ", "Zhan ", "Lin ", "Liao ", "Liao ", "Jin ", "Deng ", "Duo ", "Zun ", "Jiao ", "Gui ", "Yao ", "Qiao ", "Yao ", "Jue ", "Zhan ", "Yi ", "Xue ", "Nao ", "Ye ", "Ye ", "Yi ", "E ", "Xian ", "Ji ", "Xie ", "Ke ", "Xi ", "Di ", "Ao ", "Zui ", "[?] ", "Ni ", "Rong ", "Dao ", "Ling ", "Za ", "Yu ", "Yue ", "Yin ", "[?] ", "Jie ", "Li ", "Sui ", "Long ", "Long ", "Dian ", "Ying ", "Xi ", "Ju ", "Chan ", "Ying ", "Kui ", "Yan ", "Wei ", "Nao ", "Quan ", "Chao ", "Cuan ", "Luan ", "Dian ", "Dian ", "[?] ", "Yan ", "Yan ", "Yan ", "Nao ", "Yan ", "Chuan ", "Gui ", "Chuan ", "Zhou ", "Huang ", "Jing ", "Xun ", "Chao ", "Chao ", "Lie ", "Gong ", "Zuo ", "Qiao ", "Ju ", "Gong ", "Kek ", "Wu ", "Pwu ", "Pwu ", "Chai ", "Qiu ", "Qiu ", "Ji ", "Yi ", "Si ", "Ba ", "Zhi ", "Zhao ", "Xiang ", "Yi ", "Jin ", "Xun ", "Juan ", "Phas ", "Xun ", "Jin ", "Fu "];
  }
});

// node_modules/unidecode/data/x5e.js
var require_x5e = __commonJS({
  "node_modules/unidecode/data/x5e.js"(exports, module2) {
    module2.exports = ["Za ", "Bi ", "Shi ", "Bu ", "Ding ", "Shuai ", "Fan ", "Nie ", "Shi ", "Fen ", "Pa ", "Zhi ", "Xi ", "Hu ", "Dan ", "Wei ", "Zhang ", "Tang ", "Dai ", "Ma ", "Pei ", "Pa ", "Tie ", "Fu ", "Lian ", "Zhi ", "Zhou ", "Bo ", "Zhi ", "Di ", "Mo ", "Yi ", "Yi ", "Ping ", "Qia ", "Juan ", "Ru ", "Shuai ", "Dai ", "Zheng ", "Shui ", "Qiao ", "Zhen ", "Shi ", "Qun ", "Xi ", "Bang ", "Dai ", "Gui ", "Chou ", "Ping ", "Zhang ", "Sha ", "Wan ", "Dai ", "Wei ", "Chang ", "Sha ", "Qi ", "Ze ", "Guo ", "Mao ", "Du ", "Hou ", "Zheng ", "Xu ", "Mi ", "Wei ", "Wo ", "Fu ", "Yi ", "Bang ", "Ping ", "Tazuna ", "Gong ", "Pan ", "Huang ", "Dao ", "Mi ", "Jia ", "Teng ", "Hui ", "Zhong ", "Shan ", "Man ", "Mu ", "Biao ", "Guo ", "Ze ", "Mu ", "Bang ", "Zhang ", "Jiong ", "Chan ", "Fu ", "Zhi ", "Hu ", "Fan ", "Chuang ", "Bi ", "Hei ", "[?] ", "Mi ", "Qiao ", "Chan ", "Fen ", "Meng ", "Bang ", "Chou ", "Mie ", "Chu ", "Jie ", "Xian ", "Lan ", "Gan ", "Ping ", "Nian ", "Qian ", "Bing ", "Bing ", "Xing ", "Gan ", "Yao ", "Huan ", "You ", "You ", "Ji ", "Yan ", "Pi ", "Ting ", "Ze ", "Guang ", "Zhuang ", "Mo ", "Qing ", "Bi ", "Qin ", "Dun ", "Chuang ", "Gui ", "Ya ", "Bai ", "Jie ", "Xu ", "Lu ", "Wu ", "[?] ", "Ku ", "Ying ", "Di ", "Pao ", "Dian ", "Ya ", "Miao ", "Geng ", "Ci ", "Fu ", "Tong ", "Pang ", "Fei ", "Xiang ", "Yi ", "Zhi ", "Tiao ", "Zhi ", "Xiu ", "Du ", "Zuo ", "Xiao ", "Tu ", "Gui ", "Ku ", "Pang ", "Ting ", "You ", "Bu ", "Ding ", "Cheng ", "Lai ", "Bei ", "Ji ", "An ", "Shu ", "Kang ", "Yong ", "Tuo ", "Song ", "Shu ", "Qing ", "Yu ", "Yu ", "Miao ", "Sou ", "Ce ", "Xiang ", "Fei ", "Jiu ", "He ", "Hui ", "Liu ", "Sha ", "Lian ", "Lang ", "Sou ", "Jian ", "Pou ", "Qing ", "Jiu ", "Jiu ", "Qin ", "Ao ", "Kuo ", "Lou ", "Yin ", "Liao ", "Dai ", "Lu ", "Yi ", "Chu ", "Chan ", "Tu ", "Si ", "Xin ", "Miao ", "Chang ", "Wu ", "Fei ", "Guang ", "Koc ", "Kuai ", "Bi ", "Qiang ", "Xie ", "Lin ", "Lin ", "Liao ", "Lu ", "[?] ", "Ying ", "Xian ", "Ting ", "Yong ", "Li ", "Ting ", "Yin ", "Xun ", "Yan ", "Ting ", "Di ", "Po ", "Jian ", "Hui ", "Nai ", "Hui ", "Gong ", "Nian "];
  }
});

// node_modules/unidecode/data/x5f.js
var require_x5f = __commonJS({
  "node_modules/unidecode/data/x5f.js"(exports, module2) {
    module2.exports = ["Kai ", "Bian ", "Yi ", "Qi ", "Nong ", "Fen ", "Ju ", "Yan ", "Yi ", "Zang ", "Bi ", "Yi ", "Yi ", "Er ", "San ", "Shi ", "Er ", "Shi ", "Shi ", "Gong ", "Diao ", "Yin ", "Hu ", "Fu ", "Hong ", "Wu ", "Tui ", "Chi ", "Jiang ", "Ba ", "Shen ", "Di ", "Zhang ", "Jue ", "Tao ", "Fu ", "Di ", "Mi ", "Xian ", "Hu ", "Chao ", "Nu ", "Jing ", "Zhen ", "Yi ", "Mi ", "Quan ", "Wan ", "Shao ", "Ruo ", "Xuan ", "Jing ", "Dun ", "Zhang ", "Jiang ", "Qiang ", "Peng ", "Dan ", "Qiang ", "Bi ", "Bi ", "She ", "Dan ", "Jian ", "Gou ", "Sei ", "Fa ", "Bi ", "Kou ", "Nagi ", "Bie ", "Xiao ", "Dan ", "Kuo ", "Qiang ", "Hong ", "Mi ", "Kuo ", "Wan ", "Jue ", "Ji ", "Ji ", "Gui ", "Dang ", "Lu ", "Lu ", "Tuan ", "Hui ", "Zhi ", "Hui ", "Hui ", "Yi ", "Yi ", "Yi ", "Yi ", "Huo ", "Huo ", "Shan ", "Xing ", "Wen ", "Tong ", "Yan ", "Yan ", "Yu ", "Chi ", "Cai ", "Biao ", "Diao ", "Bin ", "Peng ", "Yong ", "Piao ", "Zhang ", "Ying ", "Chi ", "Chi ", "Zhuo ", "Tuo ", "Ji ", "Pang ", "Zhong ", "Yi ", "Wang ", "Che ", "Bi ", "Chi ", "Ling ", "Fu ", "Wang ", "Zheng ", "Cu ", "Wang ", "Jing ", "Dai ", "Xi ", "Xun ", "Hen ", "Yang ", "Huai ", "Lu ", "Hou ", "Wa ", "Cheng ", "Zhi ", "Xu ", "Jing ", "Tu ", "Cong ", "[?] ", "Lai ", "Cong ", "De ", "Pai ", "Xi ", "[?] ", "Qi ", "Chang ", "Zhi ", "Cong ", "Zhou ", "Lai ", "Yu ", "Xie ", "Jie ", "Jian ", "Chi ", "Jia ", "Bian ", "Huang ", "Fu ", "Xun ", "Wei ", "Pang ", "Yao ", "Wei ", "Xi ", "Zheng ", "Piao ", "Chi ", "De ", "Zheng ", "Zheng ", "Bie ", "De ", "Chong ", "Che ", "Jiao ", "Wei ", "Jiao ", "Hui ", "Mei ", "Long ", "Xiang ", "Bao ", "Qu ", "Xin ", "Shu ", "Bi ", "Yi ", "Le ", "Ren ", "Dao ", "Ding ", "Gai ", "Ji ", "Ren ", "Ren ", "Chan ", "Tan ", "Te ", "Te ", "Gan ", "Qi ", "Shi ", "Cun ", "Zhi ", "Wang ", "Mang ", "Xi ", "Fan ", "Ying ", "Tian ", "Min ", "Min ", "Zhong ", "Chong ", "Wu ", "Ji ", "Wu ", "Xi ", "Ye ", "You ", "Wan ", "Cong ", "Zhong ", "Kuai ", "Yu ", "Bian ", "Zhi ", "Qi ", "Cui ", "Chen ", "Tai ", "Tun ", "Qian ", "Nian ", "Hun ", "Xiong ", "Niu ", "Wang ", "Xian ", "Xin ", "Kang ", "Hu ", "Kai ", "Fen "];
  }
});

// node_modules/unidecode/data/x60.js
var require_x60 = __commonJS({
  "node_modules/unidecode/data/x60.js"(exports, module2) {
    module2.exports = ["Huai ", "Tai ", "Song ", "Wu ", "Ou ", "Chang ", "Chuang ", "Ju ", "Yi ", "Bao ", "Chao ", "Min ", "Pei ", "Zuo ", "Zen ", "Yang ", "Kou ", "Ban ", "Nu ", "Nao ", "Zheng ", "Pa ", "Bu ", "Tie ", "Gu ", "Hu ", "Ju ", "Da ", "Lian ", "Si ", "Chou ", "Di ", "Dai ", "Yi ", "Tu ", "You ", "Fu ", "Ji ", "Peng ", "Xing ", "Yuan ", "Ni ", "Guai ", "Fu ", "Xi ", "Bi ", "You ", "Qie ", "Xuan ", "Cong ", "Bing ", "Huang ", "Xu ", "Chu ", "Pi ", "Xi ", "Xi ", "Tan ", "Koraeru ", "Zong ", "Dui ", "[?] ", "Ki ", "Yi ", "Chi ", "Ren ", "Xun ", "Shi ", "Xi ", "Lao ", "Heng ", "Kuang ", "Mu ", "Zhi ", "Xie ", "Lian ", "Tiao ", "Huang ", "Die ", "Hao ", "Kong ", "Gui ", "Heng ", "Xi ", "Xiao ", "Shu ", "S ", "Kua ", "Qiu ", "Yang ", "Hui ", "Hui ", "Chi ", "Jia ", "Yi ", "Xiong ", "Guai ", "Lin ", "Hui ", "Zi ", "Xu ", "Chi ", "Xiang ", "Nu ", "Hen ", "En ", "Ke ", "Tong ", "Tian ", "Gong ", "Quan ", "Xi ", "Qia ", "Yue ", "Peng ", "Ken ", "De ", "Hui ", "E ", "Kyuu ", "Tong ", "Yan ", "Kai ", "Ce ", "Nao ", "Yun ", "Mang ", "Yong ", "Yong ", "Yuan ", "Pi ", "Kun ", "Qiao ", "Yue ", "Yu ", "Yu ", "Jie ", "Xi ", "Zhe ", "Lin ", "Ti ", "Han ", "Hao ", "Qie ", "Ti ", "Bu ", "Yi ", "Qian ", "Hui ", "Xi ", "Bei ", "Man ", "Yi ", "Heng ", "Song ", "Quan ", "Cheng ", "Hui ", "Wu ", "Wu ", "You ", "Li ", "Liang ", "Huan ", "Cong ", "Yi ", "Yue ", "Li ", "Nin ", "Nao ", "E ", "Que ", "Xuan ", "Qian ", "Wu ", "Min ", "Cong ", "Fei ", "Bei ", "Duo ", "Cui ", "Chang ", "Men ", "Li ", "Ji ", "Guan ", "Guan ", "Xing ", "Dao ", "Qi ", "Kong ", "Tian ", "Lun ", "Xi ", "Kan ", "Kun ", "Ni ", "Qing ", "Chou ", "Dun ", "Guo ", "Chan ", "Liang ", "Wan ", "Yuan ", "Jin ", "Ji ", "Lin ", "Yu ", "Huo ", "He ", "Quan ", "Tan ", "Ti ", "Ti ", "Nie ", "Wang ", "Chuo ", "Bu ", "Hun ", "Xi ", "Tang ", "Xin ", "Wei ", "Hui ", "E ", "Rui ", "Zong ", "Jian ", "Yong ", "Dian ", "Ju ", "Can ", "Cheng ", "De ", "Bei ", "Qie ", "Can ", "Dan ", "Guan ", "Duo ", "Nao ", "Yun ", "Xiang ", "Zhui ", "Die ", "Huang ", "Chun ", "Qiong ", "Re ", "Xing ", "Ce ", "Bian ", "Hun ", "Zong ", "Ti "];
  }
});

// node_modules/unidecode/data/x61.js
var require_x61 = __commonJS({
  "node_modules/unidecode/data/x61.js"(exports, module2) {
    module2.exports = ["Qiao ", "Chou ", "Bei ", "Xuan ", "Wei ", "Ge ", "Qian ", "Wei ", "Yu ", "Yu ", "Bi ", "Xuan ", "Huan ", "Min ", "Bi ", "Yi ", "Mian ", "Yong ", "Kai ", "Dang ", "Yin ", "E ", "Chen ", "Mou ", "Ke ", "Ke ", "Yu ", "Ai ", "Qie ", "Yan ", "Nuo ", "Gan ", "Yun ", "Zong ", "Sai ", "Leng ", "Fen ", "[?] ", "Kui ", "Kui ", "Que ", "Gong ", "Yun ", "Su ", "Su ", "Qi ", "Yao ", "Song ", "Huang ", "Ji ", "Gu ", "Ju ", "Chuang ", "Ni ", "Xie ", "Kai ", "Zheng ", "Yong ", "Cao ", "Sun ", "Shen ", "Bo ", "Kai ", "Yuan ", "Xie ", "Hun ", "Yong ", "Yang ", "Li ", "Sao ", "Tao ", "Yin ", "Ci ", "Xu ", "Qian ", "Tai ", "Huang ", "Yun ", "Shen ", "Ming ", "[?] ", "She ", "Cong ", "Piao ", "Mo ", "Mu ", "Guo ", "Chi ", "Can ", "Can ", "Can ", "Cui ", "Min ", "Te ", "Zhang ", "Tong ", "Ao ", "Shuang ", "Man ", "Guan ", "Que ", "Zao ", "Jiu ", "Hui ", "Kai ", "Lian ", "Ou ", "Song ", "Jin ", "Yin ", "Lu ", "Shang ", "Wei ", "Tuan ", "Man ", "Qian ", "She ", "Yong ", "Qing ", "Kang ", "Di ", "Zhi ", "Lou ", "Juan ", "Qi ", "Qi ", "Yu ", "Ping ", "Liao ", "Cong ", "You ", "Chong ", "Zhi ", "Tong ", "Cheng ", "Qi ", "Qu ", "Peng ", "Bei ", "Bie ", "Chun ", "Jiao ", "Zeng ", "Chi ", "Lian ", "Ping ", "Kui ", "Hui ", "Qiao ", "Cheng ", "Yin ", "Yin ", "Xi ", "Xi ", "Dan ", "Tan ", "Duo ", "Dui ", "Dui ", "Su ", "Jue ", "Ce ", "Xiao ", "Fan ", "Fen ", "Lao ", "Lao ", "Chong ", "Han ", "Qi ", "Xian ", "Min ", "Jing ", "Liao ", "Wu ", "Can ", "Jue ", "Cu ", "Xian ", "Tan ", "Sheng ", "Pi ", "Yi ", "Chu ", "Xian ", "Nao ", "Dan ", "Tan ", "Jing ", "Song ", "Han ", "Jiao ", "Wai ", "Huan ", "Dong ", "Qin ", "Qin ", "Qu ", "Cao ", "Ken ", "Xie ", "Ying ", "Ao ", "Mao ", "Yi ", "Lin ", "Se ", "Jun ", "Huai ", "Men ", "Lan ", "Ai ", "Lin ", "Yan ", "Gua ", "Xia ", "Chi ", "Yu ", "Yin ", "Dai ", "Meng ", "Ai ", "Meng ", "Dui ", "Qi ", "Mo ", "Lan ", "Men ", "Chou ", "Zhi ", "Nuo ", "Nuo ", "Yan ", "Yang ", "Bo ", "Zhi ", "Kuang ", "Kuang ", "You ", "Fu ", "Liu ", "Mie ", "Cheng ", "[?] ", "Chan ", "Meng ", "Lan ", "Huai ", "Xuan ", "Rang ", "Chan ", "Ji ", "Ju ", "Huan ", "She ", "Yi "];
  }
});

// node_modules/unidecode/data/x62.js
var require_x62 = __commonJS({
  "node_modules/unidecode/data/x62.js"(exports, module2) {
    module2.exports = ["Lian ", "Nan ", "Mi ", "Tang ", "Jue ", "Gang ", "Gang ", "Gang ", "Ge ", "Yue ", "Wu ", "Jian ", "Xu ", "Shu ", "Rong ", "Xi ", "Cheng ", "Wo ", "Jie ", "Ge ", "Jian ", "Qiang ", "Huo ", "Qiang ", "Zhan ", "Dong ", "Qi ", "Jia ", "Die ", "Zei ", "Jia ", "Ji ", "Shi ", "Kan ", "Ji ", "Kui ", "Gai ", "Deng ", "Zhan ", "Chuang ", "Ge ", "Jian ", "Jie ", "Yu ", "Jian ", "Yan ", "Lu ", "Xi ", "Zhan ", "Xi ", "Xi ", "Chuo ", "Dai ", "Qu ", "Hu ", "Hu ", "Hu ", "E ", "Shi ", "Li ", "Mao ", "Hu ", "Li ", "Fang ", "Suo ", "Bian ", "Dian ", "Jiong ", "Shang ", "Yi ", "Yi ", "Shan ", "Hu ", "Fei ", "Yan ", "Shou ", "T ", "Cai ", "Zha ", "Qiu ", "Le ", "Bu ", "Ba ", "Da ", "Reng ", "Fu ", "Hameru ", "Zai ", "Tuo ", "Zhang ", "Diao ", "Kang ", "Yu ", "Ku ", "Han ", "Shen ", "Cha ", "Yi ", "Gu ", "Kou ", "Wu ", "Tuo ", "Qian ", "Zhi ", "Ren ", "Kuo ", "Men ", "Sao ", "Yang ", "Niu ", "Ban ", "Che ", "Rao ", "Xi ", "Qian ", "Ban ", "Jia ", "Yu ", "Fu ", "Ao ", "Xi ", "Pi ", "Zhi ", "Zi ", "E ", "Dun ", "Zhao ", "Cheng ", "Ji ", "Yan ", "Kuang ", "Bian ", "Chao ", "Ju ", "Wen ", "Hu ", "Yue ", "Jue ", "Ba ", "Qin ", "Zhen ", "Zheng ", "Yun ", "Wan ", "Nu ", "Yi ", "Shu ", "Zhua ", "Pou ", "Tou ", "Dou ", "Kang ", "Zhe ", "Pou ", "Fu ", "Pao ", "Ba ", "Ao ", "Ze ", "Tuan ", "Kou ", "Lun ", "Qiang ", "[?] ", "Hu ", "Bao ", "Bing ", "Zhi ", "Peng ", "Tan ", "Pu ", "Pi ", "Tai ", "Yao ", "Zhen ", "Zha ", "Yang ", "Bao ", "He ", "Ni ", "Yi ", "Di ", "Chi ", "Pi ", "Za ", "Mo ", "Mo ", "Shen ", "Ya ", "Chou ", "Qu ", "Min ", "Chu ", "Jia ", "Fu ", "Zhan ", "Zhu ", "Dan ", "Chai ", "Mu ", "Nian ", "La ", "Fu ", "Pao ", "Ban ", "Pai ", "Ling ", "Na ", "Guai ", "Qian ", "Ju ", "Tuo ", "Ba ", "Tuo ", "Tuo ", "Ao ", "Ju ", "Zhuo ", "Pan ", "Zhao ", "Bai ", "Bai ", "Di ", "Ni ", "Ju ", "Kuo ", "Long ", "Jian ", "[?] ", "Yong ", "Lan ", "Ning ", "Bo ", "Ze ", "Qian ", "Hen ", "Gua ", "Shi ", "Jie ", "Zheng ", "Nin ", "Gong ", "Gong ", "Quan ", "Shuan ", "Cun ", "Zan ", "Kao ", "Chi ", "Xie ", "Ce ", "Hui ", "Pin ", "Zhuai ", "Shi ", "Na "];
  }
});

// node_modules/unidecode/data/x63.js
var require_x63 = __commonJS({
  "node_modules/unidecode/data/x63.js"(exports, module2) {
    module2.exports = ["Bo ", "Chi ", "Gua ", "Zhi ", "Kuo ", "Duo ", "Duo ", "Zhi ", "Qie ", "An ", "Nong ", "Zhen ", "Ge ", "Jiao ", "Ku ", "Dong ", "Ru ", "Tiao ", "Lie ", "Zha ", "Lu ", "Die ", "Wa ", "Jue ", "Mushiru ", "Ju ", "Zhi ", "Luan ", "Ya ", "Zhua ", "Ta ", "Xie ", "Nao ", "Dang ", "Jiao ", "Zheng ", "Ji ", "Hui ", "Xun ", "Ku ", "Ai ", "Tuo ", "Nuo ", "Cuo ", "Bo ", "Geng ", "Ti ", "Zhen ", "Cheng ", "Suo ", "Suo ", "Keng ", "Mei ", "Long ", "Ju ", "Peng ", "Jian ", "Yi ", "Ting ", "Shan ", "Nuo ", "Wan ", "Xie ", "Cha ", "Feng ", "Jiao ", "Wu ", "Jun ", "Jiu ", "Tong ", "Kun ", "Huo ", "Tu ", "Zhuo ", "Pou ", "Le ", "Ba ", "Han ", "Shao ", "Nie ", "Juan ", "Ze ", "Song ", "Ye ", "Jue ", "Bu ", "Huan ", "Bu ", "Zun ", "Yi ", "Zhai ", "Lu ", "Sou ", "Tuo ", "Lao ", "Sun ", "Bang ", "Jian ", "Huan ", "Dao ", "[?] ", "Wan ", "Qin ", "Peng ", "She ", "Lie ", "Min ", "Men ", "Fu ", "Bai ", "Ju ", "Dao ", "Wo ", "Ai ", "Juan ", "Yue ", "Zong ", "Chen ", "Chui ", "Jie ", "Tu ", "Ben ", "Na ", "Nian ", "Nuo ", "Zu ", "Wo ", "Xi ", "Xian ", "Cheng ", "Dian ", "Sao ", "Lun ", "Qing ", "Gang ", "Duo ", "Shou ", "Diao ", "Pou ", "Di ", "Zhang ", "Gun ", "Ji ", "Tao ", "Qia ", "Qi ", "Pai ", "Shu ", "Qian ", "Ling ", "Yi ", "Ya ", "Jue ", "Zheng ", "Liang ", "Gua ", "Yi ", "Huo ", "Shan ", "Zheng ", "Lue ", "Cai ", "Tan ", "Che ", "Bing ", "Jie ", "Ti ", "Kong ", "Tui ", "Yan ", "Cuo ", "Zou ", "Ju ", "Tian ", "Qian ", "Ken ", "Bai ", "Shou ", "Jie ", "Lu ", "Guo ", "Haba ", "[?] ", "Zhi ", "Dan ", "Mang ", "Xian ", "Sao ", "Guan ", "Peng ", "Yuan ", "Nuo ", "Jian ", "Zhen ", "Jiu ", "Jian ", "Yu ", "Yan ", "Kui ", "Nan ", "Hong ", "Rou ", "Pi ", "Wei ", "Sai ", "Zou ", "Xuan ", "Miao ", "Ti ", "Nie ", "Cha ", "Shi ", "Zong ", "Zhen ", "Yi ", "Shun ", "Heng ", "Bian ", "Yang ", "Huan ", "Yan ", "Zuan ", "An ", "Xu ", "Ya ", "Wo ", "Ke ", "Chuai ", "Ji ", "Ti ", "La ", "La ", "Cheng ", "Kai ", "Jiu ", "Jiu ", "Tu ", "Jie ", "Hui ", "Geng ", "Chong ", "Shuo ", "She ", "Xie ", "Yuan ", "Qian ", "Ye ", "Cha ", "Zha ", "Bei ", "Yao ", "[?] ", "[?] ", "Lan ", "Wen ", "Qin "];
  }
});

// node_modules/unidecode/data/x64.js
var require_x64 = __commonJS({
  "node_modules/unidecode/data/x64.js"(exports, module2) {
    module2.exports = ["Chan ", "Ge ", "Lou ", "Zong ", "Geng ", "Jiao ", "Gou ", "Qin ", "Yong ", "Que ", "Chou ", "Chi ", "Zhan ", "Sun ", "Sun ", "Bo ", "Chu ", "Rong ", "Beng ", "Cuo ", "Sao ", "Ke ", "Yao ", "Dao ", "Zhi ", "Nu ", "Xie ", "Jian ", "Sou ", "Qiu ", "Gao ", "Xian ", "Shuo ", "Sang ", "Jin ", "Mie ", "E ", "Chui ", "Nuo ", "Shan ", "Ta ", "Jie ", "Tang ", "Pan ", "Ban ", "Da ", "Li ", "Tao ", "Hu ", "Zhi ", "Wa ", "Xia ", "Qian ", "Wen ", "Qiang ", "Tian ", "Zhen ", "E ", "Xi ", "Nuo ", "Quan ", "Cha ", "Zha ", "Ge ", "Wu ", "En ", "She ", "Kang ", "She ", "Shu ", "Bai ", "Yao ", "Bin ", "Sou ", "Tan ", "Sa ", "Chan ", "Suo ", "Liao ", "Chong ", "Chuang ", "Guo ", "Bing ", "Feng ", "Shuai ", "Di ", "Qi ", "Sou ", "Zhai ", "Lian ", "Tang ", "Chi ", "Guan ", "Lu ", "Luo ", "Lou ", "Zong ", "Gai ", "Hu ", "Zha ", "Chuang ", "Tang ", "Hua ", "Cui ", "Nai ", "Mo ", "Jiang ", "Gui ", "Ying ", "Zhi ", "Ao ", "Zhi ", "Nie ", "Man ", "Shan ", "Kou ", "Shu ", "Suo ", "Tuan ", "Jiao ", "Mo ", "Mo ", "Zhe ", "Xian ", "Keng ", "Piao ", "Jiang ", "Yin ", "Gou ", "Qian ", "Lue ", "Ji ", "Ying ", "Jue ", "Pie ", "Pie ", "Lao ", "Dun ", "Xian ", "Ruan ", "Kui ", "Zan ", "Yi ", "Xun ", "Cheng ", "Cheng ", "Sa ", "Nao ", "Heng ", "Si ", "Qian ", "Huang ", "Da ", "Zun ", "Nian ", "Lin ", "Zheng ", "Hui ", "Zhuang ", "Jiao ", "Ji ", "Cao ", "Dan ", "Dan ", "Che ", "Bo ", "Che ", "Jue ", "Xiao ", "Liao ", "Ben ", "Fu ", "Qiao ", "Bo ", "Cuo ", "Zhuo ", "Zhuan ", "Tuo ", "Pu ", "Qin ", "Dun ", "Nian ", "[?] ", "Xie ", "Lu ", "Jiao ", "Cuan ", "Ta ", "Han ", "Qiao ", "Zhua ", "Jian ", "Gan ", "Yong ", "Lei ", "Kuo ", "Lu ", "Shan ", "Zhuo ", "Ze ", "Pu ", "Chuo ", "Ji ", "Dang ", "Suo ", "Cao ", "Qing ", "Jing ", "Huan ", "Jie ", "Qin ", "Kuai ", "Dan ", "Xi ", "Ge ", "Pi ", "Bo ", "Ao ", "Ju ", "Ye ", "[?] ", "Mang ", "Sou ", "Mi ", "Ji ", "Tai ", "Zhuo ", "Dao ", "Xing ", "Lan ", "Ca ", "Ju ", "Ye ", "Ru ", "Ye ", "Ye ", "Ni ", "Hu ", "Ji ", "Bin ", "Ning ", "Ge ", "Zhi ", "Jie ", "Kuo ", "Mo ", "Jian ", "Xie ", "Lie ", "Tan ", "Bai ", "Sou ", "Lu ", "Lue ", "Rao ", "Zhi "];
  }
});

// node_modules/unidecode/data/x65.js
var require_x65 = __commonJS({
  "node_modules/unidecode/data/x65.js"(exports, module2) {
    module2.exports = ["Pan ", "Yang ", "Lei ", "Sa ", "Shu ", "Zan ", "Nian ", "Xian ", "Jun ", "Huo ", "Li ", "La ", "Han ", "Ying ", "Lu ", "Long ", "Qian ", "Qian ", "Zan ", "Qian ", "Lan ", "San ", "Ying ", "Mei ", "Rang ", "Chan ", "[?] ", "Cuan ", "Xi ", "She ", "Luo ", "Jun ", "Mi ", "Li ", "Zan ", "Luan ", "Tan ", "Zuan ", "Li ", "Dian ", "Wa ", "Dang ", "Jiao ", "Jue ", "Lan ", "Li ", "Nang ", "Zhi ", "Gui ", "Gui ", "Qi ", "Xin ", "Pu ", "Sui ", "Shou ", "Kao ", "You ", "Gai ", "Yi ", "Gong ", "Gan ", "Ban ", "Fang ", "Zheng ", "Bo ", "Dian ", "Kou ", "Min ", "Wu ", "Gu ", "He ", "Ce ", "Xiao ", "Mi ", "Chu ", "Ge ", "Di ", "Xu ", "Jiao ", "Min ", "Chen ", "Jiu ", "Zhen ", "Duo ", "Yu ", "Chi ", "Ao ", "Bai ", "Xu ", "Jiao ", "Duo ", "Lian ", "Nie ", "Bi ", "Chang ", "Dian ", "Duo ", "Yi ", "Gan ", "San ", "Ke ", "Yan ", "Dun ", "Qi ", "Dou ", "Xiao ", "Duo ", "Jiao ", "Jing ", "Yang ", "Xia ", "Min ", "Shu ", "Ai ", "Qiao ", "Ai ", "Zheng ", "Di ", "Zhen ", "Fu ", "Shu ", "Liao ", "Qu ", "Xiong ", "Xi ", "Jiao ", "Sen ", "Jiao ", "Zhuo ", "Yi ", "Lian ", "Bi ", "Li ", "Xiao ", "Xiao ", "Wen ", "Xue ", "Qi ", "Qi ", "Zhai ", "Bin ", "Jue ", "Zhai ", "[?] ", "Fei ", "Ban ", "Ban ", "Lan ", "Yu ", "Lan ", "Wei ", "Dou ", "Sheng ", "Liao ", "Jia ", "Hu ", "Xie ", "Jia ", "Yu ", "Zhen ", "Jiao ", "Wo ", "Tou ", "Chu ", "Jin ", "Chi ", "Yin ", "Fu ", "Qiang ", "Zhan ", "Qu ", "Zhuo ", "Zhan ", "Duan ", "Zhuo ", "Si ", "Xin ", "Zhuo ", "Zhuo ", "Qin ", "Lin ", "Zhuo ", "Chu ", "Duan ", "Zhu ", "Fang ", "Xie ", "Hang ", "Yu ", "Shi ", "Pei ", "You ", "Mye ", "Pang ", "Qi ", "Zhan ", "Mao ", "Lu ", "Pei ", "Pi ", "Liu ", "Fu ", "Fang ", "Xuan ", "Jing ", "Jing ", "Ni ", "Zu ", "Zhao ", "Yi ", "Liu ", "Shao ", "Jian ", "Es ", "Yi ", "Qi ", "Zhi ", "Fan ", "Piao ", "Fan ", "Zhan ", "Guai ", "Sui ", "Yu ", "Wu ", "Ji ", "Ji ", "Ji ", "Huo ", "Ri ", "Dan ", "Jiu ", "Zhi ", "Zao ", "Xie ", "Tiao ", "Xun ", "Xu ", "Xu ", "Xu ", "Gan ", "Han ", "Tai ", "Di ", "Xu ", "Chan ", "Shi ", "Kuang ", "Yang ", "Shi ", "Wang ", "Min ", "Min ", "Tun ", "Chun ", "Wu "];
  }
});

// node_modules/unidecode/data/x66.js
var require_x66 = __commonJS({
  "node_modules/unidecode/data/x66.js"(exports, module2) {
    module2.exports = ["Yun ", "Bei ", "Ang ", "Ze ", "Ban ", "Jie ", "Kun ", "Sheng ", "Hu ", "Fang ", "Hao ", "Gui ", "Chang ", "Xuan ", "Ming ", "Hun ", "Fen ", "Qin ", "Hu ", "Yi ", "Xi ", "Xin ", "Yan ", "Ze ", "Fang ", "Tan ", "Shen ", "Ju ", "Yang ", "Zan ", "Bing ", "Xing ", "Ying ", "Xuan ", "Pei ", "Zhen ", "Ling ", "Chun ", "Hao ", "Mei ", "Zuo ", "Mo ", "Bian ", "Xu ", "Hun ", "Zhao ", "Zong ", "Shi ", "Shi ", "Yu ", "Fei ", "Die ", "Mao ", "Ni ", "Chang ", "Wen ", "Dong ", "Ai ", "Bing ", "Ang ", "Zhou ", "Long ", "Xian ", "Kuang ", "Tiao ", "Chao ", "Shi ", "Huang ", "Huang ", "Xuan ", "Kui ", "Xu ", "Jiao ", "Jin ", "Zhi ", "Jin ", "Shang ", "Tong ", "Hong ", "Yan ", "Gai ", "Xiang ", "Shai ", "Xiao ", "Ye ", "Yun ", "Hui ", "Han ", "Han ", "Jun ", "Wan ", "Xian ", "Kun ", "Zhou ", "Xi ", "Cheng ", "Sheng ", "Bu ", "Zhe ", "Zhe ", "Wu ", "Han ", "Hui ", "Hao ", "Chen ", "Wan ", "Tian ", "Zhuo ", "Zui ", "Zhou ", "Pu ", "Jing ", "Xi ", "Shan ", "Yi ", "Xi ", "Qing ", "Qi ", "Jing ", "Gui ", "Zhen ", "Yi ", "Zhi ", "An ", "Wan ", "Lin ", "Liang ", "Chang ", "Wang ", "Xiao ", "Zan ", "Hi ", "Xuan ", "Xuan ", "Yi ", "Xia ", "Yun ", "Hui ", "Fu ", "Min ", "Kui ", "He ", "Ying ", "Du ", "Wei ", "Shu ", "Qing ", "Mao ", "Nan ", "Jian ", "Nuan ", "An ", "Yang ", "Chun ", "Yao ", "Suo ", "Jin ", "Ming ", "Jiao ", "Kai ", "Gao ", "Weng ", "Chang ", "Qi ", "Hao ", "Yan ", "Li ", "Ai ", "Ji ", "Gui ", "Men ", "Zan ", "Xie ", "Hao ", "Mu ", "Mo ", "Cong ", "Ni ", "Zhang ", "Hui ", "Bao ", "Han ", "Xuan ", "Chuan ", "Liao ", "Xian ", "Dan ", "Jing ", "Pie ", "Lin ", "Tun ", "Xi ", "Yi ", "Ji ", "Huang ", "Tai ", "Ye ", "Ye ", "Li ", "Tan ", "Tong ", "Xiao ", "Fei ", "Qin ", "Zhao ", "Hao ", "Yi ", "Xiang ", "Xing ", "Sen ", "Jiao ", "Bao ", "Jing ", "Yian ", "Ai ", "Ye ", "Ru ", "Shu ", "Meng ", "Xun ", "Yao ", "Pu ", "Li ", "Chen ", "Kuang ", "Die ", "[?] ", "Yan ", "Huo ", "Lu ", "Xi ", "Rong ", "Long ", "Nang ", "Luo ", "Luan ", "Shai ", "Tang ", "Yan ", "Chu ", "Yue ", "Yue ", "Qu ", "Yi ", "Geng ", "Ye ", "Hu ", "He ", "Shu ", "Cao ", "Cao ", "Noboru ", "Man ", "Ceng ", "Ceng ", "Ti "];
  }
});

// node_modules/unidecode/data/x67.js
var require_x67 = __commonJS({
  "node_modules/unidecode/data/x67.js"(exports, module2) {
    module2.exports = ["Zui ", "Can ", "Xu ", "Hui ", "Yin ", "Qie ", "Fen ", "Pi ", "Yue ", "You ", "Ruan ", "Peng ", "Ban ", "Fu ", "Ling ", "Fei ", "Qu ", "[?] ", "Nu ", "Tiao ", "Shuo ", "Zhen ", "Lang ", "Lang ", "Juan ", "Ming ", "Huang ", "Wang ", "Tun ", "Zhao ", "Ji ", "Qi ", "Ying ", "Zong ", "Wang ", "Tong ", "Lang ", "[?] ", "Meng ", "Long ", "Mu ", "Deng ", "Wei ", "Mo ", "Ben ", "Zha ", "Zhu ", "Zhu ", "[?] ", "Zhu ", "Ren ", "Ba ", "Po ", "Duo ", "Duo ", "Dao ", "Li ", "Qiu ", "Ji ", "Jiu ", "Bi ", "Xiu ", "Ting ", "Ci ", "Sha ", "Eburi ", "Za ", "Quan ", "Qian ", "Yu ", "Gan ", "Wu ", "Cha ", "Shan ", "Xun ", "Fan ", "Wu ", "Zi ", "Li ", "Xing ", "Cai ", "Cun ", "Ren ", "Shao ", "Tuo ", "Di ", "Zhang ", "Mang ", "Chi ", "Yi ", "Gu ", "Gong ", "Du ", "Yi ", "Qi ", "Shu ", "Gang ", "Tiao ", "Moku ", "Soma ", "Tochi ", "Lai ", "Sugi ", "Mang ", "Yang ", "Ma ", "Miao ", "Si ", "Yuan ", "Hang ", "Fei ", "Bei ", "Jie ", "Dong ", "Gao ", "Yao ", "Xian ", "Chu ", "Qun ", "Pa ", "Shu ", "Hua ", "Xin ", "Chou ", "Zhu ", "Chou ", "Song ", "Ban ", "Song ", "Ji ", "Yue ", "Jin ", "Gou ", "Ji ", "Mao ", "Pi ", "Bi ", "Wang ", "Ang ", "Fang ", "Fen ", "Yi ", "Fu ", "Nan ", "Xi ", "Hu ", "Ya ", "Dou ", "Xun ", "Zhen ", "Yao ", "Lin ", "Rui ", "E ", "Mei ", "Zhao ", "Guo ", "Zhi ", "Cong ", "Yun ", "Waku ", "Dou ", "Shu ", "Zao ", "[?] ", "Li ", "Haze ", "Jian ", "Cheng ", "Matsu ", "Qiang ", "Feng ", "Nan ", "Xiao ", "Xian ", "Ku ", "Ping ", "Yi ", "Xi ", "Zhi ", "Guai ", "Xiao ", "Jia ", "Jia ", "Gou ", "Fu ", "Mo ", "Yi ", "Ye ", "Ye ", "Shi ", "Nie ", "Bi ", "Duo ", "Yi ", "Ling ", "Bing ", "Ni ", "La ", "He ", "Pan ", "Fan ", "Zhong ", "Dai ", "Ci ", "Yang ", "Fu ", "Bo ", "Mou ", "Gan ", "Qi ", "Ran ", "Rou ", "Mao ", "Zhao ", "Song ", "Zhe ", "Xia ", "You ", "Shen ", "Ju ", "Tuo ", "Zuo ", "Nan ", "Ning ", "Yong ", "Di ", "Zhi ", "Zha ", "Cha ", "Dan ", "Gu ", "Pu ", "Jiu ", "Ao ", "Fu ", "Jian ", "Bo ", "Duo ", "Ke ", "Nai ", "Zhu ", "Bi ", "Liu ", "Chai ", "Zha ", "Si ", "Zhu ", "Pei ", "Shi ", "Guai ", "Cha ", "Yao ", "Jue ", "Jiu ", "Shi "];
  }
});

// node_modules/unidecode/data/x68.js
var require_x68 = __commonJS({
  "node_modules/unidecode/data/x68.js"(exports, module2) {
    module2.exports = ["Zhi ", "Liu ", "Mei ", "Hoy ", "Rong ", "Zha ", "[?] ", "Biao ", "Zhan ", "Jie ", "Long ", "Dong ", "Lu ", "Sayng ", "Li ", "Lan ", "Yong ", "Shu ", "Xun ", "Shuan ", "Qi ", "Zhen ", "Qi ", "Li ", "Yi ", "Xiang ", "Zhen ", "Li ", "Su ", "Gua ", "Kan ", "Bing ", "Ren ", "Xiao ", "Bo ", "Ren ", "Bing ", "Zi ", "Chou ", "Yi ", "Jie ", "Xu ", "Zhu ", "Jian ", "Zui ", "Er ", "Er ", "You ", "Fa ", "Gong ", "Kao ", "Lao ", "Zhan ", "Li ", "Yin ", "Yang ", "He ", "Gen ", "Zhi ", "Chi ", "Ge ", "Zai ", "Luan ", "Fu ", "Jie ", "Hang ", "Gui ", "Tao ", "Guang ", "Wei ", "Kuang ", "Ru ", "An ", "An ", "Juan ", "Yi ", "Zhuo ", "Ku ", "Zhi ", "Qiong ", "Tong ", "Sang ", "Sang ", "Huan ", "Jie ", "Jiu ", "Xue ", "Duo ", "Zhui ", "Yu ", "Zan ", "Kasei ", "Ying ", "Masu ", "[?] ", "Zhan ", "Ya ", "Nao ", "Zhen ", "Dang ", "Qi ", "Qiao ", "Hua ", "Kuai ", "Jiang ", "Zhuang ", "Xun ", "Suo ", "Sha ", "Zhen ", "Bei ", "Ting ", "Gua ", "Jing ", "Bo ", "Ben ", "Fu ", "Rui ", "Tong ", "Jue ", "Xi ", "Lang ", "Liu ", "Feng ", "Qi ", "Wen ", "Jun ", "Gan ", "Cu ", "Liang ", "Qiu ", "Ting ", "You ", "Mei ", "Bang ", "Long ", "Peng ", "Zhuang ", "Di ", "Xuan ", "Tu ", "Zao ", "Ao ", "Gu ", "Bi ", "Di ", "Han ", "Zi ", "Zhi ", "Ren ", "Bei ", "Geng ", "Jian ", "Huan ", "Wan ", "Nuo ", "Jia ", "Tiao ", "Ji ", "Xiao ", "Lu ", "Huan ", "Shao ", "Cen ", "Fen ", "Song ", "Meng ", "Wu ", "Li ", "Li ", "Dou ", "Cen ", "Ying ", "Suo ", "Ju ", "Ti ", "Jie ", "Kun ", "Zhuo ", "Shu ", "Chan ", "Fan ", "Wei ", "Jing ", "Li ", "Bing ", "Fumoto ", "Shikimi ", "Tao ", "Zhi ", "Lai ", "Lian ", "Jian ", "Zhuo ", "Ling ", "Li ", "Qi ", "Bing ", "Zhun ", "Cong ", "Qian ", "Mian ", "Qi ", "Qi ", "Cai ", "Gun ", "Chan ", "Te ", "Fei ", "Pai ", "Bang ", "Pou ", "Hun ", "Zong ", "Cheng ", "Zao ", "Ji ", "Li ", "Peng ", "Yu ", "Yu ", "Gu ", "Hun ", "Dong ", "Tang ", "Gang ", "Wang ", "Di ", "Xi ", "Fan ", "Cheng ", "Zhan ", "Qi ", "Yuan ", "Yan ", "Yu ", "Quan ", "Yi ", "Sen ", "Ren ", "Chui ", "Leng ", "Qi ", "Zhuo ", "Fu ", "Ke ", "Lai ", "Zou ", "Zou ", "Zhuo ", "Guan ", "Fen ", "Fen ", "Chen ", "Qiong ", "Nie "];
  }
});

// node_modules/unidecode/data/x69.js
var require_x69 = __commonJS({
  "node_modules/unidecode/data/x69.js"(exports, module2) {
    module2.exports = ["Wan ", "Guo ", "Lu ", "Hao ", "Jie ", "Yi ", "Chou ", "Ju ", "Ju ", "Cheng ", "Zuo ", "Liang ", "Qiang ", "Zhi ", "Zhui ", "Ya ", "Ju ", "Bei ", "Jiao ", "Zhuo ", "Zi ", "Bin ", "Peng ", "Ding ", "Chu ", "Chang ", "Kunugi ", "Momiji ", "Jian ", "Gui ", "Xi ", "Du ", "Qian ", "Kunugi ", "Soko ", "Shide ", "Luo ", "Zhi ", "Ken ", "Myeng ", "Tafu ", "[?] ", "Peng ", "Zhan ", "[?] ", "Tuo ", "Sen ", "Duo ", "Ye ", "Fou ", "Wei ", "Wei ", "Duan ", "Jia ", "Zong ", "Jian ", "Yi ", "Shen ", "Xi ", "Yan ", "Yan ", "Chuan ", "Zhan ", "Chun ", "Yu ", "He ", "Zha ", "Wo ", "Pian ", "Bi ", "Yao ", "Huo ", "Xu ", "Ruo ", "Yang ", "La ", "Yan ", "Ben ", "Hun ", "Kui ", "Jie ", "Kui ", "Si ", "Feng ", "Xie ", "Tuo ", "Zhi ", "Jian ", "Mu ", "Mao ", "Chu ", "Hu ", "Hu ", "Lian ", "Leng ", "Ting ", "Nan ", "Yu ", "You ", "Mei ", "Song ", "Xuan ", "Xuan ", "Ying ", "Zhen ", "Pian ", "Ye ", "Ji ", "Jie ", "Ye ", "Chu ", "Shun ", "Yu ", "Cou ", "Wei ", "Mei ", "Di ", "Ji ", "Jie ", "Kai ", "Qiu ", "Ying ", "Rou ", "Heng ", "Lou ", "Le ", "Hazou ", "Katsura ", "Pin ", "Muro ", "Gai ", "Tan ", "Lan ", "Yun ", "Yu ", "Chen ", "Lu ", "Ju ", "Sakaki ", "[?] ", "Pi ", "Xie ", "Jia ", "Yi ", "Zhan ", "Fu ", "Nai ", "Mi ", "Lang ", "Rong ", "Gu ", "Jian ", "Ju ", "Ta ", "Yao ", "Zhen ", "Bang ", "Sha ", "Yuan ", "Zi ", "Ming ", "Su ", "Jia ", "Yao ", "Jie ", "Huang ", "Gan ", "Fei ", "Zha ", "Qian ", "Ma ", "Sun ", "Yuan ", "Xie ", "Rong ", "Shi ", "Zhi ", "Cui ", "Yun ", "Ting ", "Liu ", "Rong ", "Tang ", "Que ", "Zhai ", "Si ", "Sheng ", "Ta ", "Ke ", "Xi ", "Gu ", "Qi ", "Kao ", "Gao ", "Sun ", "Pan ", "Tao ", "Ge ", "Xun ", "Dian ", "Nou ", "Ji ", "Shuo ", "Gou ", "Chui ", "Qiang ", "Cha ", "Qian ", "Huai ", "Mei ", "Xu ", "Gang ", "Gao ", "Zhuo ", "Tuo ", "Hashi ", "Yang ", "Dian ", "Jia ", "Jian ", "Zui ", "Kashi ", "Ori ", "Bin ", "Zhu ", "[?] ", "Xi ", "Qi ", "Lian ", "Hui ", "Yong ", "Qian ", "Guo ", "Gai ", "Gai ", "Tuan ", "Hua ", "Cu ", "Sen ", "Cui ", "Beng ", "You ", "Hu ", "Jiang ", "Hu ", "Huan ", "Kui ", "Yi ", "Nie ", "Gao ", "Kang ", "Gui ", "Gui ", "Cao ", "Man ", "Jin "];
  }
});

// node_modules/unidecode/data/x6a.js
var require_x6a = __commonJS({
  "node_modules/unidecode/data/x6a.js"(exports, module2) {
    module2.exports = ["Di ", "Zhuang ", "Le ", "Lang ", "Chen ", "Cong ", "Li ", "Xiu ", "Qing ", "Shuang ", "Fan ", "Tong ", "Guan ", "Ji ", "Suo ", "Lei ", "Lu ", "Liang ", "Mi ", "Lou ", "Chao ", "Su ", "Ke ", "Shu ", "Tang ", "Biao ", "Lu ", "Jiu ", "Shu ", "Zha ", "Shu ", "Zhang ", "Men ", "Mo ", "Niao ", "Yang ", "Tiao ", "Peng ", "Zhu ", "Sha ", "Xi ", "Quan ", "Heng ", "Jian ", "Cong ", "[?] ", "Hokuso ", "Qiang ", "Tara ", "Ying ", "Er ", "Xin ", "Zhi ", "Qiao ", "Zui ", "Cong ", "Pu ", "Shu ", "Hua ", "Kui ", "Zhen ", "Zun ", "Yue ", "Zhan ", "Xi ", "Xun ", "Dian ", "Fa ", "Gan ", "Mo ", "Wu ", "Qiao ", "Nao ", "Lin ", "Liu ", "Qiao ", "Xian ", "Run ", "Fan ", "Zhan ", "Tuo ", "Lao ", "Yun ", "Shun ", "Tui ", "Cheng ", "Tang ", "Meng ", "Ju ", "Cheng ", "Su ", "Jue ", "Jue ", "Tan ", "Hui ", "Ji ", "Nuo ", "Xiang ", "Tuo ", "Ning ", "Rui ", "Zhu ", "Chuang ", "Zeng ", "Fen ", "Qiong ", "Ran ", "Heng ", "Cen ", "Gu ", "Liu ", "Lao ", "Gao ", "Chu ", "Zusa ", "Nude ", "Ca ", "San ", "Ji ", "Dou ", "Shou ", "Lu ", "[?] ", "[?] ", "Yuan ", "Ta ", "Shu ", "Jiang ", "Tan ", "Lin ", "Nong ", "Yin ", "Xi ", "Sui ", "Shan ", "Zui ", "Xuan ", "Cheng ", "Gan ", "Ju ", "Zui ", "Yi ", "Qin ", "Pu ", "Yan ", "Lei ", "Feng ", "Hui ", "Dang ", "Ji ", "Sui ", "Bo ", "Bi ", "Ding ", "Chu ", "Zhua ", "Kuai ", "Ji ", "Jie ", "Jia ", "Qing ", "Zhe ", "Jian ", "Qiang ", "Dao ", "Yi ", "Biao ", "Song ", "She ", "Lin ", "Kunugi ", "Cha ", "Meng ", "Yin ", "Tao ", "Tai ", "Mian ", "Qi ", "Toan ", "Bin ", "Huo ", "Ji ", "Qian ", "Mi ", "Ning ", "Yi ", "Gao ", "Jian ", "Yin ", "Er ", "Qing ", "Yan ", "Qi ", "Mi ", "Zhao ", "Gui ", "Chun ", "Ji ", "Kui ", "Po ", "Deng ", "Chu ", "[?] ", "Mian ", "You ", "Zhi ", "Guang ", "Qian ", "Lei ", "Lei ", "Sa ", "Lu ", "Li ", "Cuan ", "Lu ", "Mie ", "Hui ", "Ou ", "Lu ", "Jie ", "Gao ", "Du ", "Yuan ", "Li ", "Fei ", "Zhuo ", "Sou ", "Lian ", "Tamo ", "Chu ", "[?] ", "Zhu ", "Lu ", "Yan ", "Li ", "Zhu ", "Chen ", "Jie ", "E ", "Su ", "Huai ", "Nie ", "Yu ", "Long ", "Lai ", "[?] ", "Xian ", "Kwi ", "Ju ", "Xiao ", "Ling ", "Ying ", "Jian ", "Yin ", "You ", "Ying "];
  }
});

// node_modules/unidecode/data/x6b.js
var require_x6b = __commonJS({
  "node_modules/unidecode/data/x6b.js"(exports, module2) {
    module2.exports = ["Xiang ", "Nong ", "Bo ", "Chan ", "Lan ", "Ju ", "Shuang ", "She ", "Wei ", "Cong ", "Quan ", "Qu ", "Cang ", "[?] ", "Yu ", "Luo ", "Li ", "Zan ", "Luan ", "Dang ", "Jue ", "Em ", "Lan ", "Lan ", "Zhu ", "Lei ", "Li ", "Ba ", "Nang ", "Yu ", "Ling ", "Tsuki ", "Qian ", "Ci ", "Huan ", "Xin ", "Yu ", "Yu ", "Qian ", "Ou ", "Xu ", "Chao ", "Chu ", "Chi ", "Kai ", "Yi ", "Jue ", "Xi ", "Xu ", "Xia ", "Yu ", "Kuai ", "Lang ", "Kuan ", "Shuo ", "Xi ", "Ai ", "Yi ", "Qi ", "Hu ", "Chi ", "Qin ", "Kuan ", "Kan ", "Kuan ", "Kan ", "Chuan ", "Sha ", "Gua ", "Yin ", "Xin ", "Xie ", "Yu ", "Qian ", "Xiao ", "Yi ", "Ge ", "Wu ", "Tan ", "Jin ", "Ou ", "Hu ", "Ti ", "Huan ", "Xu ", "Pen ", "Xi ", "Xiao ", "Xu ", "Xi ", "Sen ", "Lian ", "Chu ", "Yi ", "Kan ", "Yu ", "Chuo ", "Huan ", "Zhi ", "Zheng ", "Ci ", "Bu ", "Wu ", "Qi ", "Bu ", "Bu ", "Wai ", "Ju ", "Qian ", "Chi ", "Se ", "Chi ", "Se ", "Zhong ", "Sui ", "Sui ", "Li ", "Cuo ", "Yu ", "Li ", "Gui ", "Dai ", "Dai ", "Si ", "Jian ", "Zhe ", "Mo ", "Mo ", "Yao ", "Mo ", "Cu ", "Yang ", "Tian ", "Sheng ", "Dai ", "Shang ", "Xu ", "Xun ", "Shu ", "Can ", "Jue ", "Piao ", "Qia ", "Qiu ", "Su ", "Qing ", "Yun ", "Lian ", "Yi ", "Fou ", "Zhi ", "Ye ", "Can ", "Hun ", "Dan ", "Ji ", "Ye ", "Zhen ", "Yun ", "Wen ", "Chou ", "Bin ", "Ti ", "Jin ", "Shang ", "Yin ", "Diao ", "Cu ", "Hui ", "Cuan ", "Yi ", "Dan ", "Du ", "Jiang ", "Lian ", "Bin ", "Du ", "Tsukusu ", "Jian ", "Shu ", "Ou ", "Duan ", "Zhu ", "Yin ", "Qing ", "Yi ", "Sha ", "Que ", "Ke ", "Yao ", "Jun ", "Dian ", "Hui ", "Hui ", "Gu ", "Que ", "Ji ", "Yi ", "Ou ", "Hui ", "Duan ", "Yi ", "Xiao ", "Wu ", "Guan ", "Mu ", "Mei ", "Mei ", "Ai ", "Zuo ", "Du ", "Yu ", "Bi ", "Bi ", "Bi ", "Pi ", "Pi ", "Bi ", "Chan ", "Mao ", "[?] ", "[?] ", "Pu ", "Mushiru ", "Jia ", "Zhan ", "Sai ", "Mu ", "Tuo ", "Xun ", "Er ", "Rong ", "Xian ", "Ju ", "Mu ", "Hao ", "Qiu ", "Dou ", "Mushiru ", "Tan ", "Pei ", "Ju ", "Duo ", "Cui ", "Bi ", "San ", "[?] ", "Mao ", "Sui ", "Yu ", "Yu ", "Tuo ", "He ", "Jian ", "Ta ", "San "];
  }
});

// node_modules/unidecode/data/x6c.js
var require_x6c = __commonJS({
  "node_modules/unidecode/data/x6c.js"(exports, module2) {
    module2.exports = ["Lu ", "Mu ", "Li ", "Tong ", "Rong ", "Chang ", "Pu ", "Luo ", "Zhan ", "Sao ", "Zhan ", "Meng ", "Luo ", "Qu ", "Die ", "Shi ", "Di ", "Min ", "Jue ", "Mang ", "Qi ", "Pie ", "Nai ", "Qi ", "Dao ", "Xian ", "Chuan ", "Fen ", "Ri ", "Nei ", "[?] ", "Fu ", "Shen ", "Dong ", "Qing ", "Qi ", "Yin ", "Xi ", "Hai ", "Yang ", "An ", "Ya ", "Ke ", "Qing ", "Ya ", "Dong ", "Dan ", "Lu ", "Qing ", "Yang ", "Yun ", "Yun ", "Shui ", "San ", "Zheng ", "Bing ", "Yong ", "Dang ", "Shitamizu ", "Le ", "Ni ", "Tun ", "Fan ", "Gui ", "Ting ", "Zhi ", "Qiu ", "Bin ", "Ze ", "Mian ", "Cuan ", "Hui ", "Diao ", "Yi ", "Cha ", "Zhuo ", "Chuan ", "Wan ", "Fan ", "Dai ", "Xi ", "Tuo ", "Mang ", "Qiu ", "Qi ", "Shan ", "Pai ", "Han ", "Qian ", "Wu ", "Wu ", "Xun ", "Si ", "Ru ", "Gong ", "Jiang ", "Chi ", "Wu ", "Tsuchi ", "[?] ", "Tang ", "Zhi ", "Chi ", "Qian ", "Mi ", "Yu ", "Wang ", "Qing ", "Jing ", "Rui ", "Jun ", "Hong ", "Tai ", "Quan ", "Ji ", "Bian ", "Bian ", "Gan ", "Wen ", "Zhong ", "Fang ", "Xiong ", "Jue ", "Hang ", "Niou ", "Qi ", "Fen ", "Xu ", "Xu ", "Qin ", "Yi ", "Wo ", "Yun ", "Yuan ", "Hang ", "Yan ", "Chen ", "Chen ", "Dan ", "You ", "Dun ", "Hu ", "Huo ", "Qie ", "Mu ", "Rou ", "Mei ", "Ta ", "Mian ", "Wu ", "Chong ", "Tian ", "Bi ", "Sha ", "Zhi ", "Pei ", "Pan ", "Zhui ", "Za ", "Gou ", "Liu ", "Mei ", "Ze ", "Feng ", "Ou ", "Li ", "Lun ", "Cang ", "Feng ", "Wei ", "Hu ", "Mo ", "Mei ", "Shu ", "Ju ", "Zan ", "Tuo ", "Tuo ", "Tuo ", "He ", "Li ", "Mi ", "Yi ", "Fa ", "Fei ", "You ", "Tian ", "Zhi ", "Zhao ", "Gu ", "Zhan ", "Yan ", "Si ", "Kuang ", "Jiong ", "Ju ", "Xie ", "Qiu ", "Yi ", "Jia ", "Zhong ", "Quan ", "Bo ", "Hui ", "Mi ", "Ben ", "Zhuo ", "Chu ", "Le ", "You ", "Gu ", "Hong ", "Gan ", "Fa ", "Mao ", "Si ", "Hu ", "Ping ", "Ci ", "Fan ", "Chi ", "Su ", "Ning ", "Cheng ", "Ling ", "Pao ", "Bo ", "Qi ", "Si ", "Ni ", "Ju ", "Yue ", "Zhu ", "Sheng ", "Lei ", "Xuan ", "Xue ", "Fu ", "Pan ", "Min ", "Tai ", "Yang ", "Ji ", "Yong ", "Guan ", "Beng ", "Xue ", "Long ", "Lu ", "[?] ", "Bo ", "Xie ", "Po ", "Ze ", "Jing ", "Yin "];
  }
});

// node_modules/unidecode/data/x6d.js
var require_x6d = __commonJS({
  "node_modules/unidecode/data/x6d.js"(exports, module2) {
    module2.exports = ["Zhou ", "Ji ", "Yi ", "Hui ", "Hui ", "Zui ", "Cheng ", "Yin ", "Wei ", "Hou ", "Jian ", "Yang ", "Lie ", "Si ", "Ji ", "Er ", "Xing ", "Fu ", "Sa ", "Suo ", "Zhi ", "Yin ", "Wu ", "Xi ", "Kao ", "Zhu ", "Jiang ", "Luo ", "[?] ", "An ", "Dong ", "Yi ", "Mou ", "Lei ", "Yi ", "Mi ", "Quan ", "Jin ", "Mo ", "Wei ", "Xiao ", "Xie ", "Hong ", "Xu ", "Shuo ", "Kuang ", "Tao ", "Qie ", "Ju ", "Er ", "Zhou ", "Ru ", "Ping ", "Xun ", "Xiong ", "Zhi ", "Guang ", "Huan ", "Ming ", "Huo ", "Wa ", "Qia ", "Pai ", "Wu ", "Qu ", "Liu ", "Yi ", "Jia ", "Jing ", "Qian ", "Jiang ", "Jiao ", "Cheng ", "Shi ", "Zhuo ", "Ce ", "Pal ", "Kuai ", "Ji ", "Liu ", "Chan ", "Hun ", "Hu ", "Nong ", "Xun ", "Jin ", "Lie ", "Qiu ", "Wei ", "Zhe ", "Jun ", "Han ", "Bang ", "Mang ", "Zhuo ", "You ", "Xi ", "Bo ", "Dou ", "Wan ", "Hong ", "Yi ", "Pu ", "Ying ", "Lan ", "Hao ", "Lang ", "Han ", "Li ", "Geng ", "Fu ", "Wu ", "Lian ", "Chun ", "Feng ", "Yi ", "Yu ", "Tong ", "Lao ", "Hai ", "Jin ", "Jia ", "Chong ", "Weng ", "Mei ", "Sui ", "Cheng ", "Pei ", "Xian ", "Shen ", "Tu ", "Kun ", "Pin ", "Nie ", "Han ", "Jing ", "Xiao ", "She ", "Nian ", "Tu ", "Yong ", "Xiao ", "Xian ", "Ting ", "E ", "Su ", "Tun ", "Juan ", "Cen ", "Ti ", "Li ", "Shui ", "Si ", "Lei ", "Shui ", "Tao ", "Du ", "Lao ", "Lai ", "Lian ", "Wei ", "Wo ", "Yun ", "Huan ", "Di ", "[?] ", "Run ", "Jian ", "Zhang ", "Se ", "Fu ", "Guan ", "Xing ", "Shou ", "Shuan ", "Ya ", "Chuo ", "Zhang ", "Ye ", "Kong ", "Wo ", "Han ", "Tuo ", "Dong ", "He ", "Wo ", "Ju ", "Gan ", "Liang ", "Hun ", "Ta ", "Zhuo ", "Dian ", "Qie ", "De ", "Juan ", "Zi ", "Xi ", "Yao ", "Qi ", "Gu ", "Guo ", "Han ", "Lin ", "Tang ", "Zhou ", "Peng ", "Hao ", "Chang ", "Shu ", "Qi ", "Fang ", "Chi ", "Lu ", "Nao ", "Ju ", "Tao ", "Cong ", "Lei ", "Zhi ", "Peng ", "Fei ", "Song ", "Tian ", "Pi ", "Dan ", "Yu ", "Ni ", "Yu ", "Lu ", "Gan ", "Mi ", "Jing ", "Ling ", "Lun ", "Yin ", "Cui ", "Qu ", "Huai ", "Yu ", "Nian ", "Shen ", "Piao ", "Chun ", "Wa ", "Yuan ", "Lai ", "Hun ", "Qing ", "Yan ", "Qian ", "Tian ", "Miao ", "Zhi ", "Yin ", "Mi "];
  }
});

// node_modules/unidecode/data/x6e.js
var require_x6e = __commonJS({
  "node_modules/unidecode/data/x6e.js"(exports, module2) {
    module2.exports = ["Ben ", "Yuan ", "Wen ", "Re ", "Fei ", "Qing ", "Yuan ", "Ke ", "Ji ", "She ", "Yuan ", "Shibui ", "Lu ", "Zi ", "Du ", "[?] ", "Jian ", "Min ", "Pi ", "Tani ", "Yu ", "Yuan ", "Shen ", "Shen ", "Rou ", "Huan ", "Zhu ", "Jian ", "Nuan ", "Yu ", "Qiu ", "Ting ", "Qu ", "Du ", "Feng ", "Zha ", "Bo ", "Wo ", "Wo ", "Di ", "Wei ", "Wen ", "Ru ", "Xie ", "Ce ", "Wei ", "Ge ", "Gang ", "Yan ", "Hong ", "Xuan ", "Mi ", "Ke ", "Mao ", "Ying ", "Yan ", "You ", "Hong ", "Miao ", "Xing ", "Mei ", "Zai ", "Hun ", "Nai ", "Kui ", "Shi ", "E ", "Pai ", "Mei ", "Lian ", "Qi ", "Qi ", "Mei ", "Tian ", "Cou ", "Wei ", "Can ", "Tuan ", "Mian ", "Hui ", "Mo ", "Xu ", "Ji ", "Pen ", "Jian ", "Jian ", "Hu ", "Feng ", "Xiang ", "Yi ", "Yin ", "Zhan ", "Shi ", "Jie ", "Cheng ", "Huang ", "Tan ", "Yu ", "Bi ", "Min ", "Shi ", "Tu ", "Sheng ", "Yong ", "Qu ", "Zhong ", "Suei ", "Jiu ", "Jiao ", "Qiou ", "Yin ", "Tang ", "Long ", "Huo ", "Yuan ", "Nan ", "Ban ", "You ", "Quan ", "Chui ", "Liang ", "Chan ", "Yan ", "Chun ", "Nie ", "Zi ", "Wan ", "Shi ", "Man ", "Ying ", "Ratsu ", "Kui ", "[?] ", "Jian ", "Xu ", "Lu ", "Gui ", "Gai ", "[?] ", "[?] ", "Po ", "Jin ", "Gui ", "Tang ", "Yuan ", "Suo ", "Yuan ", "Lian ", "Yao ", "Meng ", "Zhun ", "Sheng ", "Ke ", "Tai ", "Da ", "Wa ", "Liu ", "Gou ", "Sao ", "Ming ", "Zha ", "Shi ", "Yi ", "Lun ", "Ma ", "Pu ", "Wei ", "Li ", "Cai ", "Wu ", "Xi ", "Wen ", "Qiang ", "Ze ", "Shi ", "Su ", "Yi ", "Zhen ", "Sou ", "Yun ", "Xiu ", "Yin ", "Rong ", "Hun ", "Su ", "Su ", "Ni ", "Ta ", "Shi ", "Ru ", "Wei ", "Pan ", "Chu ", "Chu ", "Pang ", "Weng ", "Cang ", "Mie ", "He ", "Dian ", "Hao ", "Huang ", "Xi ", "Zi ", "Di ", "Zhi ", "Ying ", "Fu ", "Jie ", "Hua ", "Ge ", "Zi ", "Tao ", "Teng ", "Sui ", "Bi ", "Jiao ", "Hui ", "Gun ", "Yin ", "Gao ", "Long ", "Zhi ", "Yan ", "She ", "Man ", "Ying ", "Chun ", "Lu ", "Lan ", "Luan ", "[?] ", "Bin ", "Tan ", "Yu ", "Sou ", "Hu ", "Bi ", "Biao ", "Zhi ", "Jiang ", "Kou ", "Shen ", "Shang ", "Di ", "Mi ", "Ao ", "Lu ", "Hu ", "Hu ", "You ", "Chan ", "Fan ", "Yong ", "Gun ", "Man "];
  }
});

// node_modules/unidecode/data/x6f.js
var require_x6f = __commonJS({
  "node_modules/unidecode/data/x6f.js"(exports, module2) {
    module2.exports = ["Qing ", "Yu ", "Piao ", "Ji ", "Ya ", "Jiao ", "Qi ", "Xi ", "Ji ", "Lu ", "Lu ", "Long ", "Jin ", "Guo ", "Cong ", "Lou ", "Zhi ", "Gai ", "Qiang ", "Li ", "Yan ", "Cao ", "Jiao ", "Cong ", "Qun ", "Tuan ", "Ou ", "Teng ", "Ye ", "Xi ", "Mi ", "Tang ", "Mo ", "Shang ", "Han ", "Lian ", "Lan ", "Wa ", "Li ", "Qian ", "Feng ", "Xuan ", "Yi ", "Man ", "Zi ", "Mang ", "Kang ", "Lei ", "Peng ", "Shu ", "Zhang ", "Zhang ", "Chong ", "Xu ", "Huan ", "Kuo ", "Jian ", "Yan ", "Chuang ", "Liao ", "Cui ", "Ti ", "Yang ", "Jiang ", "Cong ", "Ying ", "Hong ", "Xun ", "Shu ", "Guan ", "Ying ", "Xiao ", "[?] ", "[?] ", "Xu ", "Lian ", "Zhi ", "Wei ", "Pi ", "Jue ", "Jiao ", "Po ", "Dang ", "Hui ", "Jie ", "Wu ", "Pa ", "Ji ", "Pan ", "Gui ", "Xiao ", "Qian ", "Qian ", "Xi ", "Lu ", "Xi ", "Xuan ", "Dun ", "Huang ", "Min ", "Run ", "Su ", "Liao ", "Zhen ", "Zhong ", "Yi ", "Di ", "Wan ", "Dan ", "Tan ", "Chao ", "Xun ", "Kui ", "Yie ", "Shao ", "Tu ", "Zhu ", "San ", "Hei ", "Bi ", "Shan ", "Chan ", "Chan ", "Shu ", "Tong ", "Pu ", "Lin ", "Wei ", "Se ", "Se ", "Cheng ", "Jiong ", "Cheng ", "Hua ", "Jiao ", "Lao ", "Che ", "Gan ", "Cun ", "Heng ", "Si ", "Shu ", "Peng ", "Han ", "Yun ", "Liu ", "Hong ", "Fu ", "Hao ", "He ", "Xian ", "Jian ", "Shan ", "Xi ", "Oki ", "[?] ", "Lan ", "[?] ", "Yu ", "Lin ", "Min ", "Zao ", "Dang ", "Wan ", "Ze ", "Xie ", "Yu ", "Li ", "Shi ", "Xue ", "Ling ", "Man ", "Zi ", "Yong ", "Kuai ", "Can ", "Lian ", "Dian ", "Ye ", "Ao ", "Huan ", "Zhen ", "Chan ", "Man ", "Dan ", "Dan ", "Yi ", "Sui ", "Pi ", "Ju ", "Ta ", "Qin ", "Ji ", "Zhuo ", "Lian ", "Nong ", "Guo ", "Jin ", "Fen ", "Se ", "Ji ", "Sui ", "Hui ", "Chu ", "Ta ", "Song ", "Ding ", "[?] ", "Zhu ", "Lai ", "Bin ", "Lian ", "Mi ", "Shi ", "Shu ", "Mi ", "Ning ", "Ying ", "Ying ", "Meng ", "Jin ", "Qi ", "Pi ", "Ji ", "Hao ", "Ru ", "Zui ", "Wo ", "Tao ", "Yin ", "Yin ", "Dui ", "Ci ", "Huo ", "Jing ", "Lan ", "Jun ", "Ai ", "Pu ", "Zhuo ", "Wei ", "Bin ", "Gu ", "Qian ", "Xing ", "Hama ", "Kuo ", "Fei ", "[?] ", "Boku ", "Jian ", "Wei ", "Luo ", "Zan ", "Lu ", "Li "];
  }
});

// node_modules/unidecode/data/x70.js
var require_x70 = __commonJS({
  "node_modules/unidecode/data/x70.js"(exports, module2) {
    module2.exports = ["You ", "Yang ", "Lu ", "Si ", "Jie ", "Ying ", "Du ", "Wang ", "Hui ", "Xie ", "Pan ", "Shen ", "Biao ", "Chan ", "Mo ", "Liu ", "Jian ", "Pu ", "Se ", "Cheng ", "Gu ", "Bin ", "Huo ", "Xian ", "Lu ", "Qin ", "Han ", "Ying ", "Yong ", "Li ", "Jing ", "Xiao ", "Ying ", "Sui ", "Wei ", "Xie ", "Huai ", "Hao ", "Zhu ", "Long ", "Lai ", "Dui ", "Fan ", "Hu ", "Lai ", "[?] ", "[?] ", "Ying ", "Mi ", "Ji ", "Lian ", "Jian ", "Ying ", "Fen ", "Lin ", "Yi ", "Jian ", "Yue ", "Chan ", "Dai ", "Rang ", "Jian ", "Lan ", "Fan ", "Shuang ", "Yuan ", "Zhuo ", "Feng ", "She ", "Lei ", "Lan ", "Cong ", "Qu ", "Yong ", "Qian ", "Fa ", "Guan ", "Que ", "Yan ", "Hao ", "Hyeng ", "Sa ", "Zan ", "Luan ", "Yan ", "Li ", "Mi ", "Shan ", "Tan ", "Dang ", "Jiao ", "Chan ", "[?] ", "Hao ", "Ba ", "Zhu ", "Lan ", "Lan ", "Nang ", "Wan ", "Luan ", "Xun ", "Xian ", "Yan ", "Gan ", "Yan ", "Yu ", "Huo ", "Si ", "Mie ", "Guang ", "Deng ", "Hui ", "Xiao ", "Xiao ", "Hu ", "Hong ", "Ling ", "Zao ", "Zhuan ", "Jiu ", "Zha ", "Xie ", "Chi ", "Zhuo ", "Zai ", "Zai ", "Can ", "Yang ", "Qi ", "Zhong ", "Fen ", "Niu ", "Jiong ", "Wen ", "Po ", "Yi ", "Lu ", "Chui ", "Pi ", "Kai ", "Pan ", "Yan ", "Kai ", "Pang ", "Mu ", "Chao ", "Liao ", "Gui ", "Kang ", "Tun ", "Guang ", "Xin ", "Zhi ", "Guang ", "Guang ", "Wei ", "Qiang ", "[?] ", "Da ", "Xia ", "Zheng ", "Zhu ", "Ke ", "Zhao ", "Fu ", "Ba ", "Duo ", "Duo ", "Ling ", "Zhuo ", "Xuan ", "Ju ", "Tan ", "Pao ", "Jiong ", "Pao ", "Tai ", "Tai ", "Bing ", "Yang ", "Tong ", "Han ", "Zhu ", "Zha ", "Dian ", "Wei ", "Shi ", "Lian ", "Chi ", "Huang ", "[?] ", "Hu ", "Shuo ", "Lan ", "Jing ", "Jiao ", "Xu ", "Xing ", "Quan ", "Lie ", "Huan ", "Yang ", "Xiao ", "Xiu ", "Xian ", "Yin ", "Wu ", "Zhou ", "Yao ", "Shi ", "Wei ", "Tong ", "Xue ", "Zai ", "Kai ", "Hong ", "Luo ", "Xia ", "Zhu ", "Xuan ", "Zheng ", "Po ", "Yan ", "Hui ", "Guang ", "Zhe ", "Hui ", "Kao ", "[?] ", "Fan ", "Shao ", "Ye ", "Hui ", "[?] ", "Tang ", "Jin ", "Re ", "[?] ", "Xi ", "Fu ", "Jiong ", "Che ", "Pu ", "Jing ", "Zhuo ", "Ting ", "Wan ", "Hai ", "Peng ", "Lang ", "Shan ", "Hu ", "Feng ", "Chi ", "Rong "];
  }
});

// node_modules/unidecode/data/x71.js
var require_x71 = __commonJS({
  "node_modules/unidecode/data/x71.js"(exports, module2) {
    module2.exports = ["Hu ", "Xi ", "Shu ", "He ", "Xun ", "Ku ", "Jue ", "Xiao ", "Xi ", "Yan ", "Han ", "Zhuang ", "Jun ", "Di ", "Xie ", "Ji ", "Wu ", "[?] ", "[?] ", "Han ", "Yan ", "Huan ", "Men ", "Ju ", "Chou ", "Bei ", "Fen ", "Lin ", "Kun ", "Hun ", "Tun ", "Xi ", "Cui ", "Wu ", "Hong ", "Ju ", "Fu ", "Wo ", "Jiao ", "Cong ", "Feng ", "Ping ", "Qiong ", "Ruo ", "Xi ", "Qiong ", "Xin ", "Zhuo ", "Yan ", "Yan ", "Yi ", "Jue ", "Yu ", "Gang ", "Ran ", "Pi ", "Gu ", "[?] ", "Sheng ", "Chang ", "Shao ", "[?] ", "[?] ", "[?] ", "[?] ", "Chen ", "He ", "Kui ", "Zhong ", "Duan ", "Xia ", "Hui ", "Feng ", "Lian ", "Xuan ", "Xing ", "Huang ", "Jiao ", "Jian ", "Bi ", "Ying ", "Zhu ", "Wei ", "Tuan ", "Tian ", "Xi ", "Nuan ", "Nuan ", "Chan ", "Yan ", "Jiong ", "Jiong ", "Yu ", "Mei ", "Sha ", "Wei ", "Ye ", "Xin ", "Qiong ", "Rou ", "Mei ", "Huan ", "Xu ", "Zhao ", "Wei ", "Fan ", "Qiu ", "Sui ", "Yang ", "Lie ", "Zhu ", "Jie ", "Gao ", "Gua ", "Bao ", "Hu ", "Yun ", "Xia ", "[?] ", "[?] ", "Bian ", "Gou ", "Tui ", "Tang ", "Chao ", "Shan ", "N ", "Bo ", "Huang ", "Xie ", "Xi ", "Wu ", "Xi ", "Yun ", "He ", "He ", "Xi ", "Yun ", "Xiong ", "Nai ", "Shan ", "Qiong ", "Yao ", "Xun ", "Mi ", "Lian ", "Ying ", "Wen ", "Rong ", "Oozutsu ", "[?] ", "Qiang ", "Liu ", "Xi ", "Bi ", "Biao ", "Zong ", "Lu ", "Jian ", "Shou ", "Yi ", "Lou ", "Feng ", "Sui ", "Yi ", "Tong ", "Jue ", "Zong ", "Yun ", "Hu ", "Yi ", "Zhi ", "Ao ", "Wei ", "Liao ", "Han ", "Ou ", "Re ", "Jiong ", "Man ", "[?] ", "Shang ", "Cuan ", "Zeng ", "Jian ", "Xi ", "Xi ", "Xi ", "Yi ", "Xiao ", "Chi ", "Huang ", "Chan ", "Ye ", "Qian ", "Ran ", "Yan ", "Xian ", "Qiao ", "Zun ", "Deng ", "Dun ", "Shen ", "Jiao ", "Fen ", "Si ", "Liao ", "Yu ", "Lin ", "Tong ", "Shao ", "Fen ", "Fan ", "Yan ", "Xun ", "Lan ", "Mei ", "Tang ", "Yi ", "Jing ", "Men ", "[?] ", "[?] ", "Ying ", "Yu ", "Yi ", "Xue ", "Lan ", "Tai ", "Zao ", "Can ", "Sui ", "Xi ", "Que ", "Cong ", "Lian ", "Hui ", "Zhu ", "Xie ", "Ling ", "Wei ", "Yi ", "Xie ", "Zhao ", "Hui ", "Tatsu ", "Nung ", "Lan ", "Ru ", "Xian ", "Kao ", "Xun ", "Jin ", "Chou ", "Chou ", "Yao "];
  }
});

// node_modules/unidecode/data/x72.js
var require_x72 = __commonJS({
  "node_modules/unidecode/data/x72.js"(exports, module2) {
    module2.exports = ["He ", "Lan ", "Biao ", "Rong ", "Li ", "Mo ", "Bao ", "Ruo ", "Lu ", "La ", "Ao ", "Xun ", "Kuang ", "Shuo ", "[?] ", "Li ", "Lu ", "Jue ", "Liao ", "Yan ", "Xi ", "Xie ", "Long ", "Ye ", "[?] ", "Rang ", "Yue ", "Lan ", "Cong ", "Jue ", "Tong ", "Guan ", "[?] ", "Che ", "Mi ", "Tang ", "Lan ", "Zhu ", "[?] ", "Ling ", "Cuan ", "Yu ", "Zhua ", "Tsumekanmuri ", "Pa ", "Zheng ", "Pao ", "Cheng ", "Yuan ", "Ai ", "Wei ", "[?] ", "Jue ", "Jue ", "Fu ", "Ye ", "Ba ", "Die ", "Ye ", "Yao ", "Zu ", "Shuang ", "Er ", "Qiang ", "Chuang ", "Ge ", "Zang ", "Die ", "Qiang ", "Yong ", "Qiang ", "Pian ", "Ban ", "Pan ", "Shao ", "Jian ", "Pai ", "Du ", "Chuang ", "Tou ", "Zha ", "Bian ", "Die ", "Bang ", "Bo ", "Chuang ", "You ", "[?] ", "Du ", "Ya ", "Cheng ", "Niu ", "Ushihen ", "Pin ", "Jiu ", "Mou ", "Tuo ", "Mu ", "Lao ", "Ren ", "Mang ", "Fang ", "Mao ", "Mu ", "Gang ", "Wu ", "Yan ", "Ge ", "Bei ", "Si ", "Jian ", "Gu ", "You ", "Ge ", "Sheng ", "Mu ", "Di ", "Qian ", "Quan ", "Quan ", "Zi ", "Te ", "Xi ", "Mang ", "Keng ", "Qian ", "Wu ", "Gu ", "Xi ", "Li ", "Li ", "Pou ", "Ji ", "Gang ", "Zhi ", "Ben ", "Quan ", "Run ", "Du ", "Ju ", "Jia ", "Jian ", "Feng ", "Pian ", "Ke ", "Ju ", "Kao ", "Chu ", "Xi ", "Bei ", "Luo ", "Jie ", "Ma ", "San ", "Wei ", "Li ", "Dun ", "Tong ", "[?] ", "Jiang ", "Ikenie ", "Li ", "Du ", "Lie ", "Pi ", "Piao ", "Bao ", "Xi ", "Chou ", "Wei ", "Kui ", "Chou ", "Quan ", "Fan ", "Ba ", "Fan ", "Qiu ", "Ji ", "Cai ", "Chuo ", "An ", "Jie ", "Zhuang ", "Guang ", "Ma ", "You ", "Kang ", "Bo ", "Hou ", "Ya ", "Yin ", "Huan ", "Zhuang ", "Yun ", "Kuang ", "Niu ", "Di ", "Qing ", "Zhong ", "Mu ", "Bei ", "Pi ", "Ju ", "Ni ", "Sheng ", "Pao ", "Xia ", "Tuo ", "Hu ", "Ling ", "Fei ", "Pi ", "Ni ", "Ao ", "You ", "Gou ", "Yue ", "Ju ", "Dan ", "Po ", "Gu ", "Xian ", "Ning ", "Huan ", "Hen ", "Jiao ", "He ", "Zhao ", "Ji ", "Xun ", "Shan ", "Ta ", "Rong ", "Shou ", "Tong ", "Lao ", "Du ", "Xia ", "Shi ", "Hua ", "Zheng ", "Yu ", "Sun ", "Yu ", "Bi ", "Mang ", "Xi ", "Juan ", "Li ", "Xia ", "Yin ", "Suan ", "Lang ", "Bei ", "Zhi ", "Yan "];
  }
});

// node_modules/unidecode/data/x73.js
var require_x73 = __commonJS({
  "node_modules/unidecode/data/x73.js"(exports, module2) {
    module2.exports = ["Sha ", "Li ", "Han ", "Xian ", "Jing ", "Pai ", "Fei ", "Yao ", "Ba ", "Qi ", "Ni ", "Biao ", "Yin ", "Lai ", "Xi ", "Jian ", "Qiang ", "Kun ", "Yan ", "Guo ", "Zong ", "Mi ", "Chang ", "Yi ", "Zhi ", "Zheng ", "Ya ", "Meng ", "Cai ", "Cu ", "She ", "Kari ", "Cen ", "Luo ", "Hu ", "Zong ", "Ji ", "Wei ", "Feng ", "Wo ", "Yuan ", "Xing ", "Zhu ", "Mao ", "Wei ", "Yuan ", "Xian ", "Tuan ", "Ya ", "Nao ", "Xie ", "Jia ", "Hou ", "Bian ", "You ", "You ", "Mei ", "Zha ", "Yao ", "Sun ", "Bo ", "Ming ", "Hua ", "Yuan ", "Sou ", "Ma ", "Yuan ", "Dai ", "Yu ", "Shi ", "Hao ", "[?] ", "Yi ", "Zhen ", "Chuang ", "Hao ", "Man ", "Jing ", "Jiang ", "Mu ", "Zhang ", "Chan ", "Ao ", "Ao ", "Hao ", "Cui ", "Fen ", "Jue ", "Bi ", "Bi ", "Huang ", "Pu ", "Lin ", "Yu ", "Tong ", "Yao ", "Liao ", "Shuo ", "Xiao ", "Swu ", "Ton ", "Xi ", "Ge ", "Juan ", "Du ", "Hui ", "Kuai ", "Xian ", "Xie ", "Ta ", "Xian ", "Xun ", "Ning ", "Pin ", "Huo ", "Nou ", "Meng ", "Lie ", "Nao ", "Guang ", "Shou ", "Lu ", "Ta ", "Xian ", "Mi ", "Rang ", "Huan ", "Nao ", "Luo ", "Xian ", "Qi ", "Jue ", "Xuan ", "Miao ", "Zi ", "Lu ", "Lu ", "Yu ", "Su ", "Wang ", "Qiu ", "Ga ", "Ding ", "Le ", "Ba ", "Ji ", "Hong ", "Di ", "Quan ", "Gan ", "Jiu ", "Yu ", "Ji ", "Yu ", "Yang ", "Ma ", "Gong ", "Wu ", "Fu ", "Wen ", "Jie ", "Ya ", "Fen ", "Bian ", "Beng ", "Yue ", "Jue ", "Yun ", "Jue ", "Wan ", "Jian ", "Mei ", "Dan ", "Pi ", "Wei ", "Huan ", "Xian ", "Qiang ", "Ling ", "Dai ", "Yi ", "An ", "Ping ", "Dian ", "Fu ", "Xuan ", "Xi ", "Bo ", "Ci ", "Gou ", "Jia ", "Shao ", "Po ", "Ci ", "Ke ", "Ran ", "Sheng ", "Shen ", "Yi ", "Zu ", "Jia ", "Min ", "Shan ", "Liu ", "Bi ", "Zhen ", "Zhen ", "Jue ", "Fa ", "Long ", "Jin ", "Jiao ", "Jian ", "Li ", "Guang ", "Xian ", "Zhou ", "Gong ", "Yan ", "Xiu ", "Yang ", "Xu ", "Luo ", "Su ", "Zhu ", "Qin ", "Ken ", "Xun ", "Bao ", "Er ", "Xiang ", "Yao ", "Xia ", "Heng ", "Gui ", "Chong ", "Xu ", "Ban ", "Pei ", "[?] ", "Dang ", "Ei ", "Hun ", "Wen ", "E ", "Cheng ", "Ti ", "Wu ", "Wu ", "Cheng ", "Jun ", "Mei ", "Bei ", "Ting ", "Xian ", "Chuo "];
  }
});

// node_modules/unidecode/data/x74.js
var require_x74 = __commonJS({
  "node_modules/unidecode/data/x74.js"(exports, module2) {
    module2.exports = ["Han ", "Xuan ", "Yan ", "Qiu ", "Quan ", "Lang ", "Li ", "Xiu ", "Fu ", "Liu ", "Ye ", "Xi ", "Ling ", "Li ", "Jin ", "Lian ", "Suo ", "Chiisai ", "[?] ", "Wan ", "Dian ", "Pin ", "Zhan ", "Cui ", "Min ", "Yu ", "Ju ", "Chen ", "Lai ", "Wen ", "Sheng ", "Wei ", "Dian ", "Chu ", "Zhuo ", "Pei ", "Cheng ", "Hu ", "Qi ", "E ", "Kun ", "Chang ", "Qi ", "Beng ", "Wan ", "Lu ", "Cong ", "Guan ", "Yan ", "Diao ", "Bei ", "Lin ", "Qin ", "Pi ", "Pa ", "Que ", "Zhuo ", "Qin ", "Fa ", "[?] ", "Qiong ", "Du ", "Jie ", "Hun ", "Yu ", "Mao ", "Mei ", "Chun ", "Xuan ", "Ti ", "Xing ", "Dai ", "Rou ", "Min ", "Zhen ", "Wei ", "Ruan ", "Huan ", "Jie ", "Chuan ", "Jian ", "Zhuan ", "Yang ", "Lian ", "Quan ", "Xia ", "Duan ", "Yuan ", "Ye ", "Nao ", "Hu ", "Ying ", "Yu ", "Huang ", "Rui ", "Se ", "Liu ", "Shi ", "Rong ", "Suo ", "Yao ", "Wen ", "Wu ", "Jin ", "Jin ", "Ying ", "Ma ", "Tao ", "Liu ", "Tang ", "Li ", "Lang ", "Gui ", "Zhen ", "Qiang ", "Cuo ", "Jue ", "Zhao ", "Yao ", "Ai ", "Bin ", "Tu ", "Chang ", "Kun ", "Zhuan ", "Cong ", "Jin ", "Yi ", "Cui ", "Cong ", "Qi ", "Li ", "Ying ", "Suo ", "Qiu ", "Xuan ", "Ao ", "Lian ", "Man ", "Zhang ", "Yin ", "[?] ", "Ying ", "Zhi ", "Lu ", "Wu ", "Deng ", "Xiou ", "Zeng ", "Xun ", "Qu ", "Dang ", "Lin ", "Liao ", "Qiong ", "Su ", "Huang ", "Gui ", "Pu ", "Jing ", "Fan ", "Jin ", "Liu ", "Ji ", "[?] ", "Jing ", "Ai ", "Bi ", "Can ", "Qu ", "Zao ", "Dang ", "Jiao ", "Gun ", "Tan ", "Hui ", "Huan ", "Se ", "Sui ", "Tian ", "[?] ", "Yu ", "Jin ", "Lu ", "Bin ", "Shou ", "Wen ", "Zui ", "Lan ", "Xi ", "Ji ", "Xuan ", "Ruan ", "Huo ", "Gai ", "Lei ", "Du ", "Li ", "Zhi ", "Rou ", "Li ", "Zan ", "Qiong ", "Zhe ", "Gui ", "Sui ", "La ", "Long ", "Lu ", "Li ", "Zan ", "Lan ", "Ying ", "Mi ", "Xiang ", "Xi ", "Guan ", "Dao ", "Zan ", "Huan ", "Gua ", "Bo ", "Die ", "Bao ", "Hu ", "Zhi ", "Piao ", "Ban ", "Rang ", "Li ", "Wa ", "Dekaguramu ", "Jiang ", "Qian ", "Fan ", "Pen ", "Fang ", "Dan ", "Weng ", "Ou ", "Deshiguramu ", "Miriguramu ", "Thon ", "Hu ", "Ling ", "Yi ", "Ping ", "Ci ", "Hekutogura ", "Juan ", "Chang ", "Chi ", "Sarake ", "Dang ", "Meng ", "Pou "];
  }
});

// node_modules/unidecode/data/x75.js
var require_x75 = __commonJS({
  "node_modules/unidecode/data/x75.js"(exports, module2) {
    module2.exports = ["Zhui ", "Ping ", "Bian ", "Zhou ", "Zhen ", "Senchigura ", "Ci ", "Ying ", "Qi ", "Xian ", "Lou ", "Di ", "Ou ", "Meng ", "Zhuan ", "Peng ", "Lin ", "Zeng ", "Wu ", "Pi ", "Dan ", "Weng ", "Ying ", "Yan ", "Gan ", "Dai ", "Shen ", "Tian ", "Tian ", "Han ", "Chang ", "Sheng ", "Qing ", "Sheng ", "Chan ", "Chan ", "Rui ", "Sheng ", "Su ", "Sen ", "Yong ", "Shuai ", "Lu ", "Fu ", "Yong ", "Beng ", "Feng ", "Ning ", "Tian ", "You ", "Jia ", "Shen ", "Zha ", "Dian ", "Fu ", "Nan ", "Dian ", "Ping ", "Ting ", "Hua ", "Ting ", "Quan ", "Zi ", "Meng ", "Bi ", "Qi ", "Liu ", "Xun ", "Liu ", "Chang ", "Mu ", "Yun ", "Fan ", "Fu ", "Geng ", "Tian ", "Jie ", "Jie ", "Quan ", "Wei ", "Fu ", "Tian ", "Mu ", "Tap ", "Pan ", "Jiang ", "Wa ", "Da ", "Nan ", "Liu ", "Ben ", "Zhen ", "Chu ", "Mu ", "Mu ", "Ce ", "Cen ", "Gai ", "Bi ", "Da ", "Zhi ", "Lue ", "Qi ", "Lue ", "Pan ", "Kesa ", "Fan ", "Hua ", "Yu ", "Yu ", "Mu ", "Jun ", "Yi ", "Liu ", "Yu ", "Die ", "Chou ", "Hua ", "Dang ", "Chuo ", "Ji ", "Wan ", "Jiang ", "Sheng ", "Chang ", "Tuan ", "Lei ", "Ji ", "Cha ", "Liu ", "Tatamu ", "Tuan ", "Lin ", "Jiang ", "Jiang ", "Chou ", "Bo ", "Die ", "Die ", "Pi ", "Nie ", "Dan ", "Shu ", "Shu ", "Zhi ", "Yi ", "Chuang ", "Nai ", "Ding ", "Bi ", "Jie ", "Liao ", "Gong ", "Ge ", "Jiu ", "Zhou ", "Xia ", "Shan ", "Xu ", "Nue ", "Li ", "Yang ", "Chen ", "You ", "Ba ", "Jie ", "Jue ", "Zhi ", "Xia ", "Cui ", "Bi ", "Yi ", "Li ", "Zong ", "Chuang ", "Feng ", "Zhu ", "Pao ", "Pi ", "Gan ", "Ke ", "Ci ", "Xie ", "Qi ", "Dan ", "Zhen ", "Fa ", "Zhi ", "Teng ", "Ju ", "Ji ", "Fei ", "Qu ", "Dian ", "Jia ", "Xian ", "Cha ", "Bing ", "Ni ", "Zheng ", "Yong ", "Jing ", "Quan ", "Chong ", "Tong ", "Yi ", "Kai ", "Wei ", "Hui ", "Duo ", "Yang ", "Chi ", "Zhi ", "Hen ", "Ya ", "Mei ", "Dou ", "Jing ", "Xiao ", "Tong ", "Tu ", "Mang ", "Pi ", "Xiao ", "Suan ", "Pu ", "Li ", "Zhi ", "Cuo ", "Duo ", "Wu ", "Sha ", "Lao ", "Shou ", "Huan ", "Xian ", "Yi ", "Peng ", "Zhang ", "Guan ", "Tan ", "Fei ", "Ma ", "Lin ", "Chi ", "Ji ", "Dian ", "An ", "Chi ", "Bi ", "Bei ", "Min ", "Gu ", "Dui ", "E ", "Wei "];
  }
});

// node_modules/unidecode/data/x76.js
var require_x76 = __commonJS({
  "node_modules/unidecode/data/x76.js"(exports, module2) {
    module2.exports = ["Yu ", "Cui ", "Ya ", "Zhu ", "Cu ", "Dan ", "Shen ", "Zhung ", "Ji ", "Yu ", "Hou ", "Feng ", "La ", "Yang ", "Shen ", "Tu ", "Yu ", "Gua ", "Wen ", "Huan ", "Ku ", "Jia ", "Yin ", "Yi ", "Lu ", "Sao ", "Jue ", "Chi ", "Xi ", "Guan ", "Yi ", "Wen ", "Ji ", "Chuang ", "Ban ", "Lei ", "Liu ", "Chai ", "Shou ", "Nue ", "Dian ", "Da ", "Pie ", "Tan ", "Zhang ", "Biao ", "Shen ", "Cu ", "Luo ", "Yi ", "Zong ", "Chou ", "Zhang ", "Zhai ", "Sou ", "Suo ", "Que ", "Diao ", "Lou ", "Lu ", "Mo ", "Jin ", "Yin ", "Ying ", "Huang ", "Fu ", "Liao ", "Long ", "Qiao ", "Liu ", "Lao ", "Xian ", "Fei ", "Dan ", "Yin ", "He ", "Yan ", "Ban ", "Xian ", "Guan ", "Guai ", "Nong ", "Yu ", "Wei ", "Yi ", "Yong ", "Pi ", "Lei ", "Li ", "Shu ", "Dan ", "Lin ", "Dian ", "Lin ", "Lai ", "Pie ", "Ji ", "Chi ", "Yang ", "Xian ", "Jie ", "Zheng ", "[?] ", "Li ", "Huo ", "Lai ", "Shaku ", "Dian ", "Xian ", "Ying ", "Yin ", "Qu ", "Yong ", "Tan ", "Dian ", "Luo ", "Luan ", "Luan ", "Bo ", "[?] ", "Gui ", "Po ", "Fa ", "Deng ", "Fa ", "Bai ", "Bai ", "Qie ", "Bi ", "Zao ", "Zao ", "Mao ", "De ", "Pa ", "Jie ", "Huang ", "Gui ", "Ci ", "Ling ", "Gao ", "Mo ", "Ji ", "Jiao ", "Peng ", "Gao ", "Ai ", "E ", "Hao ", "Han ", "Bi ", "Wan ", "Chou ", "Qian ", "Xi ", "Ai ", "Jiong ", "Hao ", "Huang ", "Hao ", "Ze ", "Cui ", "Hao ", "Xiao ", "Ye ", "Po ", "Hao ", "Jiao ", "Ai ", "Xing ", "Huang ", "Li ", "Piao ", "He ", "Jiao ", "Pi ", "Gan ", "Pao ", "Zhou ", "Jun ", "Qiu ", "Cun ", "Que ", "Zha ", "Gu ", "Jun ", "Jun ", "Zhou ", "Zha ", "Gu ", "Zhan ", "Du ", "Min ", "Qi ", "Ying ", "Yu ", "Bei ", "Zhao ", "Zhong ", "Pen ", "He ", "Ying ", "He ", "Yi ", "Bo ", "Wan ", "He ", "Ang ", "Zhan ", "Yan ", "Jian ", "He ", "Yu ", "Kui ", "Fan ", "Gai ", "Dao ", "Pan ", "Fu ", "Qiu ", "Sheng ", "Dao ", "Lu ", "Zhan ", "Meng ", "Li ", "Jin ", "Xu ", "Jian ", "Pan ", "Guan ", "An ", "Lu ", "Shu ", "Zhou ", "Dang ", "An ", "Gu ", "Li ", "Mu ", "Cheng ", "Gan ", "Xu ", "Mang ", "Mang ", "Zhi ", "Qi ", "Ruan ", "Tian ", "Xiang ", "Dun ", "Xin ", "Xi ", "Pan ", "Feng ", "Dun ", "Min "];
  }
});

// node_modules/unidecode/data/x77.js
var require_x77 = __commonJS({
  "node_modules/unidecode/data/x77.js"(exports, module2) {
    module2.exports = ["Ming ", "Sheng ", "Shi ", "Yun ", "Mian ", "Pan ", "Fang ", "Miao ", "Dan ", "Mei ", "Mao ", "Kan ", "Xian ", "Ou ", "Shi ", "Yang ", "Zheng ", "Yao ", "Shen ", "Huo ", "Da ", "Zhen ", "Kuang ", "Ju ", "Shen ", "Chi ", "Sheng ", "Mei ", "Mo ", "Zhu ", "Zhen ", "Zhen ", "Mian ", "Di ", "Yuan ", "Die ", "Yi ", "Zi ", "Zi ", "Chao ", "Zha ", "Xuan ", "Bing ", "Mi ", "Long ", "Sui ", "Dong ", "Mi ", "Die ", "Yi ", "Er ", "Ming ", "Xuan ", "Chi ", "Kuang ", "Juan ", "Mou ", "Zhen ", "Tiao ", "Yang ", "Yan ", "Mo ", "Zhong ", "Mai ", "Zhao ", "Zheng ", "Mei ", "Jun ", "Shao ", "Han ", "Huan ", "Di ", "Cheng ", "Cuo ", "Juan ", "E ", "Wan ", "Xian ", "Xi ", "Kun ", "Lai ", "Jian ", "Shan ", "Tian ", "Hun ", "Wan ", "Ling ", "Shi ", "Qiong ", "Lie ", "Yai ", "Jing ", "Zheng ", "Li ", "Lai ", "Sui ", "Juan ", "Shui ", "Sui ", "Du ", "Bi ", "Bi ", "Mu ", "Hun ", "Ni ", "Lu ", "Yi ", "Jie ", "Cai ", "Zhou ", "Yu ", "Hun ", "Ma ", "Xia ", "Xing ", "Xi ", "Gun ", "Cai ", "Chun ", "Jian ", "Mei ", "Du ", "Hou ", "Xuan ", "Ti ", "Kui ", "Gao ", "Rui ", "Mou ", "Xu ", "Fa ", "Wen ", "Miao ", "Chou ", "Kui ", "Mi ", "Weng ", "Kou ", "Dang ", "Chen ", "Ke ", "Sou ", "Xia ", "Qiong ", "Mao ", "Ming ", "Man ", "Shui ", "Ze ", "Zhang ", "Yi ", "Diao ", "Ou ", "Mo ", "Shun ", "Cong ", "Lou ", "Chi ", "Man ", "Piao ", "Cheng ", "Ji ", "Meng ", "[?] ", "Run ", "Pie ", "Xi ", "Qiao ", "Pu ", "Zhu ", "Deng ", "Shen ", "Shun ", "Liao ", "Che ", "Xian ", "Kan ", "Ye ", "Xu ", "Tong ", "Mou ", "Lin ", "Kui ", "Xian ", "Ye ", "Ai ", "Hui ", "Zhan ", "Jian ", "Gu ", "Zhao ", "Qu ", "Wei ", "Chou ", "Sao ", "Ning ", "Xun ", "Yao ", "Huo ", "Meng ", "Mian ", "Bin ", "Mian ", "Li ", "Kuang ", "Jue ", "Xuan ", "Mian ", "Huo ", "Lu ", "Meng ", "Long ", "Guan ", "Man ", "Xi ", "Chu ", "Tang ", "Kan ", "Zhu ", "Mao ", "Jin ", "Lin ", "Yu ", "Shuo ", "Ce ", "Jue ", "Shi ", "Yi ", "Shen ", "Zhi ", "Hou ", "Shen ", "Ying ", "Ju ", "Zhou ", "Jiao ", "Cuo ", "Duan ", "Ai ", "Jiao ", "Zeng ", "Huo ", "Bai ", "Shi ", "Ding ", "Qi ", "Ji ", "Zi ", "Gan ", "Wu ", "Tuo ", "Ku ", "Qiang ", "Xi ", "Fan ", "Kuang "];
  }
});

// node_modules/unidecode/data/x78.js
var require_x78 = __commonJS({
  "node_modules/unidecode/data/x78.js"(exports, module2) {
    module2.exports = ["Dang ", "Ma ", "Sha ", "Dan ", "Jue ", "Li ", "Fu ", "Min ", "Nuo ", "Huo ", "Kang ", "Zhi ", "Qi ", "Kan ", "Jie ", "Fen ", "E ", "Ya ", "Pi ", "Zhe ", "Yan ", "Sui ", "Zhuan ", "Che ", "Dun ", "Pan ", "Yan ", "[?] ", "Feng ", "Fa ", "Mo ", "Zha ", "Qu ", "Yu ", "Luo ", "Tuo ", "Tuo ", "Di ", "Zhai ", "Zhen ", "Ai ", "Fei ", "Mu ", "Zhu ", "Li ", "Bian ", "Nu ", "Ping ", "Peng ", "Ling ", "Pao ", "Le ", "Po ", "Bo ", "Po ", "Shen ", "Za ", "Nuo ", "Li ", "Long ", "Tong ", "[?] ", "Li ", "Aragane ", "Chu ", "Keng ", "Quan ", "Zhu ", "Kuang ", "Huo ", "E ", "Nao ", "Jia ", "Lu ", "Wei ", "Ai ", "Luo ", "Ken ", "Xing ", "Yan ", "Tong ", "Peng ", "Xi ", "[?] ", "Hong ", "Shuo ", "Xia ", "Qiao ", "[?] ", "Wei ", "Qiao ", "[?] ", "Keng ", "Xiao ", "Que ", "Chan ", "Lang ", "Hong ", "Yu ", "Xiao ", "Xia ", "Mang ", "Long ", "Iong ", "Che ", "Che ", "E ", "Liu ", "Ying ", "Mang ", "Que ", "Yan ", "Sha ", "Kun ", "Yu ", "[?] ", "Kaki ", "Lu ", "Chen ", "Jian ", "Nue ", "Song ", "Zhuo ", "Keng ", "Peng ", "Yan ", "Zhui ", "Kong ", "Ceng ", "Qi ", "Zong ", "Qing ", "Lin ", "Jun ", "Bo ", "Ding ", "Min ", "Diao ", "Jian ", "He ", "Lu ", "Ai ", "Sui ", "Que ", "Ling ", "Bei ", "Yin ", "Dui ", "Wu ", "Qi ", "Lun ", "Wan ", "Dian ", "Gang ", "Pei ", "Qi ", "Chen ", "Ruan ", "Yan ", "Die ", "Ding ", "Du ", "Tuo ", "Jie ", "Ying ", "Bian ", "Ke ", "Bi ", "Wei ", "Shuo ", "Zhen ", "Duan ", "Xia ", "Dang ", "Ti ", "Nao ", "Peng ", "Jian ", "Di ", "Tan ", "Cha ", "Seki ", "Qi ", "[?] ", "Feng ", "Xuan ", "Que ", "Que ", "Ma ", "Gong ", "Nian ", "Su ", "E ", "Ci ", "Liu ", "Si ", "Tang ", "Bang ", "Hua ", "Pi ", "Wei ", "Sang ", "Lei ", "Cuo ", "Zhen ", "Xia ", "Qi ", "Lian ", "Pan ", "Wei ", "Yun ", "Dui ", "Zhe ", "Ke ", "La ", "[?] ", "Qing ", "Gun ", "Zhuan ", "Chan ", "Qi ", "Ao ", "Peng ", "Lu ", "Lu ", "Kan ", "Qiang ", "Chen ", "Yin ", "Lei ", "Biao ", "Qi ", "Mo ", "Qi ", "Cui ", "Zong ", "Qing ", "Chuo ", "[?] ", "Ji ", "Shan ", "Lao ", "Qu ", "Zeng ", "Deng ", "Jian ", "Xi ", "Lin ", "Ding ", "Dian ", "Huang ", "Pan ", "Za ", "Qiao ", "Di ", "Li "];
  }
});

// node_modules/unidecode/data/x79.js
var require_x79 = __commonJS({
  "node_modules/unidecode/data/x79.js"(exports, module2) {
    module2.exports = ["Tani ", "Jiao ", "[?] ", "Zhang ", "Qiao ", "Dun ", "Xian ", "Yu ", "Zhui ", "He ", "Huo ", "Zhai ", "Lei ", "Ke ", "Chu ", "Ji ", "Que ", "Dang ", "Yi ", "Jiang ", "Pi ", "Pi ", "Yu ", "Pin ", "Qi ", "Ai ", "Kai ", "Jian ", "Yu ", "Ruan ", "Meng ", "Pao ", "Ci ", "[?] ", "[?] ", "Mie ", "Ca ", "Xian ", "Kuang ", "Lei ", "Lei ", "Zhi ", "Li ", "Li ", "Fan ", "Que ", "Pao ", "Ying ", "Li ", "Long ", "Long ", "Mo ", "Bo ", "Shuang ", "Guan ", "Lan ", "Zan ", "Yan ", "Shi ", "Shi ", "Li ", "Reng ", "She ", "Yue ", "Si ", "Qi ", "Ta ", "Ma ", "Xie ", "Xian ", "Xian ", "Zhi ", "Qi ", "Zhi ", "Beng ", "Dui ", "Zhong ", "[?] ", "Yi ", "Shi ", "You ", "Zhi ", "Tiao ", "Fu ", "Fu ", "Mi ", "Zu ", "Zhi ", "Suan ", "Mei ", "Zuo ", "Qu ", "Hu ", "Zhu ", "Shen ", "Sui ", "Ci ", "Chai ", "Mi ", "Lu ", "Yu ", "Xiang ", "Wu ", "Tiao ", "Piao ", "Zhu ", "Gui ", "Xia ", "Zhi ", "Ji ", "Gao ", "Zhen ", "Gao ", "Shui ", "Jin ", "Chen ", "Gai ", "Kun ", "Di ", "Dao ", "Huo ", "Tao ", "Qi ", "Gu ", "Guan ", "Zui ", "Ling ", "Lu ", "Bing ", "Jin ", "Dao ", "Zhi ", "Lu ", "Shan ", "Bei ", "Zhe ", "Hui ", "You ", "Xi ", "Yin ", "Zi ", "Huo ", "Zhen ", "Fu ", "Yuan ", "Wu ", "Xian ", "Yang ", "Ti ", "Yi ", "Mei ", "Si ", "Di ", "[?] ", "Zhuo ", "Zhen ", "Yong ", "Ji ", "Gao ", "Tang ", "Si ", "Ma ", "Ta ", "[?] ", "Xuan ", "Qi ", "Yu ", "Xi ", "Ji ", "Si ", "Chan ", "Tan ", "Kuai ", "Sui ", "Li ", "Nong ", "Ni ", "Dao ", "Li ", "Rang ", "Yue ", "Ti ", "Zan ", "Lei ", "Rou ", "Yu ", "Yu ", "Chi ", "Xie ", "Qin ", "He ", "Tu ", "Xiu ", "Si ", "Ren ", "Tu ", "Zi ", "Cha ", "Gan ", "Yi ", "Xian ", "Bing ", "Nian ", "Qiu ", "Qiu ", "Chong ", "Fen ", "Hao ", "Yun ", "Ke ", "Miao ", "Zhi ", "Geng ", "Bi ", "Zhi ", "Yu ", "Mi ", "Ku ", "Ban ", "Pi ", "Ni ", "Li ", "You ", "Zu ", "Pi ", "Ba ", "Ling ", "Mo ", "Cheng ", "Nian ", "Qin ", "Yang ", "Zuo ", "Zhi ", "Zhi ", "Shu ", "Ju ", "Zi ", "Huo ", "Ji ", "Cheng ", "Tong ", "Zhi ", "Huo ", "He ", "Yin ", "Zi ", "Zhi ", "Jie ", "Ren ", "Du ", "Yi ", "Zhu ", "Hui ", "Nong ", "Fu "];
  }
});

// node_modules/unidecode/data/x7a.js
var require_x7a = __commonJS({
  "node_modules/unidecode/data/x7a.js"(exports, module2) {
    module2.exports = ["Xi ", "Kao ", "Lang ", "Fu ", "Ze ", "Shui ", "Lu ", "Kun ", "Gan ", "Geng ", "Ti ", "Cheng ", "Tu ", "Shao ", "Shui ", "Ya ", "Lun ", "Lu ", "Gu ", "Zuo ", "Ren ", "Zhun ", "Bang ", "Bai ", "Ji ", "Zhi ", "Zhi ", "Kun ", "Leng ", "Peng ", "Ke ", "Bing ", "Chou ", "Zu ", "Yu ", "Su ", "Lue ", "[?] ", "Yi ", "Xi ", "Bian ", "Ji ", "Fu ", "Bi ", "Nuo ", "Jie ", "Zhong ", "Zong ", "Xu ", "Cheng ", "Dao ", "Wen ", "Lian ", "Zi ", "Yu ", "Ji ", "Xu ", "Zhen ", "Zhi ", "Dao ", "Jia ", "Ji ", "Gao ", "Gao ", "Gu ", "Rong ", "Sui ", "You ", "Ji ", "Kang ", "Mu ", "Shan ", "Men ", "Zhi ", "Ji ", "Lu ", "Su ", "Ji ", "Ying ", "Wen ", "Qiu ", "Se ", "[?] ", "Yi ", "Huang ", "Qie ", "Ji ", "Sui ", "Xiao ", "Pu ", "Jiao ", "Zhuo ", "Tong ", "Sai ", "Lu ", "Sui ", "Nong ", "Se ", "Hui ", "Rang ", "Nuo ", "Yu ", "Bin ", "Ji ", "Tui ", "Wen ", "Cheng ", "Huo ", "Gong ", "Lu ", "Biao ", "[?] ", "Rang ", "Zhuo ", "Li ", "Zan ", "Xue ", "Wa ", "Jiu ", "Qiong ", "Xi ", "Qiong ", "Kong ", "Yu ", "Sen ", "Jing ", "Yao ", "Chuan ", "Zhun ", "Tu ", "Lao ", "Qie ", "Zhai ", "Yao ", "Bian ", "Bao ", "Yao ", "Bing ", "Wa ", "Zhu ", "Jiao ", "Qiao ", "Diao ", "Wu ", "Gui ", "Yao ", "Zhi ", "Chuang ", "Yao ", "Tiao ", "Jiao ", "Chuang ", "Jiong ", "Xiao ", "Cheng ", "Kou ", "Cuan ", "Wo ", "Dan ", "Ku ", "Ke ", "Zhui ", "Xu ", "Su ", "Guan ", "Kui ", "Dou ", "[?] ", "Yin ", "Wo ", "Wa ", "Ya ", "Yu ", "Ju ", "Qiong ", "Yao ", "Yao ", "Tiao ", "Chao ", "Yu ", "Tian ", "Diao ", "Ju ", "Liao ", "Xi ", "Wu ", "Kui ", "Chuang ", "Zhao ", "[?] ", "Kuan ", "Long ", "Cheng ", "Cui ", "Piao ", "Zao ", "Cuan ", "Qiao ", "Qiong ", "Dou ", "Zao ", "Long ", "Qie ", "Li ", "Chu ", "Shi ", "Fou ", "Qian ", "Chu ", "Hong ", "Qi ", "Qian ", "Gong ", "Shi ", "Shu ", "Miao ", "Ju ", "Zhan ", "Zhu ", "Ling ", "Long ", "Bing ", "Jing ", "Jing ", "Zhang ", "Yi ", "Si ", "Jun ", "Hong ", "Tong ", "Song ", "Jing ", "Diao ", "Yi ", "Shu ", "Jing ", "Qu ", "Jie ", "Ping ", "Duan ", "Shao ", "Zhuan ", "Ceng ", "Deng ", "Cui ", "Huai ", "Jing ", "Kan ", "Jing ", "Zhu ", "Zhu ", "Le ", "Peng ", "Yu ", "Chi ", "Gan "];
  }
});

// node_modules/unidecode/data/x7b.js
var require_x7b = __commonJS({
  "node_modules/unidecode/data/x7b.js"(exports, module2) {
    module2.exports = ["Mang ", "Zhu ", "Utsubo ", "Du ", "Ji ", "Xiao ", "Ba ", "Suan ", "Ji ", "Zhen ", "Zhao ", "Sun ", "Ya ", "Zhui ", "Yuan ", "Hu ", "Gang ", "Xiao ", "Cen ", "Pi ", "Bi ", "Jian ", "Yi ", "Dong ", "Shan ", "Sheng ", "Xia ", "Di ", "Zhu ", "Na ", "Chi ", "Gu ", "Li ", "Qie ", "Min ", "Bao ", "Tiao ", "Si ", "Fu ", "Ce ", "Ben ", "Pei ", "Da ", "Zi ", "Di ", "Ling ", "Ze ", "Nu ", "Fu ", "Gou ", "Fan ", "Jia ", "Ge ", "Fan ", "Shi ", "Mao ", "Po ", "Sey ", "Jian ", "Qiong ", "Long ", "Souke ", "Bian ", "Luo ", "Gui ", "Qu ", "Chi ", "Yin ", "Yao ", "Xian ", "Bi ", "Qiong ", "Gua ", "Deng ", "Jiao ", "Jin ", "Quan ", "Sun ", "Ru ", "Fa ", "Kuang ", "Zhu ", "Tong ", "Ji ", "Da ", "Xing ", "Ce ", "Zhong ", "Kou ", "Lai ", "Bi ", "Shai ", "Dang ", "Zheng ", "Ce ", "Fu ", "Yun ", "Tu ", "Pa ", "Li ", "Lang ", "Ju ", "Guan ", "Jian ", "Han ", "Tong ", "Xia ", "Zhi ", "Cheng ", "Suan ", "Shi ", "Zhu ", "Zuo ", "Xiao ", "Shao ", "Ting ", "Ce ", "Yan ", "Gao ", "Kuai ", "Gan ", "Chou ", "Kago ", "Gang ", "Yun ", "O ", "Qian ", "Xiao ", "Jian ", "Pu ", "Lai ", "Zou ", "Bi ", "Bi ", "Bi ", "Ge ", "Chi ", "Guai ", "Yu ", "Jian ", "Zhao ", "Gu ", "Chi ", "Zheng ", "Jing ", "Sha ", "Zhou ", "Lu ", "Bo ", "Ji ", "Lin ", "Suan ", "Jun ", "Fu ", "Zha ", "Gu ", "Kong ", "Qian ", "Quan ", "Jun ", "Chui ", "Guan ", "Yuan ", "Ce ", "Ju ", "Bo ", "Ze ", "Qie ", "Tuo ", "Luo ", "Dan ", "Xiao ", "Ruo ", "Jian ", "Xuan ", "Bian ", "Sun ", "Xiang ", "Xian ", "Ping ", "Zhen ", "Sheng ", "Hu ", "Shi ", "Zhu ", "Yue ", "Chun ", "Lu ", "Wu ", "Dong ", "Xiao ", "Ji ", "Jie ", "Huang ", "Xing ", "Mei ", "Fan ", "Chui ", "Zhuan ", "Pian ", "Feng ", "Zhu ", "Hong ", "Qie ", "Hou ", "Qiu ", "Miao ", "Qian ", "[?] ", "Kui ", "Sik ", "Lou ", "Yun ", "He ", "Tang ", "Yue ", "Chou ", "Gao ", "Fei ", "Ruo ", "Zheng ", "Gou ", "Nie ", "Qian ", "Xiao ", "Cuan ", "Gong ", "Pang ", "Du ", "Li ", "Bi ", "Zhuo ", "Chu ", "Shai ", "Chi ", "Zhu ", "Qiang ", "Long ", "Lan ", "Jian ", "Bu ", "Li ", "Hui ", "Bi ", "Di ", "Cong ", "Yan ", "Peng ", "Sen ", "Zhuan ", "Pai ", "Piao ", "Dou ", "Yu ", "Mie ", "Zhuan "];
  }
});

// node_modules/unidecode/data/x7c.js
var require_x7c = __commonJS({
  "node_modules/unidecode/data/x7c.js"(exports, module2) {
    module2.exports = ["Ze ", "Xi ", "Guo ", "Yi ", "Hu ", "Chan ", "Kou ", "Cu ", "Ping ", "Chou ", "Ji ", "Gui ", "Su ", "Lou ", "Zha ", "Lu ", "Nian ", "Suo ", "Cuan ", "Sasara ", "Suo ", "Le ", "Duan ", "Yana ", "Xiao ", "Bo ", "Mi ", "Si ", "Dang ", "Liao ", "Dan ", "Dian ", "Fu ", "Jian ", "Min ", "Kui ", "Dai ", "Qiao ", "Deng ", "Huang ", "Sun ", "Lao ", "Zan ", "Xiao ", "Du ", "Shi ", "Zan ", "[?] ", "Pai ", "Hata ", "Pai ", "Gan ", "Ju ", "Du ", "Lu ", "Yan ", "Bo ", "Dang ", "Sai ", "Ke ", "Long ", "Qian ", "Lian ", "Bo ", "Zhou ", "Lai ", "[?] ", "Lan ", "Kui ", "Yu ", "Yue ", "Hao ", "Zhen ", "Tai ", "Ti ", "Mi ", "Chou ", "Ji ", "[?] ", "Hata ", "Teng ", "Zhuan ", "Zhou ", "Fan ", "Sou ", "Zhou ", "Kuji ", "Zhuo ", "Teng ", "Lu ", "Lu ", "Jian ", "Tuo ", "Ying ", "Yu ", "Lai ", "Long ", "Shinshi ", "Lian ", "Lan ", "Qian ", "Yue ", "Zhong ", "Qu ", "Lian ", "Bian ", "Duan ", "Zuan ", "Li ", "Si ", "Luo ", "Ying ", "Yue ", "Zhuo ", "Xu ", "Mi ", "Di ", "Fan ", "Shen ", "Zhe ", "Shen ", "Nu ", "Xie ", "Lei ", "Xian ", "Zi ", "Ni ", "Cun ", "[?] ", "Qian ", "Kume ", "Bi ", "Ban ", "Wu ", "Sha ", "Kang ", "Rou ", "Fen ", "Bi ", "Cui ", "[?] ", "Li ", "Chi ", "Nukamiso ", "Ro ", "Ba ", "Li ", "Gan ", "Ju ", "Po ", "Mo ", "Cu ", "Nian ", "Zhou ", "Li ", "Su ", "Tiao ", "Li ", "Qi ", "Su ", "Hong ", "Tong ", "Zi ", "Ce ", "Yue ", "Zhou ", "Lin ", "Zhuang ", "Bai ", "[?] ", "Fen ", "Ji ", "[?] ", "Sukumo ", "Liang ", "Xian ", "Fu ", "Liang ", "Can ", "Geng ", "Li ", "Yue ", "Lu ", "Ju ", "Qi ", "Cui ", "Bai ", "Zhang ", "Lin ", "Zong ", "Jing ", "Guo ", "Kouji ", "San ", "San ", "Tang ", "Bian ", "Rou ", "Mian ", "Hou ", "Xu ", "Zong ", "Hu ", "Jian ", "Zan ", "Ci ", "Li ", "Xie ", "Fu ", "Ni ", "Bei ", "Gu ", "Xiu ", "Gao ", "Tang ", "Qiu ", "Sukumo ", "Cao ", "Zhuang ", "Tang ", "Mi ", "San ", "Fen ", "Zao ", "Kang ", "Jiang ", "Mo ", "San ", "San ", "Nuo ", "Xi ", "Liang ", "Jiang ", "Kuai ", "Bo ", "Huan ", "[?] ", "Zong ", "Xian ", "Nuo ", "Tuan ", "Nie ", "Li ", "Zuo ", "Di ", "Nie ", "Tiao ", "Lan ", "Mi ", "Jiao ", "Jiu ", "Xi ", "Gong ", "Zheng ", "Jiu ", "You "];
  }
});

// node_modules/unidecode/data/x7d.js
var require_x7d = __commonJS({
  "node_modules/unidecode/data/x7d.js"(exports, module2) {
    module2.exports = ["Ji ", "Cha ", "Zhou ", "Xun ", "Yue ", "Hong ", "Yu ", "He ", "Wan ", "Ren ", "Wen ", "Wen ", "Qiu ", "Na ", "Zi ", "Tou ", "Niu ", "Fou ", "Jie ", "Shu ", "Chun ", "Pi ", "Yin ", "Sha ", "Hong ", "Zhi ", "Ji ", "Fen ", "Yun ", "Ren ", "Dan ", "Jin ", "Su ", "Fang ", "Suo ", "Cui ", "Jiu ", "Zha ", "Kinu ", "Jin ", "Fu ", "Zhi ", "Ci ", "Zi ", "Chou ", "Hong ", "Zha ", "Lei ", "Xi ", "Fu ", "Xie ", "Shen ", "Bei ", "Zhu ", "Qu ", "Ling ", "Zhu ", "Shao ", "Gan ", "Yang ", "Fu ", "Tuo ", "Zhen ", "Dai ", "Zhuo ", "Shi ", "Zhong ", "Xian ", "Zu ", "Jiong ", "Ban ", "Ju ", "Mo ", "Shu ", "Zui ", "Wata ", "Jing ", "Ren ", "Heng ", "Xie ", "Jie ", "Zhu ", "Chou ", "Gua ", "Bai ", "Jue ", "Kuang ", "Hu ", "Ci ", "Geng ", "Geng ", "Tao ", "Xie ", "Ku ", "Jiao ", "Quan ", "Gai ", "Luo ", "Xuan ", "Bing ", "Xian ", "Fu ", "Gei ", "Tong ", "Rong ", "Tiao ", "Yin ", "Lei ", "Xie ", "Quan ", "Xu ", "Lun ", "Die ", "Tong ", "Si ", "Jiang ", "Xiang ", "Hui ", "Jue ", "Zhi ", "Jian ", "Juan ", "Chi ", "Mian ", "Zhen ", "Lu ", "Cheng ", "Qiu ", "Shu ", "Bang ", "Tong ", "Xiao ", "Wan ", "Qin ", "Geng ", "Xiu ", "Ti ", "Xiu ", "Xie ", "Hong ", "Xi ", "Fu ", "Ting ", "Sui ", "Dui ", "Kun ", "Fu ", "Jing ", "Hu ", "Zhi ", "Yan ", "Jiong ", "Feng ", "Ji ", "Sok ", "Kase ", "Zong ", "Lin ", "Duo ", "Li ", "Lu ", "Liang ", "Chou ", "Quan ", "Shao ", "Qi ", "Qi ", "Zhun ", "Qi ", "Wan ", "Qian ", "Xian ", "Shou ", "Wei ", "Qi ", "Tao ", "Wan ", "Gang ", "Wang ", "Beng ", "Zhui ", "Cai ", "Guo ", "Cui ", "Lun ", "Liu ", "Qi ", "Zhan ", "Bei ", "Chuo ", "Ling ", "Mian ", "Qi ", "Qie ", "Tan ", "Zong ", "Gun ", "Zou ", "Yi ", "Zi ", "Xing ", "Liang ", "Jin ", "Fei ", "Rui ", "Min ", "Yu ", "Zong ", "Fan ", "Lu ", "Xu ", "Yingl ", "Zhang ", "Kasuri ", "Xu ", "Xiang ", "Jian ", "Ke ", "Xian ", "Ruan ", "Mian ", "Qi ", "Duan ", "Zhong ", "Di ", "Min ", "Miao ", "Yuan ", "Xie ", "Bao ", "Si ", "Qiu ", "Bian ", "Huan ", "Geng ", "Cong ", "Mian ", "Wei ", "Fu ", "Wei ", "Yu ", "Gou ", "Miao ", "Xie ", "Lian ", "Zong ", "Bian ", "Yun ", "Yin ", "Ti ", "Gua ", "Zhi ", "Yun ", "Cheng ", "Chan ", "Dai "];
  }
});

// node_modules/unidecode/data/x7e.js
var require_x7e = __commonJS({
  "node_modules/unidecode/data/x7e.js"(exports, module2) {
    module2.exports = ["Xia ", "Yuan ", "Zong ", "Xu ", "Nawa ", "Odoshi ", "Geng ", "Sen ", "Ying ", "Jin ", "Yi ", "Zhui ", "Ni ", "Bang ", "Gu ", "Pan ", "Zhou ", "Jian ", "Cuo ", "Quan ", "Shuang ", "Yun ", "Xia ", "Shuai ", "Xi ", "Rong ", "Tao ", "Fu ", "Yun ", "Zhen ", "Gao ", "Ru ", "Hu ", "Zai ", "Teng ", "Xian ", "Su ", "Zhen ", "Zong ", "Tao ", "Horo ", "Cai ", "Bi ", "Feng ", "Cu ", "Li ", "Suo ", "Yin ", "Xi ", "Zong ", "Lei ", "Zhuan ", "Qian ", "Man ", "Zhi ", "Lu ", "Mo ", "Piao ", "Lian ", "Mi ", "Xuan ", "Zong ", "Ji ", "Shan ", "Sui ", "Fan ", "Shuai ", "Beng ", "Yi ", "Sao ", "Mou ", "Zhou ", "Qiang ", "Hun ", "Sem ", "Xi ", "Jung ", "Xiu ", "Ran ", "Xuan ", "Hui ", "Qiao ", "Zeng ", "Zuo ", "Zhi ", "Shan ", "San ", "Lin ", "Yu ", "Fan ", "Liao ", "Chuo ", "Zun ", "Jian ", "Rao ", "Chan ", "Rui ", "Xiu ", "Hui ", "Hua ", "Zuan ", "Xi ", "Qiang ", "Un ", "Da ", "Sheng ", "Hui ", "Xi ", "Se ", "Jian ", "Jiang ", "Huan ", "Zao ", "Cong ", "Jie ", "Jiao ", "Bo ", "Chan ", "Yi ", "Nao ", "Sui ", "Yi ", "Shai ", "Xu ", "Ji ", "Bin ", "Qian ", "Lan ", "Pu ", "Xun ", "Zuan ", "Qi ", "Peng ", "Li ", "Mo ", "Lei ", "Xie ", "Zuan ", "Kuang ", "You ", "Xu ", "Lei ", "Xian ", "Chan ", "Kou ", "Lu ", "Chan ", "Ying ", "Cai ", "Xiang ", "Xian ", "Zui ", "Zuan ", "Luo ", "Xi ", "Dao ", "Lan ", "Lei ", "Lian ", "Si ", "Jiu ", "Yu ", "Hong ", "Zhou ", "Xian ", "He ", "Yue ", "Ji ", "Wan ", "Kuang ", "Ji ", "Ren ", "Wei ", "Yun ", "Hong ", "Chun ", "Pi ", "Sha ", "Gang ", "Na ", "Ren ", "Zong ", "Lun ", "Fen ", "Zhi ", "Wen ", "Fang ", "Zhu ", "Yin ", "Niu ", "Shu ", "Xian ", "Gan ", "Xie ", "Fu ", "Lian ", "Zu ", "Shen ", "Xi ", "Zhi ", "Zhong ", "Zhou ", "Ban ", "Fu ", "Zhuo ", "Shao ", "Yi ", "Jing ", "Dai ", "Bang ", "Rong ", "Jie ", "Ku ", "Rao ", "Die ", "Heng ", "Hui ", "Gei ", "Xuan ", "Jiang ", "Luo ", "Jue ", "Jiao ", "Tong ", "Geng ", "Xiao ", "Juan ", "Xiu ", "Xi ", "Sui ", "Tao ", "Ji ", "Ti ", "Ji ", "Xu ", "Ling ", "[?] ", "Xu ", "Qi ", "Fei ", "Chuo ", "Zhang ", "Gun ", "Sheng ", "Wei ", "Mian ", "Shou ", "Beng ", "Chou ", "Tao ", "Liu ", "Quan ", "Zong ", "Zhan ", "Wan ", "Lu "];
  }
});

// node_modules/unidecode/data/x7f.js
var require_x7f = __commonJS({
  "node_modules/unidecode/data/x7f.js"(exports, module2) {
    module2.exports = ["Zhui ", "Zi ", "Ke ", "Xiang ", "Jian ", "Mian ", "Lan ", "Ti ", "Miao ", "Qi ", "Yun ", "Hui ", "Si ", "Duo ", "Duan ", "Bian ", "Xian ", "Gou ", "Zhui ", "Huan ", "Di ", "Lu ", "Bian ", "Min ", "Yuan ", "Jin ", "Fu ", "Ru ", "Zhen ", "Feng ", "Shuai ", "Gao ", "Chan ", "Li ", "Yi ", "Jian ", "Bin ", "Piao ", "Man ", "Lei ", "Ying ", "Suo ", "Mou ", "Sao ", "Xie ", "Liao ", "Shan ", "Zeng ", "Jiang ", "Qian ", "Zao ", "Huan ", "Jiao ", "Zuan ", "Fou ", "Xie ", "Gang ", "Fou ", "Que ", "Fou ", "Kaakeru ", "Bo ", "Ping ", "Hou ", "[?] ", "Gang ", "Ying ", "Ying ", "Qing ", "Xia ", "Guan ", "Zun ", "Tan ", "Chang ", "Qi ", "Weng ", "Ying ", "Lei ", "Tan ", "Lu ", "Guan ", "Wang ", "Wang ", "Gang ", "Wang ", "Han ", "[?] ", "Luo ", "Fu ", "Mi ", "Fa ", "Gu ", "Zhu ", "Ju ", "Mao ", "Gu ", "Min ", "Gang ", "Ba ", "Gua ", "Ti ", "Juan ", "Fu ", "Lin ", "Yan ", "Zhao ", "Zui ", "Gua ", "Zhuo ", "Yu ", "Zhi ", "An ", "Fa ", "Nan ", "Shu ", "Si ", "Pi ", "Ma ", "Liu ", "Ba ", "Fa ", "Li ", "Chao ", "Wei ", "Bi ", "Ji ", "Zeng ", "Tong ", "Liu ", "Ji ", "Juan ", "Mi ", "Zhao ", "Luo ", "Pi ", "Ji ", "Ji ", "Luan ", "Yang ", "Mie ", "Qiang ", "Ta ", "Mei ", "Yang ", "You ", "You ", "Fen ", "Ba ", "Gao ", "Yang ", "Gu ", "Qiang ", "Zang ", "Gao ", "Ling ", "Yi ", "Zhu ", "Di ", "Xiu ", "Qian ", "Yi ", "Xian ", "Rong ", "Qun ", "Qun ", "Qian ", "Huan ", "Zui ", "Xian ", "Yi ", "Yashinau ", "Qiang ", "Xian ", "Yu ", "Geng ", "Jie ", "Tang ", "Yuan ", "Xi ", "Fan ", "Shan ", "Fen ", "Shan ", "Lian ", "Lei ", "Geng ", "Nou ", "Qiang ", "Chan ", "Yu ", "Gong ", "Yi ", "Chong ", "Weng ", "Fen ", "Hong ", "Chi ", "Chi ", "Cui ", "Fu ", "Xia ", "Pen ", "Yi ", "La ", "Yi ", "Pi ", "Ling ", "Liu ", "Zhi ", "Qu ", "Xi ", "Xie ", "Xiang ", "Xi ", "Xi ", "Qi ", "Qiao ", "Hui ", "Hui ", "Xiao ", "Se ", "Hong ", "Jiang ", "Di ", "Cui ", "Fei ", "Tao ", "Sha ", "Chi ", "Zhu ", "Jian ", "Xuan ", "Shi ", "Pian ", "Zong ", "Wan ", "Hui ", "Hou ", "He ", "He ", "Han ", "Ao ", "Piao ", "Yi ", "Lian ", "Qu ", "[?] ", "Lin ", "Pen ", "Qiao ", "Ao ", "Fan ", "Yi ", "Hui ", "Xuan ", "Dao "];
  }
});

// node_modules/unidecode/data/x80.js
var require_x80 = __commonJS({
  "node_modules/unidecode/data/x80.js"(exports, module2) {
    module2.exports = ["Yao ", "Lao ", "[?] ", "Kao ", "Mao ", "Zhe ", "Qi ", "Gou ", "Gou ", "Gou ", "Die ", "Die ", "Er ", "Shua ", "Ruan ", "Er ", "Nai ", "Zhuan ", "Lei ", "Ting ", "Zi ", "Geng ", "Chao ", "Hao ", "Yun ", "Pa ", "Pi ", "Chi ", "Si ", "Chu ", "Jia ", "Ju ", "He ", "Chu ", "Lao ", "Lun ", "Ji ", "Tang ", "Ou ", "Lou ", "Nou ", "Gou ", "Pang ", "Ze ", "Lou ", "Ji ", "Lao ", "Huo ", "You ", "Mo ", "Huai ", "Er ", "Zhe ", "Ting ", "Ye ", "Da ", "Song ", "Qin ", "Yun ", "Chi ", "Dan ", "Dan ", "Hong ", "Geng ", "Zhi ", "[?] ", "Nie ", "Dan ", "Zhen ", "Che ", "Ling ", "Zheng ", "You ", "Wa ", "Liao ", "Long ", "Zhi ", "Ning ", "Tiao ", "Er ", "Ya ", "Die ", "Gua ", "[?] ", "Lian ", "Hao ", "Sheng ", "Lie ", "Pin ", "Jing ", "Ju ", "Bi ", "Di ", "Guo ", "Wen ", "Xu ", "Ping ", "Cong ", "Shikato ", "[?] ", "Ting ", "Yu ", "Cong ", "Kui ", "Tsuraneru ", "Kui ", "Cong ", "Lian ", "Weng ", "Kui ", "Lian ", "Lian ", "Cong ", "Ao ", "Sheng ", "Song ", "Ting ", "Kui ", "Nie ", "Zhi ", "Dan ", "Ning ", "Qie ", "Ji ", "Ting ", "Ting ", "Long ", "Yu ", "Yu ", "Zhao ", "Si ", "Su ", "Yi ", "Su ", "Si ", "Zhao ", "Zhao ", "Rou ", "Yi ", "Le ", "Ji ", "Qiu ", "Ken ", "Cao ", "Ge ", "Di ", "Huan ", "Huang ", "Yi ", "Ren ", "Xiao ", "Ru ", "Zhou ", "Yuan ", "Du ", "Gang ", "Rong ", "Gan ", "Cha ", "Wo ", "Chang ", "Gu ", "Zhi ", "Han ", "Fu ", "Fei ", "Fen ", "Pei ", "Pang ", "Jian ", "Fang ", "Zhun ", "You ", "Na ", "Hang ", "Ken ", "Ran ", "Gong ", "Yu ", "Wen ", "Yao ", "Jin ", "Pi ", "Qian ", "Xi ", "Xi ", "Fei ", "Ken ", "Jing ", "Tai ", "Shen ", "Zhong ", "Zhang ", "Xie ", "Shen ", "Wei ", "Zhou ", "Die ", "Dan ", "Fei ", "Ba ", "Bo ", "Qu ", "Tian ", "Bei ", "Gua ", "Tai ", "Zi ", "Ku ", "Zhi ", "Ni ", "Ping ", "Zi ", "Fu ", "Pang ", "Zhen ", "Xian ", "Zuo ", "Pei ", "Jia ", "Sheng ", "Zhi ", "Bao ", "Mu ", "Qu ", "Hu ", "Ke ", "Yi ", "Yin ", "Xu ", "Yang ", "Long ", "Dong ", "Ka ", "Lu ", "Jing ", "Nu ", "Yan ", "Pang ", "Kua ", "Yi ", "Guang ", "Gai ", "Ge ", "Dong ", "Zhi ", "Xiao ", "Xiong ", "Xiong ", "Er ", "E ", "Xing ", "Pian ", "Neng ", "Zi ", "Gui "];
  }
});

// node_modules/unidecode/data/x81.js
var require_x81 = __commonJS({
  "node_modules/unidecode/data/x81.js"(exports, module2) {
    module2.exports = ["Cheng ", "Tiao ", "Zhi ", "Cui ", "Mei ", "Xie ", "Cui ", "Xie ", "Mo ", "Mai ", "Ji ", "Obiyaakasu ", "[?] ", "Kuai ", "Sa ", "Zang ", "Qi ", "Nao ", "Mi ", "Nong ", "Luan ", "Wan ", "Bo ", "Wen ", "Guan ", "Qiu ", "Jiao ", "Jing ", "Rou ", "Heng ", "Cuo ", "Lie ", "Shan ", "Ting ", "Mei ", "Chun ", "Shen ", "Xie ", "De ", "Zui ", "Cu ", "Xiu ", "Xin ", "Tuo ", "Pao ", "Cheng ", "Nei ", "Fu ", "Dou ", "Tuo ", "Niao ", "Noy ", "Pi ", "Gu ", "Gua ", "Li ", "Lian ", "Zhang ", "Cui ", "Jie ", "Liang ", "Zhou ", "Pi ", "Biao ", "Lun ", "Pian ", "Guo ", "Kui ", "Chui ", "Dan ", "Tian ", "Nei ", "Jing ", "Jie ", "La ", "Yi ", "An ", "Ren ", "Shen ", "Chuo ", "Fu ", "Fu ", "Ju ", "Fei ", "Qiang ", "Wan ", "Dong ", "Pi ", "Guo ", "Zong ", "Ding ", "Wu ", "Mei ", "Ruan ", "Zhuan ", "Zhi ", "Cou ", "Gua ", "Ou ", "Di ", "An ", "Xing ", "Nao ", "Yu ", "Chuan ", "Nan ", "Yun ", "Zhong ", "Rou ", "E ", "Sai ", "Tu ", "Yao ", "Jian ", "Wei ", "Jiao ", "Yu ", "Jia ", "Duan ", "Bi ", "Chang ", "Fu ", "Xian ", "Ni ", "Mian ", "Wa ", "Teng ", "Tui ", "Bang ", "Qian ", "Lu ", "Wa ", "Sou ", "Tang ", "Su ", "Zhui ", "Ge ", "Yi ", "Bo ", "Liao ", "Ji ", "Pi ", "Xie ", "Gao ", "Lu ", "Bin ", "Ou ", "Chang ", "Lu ", "Guo ", "Pang ", "Chuai ", "Piao ", "Jiang ", "Fu ", "Tang ", "Mo ", "Xi ", "Zhuan ", "Lu ", "Jiao ", "Ying ", "Lu ", "Zhi ", "Tara ", "Chun ", "Lian ", "Tong ", "Peng ", "Ni ", "Zha ", "Liao ", "Cui ", "Gui ", "Xiao ", "Teng ", "Fan ", "Zhi ", "Jiao ", "Shan ", "Wu ", "Cui ", "Run ", "Xiang ", "Sui ", "Fen ", "Ying ", "Tan ", "Zhua ", "Dan ", "Kuai ", "Nong ", "Tun ", "Lian ", "Bi ", "Yong ", "Jue ", "Chu ", "Yi ", "Juan ", "La ", "Lian ", "Sao ", "Tun ", "Gu ", "Qi ", "Cui ", "Bin ", "Xun ", "Ru ", "Huo ", "Zang ", "Xian ", "Biao ", "Xing ", "Kuan ", "La ", "Yan ", "Lu ", "Huo ", "Zang ", "Luo ", "Qu ", "Zang ", "Luan ", "Ni ", "Zang ", "Chen ", "Qian ", "Wo ", "Guang ", "Zang ", "Lin ", "Guang ", "Zi ", "Jiao ", "Nie ", "Chou ", "Ji ", "Gao ", "Chou ", "Mian ", "Nie ", "Zhi ", "Zhi ", "Ge ", "Jian ", "Die ", "Zhi ", "Xiu ", "Tai ", "Zhen ", "Jiu ", "Xian ", "Yu ", "Cha "];
  }
});

// node_modules/unidecode/data/x82.js
var require_x82 = __commonJS({
  "node_modules/unidecode/data/x82.js"(exports, module2) {
    module2.exports = ["Yao ", "Yu ", "Chong ", "Xi ", "Xi ", "Jiu ", "Yu ", "Yu ", "Xing ", "Ju ", "Jiu ", "Xin ", "She ", "She ", "Yadoru ", "Jiu ", "Shi ", "Tan ", "Shu ", "Shi ", "Tian ", "Dan ", "Pu ", "Pu ", "Guan ", "Hua ", "Tan ", "Chuan ", "Shun ", "Xia ", "Wu ", "Zhou ", "Dao ", "Gang ", "Shan ", "Yi ", "[?] ", "Pa ", "Tai ", "Fan ", "Ban ", "Chuan ", "Hang ", "Fang ", "Ban ", "Que ", "Hesaki ", "Zhong ", "Jian ", "Cang ", "Ling ", "Zhu ", "Ze ", "Duo ", "Bo ", "Xian ", "Ge ", "Chuan ", "Jia ", "Lu ", "Hong ", "Pang ", "Xi ", "[?] ", "Fu ", "Zao ", "Feng ", "Li ", "Shao ", "Yu ", "Lang ", "Ting ", "[?] ", "Wei ", "Bo ", "Meng ", "Nian ", "Ju ", "Huang ", "Shou ", "Zong ", "Bian ", "Mao ", "Die ", "[?] ", "Bang ", "Cha ", "Yi ", "Sao ", "Cang ", "Cao ", "Lou ", "Dai ", "Sori ", "Yao ", "Tong ", "Yofune ", "Dang ", "Tan ", "Lu ", "Yi ", "Jie ", "Jian ", "Huo ", "Meng ", "Qi ", "Lu ", "Lu ", "Chan ", "Shuang ", "Gen ", "Liang ", "Jian ", "Jian ", "Se ", "Yan ", "Fu ", "Ping ", "Yan ", "Yan ", "Cao ", "Cao ", "Yi ", "Le ", "Ting ", "Qiu ", "Ai ", "Nai ", "Tiao ", "Jiao ", "Jie ", "Peng ", "Wan ", "Yi ", "Chai ", "Mian ", "Mie ", "Gan ", "Qian ", "Yu ", "Yu ", "Shuo ", "Qiong ", "Tu ", "Xia ", "Qi ", "Mang ", "Zi ", "Hui ", "Sui ", "Zhi ", "Xiang ", "Bi ", "Fu ", "Tun ", "Wei ", "Wu ", "Zhi ", "Qi ", "Shan ", "Wen ", "Qian ", "Ren ", "Fou ", "Kou ", "Jie ", "Lu ", "Xu ", "Ji ", "Qin ", "Qi ", "Yuan ", "Fen ", "Ba ", "Rui ", "Xin ", "Ji ", "Hua ", "Hua ", "Fang ", "Wu ", "Jue ", "Gou ", "Zhi ", "Yun ", "Qin ", "Ao ", "Chu ", "Mao ", "Ya ", "Fei ", "Reng ", "Hang ", "Cong ", "Yin ", "You ", "Bian ", "Yi ", "Susa ", "Wei ", "Li ", "Pi ", "E ", "Xian ", "Chang ", "Cang ", "Meng ", "Su ", "Yi ", "Yuan ", "Ran ", "Ling ", "Tai ", "Tiao ", "Di ", "Miao ", "Qiong ", "Li ", "Yong ", "Ke ", "Mu ", "Pei ", "Bao ", "Gou ", "Min ", "Yi ", "Yi ", "Ju ", "Pi ", "Ruo ", "Ku ", "Zhu ", "Ni ", "Bo ", "Bing ", "Shan ", "Qiu ", "Yao ", "Xian ", "Ben ", "Hong ", "Ying ", "Zha ", "Dong ", "Ju ", "Die ", "Nie ", "Gan ", "Hu ", "Ping ", "Mei ", "Fu ", "Sheng ", "Gu ", "Bi ", "Wei "];
  }
});

// node_modules/unidecode/data/x83.js
var require_x83 = __commonJS({
  "node_modules/unidecode/data/x83.js"(exports, module2) {
    module2.exports = ["Fu ", "Zhuo ", "Mao ", "Fan ", "Qie ", "Mao ", "Mao ", "Ba ", "Zi ", "Mo ", "Zi ", "Di ", "Chi ", "Ji ", "Jing ", "Long ", "[?] ", "Niao ", "[?] ", "Xue ", "Ying ", "Qiong ", "Ge ", "Ming ", "Li ", "Rong ", "Yin ", "Gen ", "Qian ", "Chai ", "Chen ", "Yu ", "Xiu ", "Zi ", "Lie ", "Wu ", "Ji ", "Kui ", "Ce ", "Chong ", "Ci ", "Gou ", "Guang ", "Mang ", "Chi ", "Jiao ", "Jiao ", "Fu ", "Yu ", "Zhu ", "Zi ", "Jiang ", "Hui ", "Yin ", "Cha ", "Fa ", "Rong ", "Ru ", "Chong ", "Mang ", "Tong ", "Zhong ", "[?] ", "Zhu ", "Xun ", "Huan ", "Kua ", "Quan ", "Gai ", "Da ", "Jing ", "Xing ", "Quan ", "Cao ", "Jing ", "Er ", "An ", "Shou ", "Chi ", "Ren ", "Jian ", "Ti ", "Huang ", "Ping ", "Li ", "Jin ", "Lao ", "Shu ", "Zhuang ", "Da ", "Jia ", "Rao ", "Bi ", "Ze ", "Qiao ", "Hui ", "Qi ", "Dang ", "[?] ", "Rong ", "Hun ", "Ying ", "Luo ", "Ying ", "Xun ", "Jin ", "Sun ", "Yin ", "Mai ", "Hong ", "Zhou ", "Yao ", "Du ", "Wei ", "Chu ", "Dou ", "Fu ", "Ren ", "Yin ", "He ", "Bi ", "Bu ", "Yun ", "Di ", "Tu ", "Sui ", "Sui ", "Cheng ", "Chen ", "Wu ", "Bie ", "Xi ", "Geng ", "Li ", "Fu ", "Zhu ", "Mo ", "Li ", "Zhuang ", "Ji ", "Duo ", "Qiu ", "Sha ", "Suo ", "Chen ", "Feng ", "Ju ", "Mei ", "Meng ", "Xing ", "Jing ", "Che ", "Xin ", "Jun ", "Yan ", "Ting ", "Diao ", "Cuo ", "Wan ", "Han ", "You ", "Cuo ", "Jia ", "Wang ", "You ", "Niu ", "Shao ", "Xian ", "Lang ", "Fu ", "E ", "Mo ", "Wen ", "Jie ", "Nan ", "Mu ", "Kan ", "Lai ", "Lian ", "Shi ", "Wo ", "Usagi ", "Lian ", "Huo ", "You ", "Ying ", "Ying ", "Nuc ", "Chun ", "Mang ", "Mang ", "Ci ", "Wan ", "Jing ", "Di ", "Qu ", "Dong ", "Jian ", "Zou ", "Gu ", "La ", "Lu ", "Ju ", "Wei ", "Jun ", "Nie ", "Kun ", "He ", "Pu ", "Zi ", "Gao ", "Guo ", "Fu ", "Lun ", "Chang ", "Chou ", "Song ", "Chui ", "Zhan ", "Men ", "Cai ", "Ba ", "Li ", "Tu ", "Bo ", "Han ", "Bao ", "Qin ", "Juan ", "Xi ", "Qin ", "Di ", "Jie ", "Pu ", "Dang ", "Jin ", "Zhao ", "Tai ", "Geng ", "Hua ", "Gu ", "Ling ", "Fei ", "Jin ", "An ", "Wang ", "Beng ", "Zhou ", "Yan ", "Ju ", "Jian ", "Lin ", "Tan ", "Shu ", "Tian ", "Dao "];
  }
});

// node_modules/unidecode/data/x84.js
var require_x84 = __commonJS({
  "node_modules/unidecode/data/x84.js"(exports, module2) {
    module2.exports = ["Hu ", "Qi ", "He ", "Cui ", "Tao ", "Chun ", "Bei ", "Chang ", "Huan ", "Fei ", "Lai ", "Qi ", "Meng ", "Ping ", "Wei ", "Dan ", "Sha ", "Huan ", "Yan ", "Yi ", "Tiao ", "Qi ", "Wan ", "Ce ", "Nai ", "Kutabireru ", "Tuo ", "Jiu ", "Tie ", "Luo ", "[?] ", "[?] ", "Meng ", "[?] ", "Yaji ", "[?] ", "Ying ", "Ying ", "Ying ", "Xiao ", "Sa ", "Qiu ", "Ke ", "Xiang ", "Wan ", "Yu ", "Yu ", "Fu ", "Lian ", "Xuan ", "Yuan ", "Nan ", "Ze ", "Wo ", "Chun ", "Xiao ", "Yu ", "Pian ", "Mao ", "An ", "E ", "Luo ", "Ying ", "Huo ", "Gua ", "Jiang ", "Mian ", "Zuo ", "Zuo ", "Ju ", "Bao ", "Rou ", "Xi ", "Xie ", "An ", "Qu ", "Jian ", "Fu ", "Lu ", "Jing ", "Pen ", "Feng ", "Hong ", "Hong ", "Hou ", "Yan ", "Tu ", "Zhu ", "Zi ", "Xiang ", "Shen ", "Ge ", "Jie ", "Jing ", "Mi ", "Huang ", "Shen ", "Pu ", "Gai ", "Dong ", "Zhou ", "Qian ", "Wei ", "Bo ", "Wei ", "Pa ", "Ji ", "Hu ", "Zang ", "Jia ", "Duan ", "Yao ", "Jun ", "Cong ", "Quan ", "Wei ", "Xian ", "Kui ", "Ting ", "Hun ", "Xi ", "Shi ", "Qi ", "Lan ", "Zong ", "Yao ", "Yuan ", "Mei ", "Yun ", "Shu ", "Di ", "Zhuan ", "Guan ", "Sukumo ", "Xue ", "Chan ", "Kai ", "Kui ", "[?] ", "Jiang ", "Lou ", "Wei ", "Pai ", "[?] ", "Sou ", "Yin ", "Shi ", "Chun ", "Shi ", "Yun ", "Zhen ", "Lang ", "Nu ", "Meng ", "He ", "Que ", "Suan ", "Yuan ", "Li ", "Ju ", "Xi ", "Pang ", "Chu ", "Xu ", "Tu ", "Liu ", "Wo ", "Zhen ", "Qian ", "Zu ", "Po ", "Cuo ", "Yuan ", "Chu ", "Yu ", "Kuai ", "Pan ", "Pu ", "Pu ", "Na ", "Shuo ", "Xi ", "Fen ", "Yun ", "Zheng ", "Jian ", "Ji ", "Ruo ", "Cang ", "En ", "Mi ", "Hao ", "Sun ", "Zhen ", "Ming ", "Sou ", "Xu ", "Liu ", "Xi ", "Gu ", "Lang ", "Rong ", "Weng ", "Gai ", "Cuo ", "Shi ", "Tang ", "Luo ", "Ru ", "Suo ", "Xian ", "Bei ", "Yao ", "Gui ", "Bi ", "Zong ", "Gun ", "Za ", "Xiu ", "Ce ", "Hai ", "Lan ", "[?] ", "Ji ", "Li ", "Can ", "Lang ", "Yu ", "[?] ", "Ying ", "Mo ", "Diao ", "Tiao ", "Mao ", "Tong ", "Zhu ", "Peng ", "An ", "Lian ", "Cong ", "Xi ", "Ping ", "Qiu ", "Jin ", "Chun ", "Jie ", "Wei ", "Tui ", "Cao ", "Yu ", "Yi ", "Ji ", "Liao ", "Bi ", "Lu ", "Su "];
  }
});

// node_modules/unidecode/data/x85.js
var require_x85 = __commonJS({
  "node_modules/unidecode/data/x85.js"(exports, module2) {
    module2.exports = ["Bu ", "Zhang ", "Luo ", "Jiang ", "Man ", "Yan ", "Ling ", "Ji ", "Piao ", "Gun ", "Han ", "Di ", "Su ", "Lu ", "She ", "Shang ", "Di ", "Mie ", "Xun ", "Man ", "Bo ", "Di ", "Cuo ", "Zhe ", "Sen ", "Xuan ", "Wei ", "Hu ", "Ao ", "Mi ", "Lou ", "Cu ", "Zhong ", "Cai ", "Po ", "Jiang ", "Mi ", "Cong ", "Niao ", "Hui ", "Jun ", "Yin ", "Jian ", "Yan ", "Shu ", "Yin ", "Kui ", "Chen ", "Hu ", "Sha ", "Kou ", "Qian ", "Ma ", "Zang ", "Sonoko ", "Qiang ", "Dou ", "Lian ", "Lin ", "Kou ", "Ai ", "Bi ", "Li ", "Wei ", "Ji ", "Xun ", "Sheng ", "Fan ", "Meng ", "Ou ", "Chan ", "Dian ", "Xun ", "Jiao ", "Rui ", "Rui ", "Lei ", "Yu ", "Qiao ", "Chu ", "Hua ", "Jian ", "Mai ", "Yun ", "Bao ", "You ", "Qu ", "Lu ", "Rao ", "Hui ", "E ", "Teng ", "Fei ", "Jue ", "Zui ", "Fa ", "Ru ", "Fen ", "Kui ", "Shun ", "Rui ", "Ya ", "Xu ", "Fu ", "Jue ", "Dang ", "Wu ", "Tong ", "Si ", "Xiao ", "Xi ", "Long ", "Yun ", "[?] ", "Qi ", "Jian ", "Yun ", "Sun ", "Ling ", "Yu ", "Xia ", "Yong ", "Ji ", "Hong ", "Si ", "Nong ", "Lei ", "Xuan ", "Yun ", "Yu ", "Xi ", "Hao ", "Bo ", "Hao ", "Ai ", "Wei ", "Hui ", "Wei ", "Ji ", "Ci ", "Xiang ", "Luan ", "Mie ", "Yi ", "Leng ", "Jiang ", "Can ", "Shen ", "Qiang ", "Lian ", "Ke ", "Yuan ", "Da ", "Ti ", "Tang ", "Xie ", "Bi ", "Zhan ", "Sun ", "Lian ", "Fan ", "Ding ", "Jie ", "Gu ", "Xie ", "Shu ", "Jian ", "Kao ", "Hong ", "Sa ", "Xin ", "Xun ", "Yao ", "Hie ", "Sou ", "Shu ", "Xun ", "Dui ", "Pin ", "Wei ", "Neng ", "Chou ", "Mai ", "Ru ", "Piao ", "Tai ", "Qi ", "Zao ", "Chen ", "Zhen ", "Er ", "Ni ", "Ying ", "Gao ", "Cong ", "Xiao ", "Qi ", "Fa ", "Jian ", "Xu ", "Kui ", "Jie ", "Bian ", "Diao ", "Mi ", "Lan ", "Jin ", "Cang ", "Miao ", "Qiong ", "Qie ", "Xian ", "[?] ", "Ou ", "Xian ", "Su ", "Lu ", "Yi ", "Xu ", "Xie ", "Li ", "Yi ", "La ", "Lei ", "Xiao ", "Di ", "Zhi ", "Bei ", "Teng ", "Yao ", "Mo ", "Huan ", "Piao ", "Fan ", "Sou ", "Tan ", "Tui ", "Qiong ", "Qiao ", "Wei ", "Liu ", "Hui ", "[?] ", "Gao ", "Yun ", "[?] ", "Li ", "Shu ", "Chu ", "Ai ", "Lin ", "Zao ", "Xuan ", "Chen ", "Lai ", "Huo "];
  }
});

// node_modules/unidecode/data/x86.js
var require_x86 = __commonJS({
  "node_modules/unidecode/data/x86.js"(exports, module2) {
    module2.exports = ["Tuo ", "Wu ", "Rui ", "Rui ", "Qi ", "Heng ", "Lu ", "Su ", "Tui ", "Mang ", "Yun ", "Pin ", "Yu ", "Xun ", "Ji ", "Jiong ", "Xian ", "Mo ", "Hagi ", "Su ", "Jiong ", "[?] ", "Nie ", "Bo ", "Rang ", "Yi ", "Xian ", "Yu ", "Ju ", "Lian ", "Lian ", "Yin ", "Qiang ", "Ying ", "Long ", "Tong ", "Wei ", "Yue ", "Ling ", "Qu ", "Yao ", "Fan ", "Mi ", "Lan ", "Kui ", "Lan ", "Ji ", "Dang ", "Katsura ", "Lei ", "Lei ", "Hua ", "Feng ", "Zhi ", "Wei ", "Kui ", "Zhan ", "Huai ", "Li ", "Ji ", "Mi ", "Lei ", "Huai ", "Luo ", "Ji ", "Kui ", "Lu ", "Jian ", "San ", "[?] ", "Lei ", "Quan ", "Xiao ", "Yi ", "Luan ", "Men ", "Bie ", "Hu ", "Hu ", "Lu ", "Nue ", "Lu ", "Si ", "Xiao ", "Qian ", "Chu ", "Hu ", "Xu ", "Cuo ", "Fu ", "Xu ", "Xu ", "Lu ", "Hu ", "Yu ", "Hao ", "Jiao ", "Ju ", "Guo ", "Bao ", "Yan ", "Zhan ", "Zhan ", "Kui ", "Ban ", "Xi ", "Shu ", "Chong ", "Qiu ", "Diao ", "Ji ", "Qiu ", "Cheng ", "Shi ", "[?] ", "Di ", "Zhe ", "She ", "Yu ", "Gan ", "Zi ", "Hong ", "Hui ", "Meng ", "Ge ", "Sui ", "Xia ", "Chai ", "Shi ", "Yi ", "Ma ", "Xiang ", "Fang ", "E ", "Pa ", "Chi ", "Qian ", "Wen ", "Wen ", "Rui ", "Bang ", "Bi ", "Yue ", "Yue ", "Jun ", "Qi ", "Ran ", "Yin ", "Qi ", "Tian ", "Yuan ", "Jue ", "Hui ", "Qin ", "Qi ", "Zhong ", "Ya ", "Ci ", "Mu ", "Wang ", "Fen ", "Fen ", "Hang ", "Gong ", "Zao ", "Fu ", "Ran ", "Jie ", "Fu ", "Chi ", "Dou ", "Piao ", "Xian ", "Ni ", "Te ", "Qiu ", "You ", "Zha ", "Ping ", "Chi ", "You ", "He ", "Han ", "Ju ", "Li ", "Fu ", "Ran ", "Zha ", "Gou ", "Pi ", "Bo ", "Xian ", "Zhu ", "Diao ", "Bie ", "Bing ", "Gu ", "Ran ", "Qu ", "She ", "Tie ", "Ling ", "Gu ", "Dan ", "Gu ", "Ying ", "Li ", "Cheng ", "Qu ", "Mou ", "Ge ", "Ci ", "Hui ", "Hui ", "Mang ", "Fu ", "Yang ", "Wa ", "Lie ", "Zhu ", "Yi ", "Xian ", "Kuo ", "Jiao ", "Li ", "Yi ", "Ping ", "Ji ", "Ha ", "She ", "Yi ", "Wang ", "Mo ", "Qiong ", "Qie ", "Gui ", "Gong ", "Zhi ", "Man ", "Ebi ", "Zhi ", "Jia ", "Rao ", "Si ", "Qi ", "Xing ", "Lie ", "Qiu ", "Shao ", "Yong ", "Jia ", "Shui ", "Che ", "Bai ", "E ", "Han "];
  }
});

// node_modules/unidecode/data/x87.js
var require_x87 = __commonJS({
  "node_modules/unidecode/data/x87.js"(exports, module2) {
    module2.exports = ["Shu ", "Xuan ", "Feng ", "Shen ", "Zhen ", "Fu ", "Xian ", "Zhe ", "Wu ", "Fu ", "Li ", "Lang ", "Bi ", "Chu ", "Yuan ", "You ", "Jie ", "Dan ", "Yan ", "Ting ", "Dian ", "Shui ", "Hui ", "Gua ", "Zhi ", "Song ", "Fei ", "Ju ", "Mi ", "Qi ", "Qi ", "Yu ", "Jun ", "Zha ", "Meng ", "Qiang ", "Si ", "Xi ", "Lun ", "Li ", "Die ", "Tiao ", "Tao ", "Kun ", "Gan ", "Han ", "Yu ", "Bang ", "Fei ", "Pi ", "Wei ", "Dun ", "Yi ", "Yuan ", "Su ", "Quan ", "Qian ", "Rui ", "Ni ", "Qing ", "Wei ", "Liang ", "Guo ", "Wan ", "Dong ", "E ", "Ban ", "Di ", "Wang ", "Can ", "Yang ", "Ying ", "Guo ", "Chan ", "[?] ", "La ", "Ke ", "Ji ", "He ", "Ting ", "Mai ", "Xu ", "Mian ", "Yu ", "Jie ", "Shi ", "Xuan ", "Huang ", "Yan ", "Bian ", "Rou ", "Wei ", "Fu ", "Yuan ", "Mei ", "Wei ", "Fu ", "Ruan ", "Xie ", "You ", "Qiu ", "Mao ", "Xia ", "Ying ", "Shi ", "Chong ", "Tang ", "Zhu ", "Zong ", "Ti ", "Fu ", "Yuan ", "Hui ", "Meng ", "La ", "Du ", "Hu ", "Qiu ", "Die ", "Li ", "Gua ", "Yun ", "Ju ", "Nan ", "Lou ", "Qun ", "Rong ", "Ying ", "Jiang ", "[?] ", "Lang ", "Pang ", "Si ", "Xi ", "Ci ", "Xi ", "Yuan ", "Weng ", "Lian ", "Sou ", "Ban ", "Rong ", "Rong ", "Ji ", "Wu ", "Qiu ", "Han ", "Qin ", "Yi ", "Bi ", "Hua ", "Tang ", "Yi ", "Du ", "Nai ", "He ", "Hu ", "Hui ", "Ma ", "Ming ", "Yi ", "Wen ", "Ying ", "Teng ", "Yu ", "Cang ", "So ", "Ebi ", "Man ", "[?] ", "Shang ", "Zhe ", "Cao ", "Chi ", "Di ", "Ao ", "Lu ", "Wei ", "Zhi ", "Tang ", "Chen ", "Piao ", "Qu ", "Pi ", "Yu ", "Jian ", "Luo ", "Lou ", "Qin ", "Zhong ", "Yin ", "Jiang ", "Shuai ", "Wen ", "Jiao ", "Wan ", "Zhi ", "Zhe ", "Ma ", "Ma ", "Guo ", "Liu ", "Mao ", "Xi ", "Cong ", "Li ", "Man ", "Xiao ", "Kamakiri ", "Zhang ", "Mang ", "Xiang ", "Mo ", "Zui ", "Si ", "Qiu ", "Te ", "Zhi ", "Peng ", "Peng ", "Jiao ", "Qu ", "Bie ", "Liao ", "Pan ", "Gui ", "Xi ", "Ji ", "Zhuan ", "Huang ", "Fei ", "Lao ", "Jue ", "Jue ", "Hui ", "Yin ", "Chan ", "Jiao ", "Shan ", "Rao ", "Xiao ", "Mou ", "Chong ", "Xun ", "Si ", "[?] ", "Cheng ", "Dang ", "Li ", "Xie ", "Shan ", "Yi ", "Jing ", "Da ", "Chan ", "Qi "];
  }
});

// node_modules/unidecode/data/x88.js
var require_x88 = __commonJS({
  "node_modules/unidecode/data/x88.js"(exports, module2) {
    module2.exports = ["Ci ", "Xiang ", "She ", "Luo ", "Qin ", "Ying ", "Chai ", "Li ", "Ze ", "Xuan ", "Lian ", "Zhu ", "Ze ", "Xie ", "Mang ", "Xie ", "Qi ", "Rong ", "Jian ", "Meng ", "Hao ", "Ruan ", "Huo ", "Zhuo ", "Jie ", "Bin ", "He ", "Mie ", "Fan ", "Lei ", "Jie ", "La ", "Mi ", "Li ", "Chun ", "Li ", "Qiu ", "Nie ", "Lu ", "Du ", "Xiao ", "Zhu ", "Long ", "Li ", "Long ", "Feng ", "Ye ", "Beng ", "Shang ", "Gu ", "Juan ", "Ying ", "[?] ", "Xi ", "Can ", "Qu ", "Quan ", "Du ", "Can ", "Man ", "Jue ", "Jie ", "Zhu ", "Zha ", "Xie ", "Huang ", "Niu ", "Pei ", "Nu ", "Xin ", "Zhong ", "Mo ", "Er ", "Ke ", "Mie ", "Xi ", "Xing ", "Yan ", "Kan ", "Yuan ", "[?] ", "Ling ", "Xuan ", "Shu ", "Xian ", "Tong ", "Long ", "Jie ", "Xian ", "Ya ", "Hu ", "Wei ", "Dao ", "Chong ", "Wei ", "Dao ", "Zhun ", "Heng ", "Qu ", "Yi ", "Yi ", "Bu ", "Gan ", "Yu ", "Biao ", "Cha ", "Yi ", "Shan ", "Chen ", "Fu ", "Gun ", "Fen ", "Shuai ", "Jie ", "Na ", "Zhong ", "Dan ", "Ri ", "Zhong ", "Zhong ", "Xie ", "Qi ", "Xie ", "Ran ", "Zhi ", "Ren ", "Qin ", "Jin ", "Jun ", "Yuan ", "Mei ", "Chai ", "Ao ", "Niao ", "Hui ", "Ran ", "Jia ", "Tuo ", "Ling ", "Dai ", "Bao ", "Pao ", "Yao ", "Zuo ", "Bi ", "Shao ", "Tan ", "Ju ", "He ", "Shu ", "Xiu ", "Zhen ", "Yi ", "Pa ", "Bo ", "Di ", "Wa ", "Fu ", "Gun ", "Zhi ", "Zhi ", "Ran ", "Pan ", "Yi ", "Mao ", "Tuo ", "Na ", "Kou ", "Xian ", "Chan ", "Qu ", "Bei ", "Gun ", "Xi ", "Ne ", "Bo ", "Horo ", "Fu ", "Yi ", "Chi ", "Ku ", "Ren ", "Jiang ", "Jia ", "Cun ", "Mo ", "Jie ", "Er ", "Luo ", "Ru ", "Zhu ", "Gui ", "Yin ", "Cai ", "Lie ", "Kamishimo ", "Yuki ", "Zhuang ", "Dang ", "[?] ", "Kun ", "Ken ", "Niao ", "Shu ", "Jia ", "Kun ", "Cheng ", "Li ", "Juan ", "Shen ", "Pou ", "Ge ", "Yi ", "Yu ", "Zhen ", "Liu ", "Qiu ", "Qun ", "Ji ", "Yi ", "Bu ", "Zhuang ", "Shui ", "Sha ", "Qun ", "Li ", "Lian ", "Lian ", "Ku ", "Jian ", "Fou ", "Chan ", "Bi ", "Gun ", "Tao ", "Yuan ", "Ling ", "Chi ", "Chang ", "Chou ", "Duo ", "Biao ", "Liang ", "Chang ", "Pei ", "Pei ", "Fei ", "Yuan ", "Luo ", "Guo ", "Yan ", "Du ", "Xi ", "Zhi ", "Ju ", "Qi "];
  }
});

// node_modules/unidecode/data/x89.js
var require_x89 = __commonJS({
  "node_modules/unidecode/data/x89.js"(exports, module2) {
    module2.exports = ["Ji ", "Zhi ", "Gua ", "Ken ", "Che ", "Ti ", "Ti ", "Fu ", "Chong ", "Xie ", "Bian ", "Die ", "Kun ", "Duan ", "Xiu ", "Xiu ", "He ", "Yuan ", "Bao ", "Bao ", "Fu ", "Yu ", "Tuan ", "Yan ", "Hui ", "Bei ", "Chu ", "Lu ", "Ena ", "Hitoe ", "Yun ", "Da ", "Gou ", "Da ", "Huai ", "Rong ", "Yuan ", "Ru ", "Nai ", "Jiong ", "Suo ", "Ban ", "Tun ", "Chi ", "Sang ", "Niao ", "Ying ", "Jie ", "Qian ", "Huai ", "Ku ", "Lian ", "Bao ", "Li ", "Zhe ", "Shi ", "Lu ", "Yi ", "Die ", "Xie ", "Xian ", "Wei ", "Biao ", "Cao ", "Ji ", "Jiang ", "Sen ", "Bao ", "Xiang ", "Chihaya ", "Pu ", "Jian ", "Zhuan ", "Jian ", "Zui ", "Ji ", "Dan ", "Za ", "Fan ", "Bo ", "Xiang ", "Xin ", "Bie ", "Rao ", "Man ", "Lan ", "Ao ", "Duo ", "Gui ", "Cao ", "Sui ", "Nong ", "Chan ", "Lian ", "Bi ", "Jin ", "Dang ", "Shu ", "Tan ", "Bi ", "Lan ", "Pu ", "Ru ", "Zhi ", "[?] ", "Shu ", "Wa ", "Shi ", "Bai ", "Xie ", "Bo ", "Chen ", "Lai ", "Long ", "Xi ", "Xian ", "Lan ", "Zhe ", "Dai ", "Tasuki ", "Zan ", "Shi ", "Jian ", "Pan ", "Yi ", "Ran ", "Ya ", "Xi ", "Xi ", "Yao ", "Feng ", "Tan ", "[?] ", "Biao ", "Fu ", "Ba ", "He ", "Ji ", "Ji ", "Jian ", "Guan ", "Bian ", "Yan ", "Gui ", "Jue ", "Pian ", "Mao ", "Mi ", "Mi ", "Mie ", "Shi ", "Si ", "Zhan ", "Luo ", "Jue ", "Mi ", "Tiao ", "Lian ", "Yao ", "Zhi ", "Jun ", "Xi ", "Shan ", "Wei ", "Xi ", "Tian ", "Yu ", "Lan ", "E ", "Du ", "Qin ", "Pang ", "Ji ", "Ming ", "Ying ", "Gou ", "Qu ", "Zhan ", "Jin ", "Guan ", "Deng ", "Jian ", "Luo ", "Qu ", "Jian ", "Wei ", "Jue ", "Qu ", "Luo ", "Lan ", "Shen ", "Di ", "Guan ", "Jian ", "Guan ", "Yan ", "Gui ", "Mi ", "Shi ", "Zhan ", "Lan ", "Jue ", "Ji ", "Xi ", "Di ", "Tian ", "Yu ", "Gou ", "Jin ", "Qu ", "Jiao ", "Jiu ", "Jin ", "Cu ", "Jue ", "Zhi ", "Chao ", "Ji ", "Gu ", "Dan ", "Zui ", "Di ", "Shang ", "Hua ", "Quan ", "Ge ", "Chi ", "Jie ", "Gui ", "Gong ", "Hong ", "Jie ", "Hun ", "Qiu ", "Xing ", "Su ", "Ni ", "Ji ", "Lu ", "Zhi ", "Zha ", "Bi ", "Xing ", "Hu ", "Shang ", "Gong ", "Zhi ", "Xue ", "Chu ", "Xi ", "Yi ", "Lu ", "Jue ", "Xi ", "Yan ", "Xi "];
  }
});

// node_modules/unidecode/data/x8a.js
var require_x8a = __commonJS({
  "node_modules/unidecode/data/x8a.js"(exports, module2) {
    module2.exports = ["Yan ", "Yan ", "Ding ", "Fu ", "Qiu ", "Qiu ", "Jiao ", "Hong ", "Ji ", "Fan ", "Xun ", "Diao ", "Hong ", "Cha ", "Tao ", "Xu ", "Jie ", "Yi ", "Ren ", "Xun ", "Yin ", "Shan ", "Qi ", "Tuo ", "Ji ", "Xun ", "Yin ", "E ", "Fen ", "Ya ", "Yao ", "Song ", "Shen ", "Yin ", "Xin ", "Jue ", "Xiao ", "Ne ", "Chen ", "You ", "Zhi ", "Xiong ", "Fang ", "Xin ", "Chao ", "She ", "Xian ", "Sha ", "Tun ", "Xu ", "Yi ", "Yi ", "Su ", "Chi ", "He ", "Shen ", "He ", "Xu ", "Zhen ", "Zhu ", "Zheng ", "Gou ", "Zi ", "Zi ", "Zhan ", "Gu ", "Fu ", "Quan ", "Die ", "Ling ", "Di ", "Yang ", "Li ", "Nao ", "Pan ", "Zhou ", "Gan ", "Yi ", "Ju ", "Ao ", "Zha ", "Tuo ", "Yi ", "Qu ", "Zhao ", "Ping ", "Bi ", "Xiong ", "Qu ", "Ba ", "Da ", "Zu ", "Tao ", "Zhu ", "Ci ", "Zhe ", "Yong ", "Xu ", "Xun ", "Yi ", "Huang ", "He ", "Shi ", "Cha ", "Jiao ", "Shi ", "Hen ", "Cha ", "Gou ", "Gui ", "Quan ", "Hui ", "Jie ", "Hua ", "Gai ", "Xiang ", "Wei ", "Shen ", "Chou ", "Tong ", "Mi ", "Zhan ", "Ming ", "E ", "Hui ", "Yan ", "Xiong ", "Gua ", "Er ", "Beng ", "Tiao ", "Chi ", "Lei ", "Zhu ", "Kuang ", "Kua ", "Wu ", "Yu ", "Teng ", "Ji ", "Zhi ", "Ren ", "Su ", "Lang ", "E ", "Kuang ", "E ", "Shi ", "Ting ", "Dan ", "Bo ", "Chan ", "You ", "Heng ", "Qiao ", "Qin ", "Shua ", "An ", "Yu ", "Xiao ", "Cheng ", "Jie ", "Xian ", "Wu ", "Wu ", "Gao ", "Song ", "Pu ", "Hui ", "Jing ", "Shuo ", "Zhen ", "Shuo ", "Du ", "Yasashi ", "Chang ", "Shui ", "Jie ", "Ke ", "Qu ", "Cong ", "Xiao ", "Sui ", "Wang ", "Xuan ", "Fei ", "Chi ", "Ta ", "Yi ", "Na ", "Yin ", "Diao ", "Pi ", "Chuo ", "Chan ", "Chen ", "Zhun ", "Ji ", "Qi ", "Tan ", "Zhui ", "Wei ", "Ju ", "Qing ", "Jian ", "Zheng ", "Ze ", "Zou ", "Qian ", "Zhuo ", "Liang ", "Jian ", "Zhu ", "Hao ", "Lun ", "Shen ", "Biao ", "Huai ", "Pian ", "Yu ", "Die ", "Xu ", "Pian ", "Shi ", "Xuan ", "Shi ", "Hun ", "Hua ", "E ", "Zhong ", "Di ", "Xie ", "Fu ", "Pu ", "Ting ", "Jian ", "Qi ", "Yu ", "Zi ", "Chuan ", "Xi ", "Hui ", "Yin ", "An ", "Xian ", "Nan ", "Chen ", "Feng ", "Zhu ", "Yang ", "Yan ", "Heng ", "Xuan ", "Ge ", "Nuo ", "Qi "];
  }
});

// node_modules/unidecode/data/x8b.js
var require_x8b = __commonJS({
  "node_modules/unidecode/data/x8b.js"(exports, module2) {
    module2.exports = ["Mou ", "Ye ", "Wei ", "[?] ", "Teng ", "Zou ", "Shan ", "Jian ", "Bo ", "Ku ", "Huang ", "Huo ", "Ge ", "Ying ", "Mi ", "Xiao ", "Mi ", "Xi ", "Qiang ", "Chen ", "Nue ", "Ti ", "Su ", "Bang ", "Chi ", "Qian ", "Shi ", "Jiang ", "Yuan ", "Xie ", "Xue ", "Tao ", "Yao ", "Yao ", "[?] ", "Yu ", "Biao ", "Cong ", "Qing ", "Li ", "Mo ", "Mo ", "Shang ", "Zhe ", "Miu ", "Jian ", "Ze ", "Jie ", "Lian ", "Lou ", "Can ", "Ou ", "Guan ", "Xi ", "Zhuo ", "Ao ", "Ao ", "Jin ", "Zhe ", "Yi ", "Hu ", "Jiang ", "Man ", "Chao ", "Han ", "Hua ", "Chan ", "Xu ", "Zeng ", "Se ", "Xi ", "She ", "Dui ", "Zheng ", "Nao ", "Lan ", "E ", "Ying ", "Jue ", "Ji ", "Zun ", "Jiao ", "Bo ", "Hui ", "Zhuan ", "Mu ", "Zen ", "Zha ", "Shi ", "Qiao ", "Tan ", "Zen ", "Pu ", "Sheng ", "Xuan ", "Zao ", "Tan ", "Dang ", "Sui ", "Qian ", "Ji ", "Jiao ", "Jing ", "Lian ", "Nou ", "Yi ", "Ai ", "Zhan ", "Pi ", "Hui ", "Hua ", "Yi ", "Yi ", "Shan ", "Rang ", "Nou ", "Qian ", "Zhui ", "Ta ", "Hu ", "Zhou ", "Hao ", "Ye ", "Ying ", "Jian ", "Yu ", "Jian ", "Hui ", "Du ", "Zhe ", "Xuan ", "Zan ", "Lei ", "Shen ", "Wei ", "Chan ", "Li ", "Yi ", "Bian ", "Zhe ", "Yan ", "E ", "Chou ", "Wei ", "Chou ", "Yao ", "Chan ", "Rang ", "Yin ", "Lan ", "Chen ", "Huo ", "Zhe ", "Huan ", "Zan ", "Yi ", "Dang ", "Zhan ", "Yan ", "Du ", "Yan ", "Ji ", "Ding ", "Fu ", "Ren ", "Ji ", "Jie ", "Hong ", "Tao ", "Rang ", "Shan ", "Qi ", "Tuo ", "Xun ", "Yi ", "Xun ", "Ji ", "Ren ", "Jiang ", "Hui ", "Ou ", "Ju ", "Ya ", "Ne ", "Xu ", "E ", "Lun ", "Xiong ", "Song ", "Feng ", "She ", "Fang ", "Jue ", "Zheng ", "Gu ", "He ", "Ping ", "Zu ", "Shi ", "Xiong ", "Zha ", "Su ", "Zhen ", "Di ", "Zou ", "Ci ", "Qu ", "Zhao ", "Bi ", "Yi ", "Yi ", "Kuang ", "Lei ", "Shi ", "Gua ", "Shi ", "Jie ", "Hui ", "Cheng ", "Zhu ", "Shen ", "Hua ", "Dan ", "Gou ", "Quan ", "Gui ", "Xun ", "Yi ", "Zheng ", "Gai ", "Xiang ", "Cha ", "Hun ", "Xu ", "Zhou ", "Jie ", "Wu ", "Yu ", "Qiao ", "Wu ", "Gao ", "You ", "Hui ", "Kuang ", "Shuo ", "Song ", "Ai ", "Qing ", "Zhu ", "Zou ", "Nuo ", "Du ", "Zhuo ", "Fei ", "Ke ", "Wei "];
  }
});

// node_modules/unidecode/data/x8c.js
var require_x8c = __commonJS({
  "node_modules/unidecode/data/x8c.js"(exports, module2) {
    module2.exports = ["Yu ", "Shui ", "Shen ", "Diao ", "Chan ", "Liang ", "Zhun ", "Sui ", "Tan ", "Shen ", "Yi ", "Mou ", "Chen ", "Die ", "Huang ", "Jian ", "Xie ", "Nue ", "Ye ", "Wei ", "E ", "Yu ", "Xuan ", "Chan ", "Zi ", "An ", "Yan ", "Di ", "Mi ", "Pian ", "Xu ", "Mo ", "Dang ", "Su ", "Xie ", "Yao ", "Bang ", "Shi ", "Qian ", "Mi ", "Jin ", "Man ", "Zhe ", "Jian ", "Miu ", "Tan ", "Zen ", "Qiao ", "Lan ", "Pu ", "Jue ", "Yan ", "Qian ", "Zhan ", "Chen ", "Gu ", "Qian ", "Hong ", "Xia ", "Jue ", "Hong ", "Han ", "Hong ", "Xi ", "Xi ", "Huo ", "Liao ", "Han ", "Du ", "Long ", "Dou ", "Jiang ", "Qi ", "Shi ", "Li ", "Deng ", "Wan ", "Bi ", "Shu ", "Xian ", "Feng ", "Zhi ", "Zhi ", "Yan ", "Yan ", "Shi ", "Chu ", "Hui ", "Tun ", "Yi ", "Tun ", "Yi ", "Jian ", "Ba ", "Hou ", "E ", "Cu ", "Xiang ", "Huan ", "Jian ", "Ken ", "Gai ", "Qu ", "Fu ", "Xi ", "Bin ", "Hao ", "Yu ", "Zhu ", "Jia ", "[?] ", "Xi ", "Bo ", "Wen ", "Huan ", "Bin ", "Di ", "Zong ", "Fen ", "Yi ", "Zhi ", "Bao ", "Chai ", "Han ", "Pi ", "Na ", "Pi ", "Gou ", "Na ", "You ", "Diao ", "Mo ", "Si ", "Xiu ", "Huan ", "Kun ", "He ", "He ", "Mo ", "Han ", "Mao ", "Li ", "Ni ", "Bi ", "Yu ", "Jia ", "Tuan ", "Mao ", "Pi ", "Xi ", "E ", "Ju ", "Mo ", "Chu ", "Tan ", "Huan ", "Jue ", "Bei ", "Zhen ", "Yuan ", "Fu ", "Cai ", "Gong ", "Te ", "Yi ", "Hang ", "Wan ", "Pin ", "Huo ", "Fan ", "Tan ", "Guan ", "Ze ", "Zhi ", "Er ", "Zhu ", "Shi ", "Bi ", "Zi ", "Er ", "Gui ", "Pian ", "Bian ", "Mai ", "Dai ", "Sheng ", "Kuang ", "Fei ", "Tie ", "Yi ", "Chi ", "Mao ", "He ", "Bi ", "Lu ", "Ren ", "Hui ", "Gai ", "Pian ", "Zi ", "Jia ", "Xu ", "Zei ", "Jiao ", "Gai ", "Zang ", "Jian ", "Ying ", "Xun ", "Zhen ", "She ", "Bin ", "Bin ", "Qiu ", "She ", "Chuan ", "Zang ", "Zhou ", "Lai ", "Zan ", "Si ", "Chen ", "Shang ", "Tian ", "Pei ", "Geng ", "Xian ", "Mai ", "Jian ", "Sui ", "Fu ", "Tan ", "Cong ", "Cong ", "Zhi ", "Ji ", "Zhang ", "Du ", "Jin ", "Xiong ", "Shun ", "Yun ", "Bao ", "Zai ", "Lai ", "Feng ", "Cang ", "Ji ", "Sheng ", "Ai ", "Zhuan ", "Fu ", "Gou ", "Sai ", "Ze ", "Liao "];
  }
});

// node_modules/unidecode/data/x8d.js
var require_x8d = __commonJS({
  "node_modules/unidecode/data/x8d.js"(exports, module2) {
    module2.exports = ["Wei ", "Bai ", "Chen ", "Zhuan ", "Zhi ", "Zhui ", "Biao ", "Yun ", "Zeng ", "Tan ", "Zan ", "Yan ", "[?] ", "Shan ", "Wan ", "Ying ", "Jin ", "Gan ", "Xian ", "Zang ", "Bi ", "Du ", "Shu ", "Yan ", "[?] ", "Xuan ", "Long ", "Gan ", "Zang ", "Bei ", "Zhen ", "Fu ", "Yuan ", "Gong ", "Cai ", "Ze ", "Xian ", "Bai ", "Zhang ", "Huo ", "Zhi ", "Fan ", "Tan ", "Pin ", "Bian ", "Gou ", "Zhu ", "Guan ", "Er ", "Jian ", "Bi ", "Shi ", "Tie ", "Gui ", "Kuang ", "Dai ", "Mao ", "Fei ", "He ", "Yi ", "Zei ", "Zhi ", "Jia ", "Hui ", "Zi ", "Ren ", "Lu ", "Zang ", "Zi ", "Gai ", "Jin ", "Qiu ", "Zhen ", "Lai ", "She ", "Fu ", "Du ", "Ji ", "Shu ", "Shang ", "Si ", "Bi ", "Zhou ", "Geng ", "Pei ", "Tan ", "Lai ", "Feng ", "Zhui ", "Fu ", "Zhuan ", "Sai ", "Ze ", "Yan ", "Zan ", "Yun ", "Zeng ", "Shan ", "Ying ", "Gan ", "Chi ", "Xi ", "She ", "Nan ", "Xiong ", "Xi ", "Cheng ", "He ", "Cheng ", "Zhe ", "Xia ", "Tang ", "Zou ", "Zou ", "Li ", "Jiu ", "Fu ", "Zhao ", "Gan ", "Qi ", "Shan ", "Qiong ", "Qin ", "Xian ", "Ci ", "Jue ", "Qin ", "Chi ", "Ci ", "Chen ", "Chen ", "Die ", "Ju ", "Chao ", "Di ", "Se ", "Zhan ", "Zhu ", "Yue ", "Qu ", "Jie ", "Chi ", "Chu ", "Gua ", "Xue ", "Ci ", "Tiao ", "Duo ", "Lie ", "Gan ", "Suo ", "Cu ", "Xi ", "Zhao ", "Su ", "Yin ", "Ju ", "Jian ", "Que ", "Tang ", "Chuo ", "Cui ", "Lu ", "Qu ", "Dang ", "Qiu ", "Zi ", "Ti ", "Qu ", "Chi ", "Huang ", "Qiao ", "Qiao ", "Yao ", "Zao ", "Ti ", "[?] ", "Zan ", "Zan ", "Zu ", "Pa ", "Bao ", "Ku ", "Ke ", "Dun ", "Jue ", "Fu ", "Chen ", "Jian ", "Fang ", "Zhi ", "Sa ", "Yue ", "Pa ", "Qi ", "Yue ", "Qiang ", "Tuo ", "Tai ", "Yi ", "Nian ", "Ling ", "Mei ", "Ba ", "Die ", "Ku ", "Tuo ", "Jia ", "Ci ", "Pao ", "Qia ", "Zhu ", "Ju ", "Die ", "Zhi ", "Fu ", "Pan ", "Ju ", "Shan ", "Bo ", "Ni ", "Ju ", "Li ", "Gen ", "Yi ", "Ji ", "Dai ", "Xian ", "Jiao ", "Duo ", "Zhu ", "Zhuan ", "Kua ", "Zhuai ", "Gui ", "Qiong ", "Kui ", "Xiang ", "Chi ", "Lu ", "Beng ", "Zhi ", "Jia ", "Tiao ", "Cai ", "Jian ", "Ta ", "Qiao ", "Bi ", "Xian ", "Duo ", "Ji ", "Ju ", "Ji ", "Shu ", "Tu "];
  }
});

// node_modules/unidecode/data/x8e.js
var require_x8e = __commonJS({
  "node_modules/unidecode/data/x8e.js"(exports, module2) {
    module2.exports = ["Chu ", "Jing ", "Nie ", "Xiao ", "Bo ", "Chi ", "Qun ", "Mou ", "Shu ", "Lang ", "Yong ", "Jiao ", "Chou ", "Qiao ", "[?] ", "Ta ", "Jian ", "Qi ", "Wo ", "Wei ", "Zhuo ", "Jie ", "Ji ", "Nie ", "Ju ", "Ju ", "Lun ", "Lu ", "Leng ", "Huai ", "Ju ", "Chi ", "Wan ", "Quan ", "Ti ", "Bo ", "Zu ", "Qie ", "Ji ", "Cu ", "Zong ", "Cai ", "Zong ", "Peng ", "Zhi ", "Zheng ", "Dian ", "Zhi ", "Yu ", "Duo ", "Dun ", "Chun ", "Yong ", "Zhong ", "Di ", "Zhe ", "Chen ", "Chuai ", "Jian ", "Gua ", "Tang ", "Ju ", "Fu ", "Zu ", "Die ", "Pian ", "Rou ", "Nuo ", "Ti ", "Cha ", "Tui ", "Jian ", "Dao ", "Cuo ", "Xi ", "Ta ", "Qiang ", "Zhan ", "Dian ", "Ti ", "Ji ", "Nie ", "Man ", "Liu ", "Zhan ", "Bi ", "Chong ", "Lu ", "Liao ", "Cu ", "Tang ", "Dai ", "Suo ", "Xi ", "Kui ", "Ji ", "Zhi ", "Qiang ", "Di ", "Man ", "Zong ", "Lian ", "Beng ", "Zao ", "Nian ", "Bie ", "Tui ", "Ju ", "Deng ", "Ceng ", "Xian ", "Fan ", "Chu ", "Zhong ", "Dun ", "Bo ", "Cu ", "Zu ", "Jue ", "Jue ", "Lin ", "Ta ", "Qiao ", "Qiao ", "Pu ", "Liao ", "Dun ", "Cuan ", "Kuang ", "Zao ", "Ta ", "Bi ", "Bi ", "Zhu ", "Ju ", "Chu ", "Qiao ", "Dun ", "Chou ", "Ji ", "Wu ", "Yue ", "Nian ", "Lin ", "Lie ", "Zhi ", "Li ", "Zhi ", "Chan ", "Chu ", "Duan ", "Wei ", "Long ", "Lin ", "Xian ", "Wei ", "Zuan ", "Lan ", "Xie ", "Rang ", "Xie ", "Nie ", "Ta ", "Qu ", "Jie ", "Cuan ", "Zuan ", "Xi ", "Kui ", "Jue ", "Lin ", "Shen ", "Gong ", "Dan ", "Segare ", "Qu ", "Ti ", "Duo ", "Duo ", "Gong ", "Lang ", "Nerau ", "Luo ", "Ai ", "Ji ", "Ju ", "Tang ", "Utsuke ", "[?] ", "Yan ", "Shitsuke ", "Kang ", "Qu ", "Lou ", "Lao ", "Tuo ", "Zhi ", "Yagate ", "Ti ", "Dao ", "Yagate ", "Yu ", "Che ", "Ya ", "Gui ", "Jun ", "Wei ", "Yue ", "Xin ", "Di ", "Xuan ", "Fan ", "Ren ", "Shan ", "Qiang ", "Shu ", "Tun ", "Chen ", "Dai ", "E ", "Na ", "Qi ", "Mao ", "Ruan ", "Ren ", "Fan ", "Zhuan ", "Hong ", "Hu ", "Qu ", "Huang ", "Di ", "Ling ", "Dai ", "Ao ", "Zhen ", "Fan ", "Kuang ", "Ang ", "Peng ", "Bei ", "Gu ", "Ku ", "Pao ", "Zhu ", "Rong ", "E ", "Ba ", "Zhou ", "Zhi ", "Yao ", "Ke ", "Yi ", "Qing ", "Shi ", "Ping "];
  }
});

// node_modules/unidecode/data/x8f.js
var require_x8f = __commonJS({
  "node_modules/unidecode/data/x8f.js"(exports, module2) {
    module2.exports = ["Er ", "Qiong ", "Ju ", "Jiao ", "Guang ", "Lu ", "Kai ", "Quan ", "Zhou ", "Zai ", "Zhi ", "She ", "Liang ", "Yu ", "Shao ", "You ", "Huan ", "Yun ", "Zhe ", "Wan ", "Fu ", "Qing ", "Zhou ", "Ni ", "Ling ", "Zhe ", "Zhan ", "Liang ", "Zi ", "Hui ", "Wang ", "Chuo ", "Guo ", "Kan ", "Yi ", "Peng ", "Qian ", "Gun ", "Nian ", "Pian ", "Guan ", "Bei ", "Lun ", "Pai ", "Liang ", "Ruan ", "Rou ", "Ji ", "Yang ", "Xian ", "Chuan ", "Cou ", "Qun ", "Ge ", "You ", "Hong ", "Shu ", "Fu ", "Zi ", "Fu ", "Wen ", "Ben ", "Zhan ", "Yu ", "Wen ", "Tao ", "Gu ", "Zhen ", "Xia ", "Yuan ", "Lu ", "Jiu ", "Chao ", "Zhuan ", "Wei ", "Hun ", "Sori ", "Che ", "Jiao ", "Zhan ", "Pu ", "Lao ", "Fen ", "Fan ", "Lin ", "Ge ", "Se ", "Kan ", "Huan ", "Yi ", "Ji ", "Dui ", "Er ", "Yu ", "Xian ", "Hong ", "Lei ", "Pei ", "Li ", "Li ", "Lu ", "Lin ", "Che ", "Ya ", "Gui ", "Xuan ", "Di ", "Ren ", "Zhuan ", "E ", "Lun ", "Ruan ", "Hong ", "Ku ", "Ke ", "Lu ", "Zhou ", "Zhi ", "Yi ", "Hu ", "Zhen ", "Li ", "Yao ", "Qing ", "Shi ", "Zai ", "Zhi ", "Jiao ", "Zhou ", "Quan ", "Lu ", "Jiao ", "Zhe ", "Fu ", "Liang ", "Nian ", "Bei ", "Hui ", "Gun ", "Wang ", "Liang ", "Chuo ", "Zi ", "Cou ", "Fu ", "Ji ", "Wen ", "Shu ", "Pei ", "Yuan ", "Xia ", "Zhan ", "Lu ", "Che ", "Lin ", "Xin ", "Gu ", "Ci ", "Ci ", "Pi ", "Zui ", "Bian ", "La ", "La ", "Ci ", "Xue ", "Ban ", "Bian ", "Bian ", "Bian ", "[?] ", "Bian ", "Ban ", "Ci ", "Bian ", "Bian ", "Chen ", "Ru ", "Nong ", "Nong ", "Zhen ", "Chuo ", "Chuo ", "Suberu ", "Reng ", "Bian ", "Bian ", "Sip ", "Ip ", "Liao ", "Da ", "Chan ", "Gan ", "Qian ", "Yu ", "Yu ", "Qi ", "Xun ", "Yi ", "Guo ", "Mai ", "Qi ", "Za ", "Wang ", "Jia ", "Zhun ", "Ying ", "Ti ", "Yun ", "Jin ", "Hang ", "Ya ", "Fan ", "Wu ", "Da ", "E ", "Huan ", "Zhe ", "Totemo ", "Jin ", "Yuan ", "Wei ", "Lian ", "Chi ", "Che ", "Ni ", "Tiao ", "Zhi ", "Yi ", "Jiong ", "Jia ", "Chen ", "Dai ", "Er ", "Di ", "Po ", "Wang ", "Die ", "Ze ", "Tao ", "Shu ", "Tuo ", "Kep ", "Jing ", "Hui ", "Tong ", "You ", "Mi ", "Beng ", "Ji ", "Nai ", "Yi ", "Jie ", "Zhui ", "Lie ", "Xun "];
  }
});

// node_modules/unidecode/data/x90.js
var require_x90 = __commonJS({
  "node_modules/unidecode/data/x90.js"(exports, module2) {
    module2.exports = ["Tui ", "Song ", "Gua ", "Tao ", "Pang ", "Hou ", "Ni ", "Dun ", "Jiong ", "Xuan ", "Xun ", "Bu ", "You ", "Xiao ", "Qiu ", "Tou ", "Zhu ", "Qiu ", "Di ", "Di ", "Tu ", "Jing ", "Ti ", "Dou ", "Yi ", "Zhe ", "Tong ", "Guang ", "Wu ", "Shi ", "Cheng ", "Su ", "Zao ", "Qun ", "Feng ", "Lian ", "Suo ", "Hui ", "Li ", "Sako ", "Lai ", "Ben ", "Cuo ", "Jue ", "Beng ", "Huan ", "Dai ", "Lu ", "You ", "Zhou ", "Jin ", "Yu ", "Chuo ", "Kui ", "Wei ", "Ti ", "Yi ", "Da ", "Yuan ", "Luo ", "Bi ", "Nuo ", "Yu ", "Dang ", "Sui ", "Dun ", "Sui ", "Yan ", "Chuan ", "Chi ", "Ti ", "Yu ", "Shi ", "Zhen ", "You ", "Yun ", "E ", "Bian ", "Guo ", "E ", "Xia ", "Huang ", "Qiu ", "Dao ", "Da ", "Wei ", "Appare ", "Yi ", "Gou ", "Yao ", "Chu ", "Liu ", "Xun ", "Ta ", "Di ", "Chi ", "Yuan ", "Su ", "Ta ", "Qian ", "[?] ", "Yao ", "Guan ", "Zhang ", "Ao ", "Shi ", "Ce ", "Chi ", "Su ", "Zao ", "Zhe ", "Dun ", "Di ", "Lou ", "Chi ", "Cuo ", "Lin ", "Zun ", "Rao ", "Qian ", "Xuan ", "Yu ", "Yi ", "Wu ", "Liao ", "Ju ", "Shi ", "Bi ", "Yao ", "Mai ", "Xie ", "Sui ", "Huan ", "Zhan ", "Teng ", "Er ", "Miao ", "Bian ", "Bian ", "La ", "Li ", "Yuan ", "Yao ", "Luo ", "Li ", "Yi ", "Ting ", "Deng ", "Qi ", "Yong ", "Shan ", "Han ", "Yu ", "Mang ", "Ru ", "Qiong ", "[?] ", "Kuang ", "Fu ", "Kang ", "Bin ", "Fang ", "Xing ", "Na ", "Xin ", "Shen ", "Bang ", "Yuan ", "Cun ", "Huo ", "Xie ", "Bang ", "Wu ", "Ju ", "You ", "Han ", "Tai ", "Qiu ", "Bi ", "Pei ", "Bing ", "Shao ", "Bei ", "Wa ", "Di ", "Zou ", "Ye ", "Lin ", "Kuang ", "Gui ", "Zhu ", "Shi ", "Ku ", "Yu ", "Gai ", "Ge ", "Xi ", "Zhi ", "Ji ", "Xun ", "Hou ", "Xing ", "Jiao ", "Xi ", "Gui ", "Nuo ", "Lang ", "Jia ", "Kuai ", "Zheng ", "Otoko ", "Yun ", "Yan ", "Cheng ", "Dou ", "Chi ", "Lu ", "Fu ", "Wu ", "Fu ", "Gao ", "Hao ", "Lang ", "Jia ", "Geng ", "Jun ", "Ying ", "Bo ", "Xi ", "Bei ", "Li ", "Yun ", "Bu ", "Xiao ", "Qi ", "Pi ", "Qing ", "Guo ", "Zhou ", "Tan ", "Zou ", "Ping ", "Lai ", "Ni ", "Chen ", "You ", "Bu ", "Xiang ", "Dan ", "Ju ", "Yong ", "Qiao ", "Yi ", "Du ", "Yan ", "Mei "];
  }
});

// node_modules/unidecode/data/x91.js
var require_x91 = __commonJS({
  "node_modules/unidecode/data/x91.js"(exports, module2) {
    module2.exports = ["Ruo ", "Bei ", "E ", "Yu ", "Juan ", "Yu ", "Yun ", "Hou ", "Kui ", "Xiang ", "Xiang ", "Sou ", "Tang ", "Ming ", "Xi ", "Ru ", "Chu ", "Zi ", "Zou ", "Ju ", "Wu ", "Xiang ", "Yun ", "Hao ", "Yong ", "Bi ", "Mo ", "Chao ", "Fu ", "Liao ", "Yin ", "Zhuan ", "Hu ", "Qiao ", "Yan ", "Zhang ", "Fan ", "Qiao ", "Xu ", "Deng ", "Bi ", "Xin ", "Bi ", "Ceng ", "Wei ", "Zheng ", "Mao ", "Shan ", "Lin ", "Po ", "Dan ", "Meng ", "Ye ", "Cao ", "Kuai ", "Feng ", "Meng ", "Zou ", "Kuang ", "Lian ", "Zan ", "Chan ", "You ", "Qi ", "Yan ", "Chan ", "Zan ", "Ling ", "Huan ", "Xi ", "Feng ", "Zan ", "Li ", "You ", "Ding ", "Qiu ", "Zhuo ", "Pei ", "Zhou ", "Yi ", "Hang ", "Yu ", "Jiu ", "Yan ", "Zui ", "Mao ", "Dan ", "Xu ", "Tou ", "Zhen ", "Fen ", "Sakenomoto ", "[?] ", "Yun ", "Tai ", "Tian ", "Qia ", "Tuo ", "Zuo ", "Han ", "Gu ", "Su ", "Po ", "Chou ", "Zai ", "Ming ", "Luo ", "Chuo ", "Chou ", "You ", "Tong ", "Zhi ", "Xian ", "Jiang ", "Cheng ", "Yin ", "Tu ", "Xiao ", "Mei ", "Ku ", "Suan ", "Lei ", "Pu ", "Zui ", "Hai ", "Yan ", "Xi ", "Niang ", "Wei ", "Lu ", "Lan ", "Yan ", "Tao ", "Pei ", "Zhan ", "Chun ", "Tan ", "Zui ", "Chuo ", "Cu ", "Kun ", "Ti ", "Mian ", "Du ", "Hu ", "Xu ", "Xing ", "Tan ", "Jiu ", "Chun ", "Yun ", "Po ", "Ke ", "Sou ", "Mi ", "Quan ", "Chou ", "Cuo ", "Yun ", "Yong ", "Ang ", "Zha ", "Hai ", "Tang ", "Jiang ", "Piao ", "Shan ", "Yu ", "Li ", "Zao ", "Lao ", "Yi ", "Jiang ", "Pu ", "Jiao ", "Xi ", "Tan ", "Po ", "Nong ", "Yi ", "Li ", "Ju ", "Jiao ", "Yi ", "Niang ", "Ru ", "Xun ", "Chou ", "Yan ", "Ling ", "Mi ", "Mi ", "Niang ", "Xin ", "Jiao ", "Xi ", "Mi ", "Yan ", "Bian ", "Cai ", "Shi ", "You ", "Shi ", "Shi ", "Li ", "Zhong ", "Ye ", "Liang ", "Li ", "Jin ", "Jin ", "Qiu ", "Yi ", "Diao ", "Dao ", "Zhao ", "Ding ", "Po ", "Qiu ", "He ", "Fu ", "Zhen ", "Zhi ", "Ba ", "Luan ", "Fu ", "Nai ", "Diao ", "Shan ", "Qiao ", "Kou ", "Chuan ", "Zi ", "Fan ", "Yu ", "Hua ", "Han ", "Gong ", "Qi ", "Mang ", "Ri ", "Di ", "Si ", "Xi ", "Yi ", "Chai ", "Shi ", "Tu ", "Xi ", "Nu ", "Qian ", "Ishiyumi ", "Jian ", "Pi ", "Ye ", "Yin "];
  }
});

// node_modules/unidecode/data/x92.js
var require_x92 = __commonJS({
  "node_modules/unidecode/data/x92.js"(exports, module2) {
    module2.exports = ["Ba ", "Fang ", "Chen ", "Xing ", "Tou ", "Yue ", "Yan ", "Fu ", "Pi ", "Na ", "Xin ", "E ", "Jue ", "Dun ", "Gou ", "Yin ", "Qian ", "Ban ", "Ji ", "Ren ", "Chao ", "Niu ", "Fen ", "Yun ", "Ji ", "Qin ", "Pi ", "Guo ", "Hong ", "Yin ", "Jun ", "Shi ", "Yi ", "Zhong ", "Nie ", "Gai ", "Ri ", "Huo ", "Tai ", "Kang ", "Habaki ", "Irori ", "Ngaak ", "[?] ", "Duo ", "Zi ", "Ni ", "Tu ", "Shi ", "Min ", "Gu ", "E ", "Ling ", "Bing ", "Yi ", "Gu ", "Ba ", "Pi ", "Yu ", "Si ", "Zuo ", "Bu ", "You ", "Dian ", "Jia ", "Zhen ", "Shi ", "Shi ", "Tie ", "Ju ", "Zhan ", "Shi ", "She ", "Xuan ", "Zhao ", "Bao ", "He ", "Bi ", "Sheng ", "Chu ", "Shi ", "Bo ", "Zhu ", "Chi ", "Za ", "Po ", "Tong ", "Qian ", "Fu ", "Zhai ", "Liu ", "Qian ", "Fu ", "Li ", "Yue ", "Pi ", "Yang ", "Ban ", "Bo ", "Jie ", "Gou ", "Shu ", "Zheng ", "Mu ", "Ni ", "Nie ", "Di ", "Jia ", "Mu ", "Dan ", "Shen ", "Yi ", "Si ", "Kuang ", "Ka ", "Bei ", "Jian ", "Tong ", "Xing ", "Hong ", "Jiao ", "Chi ", "Er ", "Ge ", "Bing ", "Shi ", "Mou ", "Jia ", "Yin ", "Jun ", "Zhou ", "Chong ", "Shang ", "Tong ", "Mo ", "Lei ", "Ji ", "Yu ", "Xu ", "Ren ", "Zun ", "Zhi ", "Qiong ", "Shan ", "Chi ", "Xian ", "Xing ", "Quan ", "Pi ", "Tie ", "Zhu ", "Hou ", "Ming ", "Kua ", "Yao ", "Xian ", "Xian ", "Xiu ", "Jun ", "Cha ", "Lao ", "Ji ", "Pi ", "Ru ", "Mi ", "Yi ", "Yin ", "Guang ", "An ", "Diou ", "You ", "Se ", "Kao ", "Qian ", "Luan ", "Kasugai ", "Ai ", "Diao ", "Han ", "Rui ", "Shi ", "Keng ", "Qiu ", "Xiao ", "Zhe ", "Xiu ", "Zang ", "Ti ", "Cuo ", "Gua ", "Gong ", "Zhong ", "Dou ", "Lu ", "Mei ", "Lang ", "Wan ", "Xin ", "Yun ", "Bei ", "Wu ", "Su ", "Yu ", "Chan ", "Ting ", "Bo ", "Han ", "Jia ", "Hong ", "Cuan ", "Feng ", "Chan ", "Wan ", "Zhi ", "Si ", "Xuan ", "Wu ", "Wu ", "Tiao ", "Gong ", "Zhuo ", "Lue ", "Xing ", "Qian ", "Shen ", "Han ", "Lue ", "Xie ", "Chu ", "Zheng ", "Ju ", "Xian ", "Tie ", "Mang ", "Pu ", "Li ", "Pan ", "Rui ", "Cheng ", "Gao ", "Li ", "Te ", "Pyeng ", "Zhu ", "[?] ", "Tu ", "Liu ", "Zui ", "Ju ", "Chang ", "Yuan ", "Jian ", "Gang ", "Diao ", "Tao ", "Chang "];
  }
});

// node_modules/unidecode/data/x93.js
var require_x93 = __commonJS({
  "node_modules/unidecode/data/x93.js"(exports, module2) {
    module2.exports = ["Lun ", "Kua ", "Ling ", "Bei ", "Lu ", "Li ", "Qiang ", "Pou ", "Juan ", "Min ", "Zui ", "Peng ", "An ", "Pi ", "Xian ", "Ya ", "Zhui ", "Lei ", "A ", "Kong ", "Ta ", "Kun ", "Du ", "Wei ", "Chui ", "Zi ", "Zheng ", "Ben ", "Nie ", "Cong ", "Qun ", "Tan ", "Ding ", "Qi ", "Qian ", "Zhuo ", "Qi ", "Yu ", "Jin ", "Guan ", "Mao ", "Chang ", "Tian ", "Xi ", "Lian ", "Tao ", "Gu ", "Cuo ", "Shu ", "Zhen ", "Lu ", "Meng ", "Lu ", "Hua ", "Biao ", "Ga ", "Lai ", "Ken ", "Kazari ", "Bu ", "Nai ", "Wan ", "Zan ", "[?] ", "De ", "Xian ", "[?] ", "Huo ", "Liang ", "[?] ", "Men ", "Kai ", "Ying ", "Di ", "Lian ", "Guo ", "Xian ", "Du ", "Tu ", "Wei ", "Cong ", "Fu ", "Rou ", "Ji ", "E ", "Rou ", "Chen ", "Ti ", "Zha ", "Hong ", "Yang ", "Duan ", "Xia ", "Yu ", "Keng ", "Xing ", "Huang ", "Wei ", "Fu ", "Zhao ", "Cha ", "Qie ", "She ", "Hong ", "Kui ", "Tian ", "Mou ", "Qiao ", "Qiao ", "Hou ", "Tou ", "Cong ", "Huan ", "Ye ", "Min ", "Jian ", "Duan ", "Jian ", "Song ", "Kui ", "Hu ", "Xuan ", "Duo ", "Jie ", "Zhen ", "Bian ", "Zhong ", "Zi ", "Xiu ", "Ye ", "Mei ", "Pai ", "Ai ", "Jie ", "[?] ", "Mei ", "Chuo ", "Ta ", "Bang ", "Xia ", "Lian ", "Suo ", "Xi ", "Liu ", "Zu ", "Ye ", "Nou ", "Weng ", "Rong ", "Tang ", "Suo ", "Qiang ", "Ge ", "Shuo ", "Chui ", "Bo ", "Pan ", "Sa ", "Bi ", "Sang ", "Gang ", "Zi ", "Wu ", "Ying ", "Huang ", "Tiao ", "Liu ", "Kai ", "Sun ", "Sha ", "Sou ", "Wan ", "Hao ", "Zhen ", "Zhen ", "Luo ", "Yi ", "Yuan ", "Tang ", "Nie ", "Xi ", "Jia ", "Ge ", "Ma ", "Juan ", "Kasugai ", "Habaki ", "Suo ", "[?] ", "[?] ", "[?] ", "Na ", "Lu ", "Suo ", "Ou ", "Zu ", "Tuan ", "Xiu ", "Guan ", "Xuan ", "Lian ", "Shou ", "Ao ", "Man ", "Mo ", "Luo ", "Bi ", "Wei ", "Liu ", "Di ", "Qiao ", "Cong ", "Yi ", "Lu ", "Ao ", "Keng ", "Qiang ", "Cui ", "Qi ", "Chang ", "Tang ", "Man ", "Yong ", "Chan ", "Feng ", "Jing ", "Biao ", "Shu ", "Lou ", "Xiu ", "Cong ", "Long ", "Zan ", "Jian ", "Cao ", "Li ", "Xia ", "Xi ", "Kang ", "[?] ", "Beng ", "[?] ", "[?] ", "Zheng ", "Lu ", "Hua ", "Ji ", "Pu ", "Hui ", "Qiang ", "Po ", "Lin ", "Suo ", "Xiu ", "San ", "Cheng "];
  }
});

// node_modules/unidecode/data/x94.js
var require_x94 = __commonJS({
  "node_modules/unidecode/data/x94.js"(exports, module2) {
    module2.exports = ["Kui ", "Si ", "Liu ", "Nao ", "Heng ", "Pie ", "Sui ", "Fan ", "Qiao ", "Quan ", "Yang ", "Tang ", "Xiang ", "Jue ", "Jiao ", "Zun ", "Liao ", "Jie ", "Lao ", "Dui ", "Tan ", "Zan ", "Ji ", "Jian ", "Zhong ", "Deng ", "Ya ", "Ying ", "Dui ", "Jue ", "Nou ", "Ti ", "Pu ", "Tie ", "[?] ", "[?] ", "Ding ", "Shan ", "Kai ", "Jian ", "Fei ", "Sui ", "Lu ", "Juan ", "Hui ", "Yu ", "Lian ", "Zhuo ", "Qiao ", "Qian ", "Zhuo ", "Lei ", "Bi ", "Tie ", "Huan ", "Ye ", "Duo ", "Guo ", "Dang ", "Ju ", "Fen ", "Da ", "Bei ", "Yi ", "Ai ", "Zong ", "Xun ", "Diao ", "Zhu ", "Heng ", "Zhui ", "Ji ", "Nie ", "Ta ", "Huo ", "Qing ", "Bin ", "Ying ", "Kui ", "Ning ", "Xu ", "Jian ", "Jian ", "Yari ", "Cha ", "Zhi ", "Mie ", "Li ", "Lei ", "Ji ", "Zuan ", "Kuang ", "Shang ", "Peng ", "La ", "Du ", "Shuo ", "Chuo ", "Lu ", "Biao ", "Bao ", "Lu ", "[?] ", "[?] ", "Long ", "E ", "Lu ", "Xin ", "Jian ", "Lan ", "Bo ", "Jian ", "Yao ", "Chan ", "Xiang ", "Jian ", "Xi ", "Guan ", "Cang ", "Nie ", "Lei ", "Cuan ", "Qu ", "Pan ", "Luo ", "Zuan ", "Luan ", "Zao ", "Nie ", "Jue ", "Tang ", "Shu ", "Lan ", "Jin ", "Qiu ", "Yi ", "Zhen ", "Ding ", "Zhao ", "Po ", "Diao ", "Tu ", "Qian ", "Chuan ", "Shan ", "Ji ", "Fan ", "Diao ", "Men ", "Nu ", "Xi ", "Chai ", "Xing ", "Gai ", "Bu ", "Tai ", "Ju ", "Dun ", "Chao ", "Zhong ", "Na ", "Bei ", "Gang ", "Ban ", "Qian ", "Yao ", "Qin ", "Jun ", "Wu ", "Gou ", "Kang ", "Fang ", "Huo ", "Tou ", "Niu ", "Ba ", "Yu ", "Qian ", "Zheng ", "Qian ", "Gu ", "Bo ", "E ", "Po ", "Bu ", "Ba ", "Yue ", "Zuan ", "Mu ", "Dan ", "Jia ", "Dian ", "You ", "Tie ", "Bo ", "Ling ", "Shuo ", "Qian ", "Liu ", "Bao ", "Shi ", "Xuan ", "She ", "Bi ", "Ni ", "Pi ", "Duo ", "Xing ", "Kao ", "Lao ", "Er ", "Mang ", "Ya ", "You ", "Cheng ", "Jia ", "Ye ", "Nao ", "Zhi ", "Dang ", "Tong ", "Lu ", "Diao ", "Yin ", "Kai ", "Zha ", "Zhu ", "Xian ", "Ting ", "Diu ", "Xian ", "Hua ", "Quan ", "Sha ", "Jia ", "Yao ", "Ge ", "Ming ", "Zheng ", "Se ", "Jiao ", "Yi ", "Chan ", "Chong ", "Tang ", "An ", "Yin ", "Ru ", "Zhu ", "Lao ", "Pu ", "Wu ", "Lai ", "Te ", "Lian ", "Keng "];
  }
});

// node_modules/unidecode/data/x95.js
var require_x95 = __commonJS({
  "node_modules/unidecode/data/x95.js"(exports, module2) {
    module2.exports = ["Xiao ", "Suo ", "Li ", "Zheng ", "Chu ", "Guo ", "Gao ", "Tie ", "Xiu ", "Cuo ", "Lue ", "Feng ", "Xin ", "Liu ", "Kai ", "Jian ", "Rui ", "Ti ", "Lang ", "Qian ", "Ju ", "A ", "Qiang ", "Duo ", "Tian ", "Cuo ", "Mao ", "Ben ", "Qi ", "De ", "Kua ", "Kun ", "Chang ", "Xi ", "Gu ", "Luo ", "Chui ", "Zhui ", "Jin ", "Zhi ", "Xian ", "Juan ", "Huo ", "Pou ", "Tan ", "Ding ", "Jian ", "Ju ", "Meng ", "Zi ", "Qie ", "Ying ", "Kai ", "Qiang ", "Song ", "E ", "Cha ", "Qiao ", "Zhong ", "Duan ", "Sou ", "Huang ", "Huan ", "Ai ", "Du ", "Mei ", "Lou ", "Zi ", "Fei ", "Mei ", "Mo ", "Zhen ", "Bo ", "Ge ", "Nie ", "Tang ", "Juan ", "Nie ", "Na ", "Liu ", "Hao ", "Bang ", "Yi ", "Jia ", "Bin ", "Rong ", "Biao ", "Tang ", "Man ", "Luo ", "Beng ", "Yong ", "Jing ", "Di ", "Zu ", "Xuan ", "Liu ", "Tan ", "Jue ", "Liao ", "Pu ", "Lu ", "Dui ", "Lan ", "Pu ", "Cuan ", "Qiang ", "Deng ", "Huo ", "Lei ", "Huan ", "Zhuo ", "Lian ", "Yi ", "Cha ", "Biao ", "La ", "Chan ", "Xiang ", "Chang ", "Chang ", "Jiu ", "Ao ", "Die ", "Qu ", "Liao ", "Mi ", "Chang ", "Men ", "Ma ", "Shuan ", "Shan ", "Huo ", "Men ", "Yan ", "Bi ", "Han ", "Bi ", "San ", "Kai ", "Kang ", "Beng ", "Hong ", "Run ", "San ", "Xian ", "Xian ", "Jian ", "Min ", "Xia ", "Yuru ", "Dou ", "Zha ", "Nao ", "Jian ", "Peng ", "Xia ", "Ling ", "Bian ", "Bi ", "Run ", "He ", "Guan ", "Ge ", "Ge ", "Fa ", "Chu ", "Hong ", "Gui ", "Min ", "Se ", "Kun ", "Lang ", "Lu ", "Ting ", "Sha ", "Ju ", "Yue ", "Yue ", "Chan ", "Qu ", "Lin ", "Chang ", "Shai ", "Kun ", "Yan ", "Min ", "Yan ", "E ", "Hun ", "Yu ", "Wen ", "Xiang ", "Bao ", "Xiang ", "Qu ", "Yao ", "Wen ", "Ban ", "An ", "Wei ", "Yin ", "Kuo ", "Que ", "Lan ", "Du ", "[?] ", "Phwung ", "Tian ", "Nie ", "Ta ", "Kai ", "He ", "Que ", "Chuang ", "Guan ", "Dou ", "Qi ", "Kui ", "Tang ", "Guan ", "Piao ", "Kan ", "Xi ", "Hui ", "Chan ", "Pi ", "Dang ", "Huan ", "Ta ", "Wen ", "[?] ", "Men ", "Shuan ", "Shan ", "Yan ", "Han ", "Bi ", "Wen ", "Chuang ", "Run ", "Wei ", "Xian ", "Hong ", "Jian ", "Min ", "Kang ", "Men ", "Zha ", "Nao ", "Gui ", "Wen ", "Ta ", "Min ", "Lu ", "Kai "];
  }
});

// node_modules/unidecode/data/x96.js
var require_x96 = __commonJS({
  "node_modules/unidecode/data/x96.js"(exports, module2) {
    module2.exports = ["Fa ", "Ge ", "He ", "Kun ", "Jiu ", "Yue ", "Lang ", "Du ", "Yu ", "Yan ", "Chang ", "Xi ", "Wen ", "Hun ", "Yan ", "E ", "Chan ", "Lan ", "Qu ", "Hui ", "Kuo ", "Que ", "Ge ", "Tian ", "Ta ", "Que ", "Kan ", "Huan ", "Fu ", "Fu ", "Le ", "Dui ", "Xin ", "Qian ", "Wu ", "Yi ", "Tuo ", "Yin ", "Yang ", "Dou ", "E ", "Sheng ", "Ban ", "Pei ", "Keng ", "Yun ", "Ruan ", "Zhi ", "Pi ", "Jing ", "Fang ", "Yang ", "Yin ", "Zhen ", "Jie ", "Cheng ", "E ", "Qu ", "Di ", "Zu ", "Zuo ", "Dian ", "Ling ", "A ", "Tuo ", "Tuo ", "Po ", "Bing ", "Fu ", "Ji ", "Lu ", "Long ", "Chen ", "Xing ", "Duo ", "Lou ", "Mo ", "Jiang ", "Shu ", "Duo ", "Xian ", "Er ", "Gui ", "Yu ", "Gai ", "Shan ", "Xun ", "Qiao ", "Xing ", "Chun ", "Fu ", "Bi ", "Xia ", "Shan ", "Sheng ", "Zhi ", "Pu ", "Dou ", "Yuan ", "Zhen ", "Chu ", "Xian ", "Tou ", "Nie ", "Yun ", "Xian ", "Pei ", "Pei ", "Zou ", "Yi ", "Dui ", "Lun ", "Yin ", "Ju ", "Chui ", "Chen ", "Pi ", "Ling ", "Tao ", "Xian ", "Lu ", "Sheng ", "Xian ", "Yin ", "Zhu ", "Yang ", "Reng ", "Shan ", "Chong ", "Yan ", "Yin ", "Yu ", "Ti ", "Yu ", "Long ", "Wei ", "Wei ", "Nie ", "Dui ", "Sui ", "An ", "Huang ", "Jie ", "Sui ", "Yin ", "Gai ", "Yan ", "Hui ", "Ge ", "Yun ", "Wu ", "Wei ", "Ai ", "Xi ", "Tang ", "Ji ", "Zhang ", "Dao ", "Ao ", "Xi ", "Yin ", "[?] ", "Rao ", "Lin ", "Tui ", "Deng ", "Pi ", "Sui ", "Sui ", "Yu ", "Xian ", "Fen ", "Ni ", "Er ", "Ji ", "Dao ", "Xi ", "Yin ", "E ", "Hui ", "Long ", "Xi ", "Li ", "Li ", "Li ", "Zhui ", "He ", "Zhi ", "Zhun ", "Jun ", "Nan ", "Yi ", "Que ", "Yan ", "Qian ", "Ya ", "Xiong ", "Ya ", "Ji ", "Gu ", "Huan ", "Zhi ", "Gou ", "Jun ", "Ci ", "Yong ", "Ju ", "Chu ", "Hu ", "Za ", "Luo ", "Yu ", "Chou ", "Diao ", "Sui ", "Han ", "Huo ", "Shuang ", "Guan ", "Chu ", "Za ", "Yong ", "Ji ", "Xi ", "Chou ", "Liu ", "Li ", "Nan ", "Xue ", "Za ", "Ji ", "Ji ", "Yu ", "Yu ", "Xue ", "Na ", "Fou ", "Se ", "Mu ", "Wen ", "Fen ", "Pang ", "Yun ", "Li ", "Li ", "Ang ", "Ling ", "Lei ", "An ", "Bao ", "Meng ", "Dian ", "Dang ", "Xing ", "Wu ", "Zhao "];
  }
});

// node_modules/unidecode/data/x97.js
var require_x97 = __commonJS({
  "node_modules/unidecode/data/x97.js"(exports, module2) {
    module2.exports = ["Xu ", "Ji ", "Mu ", "Chen ", "Xiao ", "Zha ", "Ting ", "Zhen ", "Pei ", "Mei ", "Ling ", "Qi ", "Chou ", "Huo ", "Sha ", "Fei ", "Weng ", "Zhan ", "Yin ", "Ni ", "Chou ", "Tun ", "Lin ", "[?] ", "Dong ", "Ying ", "Wu ", "Ling ", "Shuang ", "Ling ", "Xia ", "Hong ", "Yin ", "Mo ", "Mai ", "Yun ", "Liu ", "Meng ", "Bin ", "Wu ", "Wei ", "Huo ", "Yin ", "Xi ", "Yi ", "Ai ", "Dan ", "Deng ", "Xian ", "Yu ", "Lu ", "Long ", "Dai ", "Ji ", "Pang ", "Yang ", "Ba ", "Pi ", "Wei ", "[?] ", "Xi ", "Ji ", "Mai ", "Meng ", "Meng ", "Lei ", "Li ", "Huo ", "Ai ", "Fei ", "Dai ", "Long ", "Ling ", "Ai ", "Feng ", "Li ", "Bao ", "[?] ", "He ", "He ", "Bing ", "Qing ", "Qing ", "Jing ", "Tian ", "Zhen ", "Jing ", "Cheng ", "Qing ", "Jing ", "Jing ", "Dian ", "Jing ", "Tian ", "Fei ", "Fei ", "Kao ", "Mi ", "Mian ", "Mian ", "Pao ", "Ye ", "Tian ", "Hui ", "Ye ", "Ge ", "Ding ", "Cha ", "Jian ", "Ren ", "Di ", "Du ", "Wu ", "Ren ", "Qin ", "Jin ", "Xue ", "Niu ", "Ba ", "Yin ", "Sa ", "Na ", "Mo ", "Zu ", "Da ", "Ban ", "Yi ", "Yao ", "Tao ", "Tuo ", "Jia ", "Hong ", "Pao ", "Yang ", "Tomo ", "Yin ", "Jia ", "Tao ", "Ji ", "Xie ", "An ", "An ", "Hen ", "Gong ", "Kohaze ", "Da ", "Qiao ", "Ting ", "Wan ", "Ying ", "Sui ", "Tiao ", "Qiao ", "Xuan ", "Kong ", "Beng ", "Ta ", "Zhang ", "Bing ", "Kuo ", "Ju ", "La ", "Xie ", "Rou ", "Bang ", "Yi ", "Qiu ", "Qiu ", "He ", "Xiao ", "Mu ", "Ju ", "Jian ", "Bian ", "Di ", "Jian ", "On ", "Tao ", "Gou ", "Ta ", "Bei ", "Xie ", "Pan ", "Ge ", "Bi ", "Kuo ", "Tang ", "Lou ", "Gui ", "Qiao ", "Xue ", "Ji ", "Jian ", "Jiang ", "Chan ", "Da ", "Huo ", "Xian ", "Qian ", "Du ", "Wa ", "Jian ", "Lan ", "Wei ", "Ren ", "Fu ", "Mei ", "Juan ", "Ge ", "Wei ", "Qiao ", "Han ", "Chang ", "[?] ", "Rou ", "Xun ", "She ", "Wei ", "Ge ", "Bei ", "Tao ", "Gou ", "Yun ", "[?] ", "Bi ", "Wei ", "Hui ", "Du ", "Wa ", "Du ", "Wei ", "Ren ", "Fu ", "Han ", "Wei ", "Yun ", "Tao ", "Jiu ", "Jiu ", "Xian ", "Xie ", "Xian ", "Ji ", "Yin ", "Za ", "Yun ", "Shao ", "Le ", "Peng ", "Heng ", "Ying ", "Yun ", "Peng ", "Yin ", "Yin ", "Xiang "];
  }
});

// node_modules/unidecode/data/x98.js
var require_x98 = __commonJS({
  "node_modules/unidecode/data/x98.js"(exports, module2) {
    module2.exports = ["Hu ", "Ye ", "Ding ", "Qing ", "Pan ", "Xiang ", "Shun ", "Han ", "Xu ", "Yi ", "Xu ", "Gu ", "Song ", "Kui ", "Qi ", "Hang ", "Yu ", "Wan ", "Ban ", "Dun ", "Di ", "Dan ", "Pan ", "Po ", "Ling ", "Ce ", "Jing ", "Lei ", "He ", "Qiao ", "E ", "E ", "Wei ", "Jie ", "Gua ", "Shen ", "Yi ", "Shen ", "Hai ", "Dui ", "Pian ", "Ping ", "Lei ", "Fu ", "Jia ", "Tou ", "Hui ", "Kui ", "Jia ", "Le ", "Tian ", "Cheng ", "Ying ", "Jun ", "Hu ", "Han ", "Jing ", "Tui ", "Tui ", "Pin ", "Lai ", "Tui ", "Zi ", "Zi ", "Chui ", "Ding ", "Lai ", "Yan ", "Han ", "Jian ", "Ke ", "Cui ", "Jiong ", "Qin ", "Yi ", "Sai ", "Ti ", "E ", "E ", "Yan ", "Hun ", "Kan ", "Yong ", "Zhuan ", "Yan ", "Xian ", "Xin ", "Yi ", "Yuan ", "Sang ", "Dian ", "Dian ", "Jiang ", "Ku ", "Lei ", "Liao ", "Piao ", "Yi ", "Man ", "Qi ", "Rao ", "Hao ", "Qiao ", "Gu ", "Xun ", "Qian ", "Hui ", "Zhan ", "Ru ", "Hong ", "Bin ", "Xian ", "Pin ", "Lu ", "Lan ", "Nie ", "Quan ", "Ye ", "Ding ", "Qing ", "Han ", "Xiang ", "Shun ", "Xu ", "Xu ", "Wan ", "Gu ", "Dun ", "Qi ", "Ban ", "Song ", "Hang ", "Yu ", "Lu ", "Ling ", "Po ", "Jing ", "Jie ", "Jia ", "Tian ", "Han ", "Ying ", "Jiong ", "Hai ", "Yi ", "Pin ", "Hui ", "Tui ", "Han ", "Ying ", "Ying ", "Ke ", "Ti ", "Yong ", "E ", "Zhuan ", "Yan ", "E ", "Nie ", "Man ", "Dian ", "Sang ", "Hao ", "Lei ", "Zhan ", "Ru ", "Pin ", "Quan ", "Feng ", "Biao ", "Oroshi ", "Fu ", "Xia ", "Zhan ", "Biao ", "Sa ", "Ba ", "Tai ", "Lie ", "Gua ", "Xuan ", "Shao ", "Ju ", "Bi ", "Si ", "Wei ", "Yang ", "Yao ", "Sou ", "Kai ", "Sao ", "Fan ", "Liu ", "Xi ", "Liao ", "Piao ", "Piao ", "Liu ", "Biao ", "Biao ", "Biao ", "Liao ", "[?] ", "Se ", "Feng ", "Biao ", "Feng ", "Yang ", "Zhan ", "Biao ", "Sa ", "Ju ", "Si ", "Sou ", "Yao ", "Liu ", "Piao ", "Biao ", "Biao ", "Fei ", "Fan ", "Fei ", "Fei ", "Shi ", "Shi ", "Can ", "Ji ", "Ding ", "Si ", "Tuo ", "Zhan ", "Sun ", "Xiang ", "Tun ", "Ren ", "Yu ", "Juan ", "Chi ", "Yin ", "Fan ", "Fan ", "Sun ", "Yin ", "Zhu ", "Yi ", "Zhai ", "Bi ", "Jie ", "Tao ", "Liu ", "Ci ", "Tie ", "Si ", "Bao ", "Shi ", "Duo "];
  }
});

// node_modules/unidecode/data/x99.js
var require_x99 = __commonJS({
  "node_modules/unidecode/data/x99.js"(exports, module2) {
    module2.exports = ["Hai ", "Ren ", "Tian ", "Jiao ", "Jia ", "Bing ", "Yao ", "Tong ", "Ci ", "Xiang ", "Yang ", "Yang ", "Er ", "Yan ", "Le ", "Yi ", "Can ", "Bo ", "Nei ", "E ", "Bu ", "Jun ", "Dou ", "Su ", "Yu ", "Shi ", "Yao ", "Hun ", "Guo ", "Shi ", "Jian ", "Zhui ", "Bing ", "Xian ", "Bu ", "Ye ", "Tan ", "Fei ", "Zhang ", "Wei ", "Guan ", "E ", "Nuan ", "Hun ", "Hu ", "Huang ", "Tie ", "Hui ", "Jian ", "Hou ", "He ", "Xing ", "Fen ", "Wei ", "Gu ", "Cha ", "Song ", "Tang ", "Bo ", "Gao ", "Xi ", "Kui ", "Liu ", "Sou ", "Tao ", "Ye ", "Yun ", "Mo ", "Tang ", "Man ", "Bi ", "Yu ", "Xiu ", "Jin ", "San ", "Kui ", "Zhuan ", "Shan ", "Chi ", "Dan ", "Yi ", "Ji ", "Rao ", "Cheng ", "Yong ", "Tao ", "Hui ", "Xiang ", "Zhan ", "Fen ", "Hai ", "Meng ", "Yan ", "Mo ", "Chan ", "Xiang ", "Luo ", "Zuan ", "Nang ", "Shi ", "Ding ", "Ji ", "Tuo ", "Xing ", "Tun ", "Xi ", "Ren ", "Yu ", "Chi ", "Fan ", "Yin ", "Jian ", "Shi ", "Bao ", "Si ", "Duo ", "Yi ", "Er ", "Rao ", "Xiang ", "Jia ", "Le ", "Jiao ", "Yi ", "Bing ", "Bo ", "Dou ", "E ", "Yu ", "Nei ", "Jun ", "Guo ", "Hun ", "Xian ", "Guan ", "Cha ", "Kui ", "Gu ", "Sou ", "Chan ", "Ye ", "Mo ", "Bo ", "Liu ", "Xiu ", "Jin ", "Man ", "San ", "Zhuan ", "Nang ", "Shou ", "Kui ", "Guo ", "Xiang ", "Fen ", "Ba ", "Ni ", "Bi ", "Bo ", "Tu ", "Han ", "Fei ", "Jian ", "An ", "Ai ", "Fu ", "Xian ", "Wen ", "Xin ", "Fen ", "Bin ", "Xing ", "Ma ", "Yu ", "Feng ", "Han ", "Di ", "Tuo ", "Tuo ", "Chi ", "Xun ", "Zhu ", "Zhi ", "Pei ", "Xin ", "Ri ", "Sa ", "Yin ", "Wen ", "Zhi ", "Dan ", "Lu ", "You ", "Bo ", "Bao ", "Kuai ", "Tuo ", "Yi ", "Qu ", "[?] ", "Qu ", "Jiong ", "Bo ", "Zhao ", "Yuan ", "Peng ", "Zhou ", "Ju ", "Zhu ", "Nu ", "Ju ", "Pi ", "Zang ", "Jia ", "Ling ", "Zhen ", "Tai ", "Fu ", "Yang ", "Shi ", "Bi ", "Tuo ", "Tuo ", "Si ", "Liu ", "Ma ", "Pian ", "Tao ", "Zhi ", "Rong ", "Teng ", "Dong ", "Xun ", "Quan ", "Shen ", "Jiong ", "Er ", "Hai ", "Bo ", "Zhu ", "Yin ", "Luo ", "Shuu ", "Dan ", "Xie ", "Liu ", "Ju ", "Song ", "Qin ", "Mang ", "Liang ", "Han ", "Tu ", "Xuan ", "Tui ", "Jun "];
  }
});

// node_modules/unidecode/data/x9a.js
var require_x9a = __commonJS({
  "node_modules/unidecode/data/x9a.js"(exports, module2) {
    module2.exports = ["E ", "Cheng ", "Xin ", "Ai ", "Lu ", "Zhui ", "Zhou ", "She ", "Pian ", "Kun ", "Tao ", "Lai ", "Zong ", "Ke ", "Qi ", "Qi ", "Yan ", "Fei ", "Sao ", "Yan ", "Jie ", "Yao ", "Wu ", "Pian ", "Cong ", "Pian ", "Qian ", "Fei ", "Huang ", "Jian ", "Huo ", "Yu ", "Ti ", "Quan ", "Xia ", "Zong ", "Kui ", "Rou ", "Si ", "Gua ", "Tuo ", "Kui ", "Sou ", "Qian ", "Cheng ", "Zhi ", "Liu ", "Pang ", "Teng ", "Xi ", "Cao ", "Du ", "Yan ", "Yuan ", "Zou ", "Sao ", "Shan ", "Li ", "Zhi ", "Shuang ", "Lu ", "Xi ", "Luo ", "Zhang ", "Mo ", "Ao ", "Can ", "Piao ", "Cong ", "Qu ", "Bi ", "Zhi ", "Yu ", "Xu ", "Hua ", "Bo ", "Su ", "Xiao ", "Lin ", "Chan ", "Dun ", "Liu ", "Tuo ", "Zeng ", "Tan ", "Jiao ", "Tie ", "Yan ", "Luo ", "Zhan ", "Jing ", "Yi ", "Ye ", "Tuo ", "Bin ", "Zou ", "Yan ", "Peng ", "Lu ", "Teng ", "Xiang ", "Ji ", "Shuang ", "Ju ", "Xi ", "Huan ", "Li ", "Biao ", "Ma ", "Yu ", "Tuo ", "Xun ", "Chi ", "Qu ", "Ri ", "Bo ", "Lu ", "Zang ", "Shi ", "Si ", "Fu ", "Ju ", "Zou ", "Zhu ", "Tuo ", "Nu ", "Jia ", "Yi ", "Tai ", "Xiao ", "Ma ", "Yin ", "Jiao ", "Hua ", "Luo ", "Hai ", "Pian ", "Biao ", "Li ", "Cheng ", "Yan ", "Xin ", "Qin ", "Jun ", "Qi ", "Qi ", "Ke ", "Zhui ", "Zong ", "Su ", "Can ", "Pian ", "Zhi ", "Kui ", "Sao ", "Wu ", "Ao ", "Liu ", "Qian ", "Shan ", "Piao ", "Luo ", "Cong ", "Chan ", "Zou ", "Ji ", "Shuang ", "Xiang ", "Gu ", "Wei ", "Wei ", "Wei ", "Yu ", "Gan ", "Yi ", "Ang ", "Tou ", "Xie ", "Bao ", "Bi ", "Chi ", "Ti ", "Di ", "Ku ", "Hai ", "Qiao ", "Gou ", "Kua ", "Ge ", "Tui ", "Geng ", "Pian ", "Bi ", "Ke ", "Ka ", "Yu ", "Sui ", "Lou ", "Bo ", "Xiao ", "Pang ", "Bo ", "Ci ", "Kuan ", "Bin ", "Mo ", "Liao ", "Lou ", "Nao ", "Du ", "Zang ", "Sui ", "Ti ", "Bin ", "Kuan ", "Lu ", "Gao ", "Gao ", "Qiao ", "Kao ", "Qiao ", "Lao ", "Zao ", "Biao ", "Kun ", "Kun ", "Ti ", "Fang ", "Xiu ", "Ran ", "Mao ", "Dan ", "Kun ", "Bin ", "Fa ", "Tiao ", "Peng ", "Zi ", "Fa ", "Ran ", "Ti ", "Pao ", "Pi ", "Mao ", "Fu ", "Er ", "Rong ", "Qu ", "Gong ", "Xiu ", "Gua ", "Ji ", "Peng ", "Zhua ", "Shao ", "Sha "];
  }
});

// node_modules/unidecode/data/x9b.js
var require_x9b = __commonJS({
  "node_modules/unidecode/data/x9b.js"(exports, module2) {
    module2.exports = ["Ti ", "Li ", "Bin ", "Zong ", "Ti ", "Peng ", "Song ", "Zheng ", "Quan ", "Zong ", "Shun ", "Jian ", "Duo ", "Hu ", "La ", "Jiu ", "Qi ", "Lian ", "Zhen ", "Bin ", "Peng ", "Mo ", "San ", "Man ", "Man ", "Seng ", "Xu ", "Lie ", "Qian ", "Qian ", "Nong ", "Huan ", "Kuai ", "Ning ", "Bin ", "Lie ", "Rang ", "Dou ", "Dou ", "Nao ", "Hong ", "Xi ", "Dou ", "Han ", "Dou ", "Dou ", "Jiu ", "Chang ", "Yu ", "Yu ", "Li ", "Juan ", "Fu ", "Qian ", "Gui ", "Zong ", "Liu ", "Gui ", "Shang ", "Yu ", "Gui ", "Mei ", "Ji ", "Qi ", "Jie ", "Kui ", "Hun ", "Ba ", "Po ", "Mei ", "Xu ", "Yan ", "Xiao ", "Liang ", "Yu ", "Tui ", "Qi ", "Wang ", "Liang ", "Wei ", "Jian ", "Chi ", "Piao ", "Bi ", "Mo ", "Ji ", "Xu ", "Chou ", "Yan ", "Zhan ", "Yu ", "Dao ", "Ren ", "Ji ", "Eri ", "Gong ", "Tuo ", "Diao ", "Ji ", "Xu ", "E ", "E ", "Sha ", "Hang ", "Tun ", "Mo ", "Jie ", "Shen ", "Fan ", "Yuan ", "Bi ", "Lu ", "Wen ", "Hu ", "Lu ", "Za ", "Fang ", "Fen ", "Na ", "You ", "Namazu ", "Todo ", "He ", "Xia ", "Qu ", "Han ", "Pi ", "Ling ", "Tuo ", "Bo ", "Qiu ", "Ping ", "Fu ", "Bi ", "Ji ", "Wei ", "Ju ", "Diao ", "Bo ", "You ", "Gun ", "Pi ", "Nian ", "Xing ", "Tai ", "Bao ", "Fu ", "Zha ", "Ju ", "Gu ", "Kajika ", "Tong ", "[?] ", "Ta ", "Jie ", "Shu ", "Hou ", "Xiang ", "Er ", "An ", "Wei ", "Tiao ", "Zhu ", "Yin ", "Lie ", "Luo ", "Tong ", "Yi ", "Qi ", "Bing ", "Wei ", "Jiao ", "Bu ", "Gui ", "Xian ", "Ge ", "Hui ", "Bora ", "Mate ", "Kao ", "Gori ", "Duo ", "Jun ", "Ti ", "Man ", "Xiao ", "Za ", "Sha ", "Qin ", "Yu ", "Nei ", "Zhe ", "Gun ", "Geng ", "Su ", "Wu ", "Qiu ", "Ting ", "Fu ", "Wan ", "You ", "Li ", "Sha ", "Sha ", "Gao ", "Meng ", "Ugui ", "Asari ", "Subashiri ", "Kazunoko ", "Yong ", "Ni ", "Zi ", "Qi ", "Qing ", "Xiang ", "Nei ", "Chun ", "Ji ", "Diao ", "Qie ", "Gu ", "Zhou ", "Dong ", "Lai ", "Fei ", "Ni ", "Yi ", "Kun ", "Lu ", "Jiu ", "Chang ", "Jing ", "Lun ", "Ling ", "Zou ", "Li ", "Meng ", "Zong ", "Zhi ", "Nian ", "Shachi ", "Dojou ", "Sukesou ", "Shi ", "Shen ", "Hun ", "Shi ", "Hou ", "Xing ", "Zhu ", "La ", "Zong ", "Ji ", "Bian ", "Bian "];
  }
});

// node_modules/unidecode/data/x9c.js
var require_x9c = __commonJS({
  "node_modules/unidecode/data/x9c.js"(exports, module2) {
    module2.exports = ["Huan ", "Quan ", "Ze ", "Wei ", "Wei ", "Yu ", "Qun ", "Rou ", "Die ", "Huang ", "Lian ", "Yan ", "Qiu ", "Qiu ", "Jian ", "Bi ", "E ", "Yang ", "Fu ", "Sai ", "Jian ", "Xia ", "Tuo ", "Hu ", "Muroaji ", "Ruo ", "Haraka ", "Wen ", "Jian ", "Hao ", "Wu ", "Fang ", "Sao ", "Liu ", "Ma ", "Shi ", "Shi ", "Yin ", "Z ", "Teng ", "Ta ", "Yao ", "Ge ", "Rong ", "Qian ", "Qi ", "Wen ", "Ruo ", "Hatahata ", "Lian ", "Ao ", "Le ", "Hui ", "Min ", "Ji ", "Tiao ", "Qu ", "Jian ", "Sao ", "Man ", "Xi ", "Qiu ", "Biao ", "Ji ", "Ji ", "Zhu ", "Jiang ", "Qiu ", "Zhuan ", "Yong ", "Zhang ", "Kang ", "Xue ", "Bie ", "Jue ", "Qu ", "Xiang ", "Bo ", "Jiao ", "Xun ", "Su ", "Huang ", "Zun ", "Shan ", "Shan ", "Fan ", "Jue ", "Lin ", "Xun ", "Miao ", "Xi ", "Eso ", "Kyou ", "Fen ", "Guan ", "Hou ", "Kuai ", "Zei ", "Sao ", "Zhan ", "Gan ", "Gui ", "Sheng ", "Li ", "Chang ", "Hatahata ", "Shiira ", "Mutsu ", "Ru ", "Ji ", "Xu ", "Huo ", "Shiira ", "Li ", "Lie ", "Li ", "Mie ", "Zhen ", "Xiang ", "E ", "Lu ", "Guan ", "Li ", "Xian ", "Yu ", "Dao ", "Ji ", "You ", "Tun ", "Lu ", "Fang ", "Ba ", "He ", "Bo ", "Ping ", "Nian ", "Lu ", "You ", "Zha ", "Fu ", "Bo ", "Bao ", "Hou ", "Pi ", "Tai ", "Gui ", "Jie ", "Kao ", "Wei ", "Er ", "Tong ", "Ze ", "Hou ", "Kuai ", "Ji ", "Jiao ", "Xian ", "Za ", "Xiang ", "Xun ", "Geng ", "Li ", "Lian ", "Jian ", "Li ", "Shi ", "Tiao ", "Gun ", "Sha ", "Wan ", "Jun ", "Ji ", "Yong ", "Qing ", "Ling ", "Qi ", "Zou ", "Fei ", "Kun ", "Chang ", "Gu ", "Ni ", "Nian ", "Diao ", "Jing ", "Shen ", "Shi ", "Zi ", "Fen ", "Die ", "Bi ", "Chang ", "Shi ", "Wen ", "Wei ", "Sai ", "E ", "Qiu ", "Fu ", "Huang ", "Quan ", "Jiang ", "Bian ", "Sao ", "Ao ", "Qi ", "Ta ", "Yin ", "Yao ", "Fang ", "Jian ", "Le ", "Biao ", "Xue ", "Bie ", "Man ", "Min ", "Yong ", "Wei ", "Xi ", "Jue ", "Shan ", "Lin ", "Zun ", "Huo ", "Gan ", "Li ", "Zhan ", "Guan ", "Niao ", "Yi ", "Fu ", "Li ", "Jiu ", "Bu ", "Yan ", "Fu ", "Diao ", "Ji ", "Feng ", "Nio ", "Gan ", "Shi ", "Feng ", "Ming ", "Bao ", "Yuan ", "Zhi ", "Hu ", "Qin ", "Fu ", "Fen ", "Wen ", "Jian ", "Shi ", "Yu "];
  }
});

// node_modules/unidecode/data/x9d.js
var require_x9d = __commonJS({
  "node_modules/unidecode/data/x9d.js"(exports, module2) {
    module2.exports = ["Fou ", "Yiao ", "Jue ", "Jue ", "Pi ", "Huan ", "Zhen ", "Bao ", "Yan ", "Ya ", "Zheng ", "Fang ", "Feng ", "Wen ", "Ou ", "Te ", "Jia ", "Nu ", "Ling ", "Mie ", "Fu ", "Tuo ", "Wen ", "Li ", "Bian ", "Zhi ", "Ge ", "Yuan ", "Zi ", "Qu ", "Xiao ", "Zhi ", "Dan ", "Ju ", "You ", "Gu ", "Zhong ", "Yu ", "Yang ", "Rong ", "Ya ", "Tie ", "Yu ", "Shigi ", "Ying ", "Zhui ", "Wu ", "Er ", "Gua ", "Ai ", "Zhi ", "Yan ", "Heng ", "Jiao ", "Ji ", "Lie ", "Zhu ", "Ren ", "Yi ", "Hong ", "Luo ", "Ru ", "Mou ", "Ge ", "Ren ", "Jiao ", "Xiu ", "Zhou ", "Zhi ", "Luo ", "Chidori ", "Toki ", "Ten ", "Luan ", "Jia ", "Ji ", "Yu ", "Huan ", "Tuo ", "Bu ", "Wu ", "Juan ", "Yu ", "Bo ", "Xun ", "Xun ", "Bi ", "Xi ", "Jun ", "Ju ", "Tu ", "Jing ", "Ti ", "E ", "E ", "Kuang ", "Hu ", "Wu ", "Shen ", "Lai ", "Ikaruga ", "Kakesu ", "Lu ", "Ping ", "Shu ", "Fu ", "An ", "Zhao ", "Peng ", "Qin ", "Qian ", "Bei ", "Diao ", "Lu ", "Que ", "Jian ", "Ju ", "Tu ", "Ya ", "Yuan ", "Qi ", "Li ", "Ye ", "Zhui ", "Kong ", "Zhui ", "Kun ", "Sheng ", "Qi ", "Jing ", "Yi ", "Yi ", "Jing ", "Zi ", "Lai ", "Dong ", "Qi ", "Chun ", "Geng ", "Ju ", "Qu ", "Isuka ", "Kikuitadaki ", "Ji ", "Shu ", "[?] ", "Chi ", "Miao ", "Rou ", "An ", "Qiu ", "Ti ", "Hu ", "Ti ", "E ", "Jie ", "Mao ", "Fu ", "Chun ", "Tu ", "Yan ", "He ", "Yuan ", "Pian ", "Yun ", "Mei ", "Hu ", "Ying ", "Dun ", "Mu ", "Ju ", "Tsugumi ", "Cang ", "Fang ", "Gu ", "Ying ", "Yuan ", "Xuan ", "Weng ", "Shi ", "He ", "Chu ", "Tang ", "Xia ", "Ruo ", "Liu ", "Ji ", "Gu ", "Jian ", "Zhun ", "Han ", "Zi ", "Zi ", "Ni ", "Yao ", "Yan ", "Ji ", "Li ", "Tian ", "Kou ", "Ti ", "Ti ", "Ni ", "Tu ", "Ma ", "Jiao ", "Gao ", "Tian ", "Chen ", "Li ", "Zhuan ", "Zhe ", "Ao ", "Yao ", "Yi ", "Ou ", "Chi ", "Zhi ", "Liao ", "Rong ", "Lou ", "Bi ", "Shuang ", "Zhuo ", "Yu ", "Wu ", "Jue ", "Yin ", "Quan ", "Si ", "Jiao ", "Yi ", "Hua ", "Bi ", "Ying ", "Su ", "Huang ", "Fan ", "Jiao ", "Liao ", "Yan ", "Kao ", "Jiu ", "Xian ", "Xian ", "Tu ", "Mai ", "Zun ", "Yu ", "Ying ", "Lu ", "Tuan ", "Xian ", "Xue ", "Yi ", "Pi "];
  }
});

// node_modules/unidecode/data/x9e.js
var require_x9e = __commonJS({
  "node_modules/unidecode/data/x9e.js"(exports, module2) {
    module2.exports = ["Shu ", "Luo ", "Qi ", "Yi ", "Ji ", "Zhe ", "Yu ", "Zhan ", "Ye ", "Yang ", "Pi ", "Ning ", "Huo ", "Mi ", "Ying ", "Meng ", "Di ", "Yue ", "Yu ", "Lei ", "Bao ", "Lu ", "He ", "Long ", "Shuang ", "Yue ", "Ying ", "Guan ", "Qu ", "Li ", "Luan ", "Niao ", "Jiu ", "Ji ", "Yuan ", "Ming ", "Shi ", "Ou ", "Ya ", "Cang ", "Bao ", "Zhen ", "Gu ", "Dong ", "Lu ", "Ya ", "Xiao ", "Yang ", "Ling ", "Zhi ", "Qu ", "Yuan ", "Xue ", "Tuo ", "Si ", "Zhi ", "Er ", "Gua ", "Xiu ", "Heng ", "Zhou ", "Ge ", "Luan ", "Hong ", "Wu ", "Bo ", "Li ", "Juan ", "Hu ", "E ", "Yu ", "Xian ", "Ti ", "Wu ", "Que ", "Miao ", "An ", "Kun ", "Bei ", "Peng ", "Qian ", "Chun ", "Geng ", "Yuan ", "Su ", "Hu ", "He ", "E ", "Gu ", "Qiu ", "Zi ", "Mei ", "Mu ", "Ni ", "Yao ", "Weng ", "Liu ", "Ji ", "Ni ", "Jian ", "He ", "Yi ", "Ying ", "Zhe ", "Liao ", "Liao ", "Jiao ", "Jiu ", "Yu ", "Lu ", "Xuan ", "Zhan ", "Ying ", "Huo ", "Meng ", "Guan ", "Shuang ", "Lu ", "Jin ", "Ling ", "Jian ", "Xian ", "Cuo ", "Jian ", "Jian ", "Yan ", "Cuo ", "Lu ", "You ", "Cu ", "Ji ", "Biao ", "Cu ", "Biao ", "Zhu ", "Jun ", "Zhu ", "Jian ", "Mi ", "Mi ", "Wu ", "Liu ", "Chen ", "Jun ", "Lin ", "Ni ", "Qi ", "Lu ", "Jiu ", "Jun ", "Jing ", "Li ", "Xiang ", "Yan ", "Jia ", "Mi ", "Li ", "She ", "Zhang ", "Lin ", "Jing ", "Ji ", "Ling ", "Yan ", "Cu ", "Mai ", "Mai ", "Ge ", "Chao ", "Fu ", "Mian ", "Mian ", "Fu ", "Pao ", "Qu ", "Qu ", "Mou ", "Fu ", "Xian ", "Lai ", "Qu ", "Mian ", "[?] ", "Feng ", "Fu ", "Qu ", "Mian ", "Ma ", "Mo ", "Mo ", "Hui ", "Ma ", "Zou ", "Nen ", "Fen ", "Huang ", "Huang ", "Jin ", "Guang ", "Tian ", "Tou ", "Heng ", "Xi ", "Kuang ", "Heng ", "Shu ", "Li ", "Nian ", "Chi ", "Hei ", "Hei ", "Yi ", "Qian ", "Dan ", "Xi ", "Tuan ", "Mo ", "Mo ", "Qian ", "Dai ", "Chu ", "You ", "Dian ", "Yi ", "Xia ", "Yan ", "Qu ", "Mei ", "Yan ", "Jing ", "Yu ", "Li ", "Dang ", "Du ", "Can ", "Yin ", "An ", "Yan ", "Tan ", "An ", "Zhen ", "Dai ", "Can ", "Yi ", "Mei ", "Dan ", "Yan ", "Du ", "Lu ", "Zhi ", "Fen ", "Fu ", "Fu ", "Min ", "Min ", "Yuan "];
  }
});

// node_modules/unidecode/data/x9f.js
var require_x9f = __commonJS({
  "node_modules/unidecode/data/x9f.js"(exports, module2) {
    module2.exports = ["Cu ", "Qu ", "Chao ", "Wa ", "Zhu ", "Zhi ", "Mang ", "Ao ", "Bie ", "Tuo ", "Bi ", "Yuan ", "Chao ", "Tuo ", "Ding ", "Mi ", "Nai ", "Ding ", "Zi ", "Gu ", "Gu ", "Dong ", "Fen ", "Tao ", "Yuan ", "Pi ", "Chang ", "Gao ", "Qi ", "Yuan ", "Tang ", "Teng ", "Shu ", "Shu ", "Fen ", "Fei ", "Wen ", "Ba ", "Diao ", "Tuo ", "Tong ", "Qu ", "Sheng ", "Shi ", "You ", "Shi ", "Ting ", "Wu ", "Nian ", "Jing ", "Hun ", "Ju ", "Yan ", "Tu ", "Ti ", "Xi ", "Xian ", "Yan ", "Lei ", "Bi ", "Yao ", "Qiu ", "Han ", "Wu ", "Wu ", "Hou ", "Xi ", "Ge ", "Zha ", "Xiu ", "Weng ", "Zha ", "Nong ", "Nang ", "Qi ", "Zhai ", "Ji ", "Zi ", "Ji ", "Ji ", "Qi ", "Ji ", "Chi ", "Chen ", "Chen ", "He ", "Ya ", "Ken ", "Xie ", "Pao ", "Cuo ", "Shi ", "Zi ", "Chi ", "Nian ", "Ju ", "Tiao ", "Ling ", "Ling ", "Chu ", "Quan ", "Xie ", "Ken ", "Nie ", "Jiu ", "Yao ", "Chuo ", "Kun ", "Yu ", "Chu ", "Yi ", "Ni ", "Cuo ", "Zou ", "Qu ", "Nen ", "Xian ", "Ou ", "E ", "Wo ", "Yi ", "Chuo ", "Zou ", "Dian ", "Chu ", "Jin ", "Ya ", "Chi ", "Chen ", "He ", "Ken ", "Ju ", "Ling ", "Pao ", "Tiao ", "Zi ", "Ken ", "Yu ", "Chuo ", "Qu ", "Wo ", "Long ", "Pang ", "Gong ", "Pang ", "Yan ", "Long ", "Long ", "Gong ", "Kan ", "Ta ", "Ling ", "Ta ", "Long ", "Gong ", "Kan ", "Gui ", "Qiu ", "Bie ", "Gui ", "Yue ", "Chui ", "He ", "Jue ", "Xie ", "Yu ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xa0.js
var require_xa0 = __commonJS({
  "node_modules/unidecode/data/xa0.js"(exports, module2) {
    module2.exports = ["it", "ix", "i", "ip", "iet", "iex", "ie", "iep", "at", "ax", "a", "ap", "uox", "uo", "uop", "ot", "ox", "o", "op", "ex", "e", "wu", "bit", "bix", "bi", "bip", "biet", "biex", "bie", "biep", "bat", "bax", "ba", "bap", "buox", "buo", "buop", "bot", "box", "bo", "bop", "bex", "be", "bep", "but", "bux", "bu", "bup", "burx", "bur", "byt", "byx", "by", "byp", "byrx", "byr", "pit", "pix", "pi", "pip", "piex", "pie", "piep", "pat", "pax", "pa", "pap", "puox", "puo", "puop", "pot", "pox", "po", "pop", "put", "pux", "pu", "pup", "purx", "pur", "pyt", "pyx", "py", "pyp", "pyrx", "pyr", "bbit", "bbix", "bbi", "bbip", "bbiet", "bbiex", "bbie", "bbiep", "bbat", "bbax", "bba", "bbap", "bbuox", "bbuo", "bbuop", "bbot", "bbox", "bbo", "bbop", "bbex", "bbe", "bbep", "bbut", "bbux", "bbu", "bbup", "bburx", "bbur", "bbyt", "bbyx", "bby", "bbyp", "nbit", "nbix", "nbi", "nbip", "nbiex", "nbie", "nbiep", "nbat", "nbax", "nba", "nbap", "nbot", "nbox", "nbo", "nbop", "nbut", "nbux", "nbu", "nbup", "nburx", "nbur", "nbyt", "nbyx", "nby", "nbyp", "nbyrx", "nbyr", "hmit", "hmix", "hmi", "hmip", "hmiex", "hmie", "hmiep", "hmat", "hmax", "hma", "hmap", "hmuox", "hmuo", "hmuop", "hmot", "hmox", "hmo", "hmop", "hmut", "hmux", "hmu", "hmup", "hmurx", "hmur", "hmyx", "hmy", "hmyp", "hmyrx", "hmyr", "mit", "mix", "mi", "mip", "miex", "mie", "miep", "mat", "max", "ma", "map", "muot", "muox", "muo", "muop", "mot", "mox", "mo", "mop", "mex", "me", "mut", "mux", "mu", "mup", "murx", "mur", "myt", "myx", "my", "myp", "fit", "fix", "fi", "fip", "fat", "fax", "fa", "fap", "fox", "fo", "fop", "fut", "fux", "fu", "fup", "furx", "fur", "fyt", "fyx", "fy", "fyp", "vit", "vix", "vi", "vip", "viet", "viex", "vie", "viep", "vat", "vax", "va", "vap", "vot", "vox", "vo", "vop", "vex", "vep", "vut", "vux", "vu", "vup", "vurx", "vur", "vyt", "vyx", "vy", "vyp", "vyrx", "vyr"];
  }
});

// node_modules/unidecode/data/xa1.js
var require_xa1 = __commonJS({
  "node_modules/unidecode/data/xa1.js"(exports, module2) {
    module2.exports = ["dit", "dix", "di", "dip", "diex", "die", "diep", "dat", "dax", "da", "dap", "duox", "duo", "dot", "dox", "do", "dop", "dex", "de", "dep", "dut", "dux", "du", "dup", "durx", "dur", "tit", "tix", "ti", "tip", "tiex", "tie", "tiep", "tat", "tax", "ta", "tap", "tuot", "tuox", "tuo", "tuop", "tot", "tox", "to", "top", "tex", "te", "tep", "tut", "tux", "tu", "tup", "turx", "tur", "ddit", "ddix", "ddi", "ddip", "ddiex", "ddie", "ddiep", "ddat", "ddax", "dda", "ddap", "dduox", "dduo", "dduop", "ddot", "ddox", "ddo", "ddop", "ddex", "dde", "ddep", "ddut", "ddux", "ddu", "ddup", "ddurx", "ddur", "ndit", "ndix", "ndi", "ndip", "ndiex", "ndie", "ndat", "ndax", "nda", "ndap", "ndot", "ndox", "ndo", "ndop", "ndex", "nde", "ndep", "ndut", "ndux", "ndu", "ndup", "ndurx", "ndur", "hnit", "hnix", "hni", "hnip", "hniet", "hniex", "hnie", "hniep", "hnat", "hnax", "hna", "hnap", "hnuox", "hnuo", "hnot", "hnox", "hnop", "hnex", "hne", "hnep", "hnut", "nit", "nix", "ni", "nip", "niex", "nie", "niep", "nax", "na", "nap", "nuox", "nuo", "nuop", "not", "nox", "no", "nop", "nex", "ne", "nep", "nut", "nux", "nu", "nup", "nurx", "nur", "hlit", "hlix", "hli", "hlip", "hliex", "hlie", "hliep", "hlat", "hlax", "hla", "hlap", "hluox", "hluo", "hluop", "hlox", "hlo", "hlop", "hlex", "hle", "hlep", "hlut", "hlux", "hlu", "hlup", "hlurx", "hlur", "hlyt", "hlyx", "hly", "hlyp", "hlyrx", "hlyr", "lit", "lix", "li", "lip", "liet", "liex", "lie", "liep", "lat", "lax", "la", "lap", "luot", "luox", "luo", "luop", "lot", "lox", "lo", "lop", "lex", "le", "lep", "lut", "lux", "lu", "lup", "lurx", "lur", "lyt", "lyx", "ly", "lyp", "lyrx", "lyr", "git", "gix", "gi", "gip", "giet", "giex", "gie", "giep", "gat", "gax", "ga", "gap", "guot", "guox", "guo", "guop", "got", "gox", "go", "gop", "get", "gex", "ge", "gep", "gut", "gux", "gu", "gup", "gurx", "gur", "kit", "kix", "ki", "kip", "kiex", "kie", "kiep", "kat"];
  }
});

// node_modules/unidecode/data/xa2.js
var require_xa2 = __commonJS({
  "node_modules/unidecode/data/xa2.js"(exports, module2) {
    module2.exports = ["kax", "ka", "kap", "kuox", "kuo", "kuop", "kot", "kox", "ko", "kop", "ket", "kex", "ke", "kep", "kut", "kux", "ku", "kup", "kurx", "kur", "ggit", "ggix", "ggi", "ggiex", "ggie", "ggiep", "ggat", "ggax", "gga", "ggap", "gguot", "gguox", "gguo", "gguop", "ggot", "ggox", "ggo", "ggop", "gget", "ggex", "gge", "ggep", "ggut", "ggux", "ggu", "ggup", "ggurx", "ggur", "mgiex", "mgie", "mgat", "mgax", "mga", "mgap", "mguox", "mguo", "mguop", "mgot", "mgox", "mgo", "mgop", "mgex", "mge", "mgep", "mgut", "mgux", "mgu", "mgup", "mgurx", "mgur", "hxit", "hxix", "hxi", "hxip", "hxiet", "hxiex", "hxie", "hxiep", "hxat", "hxax", "hxa", "hxap", "hxuot", "hxuox", "hxuo", "hxuop", "hxot", "hxox", "hxo", "hxop", "hxex", "hxe", "hxep", "ngiex", "ngie", "ngiep", "ngat", "ngax", "nga", "ngap", "nguot", "nguox", "nguo", "ngot", "ngox", "ngo", "ngop", "ngex", "nge", "ngep", "hit", "hiex", "hie", "hat", "hax", "ha", "hap", "huot", "huox", "huo", "huop", "hot", "hox", "ho", "hop", "hex", "he", "hep", "wat", "wax", "wa", "wap", "wuox", "wuo", "wuop", "wox", "wo", "wop", "wex", "we", "wep", "zit", "zix", "zi", "zip", "ziex", "zie", "ziep", "zat", "zax", "za", "zap", "zuox", "zuo", "zuop", "zot", "zox", "zo", "zop", "zex", "ze", "zep", "zut", "zux", "zu", "zup", "zurx", "zur", "zyt", "zyx", "zy", "zyp", "zyrx", "zyr", "cit", "cix", "ci", "cip", "ciet", "ciex", "cie", "ciep", "cat", "cax", "ca", "cap", "cuox", "cuo", "cuop", "cot", "cox", "co", "cop", "cex", "ce", "cep", "cut", "cux", "cu", "cup", "curx", "cur", "cyt", "cyx", "cy", "cyp", "cyrx", "cyr", "zzit", "zzix", "zzi", "zzip", "zziet", "zziex", "zzie", "zziep", "zzat", "zzax", "zza", "zzap", "zzox", "zzo", "zzop", "zzex", "zze", "zzep", "zzux", "zzu", "zzup", "zzurx", "zzur", "zzyt", "zzyx", "zzy", "zzyp", "zzyrx", "zzyr", "nzit", "nzix", "nzi", "nzip", "nziex", "nzie", "nziep", "nzat", "nzax", "nza", "nzap", "nzuox", "nzuo", "nzox", "nzop", "nzex", "nze", "nzux", "nzu"];
  }
});

// node_modules/unidecode/data/xa3.js
var require_xa3 = __commonJS({
  "node_modules/unidecode/data/xa3.js"(exports, module2) {
    module2.exports = ["nzup", "nzurx", "nzur", "nzyt", "nzyx", "nzy", "nzyp", "nzyrx", "nzyr", "sit", "six", "si", "sip", "siex", "sie", "siep", "sat", "sax", "sa", "sap", "suox", "suo", "suop", "sot", "sox", "so", "sop", "sex", "se", "sep", "sut", "sux", "su", "sup", "surx", "sur", "syt", "syx", "sy", "syp", "syrx", "syr", "ssit", "ssix", "ssi", "ssip", "ssiex", "ssie", "ssiep", "ssat", "ssax", "ssa", "ssap", "ssot", "ssox", "sso", "ssop", "ssex", "sse", "ssep", "ssut", "ssux", "ssu", "ssup", "ssyt", "ssyx", "ssy", "ssyp", "ssyrx", "ssyr", "zhat", "zhax", "zha", "zhap", "zhuox", "zhuo", "zhuop", "zhot", "zhox", "zho", "zhop", "zhet", "zhex", "zhe", "zhep", "zhut", "zhux", "zhu", "zhup", "zhurx", "zhur", "zhyt", "zhyx", "zhy", "zhyp", "zhyrx", "zhyr", "chat", "chax", "cha", "chap", "chuot", "chuox", "chuo", "chuop", "chot", "chox", "cho", "chop", "chet", "chex", "che", "chep", "chux", "chu", "chup", "churx", "chur", "chyt", "chyx", "chy", "chyp", "chyrx", "chyr", "rrax", "rra", "rruox", "rruo", "rrot", "rrox", "rro", "rrop", "rret", "rrex", "rre", "rrep", "rrut", "rrux", "rru", "rrup", "rrurx", "rrur", "rryt", "rryx", "rry", "rryp", "rryrx", "rryr", "nrat", "nrax", "nra", "nrap", "nrox", "nro", "nrop", "nret", "nrex", "nre", "nrep", "nrut", "nrux", "nru", "nrup", "nrurx", "nrur", "nryt", "nryx", "nry", "nryp", "nryrx", "nryr", "shat", "shax", "sha", "shap", "shuox", "shuo", "shuop", "shot", "shox", "sho", "shop", "shet", "shex", "she", "shep", "shut", "shux", "shu", "shup", "shurx", "shur", "shyt", "shyx", "shy", "shyp", "shyrx", "shyr", "rat", "rax", "ra", "rap", "ruox", "ruo", "ruop", "rot", "rox", "ro", "rop", "rex", "re", "rep", "rut", "rux", "ru", "rup", "rurx", "rur", "ryt", "ryx", "ry", "ryp", "ryrx", "ryr", "jit", "jix", "ji", "jip", "jiet", "jiex", "jie", "jiep", "juot", "juox", "juo", "juop", "jot", "jox", "jo", "jop", "jut", "jux", "ju", "jup", "jurx", "jur", "jyt", "jyx", "jy", "jyp", "jyrx", "jyr", "qit", "qix", "qi", "qip"];
  }
});

// node_modules/unidecode/data/xa4.js
var require_xa4 = __commonJS({
  "node_modules/unidecode/data/xa4.js"(exports, module2) {
    module2.exports = ["qiet", "qiex", "qie", "qiep", "quot", "quox", "quo", "quop", "qot", "qox", "qo", "qop", "qut", "qux", "qu", "qup", "qurx", "qur", "qyt", "qyx", "qy", "qyp", "qyrx", "qyr", "jjit", "jjix", "jji", "jjip", "jjiet", "jjiex", "jjie", "jjiep", "jjuox", "jjuo", "jjuop", "jjot", "jjox", "jjo", "jjop", "jjut", "jjux", "jju", "jjup", "jjurx", "jjur", "jjyt", "jjyx", "jjy", "jjyp", "njit", "njix", "nji", "njip", "njiet", "njiex", "njie", "njiep", "njuox", "njuo", "njot", "njox", "njo", "njop", "njux", "nju", "njup", "njurx", "njur", "njyt", "njyx", "njy", "njyp", "njyrx", "njyr", "nyit", "nyix", "nyi", "nyip", "nyiet", "nyiex", "nyie", "nyiep", "nyuox", "nyuo", "nyuop", "nyot", "nyox", "nyo", "nyop", "nyut", "nyux", "nyu", "nyup", "xit", "xix", "xi", "xip", "xiet", "xiex", "xie", "xiep", "xuox", "xuo", "xot", "xox", "xo", "xop", "xyt", "xyx", "xy", "xyp", "xyrx", "xyr", "yit", "yix", "yi", "yip", "yiet", "yiex", "yie", "yiep", "yuot", "yuox", "yuo", "yuop", "yot", "yox", "yo", "yop", "yut", "yux", "yu", "yup", "yurx", "yur", "yyt", "yyx", "yy", "yyp", "yyrx", "yyr", "[?]", "[?]", "[?]", "Qot", "Li", "Kit", "Nyip", "Cyp", "Ssi", "Ggop", "Gep", "Mi", "Hxit", "Lyr", "Bbut", "Mop", "Yo", "Put", "Hxuo", "Tat", "Ga", "[?]", "[?]", "Ddur", "Bur", "Gguo", "Nyop", "Tu", "Op", "Jjut", "Zot", "Pyt", "Hmo", "Yit", "Vur", "Shy", "Vep", "Za", "Jo", "[?]", "Jjy", "Got", "Jjie", "Wo", "Du", "Shur", "Lie", "Cy", "Cuop", "Cip", "Hxop", "Shat", "[?]", "Shop", "Che", "Zziet", "[?]", "Ke", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xac.js
var require_xac = __commonJS({
  "node_modules/unidecode/data/xac.js"(exports, module2) {
    module2.exports = ["ga", "gag", "gagg", "gags", "gan", "ganj", "ganh", "gad", "gal", "galg", "galm", "galb", "gals", "galt", "galp", "galh", "gam", "gab", "gabs", "gas", "gass", "gang", "gaj", "gac", "gak", "gat", "gap", "gah", "gae", "gaeg", "gaegg", "gaegs", "gaen", "gaenj", "gaenh", "gaed", "gael", "gaelg", "gaelm", "gaelb", "gaels", "gaelt", "gaelp", "gaelh", "gaem", "gaeb", "gaebs", "gaes", "gaess", "gaeng", "gaej", "gaec", "gaek", "gaet", "gaep", "gaeh", "gya", "gyag", "gyagg", "gyags", "gyan", "gyanj", "gyanh", "gyad", "gyal", "gyalg", "gyalm", "gyalb", "gyals", "gyalt", "gyalp", "gyalh", "gyam", "gyab", "gyabs", "gyas", "gyass", "gyang", "gyaj", "gyac", "gyak", "gyat", "gyap", "gyah", "gyae", "gyaeg", "gyaegg", "gyaegs", "gyaen", "gyaenj", "gyaenh", "gyaed", "gyael", "gyaelg", "gyaelm", "gyaelb", "gyaels", "gyaelt", "gyaelp", "gyaelh", "gyaem", "gyaeb", "gyaebs", "gyaes", "gyaess", "gyaeng", "gyaej", "gyaec", "gyaek", "gyaet", "gyaep", "gyaeh", "geo", "geog", "geogg", "geogs", "geon", "geonj", "geonh", "geod", "geol", "geolg", "geolm", "geolb", "geols", "geolt", "geolp", "geolh", "geom", "geob", "geobs", "geos", "geoss", "geong", "geoj", "geoc", "geok", "geot", "geop", "geoh", "ge", "geg", "gegg", "gegs", "gen", "genj", "genh", "ged", "gel", "gelg", "gelm", "gelb", "gels", "gelt", "gelp", "gelh", "gem", "geb", "gebs", "ges", "gess", "geng", "gej", "gec", "gek", "get", "gep", "geh", "gyeo", "gyeog", "gyeogg", "gyeogs", "gyeon", "gyeonj", "gyeonh", "gyeod", "gyeol", "gyeolg", "gyeolm", "gyeolb", "gyeols", "gyeolt", "gyeolp", "gyeolh", "gyeom", "gyeob", "gyeobs", "gyeos", "gyeoss", "gyeong", "gyeoj", "gyeoc", "gyeok", "gyeot", "gyeop", "gyeoh", "gye", "gyeg", "gyegg", "gyegs", "gyen", "gyenj", "gyenh", "gyed", "gyel", "gyelg", "gyelm", "gyelb", "gyels", "gyelt", "gyelp", "gyelh", "gyem", "gyeb", "gyebs", "gyes", "gyess", "gyeng", "gyej", "gyec", "gyek", "gyet", "gyep", "gyeh", "go", "gog", "gogg", "gogs", "gon", "gonj", "gonh", "god", "gol", "golg", "golm", "golb", "gols", "golt", "golp", "golh", "gom", "gob", "gobs", "gos", "goss", "gong", "goj", "goc", "gok", "got", "gop", "goh", "gwa", "gwag", "gwagg", "gwags"];
  }
});

// node_modules/unidecode/data/xad.js
var require_xad = __commonJS({
  "node_modules/unidecode/data/xad.js"(exports, module2) {
    module2.exports = ["gwan", "gwanj", "gwanh", "gwad", "gwal", "gwalg", "gwalm", "gwalb", "gwals", "gwalt", "gwalp", "gwalh", "gwam", "gwab", "gwabs", "gwas", "gwass", "gwang", "gwaj", "gwac", "gwak", "gwat", "gwap", "gwah", "gwae", "gwaeg", "gwaegg", "gwaegs", "gwaen", "gwaenj", "gwaenh", "gwaed", "gwael", "gwaelg", "gwaelm", "gwaelb", "gwaels", "gwaelt", "gwaelp", "gwaelh", "gwaem", "gwaeb", "gwaebs", "gwaes", "gwaess", "gwaeng", "gwaej", "gwaec", "gwaek", "gwaet", "gwaep", "gwaeh", "goe", "goeg", "goegg", "goegs", "goen", "goenj", "goenh", "goed", "goel", "goelg", "goelm", "goelb", "goels", "goelt", "goelp", "goelh", "goem", "goeb", "goebs", "goes", "goess", "goeng", "goej", "goec", "goek", "goet", "goep", "goeh", "gyo", "gyog", "gyogg", "gyogs", "gyon", "gyonj", "gyonh", "gyod", "gyol", "gyolg", "gyolm", "gyolb", "gyols", "gyolt", "gyolp", "gyolh", "gyom", "gyob", "gyobs", "gyos", "gyoss", "gyong", "gyoj", "gyoc", "gyok", "gyot", "gyop", "gyoh", "gu", "gug", "gugg", "gugs", "gun", "gunj", "gunh", "gud", "gul", "gulg", "gulm", "gulb", "guls", "gult", "gulp", "gulh", "gum", "gub", "gubs", "gus", "guss", "gung", "guj", "guc", "guk", "gut", "gup", "guh", "gweo", "gweog", "gweogg", "gweogs", "gweon", "gweonj", "gweonh", "gweod", "gweol", "gweolg", "gweolm", "gweolb", "gweols", "gweolt", "gweolp", "gweolh", "gweom", "gweob", "gweobs", "gweos", "gweoss", "gweong", "gweoj", "gweoc", "gweok", "gweot", "gweop", "gweoh", "gwe", "gweg", "gwegg", "gwegs", "gwen", "gwenj", "gwenh", "gwed", "gwel", "gwelg", "gwelm", "gwelb", "gwels", "gwelt", "gwelp", "gwelh", "gwem", "gweb", "gwebs", "gwes", "gwess", "gweng", "gwej", "gwec", "gwek", "gwet", "gwep", "gweh", "gwi", "gwig", "gwigg", "gwigs", "gwin", "gwinj", "gwinh", "gwid", "gwil", "gwilg", "gwilm", "gwilb", "gwils", "gwilt", "gwilp", "gwilh", "gwim", "gwib", "gwibs", "gwis", "gwiss", "gwing", "gwij", "gwic", "gwik", "gwit", "gwip", "gwih", "gyu", "gyug", "gyugg", "gyugs", "gyun", "gyunj", "gyunh", "gyud", "gyul", "gyulg", "gyulm", "gyulb", "gyuls", "gyult", "gyulp", "gyulh", "gyum", "gyub", "gyubs", "gyus", "gyuss", "gyung", "gyuj", "gyuc", "gyuk", "gyut", "gyup", "gyuh", "geu", "geug", "geugg", "geugs", "geun", "geunj", "geunh", "geud"];
  }
});

// node_modules/unidecode/data/xae.js
var require_xae = __commonJS({
  "node_modules/unidecode/data/xae.js"(exports, module2) {
    module2.exports = ["geul", "geulg", "geulm", "geulb", "geuls", "geult", "geulp", "geulh", "geum", "geub", "geubs", "geus", "geuss", "geung", "geuj", "geuc", "geuk", "geut", "geup", "geuh", "gyi", "gyig", "gyigg", "gyigs", "gyin", "gyinj", "gyinh", "gyid", "gyil", "gyilg", "gyilm", "gyilb", "gyils", "gyilt", "gyilp", "gyilh", "gyim", "gyib", "gyibs", "gyis", "gyiss", "gying", "gyij", "gyic", "gyik", "gyit", "gyip", "gyih", "gi", "gig", "gigg", "gigs", "gin", "ginj", "ginh", "gid", "gil", "gilg", "gilm", "gilb", "gils", "gilt", "gilp", "gilh", "gim", "gib", "gibs", "gis", "giss", "ging", "gij", "gic", "gik", "git", "gip", "gih", "gga", "ggag", "ggagg", "ggags", "ggan", "gganj", "gganh", "ggad", "ggal", "ggalg", "ggalm", "ggalb", "ggals", "ggalt", "ggalp", "ggalh", "ggam", "ggab", "ggabs", "ggas", "ggass", "ggang", "ggaj", "ggac", "ggak", "ggat", "ggap", "ggah", "ggae", "ggaeg", "ggaegg", "ggaegs", "ggaen", "ggaenj", "ggaenh", "ggaed", "ggael", "ggaelg", "ggaelm", "ggaelb", "ggaels", "ggaelt", "ggaelp", "ggaelh", "ggaem", "ggaeb", "ggaebs", "ggaes", "ggaess", "ggaeng", "ggaej", "ggaec", "ggaek", "ggaet", "ggaep", "ggaeh", "ggya", "ggyag", "ggyagg", "ggyags", "ggyan", "ggyanj", "ggyanh", "ggyad", "ggyal", "ggyalg", "ggyalm", "ggyalb", "ggyals", "ggyalt", "ggyalp", "ggyalh", "ggyam", "ggyab", "ggyabs", "ggyas", "ggyass", "ggyang", "ggyaj", "ggyac", "ggyak", "ggyat", "ggyap", "ggyah", "ggyae", "ggyaeg", "ggyaegg", "ggyaegs", "ggyaen", "ggyaenj", "ggyaenh", "ggyaed", "ggyael", "ggyaelg", "ggyaelm", "ggyaelb", "ggyaels", "ggyaelt", "ggyaelp", "ggyaelh", "ggyaem", "ggyaeb", "ggyaebs", "ggyaes", "ggyaess", "ggyaeng", "ggyaej", "ggyaec", "ggyaek", "ggyaet", "ggyaep", "ggyaeh", "ggeo", "ggeog", "ggeogg", "ggeogs", "ggeon", "ggeonj", "ggeonh", "ggeod", "ggeol", "ggeolg", "ggeolm", "ggeolb", "ggeols", "ggeolt", "ggeolp", "ggeolh", "ggeom", "ggeob", "ggeobs", "ggeos", "ggeoss", "ggeong", "ggeoj", "ggeoc", "ggeok", "ggeot", "ggeop", "ggeoh", "gge", "ggeg", "ggegg", "ggegs", "ggen", "ggenj", "ggenh", "gged", "ggel", "ggelg", "ggelm", "ggelb", "ggels", "ggelt", "ggelp", "ggelh", "ggem", "ggeb", "ggebs", "gges", "ggess", "ggeng", "ggej", "ggec", "ggek", "gget", "ggep", "ggeh", "ggyeo", "ggyeog", "ggyeogg", "ggyeogs", "ggyeon", "ggyeonj", "ggyeonh", "ggyeod", "ggyeol", "ggyeolg", "ggyeolm", "ggyeolb"];
  }
});

// node_modules/unidecode/data/xaf.js
var require_xaf = __commonJS({
  "node_modules/unidecode/data/xaf.js"(exports, module2) {
    module2.exports = ["ggyeols", "ggyeolt", "ggyeolp", "ggyeolh", "ggyeom", "ggyeob", "ggyeobs", "ggyeos", "ggyeoss", "ggyeong", "ggyeoj", "ggyeoc", "ggyeok", "ggyeot", "ggyeop", "ggyeoh", "ggye", "ggyeg", "ggyegg", "ggyegs", "ggyen", "ggyenj", "ggyenh", "ggyed", "ggyel", "ggyelg", "ggyelm", "ggyelb", "ggyels", "ggyelt", "ggyelp", "ggyelh", "ggyem", "ggyeb", "ggyebs", "ggyes", "ggyess", "ggyeng", "ggyej", "ggyec", "ggyek", "ggyet", "ggyep", "ggyeh", "ggo", "ggog", "ggogg", "ggogs", "ggon", "ggonj", "ggonh", "ggod", "ggol", "ggolg", "ggolm", "ggolb", "ggols", "ggolt", "ggolp", "ggolh", "ggom", "ggob", "ggobs", "ggos", "ggoss", "ggong", "ggoj", "ggoc", "ggok", "ggot", "ggop", "ggoh", "ggwa", "ggwag", "ggwagg", "ggwags", "ggwan", "ggwanj", "ggwanh", "ggwad", "ggwal", "ggwalg", "ggwalm", "ggwalb", "ggwals", "ggwalt", "ggwalp", "ggwalh", "ggwam", "ggwab", "ggwabs", "ggwas", "ggwass", "ggwang", "ggwaj", "ggwac", "ggwak", "ggwat", "ggwap", "ggwah", "ggwae", "ggwaeg", "ggwaegg", "ggwaegs", "ggwaen", "ggwaenj", "ggwaenh", "ggwaed", "ggwael", "ggwaelg", "ggwaelm", "ggwaelb", "ggwaels", "ggwaelt", "ggwaelp", "ggwaelh", "ggwaem", "ggwaeb", "ggwaebs", "ggwaes", "ggwaess", "ggwaeng", "ggwaej", "ggwaec", "ggwaek", "ggwaet", "ggwaep", "ggwaeh", "ggoe", "ggoeg", "ggoegg", "ggoegs", "ggoen", "ggoenj", "ggoenh", "ggoed", "ggoel", "ggoelg", "ggoelm", "ggoelb", "ggoels", "ggoelt", "ggoelp", "ggoelh", "ggoem", "ggoeb", "ggoebs", "ggoes", "ggoess", "ggoeng", "ggoej", "ggoec", "ggoek", "ggoet", "ggoep", "ggoeh", "ggyo", "ggyog", "ggyogg", "ggyogs", "ggyon", "ggyonj", "ggyonh", "ggyod", "ggyol", "ggyolg", "ggyolm", "ggyolb", "ggyols", "ggyolt", "ggyolp", "ggyolh", "ggyom", "ggyob", "ggyobs", "ggyos", "ggyoss", "ggyong", "ggyoj", "ggyoc", "ggyok", "ggyot", "ggyop", "ggyoh", "ggu", "ggug", "ggugg", "ggugs", "ggun", "ggunj", "ggunh", "ggud", "ggul", "ggulg", "ggulm", "ggulb", "gguls", "ggult", "ggulp", "ggulh", "ggum", "ggub", "ggubs", "ggus", "gguss", "ggung", "gguj", "gguc", "gguk", "ggut", "ggup", "gguh", "ggweo", "ggweog", "ggweogg", "ggweogs", "ggweon", "ggweonj", "ggweonh", "ggweod", "ggweol", "ggweolg", "ggweolm", "ggweolb", "ggweols", "ggweolt", "ggweolp", "ggweolh", "ggweom", "ggweob", "ggweobs", "ggweos", "ggweoss", "ggweong", "ggweoj", "ggweoc", "ggweok", "ggweot", "ggweop", "ggweoh", "ggwe", "ggweg", "ggwegg", "ggwegs", "ggwen", "ggwenj", "ggwenh", "ggwed", "ggwel", "ggwelg", "ggwelm", "ggwelb", "ggwels", "ggwelt", "ggwelp", "ggwelh"];
  }
});

// node_modules/unidecode/data/xb0.js
var require_xb0 = __commonJS({
  "node_modules/unidecode/data/xb0.js"(exports, module2) {
    module2.exports = ["ggwem", "ggweb", "ggwebs", "ggwes", "ggwess", "ggweng", "ggwej", "ggwec", "ggwek", "ggwet", "ggwep", "ggweh", "ggwi", "ggwig", "ggwigg", "ggwigs", "ggwin", "ggwinj", "ggwinh", "ggwid", "ggwil", "ggwilg", "ggwilm", "ggwilb", "ggwils", "ggwilt", "ggwilp", "ggwilh", "ggwim", "ggwib", "ggwibs", "ggwis", "ggwiss", "ggwing", "ggwij", "ggwic", "ggwik", "ggwit", "ggwip", "ggwih", "ggyu", "ggyug", "ggyugg", "ggyugs", "ggyun", "ggyunj", "ggyunh", "ggyud", "ggyul", "ggyulg", "ggyulm", "ggyulb", "ggyuls", "ggyult", "ggyulp", "ggyulh", "ggyum", "ggyub", "ggyubs", "ggyus", "ggyuss", "ggyung", "ggyuj", "ggyuc", "ggyuk", "ggyut", "ggyup", "ggyuh", "ggeu", "ggeug", "ggeugg", "ggeugs", "ggeun", "ggeunj", "ggeunh", "ggeud", "ggeul", "ggeulg", "ggeulm", "ggeulb", "ggeuls", "ggeult", "ggeulp", "ggeulh", "ggeum", "ggeub", "ggeubs", "ggeus", "ggeuss", "ggeung", "ggeuj", "ggeuc", "ggeuk", "ggeut", "ggeup", "ggeuh", "ggyi", "ggyig", "ggyigg", "ggyigs", "ggyin", "ggyinj", "ggyinh", "ggyid", "ggyil", "ggyilg", "ggyilm", "ggyilb", "ggyils", "ggyilt", "ggyilp", "ggyilh", "ggyim", "ggyib", "ggyibs", "ggyis", "ggyiss", "ggying", "ggyij", "ggyic", "ggyik", "ggyit", "ggyip", "ggyih", "ggi", "ggig", "ggigg", "ggigs", "ggin", "gginj", "gginh", "ggid", "ggil", "ggilg", "ggilm", "ggilb", "ggils", "ggilt", "ggilp", "ggilh", "ggim", "ggib", "ggibs", "ggis", "ggiss", "gging", "ggij", "ggic", "ggik", "ggit", "ggip", "ggih", "na", "nag", "nagg", "nags", "nan", "nanj", "nanh", "nad", "nal", "nalg", "nalm", "nalb", "nals", "nalt", "nalp", "nalh", "nam", "nab", "nabs", "nas", "nass", "nang", "naj", "nac", "nak", "nat", "nap", "nah", "nae", "naeg", "naegg", "naegs", "naen", "naenj", "naenh", "naed", "nael", "naelg", "naelm", "naelb", "naels", "naelt", "naelp", "naelh", "naem", "naeb", "naebs", "naes", "naess", "naeng", "naej", "naec", "naek", "naet", "naep", "naeh", "nya", "nyag", "nyagg", "nyags", "nyan", "nyanj", "nyanh", "nyad", "nyal", "nyalg", "nyalm", "nyalb", "nyals", "nyalt", "nyalp", "nyalh", "nyam", "nyab", "nyabs", "nyas", "nyass", "nyang", "nyaj", "nyac", "nyak", "nyat", "nyap", "nyah", "nyae", "nyaeg", "nyaegg", "nyaegs", "nyaen", "nyaenj", "nyaenh", "nyaed", "nyael", "nyaelg", "nyaelm", "nyaelb", "nyaels", "nyaelt", "nyaelp", "nyaelh", "nyaem", "nyaeb", "nyaebs", "nyaes"];
  }
});

// node_modules/unidecode/data/xb1.js
var require_xb1 = __commonJS({
  "node_modules/unidecode/data/xb1.js"(exports, module2) {
    module2.exports = ["nyaess", "nyaeng", "nyaej", "nyaec", "nyaek", "nyaet", "nyaep", "nyaeh", "neo", "neog", "neogg", "neogs", "neon", "neonj", "neonh", "neod", "neol", "neolg", "neolm", "neolb", "neols", "neolt", "neolp", "neolh", "neom", "neob", "neobs", "neos", "neoss", "neong", "neoj", "neoc", "neok", "neot", "neop", "neoh", "ne", "neg", "negg", "negs", "nen", "nenj", "nenh", "ned", "nel", "nelg", "nelm", "nelb", "nels", "nelt", "nelp", "nelh", "nem", "neb", "nebs", "nes", "ness", "neng", "nej", "nec", "nek", "net", "nep", "neh", "nyeo", "nyeog", "nyeogg", "nyeogs", "nyeon", "nyeonj", "nyeonh", "nyeod", "nyeol", "nyeolg", "nyeolm", "nyeolb", "nyeols", "nyeolt", "nyeolp", "nyeolh", "nyeom", "nyeob", "nyeobs", "nyeos", "nyeoss", "nyeong", "nyeoj", "nyeoc", "nyeok", "nyeot", "nyeop", "nyeoh", "nye", "nyeg", "nyegg", "nyegs", "nyen", "nyenj", "nyenh", "nyed", "nyel", "nyelg", "nyelm", "nyelb", "nyels", "nyelt", "nyelp", "nyelh", "nyem", "nyeb", "nyebs", "nyes", "nyess", "nyeng", "nyej", "nyec", "nyek", "nyet", "nyep", "nyeh", "no", "nog", "nogg", "nogs", "non", "nonj", "nonh", "nod", "nol", "nolg", "nolm", "nolb", "nols", "nolt", "nolp", "nolh", "nom", "nob", "nobs", "nos", "noss", "nong", "noj", "noc", "nok", "not", "nop", "noh", "nwa", "nwag", "nwagg", "nwags", "nwan", "nwanj", "nwanh", "nwad", "nwal", "nwalg", "nwalm", "nwalb", "nwals", "nwalt", "nwalp", "nwalh", "nwam", "nwab", "nwabs", "nwas", "nwass", "nwang", "nwaj", "nwac", "nwak", "nwat", "nwap", "nwah", "nwae", "nwaeg", "nwaegg", "nwaegs", "nwaen", "nwaenj", "nwaenh", "nwaed", "nwael", "nwaelg", "nwaelm", "nwaelb", "nwaels", "nwaelt", "nwaelp", "nwaelh", "nwaem", "nwaeb", "nwaebs", "nwaes", "nwaess", "nwaeng", "nwaej", "nwaec", "nwaek", "nwaet", "nwaep", "nwaeh", "noe", "noeg", "noegg", "noegs", "noen", "noenj", "noenh", "noed", "noel", "noelg", "noelm", "noelb", "noels", "noelt", "noelp", "noelh", "noem", "noeb", "noebs", "noes", "noess", "noeng", "noej", "noec", "noek", "noet", "noep", "noeh", "nyo", "nyog", "nyogg", "nyogs", "nyon", "nyonj", "nyonh", "nyod", "nyol", "nyolg", "nyolm", "nyolb", "nyols", "nyolt", "nyolp", "nyolh", "nyom", "nyob", "nyobs", "nyos", "nyoss", "nyong", "nyoj", "nyoc"];
  }
});

// node_modules/unidecode/data/xb2.js
var require_xb2 = __commonJS({
  "node_modules/unidecode/data/xb2.js"(exports, module2) {
    module2.exports = ["nyok", "nyot", "nyop", "nyoh", "nu", "nug", "nugg", "nugs", "nun", "nunj", "nunh", "nud", "nul", "nulg", "nulm", "nulb", "nuls", "nult", "nulp", "nulh", "num", "nub", "nubs", "nus", "nuss", "nung", "nuj", "nuc", "nuk", "nut", "nup", "nuh", "nweo", "nweog", "nweogg", "nweogs", "nweon", "nweonj", "nweonh", "nweod", "nweol", "nweolg", "nweolm", "nweolb", "nweols", "nweolt", "nweolp", "nweolh", "nweom", "nweob", "nweobs", "nweos", "nweoss", "nweong", "nweoj", "nweoc", "nweok", "nweot", "nweop", "nweoh", "nwe", "nweg", "nwegg", "nwegs", "nwen", "nwenj", "nwenh", "nwed", "nwel", "nwelg", "nwelm", "nwelb", "nwels", "nwelt", "nwelp", "nwelh", "nwem", "nweb", "nwebs", "nwes", "nwess", "nweng", "nwej", "nwec", "nwek", "nwet", "nwep", "nweh", "nwi", "nwig", "nwigg", "nwigs", "nwin", "nwinj", "nwinh", "nwid", "nwil", "nwilg", "nwilm", "nwilb", "nwils", "nwilt", "nwilp", "nwilh", "nwim", "nwib", "nwibs", "nwis", "nwiss", "nwing", "nwij", "nwic", "nwik", "nwit", "nwip", "nwih", "nyu", "nyug", "nyugg", "nyugs", "nyun", "nyunj", "nyunh", "nyud", "nyul", "nyulg", "nyulm", "nyulb", "nyuls", "nyult", "nyulp", "nyulh", "nyum", "nyub", "nyubs", "nyus", "nyuss", "nyung", "nyuj", "nyuc", "nyuk", "nyut", "nyup", "nyuh", "neu", "neug", "neugg", "neugs", "neun", "neunj", "neunh", "neud", "neul", "neulg", "neulm", "neulb", "neuls", "neult", "neulp", "neulh", "neum", "neub", "neubs", "neus", "neuss", "neung", "neuj", "neuc", "neuk", "neut", "neup", "neuh", "nyi", "nyig", "nyigg", "nyigs", "nyin", "nyinj", "nyinh", "nyid", "nyil", "nyilg", "nyilm", "nyilb", "nyils", "nyilt", "nyilp", "nyilh", "nyim", "nyib", "nyibs", "nyis", "nyiss", "nying", "nyij", "nyic", "nyik", "nyit", "nyip", "nyih", "ni", "nig", "nigg", "nigs", "nin", "ninj", "ninh", "nid", "nil", "nilg", "nilm", "nilb", "nils", "nilt", "nilp", "nilh", "nim", "nib", "nibs", "nis", "niss", "ning", "nij", "nic", "nik", "nit", "nip", "nih", "da", "dag", "dagg", "dags", "dan", "danj", "danh", "dad", "dal", "dalg", "dalm", "dalb", "dals", "dalt", "dalp", "dalh", "dam", "dab", "dabs", "das", "dass", "dang", "daj", "dac", "dak", "dat", "dap", "dah"];
  }
});

// node_modules/unidecode/data/xb3.js
var require_xb3 = __commonJS({
  "node_modules/unidecode/data/xb3.js"(exports, module2) {
    module2.exports = ["dae", "daeg", "daegg", "daegs", "daen", "daenj", "daenh", "daed", "dael", "daelg", "daelm", "daelb", "daels", "daelt", "daelp", "daelh", "daem", "daeb", "daebs", "daes", "daess", "daeng", "daej", "daec", "daek", "daet", "daep", "daeh", "dya", "dyag", "dyagg", "dyags", "dyan", "dyanj", "dyanh", "dyad", "dyal", "dyalg", "dyalm", "dyalb", "dyals", "dyalt", "dyalp", "dyalh", "dyam", "dyab", "dyabs", "dyas", "dyass", "dyang", "dyaj", "dyac", "dyak", "dyat", "dyap", "dyah", "dyae", "dyaeg", "dyaegg", "dyaegs", "dyaen", "dyaenj", "dyaenh", "dyaed", "dyael", "dyaelg", "dyaelm", "dyaelb", "dyaels", "dyaelt", "dyaelp", "dyaelh", "dyaem", "dyaeb", "dyaebs", "dyaes", "dyaess", "dyaeng", "dyaej", "dyaec", "dyaek", "dyaet", "dyaep", "dyaeh", "deo", "deog", "deogg", "deogs", "deon", "deonj", "deonh", "deod", "deol", "deolg", "deolm", "deolb", "deols", "deolt", "deolp", "deolh", "deom", "deob", "deobs", "deos", "deoss", "deong", "deoj", "deoc", "deok", "deot", "deop", "deoh", "de", "deg", "degg", "degs", "den", "denj", "denh", "ded", "del", "delg", "delm", "delb", "dels", "delt", "delp", "delh", "dem", "deb", "debs", "des", "dess", "deng", "dej", "dec", "dek", "det", "dep", "deh", "dyeo", "dyeog", "dyeogg", "dyeogs", "dyeon", "dyeonj", "dyeonh", "dyeod", "dyeol", "dyeolg", "dyeolm", "dyeolb", "dyeols", "dyeolt", "dyeolp", "dyeolh", "dyeom", "dyeob", "dyeobs", "dyeos", "dyeoss", "dyeong", "dyeoj", "dyeoc", "dyeok", "dyeot", "dyeop", "dyeoh", "dye", "dyeg", "dyegg", "dyegs", "dyen", "dyenj", "dyenh", "dyed", "dyel", "dyelg", "dyelm", "dyelb", "dyels", "dyelt", "dyelp", "dyelh", "dyem", "dyeb", "dyebs", "dyes", "dyess", "dyeng", "dyej", "dyec", "dyek", "dyet", "dyep", "dyeh", "do", "dog", "dogg", "dogs", "don", "donj", "donh", "dod", "dol", "dolg", "dolm", "dolb", "dols", "dolt", "dolp", "dolh", "dom", "dob", "dobs", "dos", "doss", "dong", "doj", "doc", "dok", "dot", "dop", "doh", "dwa", "dwag", "dwagg", "dwags", "dwan", "dwanj", "dwanh", "dwad", "dwal", "dwalg", "dwalm", "dwalb", "dwals", "dwalt", "dwalp", "dwalh", "dwam", "dwab", "dwabs", "dwas", "dwass", "dwang", "dwaj", "dwac", "dwak", "dwat", "dwap", "dwah", "dwae", "dwaeg", "dwaegg", "dwaegs"];
  }
});

// node_modules/unidecode/data/xb4.js
var require_xb4 = __commonJS({
  "node_modules/unidecode/data/xb4.js"(exports, module2) {
    module2.exports = ["dwaen", "dwaenj", "dwaenh", "dwaed", "dwael", "dwaelg", "dwaelm", "dwaelb", "dwaels", "dwaelt", "dwaelp", "dwaelh", "dwaem", "dwaeb", "dwaebs", "dwaes", "dwaess", "dwaeng", "dwaej", "dwaec", "dwaek", "dwaet", "dwaep", "dwaeh", "doe", "doeg", "doegg", "doegs", "doen", "doenj", "doenh", "doed", "doel", "doelg", "doelm", "doelb", "doels", "doelt", "doelp", "doelh", "doem", "doeb", "doebs", "does", "doess", "doeng", "doej", "doec", "doek", "doet", "doep", "doeh", "dyo", "dyog", "dyogg", "dyogs", "dyon", "dyonj", "dyonh", "dyod", "dyol", "dyolg", "dyolm", "dyolb", "dyols", "dyolt", "dyolp", "dyolh", "dyom", "dyob", "dyobs", "dyos", "dyoss", "dyong", "dyoj", "dyoc", "dyok", "dyot", "dyop", "dyoh", "du", "dug", "dugg", "dugs", "dun", "dunj", "dunh", "dud", "dul", "dulg", "dulm", "dulb", "duls", "dult", "dulp", "dulh", "dum", "dub", "dubs", "dus", "duss", "dung", "duj", "duc", "duk", "dut", "dup", "duh", "dweo", "dweog", "dweogg", "dweogs", "dweon", "dweonj", "dweonh", "dweod", "dweol", "dweolg", "dweolm", "dweolb", "dweols", "dweolt", "dweolp", "dweolh", "dweom", "dweob", "dweobs", "dweos", "dweoss", "dweong", "dweoj", "dweoc", "dweok", "dweot", "dweop", "dweoh", "dwe", "dweg", "dwegg", "dwegs", "dwen", "dwenj", "dwenh", "dwed", "dwel", "dwelg", "dwelm", "dwelb", "dwels", "dwelt", "dwelp", "dwelh", "dwem", "dweb", "dwebs", "dwes", "dwess", "dweng", "dwej", "dwec", "dwek", "dwet", "dwep", "dweh", "dwi", "dwig", "dwigg", "dwigs", "dwin", "dwinj", "dwinh", "dwid", "dwil", "dwilg", "dwilm", "dwilb", "dwils", "dwilt", "dwilp", "dwilh", "dwim", "dwib", "dwibs", "dwis", "dwiss", "dwing", "dwij", "dwic", "dwik", "dwit", "dwip", "dwih", "dyu", "dyug", "dyugg", "dyugs", "dyun", "dyunj", "dyunh", "dyud", "dyul", "dyulg", "dyulm", "dyulb", "dyuls", "dyult", "dyulp", "dyulh", "dyum", "dyub", "dyubs", "dyus", "dyuss", "dyung", "dyuj", "dyuc", "dyuk", "dyut", "dyup", "dyuh", "deu", "deug", "deugg", "deugs", "deun", "deunj", "deunh", "deud", "deul", "deulg", "deulm", "deulb", "deuls", "deult", "deulp", "deulh", "deum", "deub", "deubs", "deus", "deuss", "deung", "deuj", "deuc", "deuk", "deut", "deup", "deuh", "dyi", "dyig", "dyigg", "dyigs", "dyin", "dyinj", "dyinh", "dyid"];
  }
});

// node_modules/unidecode/data/xb5.js
var require_xb5 = __commonJS({
  "node_modules/unidecode/data/xb5.js"(exports, module2) {
    module2.exports = ["dyil", "dyilg", "dyilm", "dyilb", "dyils", "dyilt", "dyilp", "dyilh", "dyim", "dyib", "dyibs", "dyis", "dyiss", "dying", "dyij", "dyic", "dyik", "dyit", "dyip", "dyih", "di", "dig", "digg", "digs", "din", "dinj", "dinh", "did", "dil", "dilg", "dilm", "dilb", "dils", "dilt", "dilp", "dilh", "dim", "dib", "dibs", "dis", "diss", "ding", "dij", "dic", "dik", "dit", "dip", "dih", "dda", "ddag", "ddagg", "ddags", "ddan", "ddanj", "ddanh", "ddad", "ddal", "ddalg", "ddalm", "ddalb", "ddals", "ddalt", "ddalp", "ddalh", "ddam", "ddab", "ddabs", "ddas", "ddass", "ddang", "ddaj", "ddac", "ddak", "ddat", "ddap", "ddah", "ddae", "ddaeg", "ddaegg", "ddaegs", "ddaen", "ddaenj", "ddaenh", "ddaed", "ddael", "ddaelg", "ddaelm", "ddaelb", "ddaels", "ddaelt", "ddaelp", "ddaelh", "ddaem", "ddaeb", "ddaebs", "ddaes", "ddaess", "ddaeng", "ddaej", "ddaec", "ddaek", "ddaet", "ddaep", "ddaeh", "ddya", "ddyag", "ddyagg", "ddyags", "ddyan", "ddyanj", "ddyanh", "ddyad", "ddyal", "ddyalg", "ddyalm", "ddyalb", "ddyals", "ddyalt", "ddyalp", "ddyalh", "ddyam", "ddyab", "ddyabs", "ddyas", "ddyass", "ddyang", "ddyaj", "ddyac", "ddyak", "ddyat", "ddyap", "ddyah", "ddyae", "ddyaeg", "ddyaegg", "ddyaegs", "ddyaen", "ddyaenj", "ddyaenh", "ddyaed", "ddyael", "ddyaelg", "ddyaelm", "ddyaelb", "ddyaels", "ddyaelt", "ddyaelp", "ddyaelh", "ddyaem", "ddyaeb", "ddyaebs", "ddyaes", "ddyaess", "ddyaeng", "ddyaej", "ddyaec", "ddyaek", "ddyaet", "ddyaep", "ddyaeh", "ddeo", "ddeog", "ddeogg", "ddeogs", "ddeon", "ddeonj", "ddeonh", "ddeod", "ddeol", "ddeolg", "ddeolm", "ddeolb", "ddeols", "ddeolt", "ddeolp", "ddeolh", "ddeom", "ddeob", "ddeobs", "ddeos", "ddeoss", "ddeong", "ddeoj", "ddeoc", "ddeok", "ddeot", "ddeop", "ddeoh", "dde", "ddeg", "ddegg", "ddegs", "dden", "ddenj", "ddenh", "dded", "ddel", "ddelg", "ddelm", "ddelb", "ddels", "ddelt", "ddelp", "ddelh", "ddem", "ddeb", "ddebs", "ddes", "ddess", "ddeng", "ddej", "ddec", "ddek", "ddet", "ddep", "ddeh", "ddyeo", "ddyeog", "ddyeogg", "ddyeogs", "ddyeon", "ddyeonj", "ddyeonh", "ddyeod", "ddyeol", "ddyeolg", "ddyeolm", "ddyeolb", "ddyeols", "ddyeolt", "ddyeolp", "ddyeolh", "ddyeom", "ddyeob", "ddyeobs", "ddyeos", "ddyeoss", "ddyeong", "ddyeoj", "ddyeoc", "ddyeok", "ddyeot", "ddyeop", "ddyeoh", "ddye", "ddyeg", "ddyegg", "ddyegs", "ddyen", "ddyenj", "ddyenh", "ddyed", "ddyel", "ddyelg", "ddyelm", "ddyelb"];
  }
});

// node_modules/unidecode/data/xb6.js
var require_xb6 = __commonJS({
  "node_modules/unidecode/data/xb6.js"(exports, module2) {
    module2.exports = ["ddyels", "ddyelt", "ddyelp", "ddyelh", "ddyem", "ddyeb", "ddyebs", "ddyes", "ddyess", "ddyeng", "ddyej", "ddyec", "ddyek", "ddyet", "ddyep", "ddyeh", "ddo", "ddog", "ddogg", "ddogs", "ddon", "ddonj", "ddonh", "ddod", "ddol", "ddolg", "ddolm", "ddolb", "ddols", "ddolt", "ddolp", "ddolh", "ddom", "ddob", "ddobs", "ddos", "ddoss", "ddong", "ddoj", "ddoc", "ddok", "ddot", "ddop", "ddoh", "ddwa", "ddwag", "ddwagg", "ddwags", "ddwan", "ddwanj", "ddwanh", "ddwad", "ddwal", "ddwalg", "ddwalm", "ddwalb", "ddwals", "ddwalt", "ddwalp", "ddwalh", "ddwam", "ddwab", "ddwabs", "ddwas", "ddwass", "ddwang", "ddwaj", "ddwac", "ddwak", "ddwat", "ddwap", "ddwah", "ddwae", "ddwaeg", "ddwaegg", "ddwaegs", "ddwaen", "ddwaenj", "ddwaenh", "ddwaed", "ddwael", "ddwaelg", "ddwaelm", "ddwaelb", "ddwaels", "ddwaelt", "ddwaelp", "ddwaelh", "ddwaem", "ddwaeb", "ddwaebs", "ddwaes", "ddwaess", "ddwaeng", "ddwaej", "ddwaec", "ddwaek", "ddwaet", "ddwaep", "ddwaeh", "ddoe", "ddoeg", "ddoegg", "ddoegs", "ddoen", "ddoenj", "ddoenh", "ddoed", "ddoel", "ddoelg", "ddoelm", "ddoelb", "ddoels", "ddoelt", "ddoelp", "ddoelh", "ddoem", "ddoeb", "ddoebs", "ddoes", "ddoess", "ddoeng", "ddoej", "ddoec", "ddoek", "ddoet", "ddoep", "ddoeh", "ddyo", "ddyog", "ddyogg", "ddyogs", "ddyon", "ddyonj", "ddyonh", "ddyod", "ddyol", "ddyolg", "ddyolm", "ddyolb", "ddyols", "ddyolt", "ddyolp", "ddyolh", "ddyom", "ddyob", "ddyobs", "ddyos", "ddyoss", "ddyong", "ddyoj", "ddyoc", "ddyok", "ddyot", "ddyop", "ddyoh", "ddu", "ddug", "ddugg", "ddugs", "ddun", "ddunj", "ddunh", "ddud", "ddul", "ddulg", "ddulm", "ddulb", "dduls", "ddult", "ddulp", "ddulh", "ddum", "ddub", "ddubs", "ddus", "dduss", "ddung", "dduj", "dduc", "dduk", "ddut", "ddup", "dduh", "ddweo", "ddweog", "ddweogg", "ddweogs", "ddweon", "ddweonj", "ddweonh", "ddweod", "ddweol", "ddweolg", "ddweolm", "ddweolb", "ddweols", "ddweolt", "ddweolp", "ddweolh", "ddweom", "ddweob", "ddweobs", "ddweos", "ddweoss", "ddweong", "ddweoj", "ddweoc", "ddweok", "ddweot", "ddweop", "ddweoh", "ddwe", "ddweg", "ddwegg", "ddwegs", "ddwen", "ddwenj", "ddwenh", "ddwed", "ddwel", "ddwelg", "ddwelm", "ddwelb", "ddwels", "ddwelt", "ddwelp", "ddwelh", "ddwem", "ddweb", "ddwebs", "ddwes", "ddwess", "ddweng", "ddwej", "ddwec", "ddwek", "ddwet", "ddwep", "ddweh", "ddwi", "ddwig", "ddwigg", "ddwigs", "ddwin", "ddwinj", "ddwinh", "ddwid", "ddwil", "ddwilg", "ddwilm", "ddwilb", "ddwils", "ddwilt", "ddwilp", "ddwilh"];
  }
});

// node_modules/unidecode/data/xb7.js
var require_xb7 = __commonJS({
  "node_modules/unidecode/data/xb7.js"(exports, module2) {
    module2.exports = ["ddwim", "ddwib", "ddwibs", "ddwis", "ddwiss", "ddwing", "ddwij", "ddwic", "ddwik", "ddwit", "ddwip", "ddwih", "ddyu", "ddyug", "ddyugg", "ddyugs", "ddyun", "ddyunj", "ddyunh", "ddyud", "ddyul", "ddyulg", "ddyulm", "ddyulb", "ddyuls", "ddyult", "ddyulp", "ddyulh", "ddyum", "ddyub", "ddyubs", "ddyus", "ddyuss", "ddyung", "ddyuj", "ddyuc", "ddyuk", "ddyut", "ddyup", "ddyuh", "ddeu", "ddeug", "ddeugg", "ddeugs", "ddeun", "ddeunj", "ddeunh", "ddeud", "ddeul", "ddeulg", "ddeulm", "ddeulb", "ddeuls", "ddeult", "ddeulp", "ddeulh", "ddeum", "ddeub", "ddeubs", "ddeus", "ddeuss", "ddeung", "ddeuj", "ddeuc", "ddeuk", "ddeut", "ddeup", "ddeuh", "ddyi", "ddyig", "ddyigg", "ddyigs", "ddyin", "ddyinj", "ddyinh", "ddyid", "ddyil", "ddyilg", "ddyilm", "ddyilb", "ddyils", "ddyilt", "ddyilp", "ddyilh", "ddyim", "ddyib", "ddyibs", "ddyis", "ddyiss", "ddying", "ddyij", "ddyic", "ddyik", "ddyit", "ddyip", "ddyih", "ddi", "ddig", "ddigg", "ddigs", "ddin", "ddinj", "ddinh", "ddid", "ddil", "ddilg", "ddilm", "ddilb", "ddils", "ddilt", "ddilp", "ddilh", "ddim", "ddib", "ddibs", "ddis", "ddiss", "dding", "ddij", "ddic", "ddik", "ddit", "ddip", "ddih", "ra", "rag", "ragg", "rags", "ran", "ranj", "ranh", "rad", "ral", "ralg", "ralm", "ralb", "rals", "ralt", "ralp", "ralh", "ram", "rab", "rabs", "ras", "rass", "rang", "raj", "rac", "rak", "rat", "rap", "rah", "rae", "raeg", "raegg", "raegs", "raen", "raenj", "raenh", "raed", "rael", "raelg", "raelm", "raelb", "raels", "raelt", "raelp", "raelh", "raem", "raeb", "raebs", "raes", "raess", "raeng", "raej", "raec", "raek", "raet", "raep", "raeh", "rya", "ryag", "ryagg", "ryags", "ryan", "ryanj", "ryanh", "ryad", "ryal", "ryalg", "ryalm", "ryalb", "ryals", "ryalt", "ryalp", "ryalh", "ryam", "ryab", "ryabs", "ryas", "ryass", "ryang", "ryaj", "ryac", "ryak", "ryat", "ryap", "ryah", "ryae", "ryaeg", "ryaegg", "ryaegs", "ryaen", "ryaenj", "ryaenh", "ryaed", "ryael", "ryaelg", "ryaelm", "ryaelb", "ryaels", "ryaelt", "ryaelp", "ryaelh", "ryaem", "ryaeb", "ryaebs", "ryaes", "ryaess", "ryaeng", "ryaej", "ryaec", "ryaek", "ryaet", "ryaep", "ryaeh", "reo", "reog", "reogg", "reogs", "reon", "reonj", "reonh", "reod", "reol", "reolg", "reolm", "reolb", "reols", "reolt", "reolp", "reolh", "reom", "reob", "reobs", "reos"];
  }
});

// node_modules/unidecode/data/xb8.js
var require_xb8 = __commonJS({
  "node_modules/unidecode/data/xb8.js"(exports, module2) {
    module2.exports = ["reoss", "reong", "reoj", "reoc", "reok", "reot", "reop", "reoh", "re", "reg", "regg", "regs", "ren", "renj", "renh", "red", "rel", "relg", "relm", "relb", "rels", "relt", "relp", "relh", "rem", "reb", "rebs", "res", "ress", "reng", "rej", "rec", "rek", "ret", "rep", "reh", "ryeo", "ryeog", "ryeogg", "ryeogs", "ryeon", "ryeonj", "ryeonh", "ryeod", "ryeol", "ryeolg", "ryeolm", "ryeolb", "ryeols", "ryeolt", "ryeolp", "ryeolh", "ryeom", "ryeob", "ryeobs", "ryeos", "ryeoss", "ryeong", "ryeoj", "ryeoc", "ryeok", "ryeot", "ryeop", "ryeoh", "rye", "ryeg", "ryegg", "ryegs", "ryen", "ryenj", "ryenh", "ryed", "ryel", "ryelg", "ryelm", "ryelb", "ryels", "ryelt", "ryelp", "ryelh", "ryem", "ryeb", "ryebs", "ryes", "ryess", "ryeng", "ryej", "ryec", "ryek", "ryet", "ryep", "ryeh", "ro", "rog", "rogg", "rogs", "ron", "ronj", "ronh", "rod", "rol", "rolg", "rolm", "rolb", "rols", "rolt", "rolp", "rolh", "rom", "rob", "robs", "ros", "ross", "rong", "roj", "roc", "rok", "rot", "rop", "roh", "rwa", "rwag", "rwagg", "rwags", "rwan", "rwanj", "rwanh", "rwad", "rwal", "rwalg", "rwalm", "rwalb", "rwals", "rwalt", "rwalp", "rwalh", "rwam", "rwab", "rwabs", "rwas", "rwass", "rwang", "rwaj", "rwac", "rwak", "rwat", "rwap", "rwah", "rwae", "rwaeg", "rwaegg", "rwaegs", "rwaen", "rwaenj", "rwaenh", "rwaed", "rwael", "rwaelg", "rwaelm", "rwaelb", "rwaels", "rwaelt", "rwaelp", "rwaelh", "rwaem", "rwaeb", "rwaebs", "rwaes", "rwaess", "rwaeng", "rwaej", "rwaec", "rwaek", "rwaet", "rwaep", "rwaeh", "roe", "roeg", "roegg", "roegs", "roen", "roenj", "roenh", "roed", "roel", "roelg", "roelm", "roelb", "roels", "roelt", "roelp", "roelh", "roem", "roeb", "roebs", "roes", "roess", "roeng", "roej", "roec", "roek", "roet", "roep", "roeh", "ryo", "ryog", "ryogg", "ryogs", "ryon", "ryonj", "ryonh", "ryod", "ryol", "ryolg", "ryolm", "ryolb", "ryols", "ryolt", "ryolp", "ryolh", "ryom", "ryob", "ryobs", "ryos", "ryoss", "ryong", "ryoj", "ryoc", "ryok", "ryot", "ryop", "ryoh", "ru", "rug", "rugg", "rugs", "run", "runj", "runh", "rud", "rul", "rulg", "rulm", "rulb", "ruls", "rult", "rulp", "rulh", "rum", "rub", "rubs", "rus", "russ", "rung", "ruj", "ruc"];
  }
});

// node_modules/unidecode/data/xb9.js
var require_xb9 = __commonJS({
  "node_modules/unidecode/data/xb9.js"(exports, module2) {
    module2.exports = ["ruk", "rut", "rup", "ruh", "rweo", "rweog", "rweogg", "rweogs", "rweon", "rweonj", "rweonh", "rweod", "rweol", "rweolg", "rweolm", "rweolb", "rweols", "rweolt", "rweolp", "rweolh", "rweom", "rweob", "rweobs", "rweos", "rweoss", "rweong", "rweoj", "rweoc", "rweok", "rweot", "rweop", "rweoh", "rwe", "rweg", "rwegg", "rwegs", "rwen", "rwenj", "rwenh", "rwed", "rwel", "rwelg", "rwelm", "rwelb", "rwels", "rwelt", "rwelp", "rwelh", "rwem", "rweb", "rwebs", "rwes", "rwess", "rweng", "rwej", "rwec", "rwek", "rwet", "rwep", "rweh", "rwi", "rwig", "rwigg", "rwigs", "rwin", "rwinj", "rwinh", "rwid", "rwil", "rwilg", "rwilm", "rwilb", "rwils", "rwilt", "rwilp", "rwilh", "rwim", "rwib", "rwibs", "rwis", "rwiss", "rwing", "rwij", "rwic", "rwik", "rwit", "rwip", "rwih", "ryu", "ryug", "ryugg", "ryugs", "ryun", "ryunj", "ryunh", "ryud", "ryul", "ryulg", "ryulm", "ryulb", "ryuls", "ryult", "ryulp", "ryulh", "ryum", "ryub", "ryubs", "ryus", "ryuss", "ryung", "ryuj", "ryuc", "ryuk", "ryut", "ryup", "ryuh", "reu", "reug", "reugg", "reugs", "reun", "reunj", "reunh", "reud", "reul", "reulg", "reulm", "reulb", "reuls", "reult", "reulp", "reulh", "reum", "reub", "reubs", "reus", "reuss", "reung", "reuj", "reuc", "reuk", "reut", "reup", "reuh", "ryi", "ryig", "ryigg", "ryigs", "ryin", "ryinj", "ryinh", "ryid", "ryil", "ryilg", "ryilm", "ryilb", "ryils", "ryilt", "ryilp", "ryilh", "ryim", "ryib", "ryibs", "ryis", "ryiss", "rying", "ryij", "ryic", "ryik", "ryit", "ryip", "ryih", "ri", "rig", "rigg", "rigs", "rin", "rinj", "rinh", "rid", "ril", "rilg", "rilm", "rilb", "rils", "rilt", "rilp", "rilh", "rim", "rib", "ribs", "ris", "riss", "ring", "rij", "ric", "rik", "rit", "rip", "rih", "ma", "mag", "magg", "mags", "man", "manj", "manh", "mad", "mal", "malg", "malm", "malb", "mals", "malt", "malp", "malh", "mam", "mab", "mabs", "mas", "mass", "mang", "maj", "mac", "mak", "mat", "map", "mah", "mae", "maeg", "maegg", "maegs", "maen", "maenj", "maenh", "maed", "mael", "maelg", "maelm", "maelb", "maels", "maelt", "maelp", "maelh", "maem", "maeb", "maebs", "maes", "maess", "maeng", "maej", "maec", "maek", "maet", "maep", "maeh"];
  }
});

// node_modules/unidecode/data/xba.js
var require_xba = __commonJS({
  "node_modules/unidecode/data/xba.js"(exports, module2) {
    module2.exports = ["mya", "myag", "myagg", "myags", "myan", "myanj", "myanh", "myad", "myal", "myalg", "myalm", "myalb", "myals", "myalt", "myalp", "myalh", "myam", "myab", "myabs", "myas", "myass", "myang", "myaj", "myac", "myak", "myat", "myap", "myah", "myae", "myaeg", "myaegg", "myaegs", "myaen", "myaenj", "myaenh", "myaed", "myael", "myaelg", "myaelm", "myaelb", "myaels", "myaelt", "myaelp", "myaelh", "myaem", "myaeb", "myaebs", "myaes", "myaess", "myaeng", "myaej", "myaec", "myaek", "myaet", "myaep", "myaeh", "meo", "meog", "meogg", "meogs", "meon", "meonj", "meonh", "meod", "meol", "meolg", "meolm", "meolb", "meols", "meolt", "meolp", "meolh", "meom", "meob", "meobs", "meos", "meoss", "meong", "meoj", "meoc", "meok", "meot", "meop", "meoh", "me", "meg", "megg", "megs", "men", "menj", "menh", "med", "mel", "melg", "melm", "melb", "mels", "melt", "melp", "melh", "mem", "meb", "mebs", "mes", "mess", "meng", "mej", "mec", "mek", "met", "mep", "meh", "myeo", "myeog", "myeogg", "myeogs", "myeon", "myeonj", "myeonh", "myeod", "myeol", "myeolg", "myeolm", "myeolb", "myeols", "myeolt", "myeolp", "myeolh", "myeom", "myeob", "myeobs", "myeos", "myeoss", "myeong", "myeoj", "myeoc", "myeok", "myeot", "myeop", "myeoh", "mye", "myeg", "myegg", "myegs", "myen", "myenj", "myenh", "myed", "myel", "myelg", "myelm", "myelb", "myels", "myelt", "myelp", "myelh", "myem", "myeb", "myebs", "myes", "myess", "myeng", "myej", "myec", "myek", "myet", "myep", "myeh", "mo", "mog", "mogg", "mogs", "mon", "monj", "monh", "mod", "mol", "molg", "molm", "molb", "mols", "molt", "molp", "molh", "mom", "mob", "mobs", "mos", "moss", "mong", "moj", "moc", "mok", "mot", "mop", "moh", "mwa", "mwag", "mwagg", "mwags", "mwan", "mwanj", "mwanh", "mwad", "mwal", "mwalg", "mwalm", "mwalb", "mwals", "mwalt", "mwalp", "mwalh", "mwam", "mwab", "mwabs", "mwas", "mwass", "mwang", "mwaj", "mwac", "mwak", "mwat", "mwap", "mwah", "mwae", "mwaeg", "mwaegg", "mwaegs", "mwaen", "mwaenj", "mwaenh", "mwaed", "mwael", "mwaelg", "mwaelm", "mwaelb", "mwaels", "mwaelt", "mwaelp", "mwaelh", "mwaem", "mwaeb", "mwaebs", "mwaes", "mwaess", "mwaeng", "mwaej", "mwaec", "mwaek", "mwaet", "mwaep", "mwaeh", "moe", "moeg", "moegg", "moegs"];
  }
});

// node_modules/unidecode/data/xbb.js
var require_xbb = __commonJS({
  "node_modules/unidecode/data/xbb.js"(exports, module2) {
    module2.exports = ["moen", "moenj", "moenh", "moed", "moel", "moelg", "moelm", "moelb", "moels", "moelt", "moelp", "moelh", "moem", "moeb", "moebs", "moes", "moess", "moeng", "moej", "moec", "moek", "moet", "moep", "moeh", "myo", "myog", "myogg", "myogs", "myon", "myonj", "myonh", "myod", "myol", "myolg", "myolm", "myolb", "myols", "myolt", "myolp", "myolh", "myom", "myob", "myobs", "myos", "myoss", "myong", "myoj", "myoc", "myok", "myot", "myop", "myoh", "mu", "mug", "mugg", "mugs", "mun", "munj", "munh", "mud", "mul", "mulg", "mulm", "mulb", "muls", "mult", "mulp", "mulh", "mum", "mub", "mubs", "mus", "muss", "mung", "muj", "muc", "muk", "mut", "mup", "muh", "mweo", "mweog", "mweogg", "mweogs", "mweon", "mweonj", "mweonh", "mweod", "mweol", "mweolg", "mweolm", "mweolb", "mweols", "mweolt", "mweolp", "mweolh", "mweom", "mweob", "mweobs", "mweos", "mweoss", "mweong", "mweoj", "mweoc", "mweok", "mweot", "mweop", "mweoh", "mwe", "mweg", "mwegg", "mwegs", "mwen", "mwenj", "mwenh", "mwed", "mwel", "mwelg", "mwelm", "mwelb", "mwels", "mwelt", "mwelp", "mwelh", "mwem", "mweb", "mwebs", "mwes", "mwess", "mweng", "mwej", "mwec", "mwek", "mwet", "mwep", "mweh", "mwi", "mwig", "mwigg", "mwigs", "mwin", "mwinj", "mwinh", "mwid", "mwil", "mwilg", "mwilm", "mwilb", "mwils", "mwilt", "mwilp", "mwilh", "mwim", "mwib", "mwibs", "mwis", "mwiss", "mwing", "mwij", "mwic", "mwik", "mwit", "mwip", "mwih", "myu", "myug", "myugg", "myugs", "myun", "myunj", "myunh", "myud", "myul", "myulg", "myulm", "myulb", "myuls", "myult", "myulp", "myulh", "myum", "myub", "myubs", "myus", "myuss", "myung", "myuj", "myuc", "myuk", "myut", "myup", "myuh", "meu", "meug", "meugg", "meugs", "meun", "meunj", "meunh", "meud", "meul", "meulg", "meulm", "meulb", "meuls", "meult", "meulp", "meulh", "meum", "meub", "meubs", "meus", "meuss", "meung", "meuj", "meuc", "meuk", "meut", "meup", "meuh", "myi", "myig", "myigg", "myigs", "myin", "myinj", "myinh", "myid", "myil", "myilg", "myilm", "myilb", "myils", "myilt", "myilp", "myilh", "myim", "myib", "myibs", "myis", "myiss", "mying", "myij", "myic", "myik", "myit", "myip", "myih", "mi", "mig", "migg", "migs", "min", "minj", "minh", "mid"];
  }
});

// node_modules/unidecode/data/xbc.js
var require_xbc = __commonJS({
  "node_modules/unidecode/data/xbc.js"(exports, module2) {
    module2.exports = ["mil", "milg", "milm", "milb", "mils", "milt", "milp", "milh", "mim", "mib", "mibs", "mis", "miss", "ming", "mij", "mic", "mik", "mit", "mip", "mih", "ba", "bag", "bagg", "bags", "ban", "banj", "banh", "bad", "bal", "balg", "balm", "balb", "bals", "balt", "balp", "balh", "bam", "bab", "babs", "bas", "bass", "bang", "baj", "bac", "bak", "bat", "bap", "bah", "bae", "baeg", "baegg", "baegs", "baen", "baenj", "baenh", "baed", "bael", "baelg", "baelm", "baelb", "baels", "baelt", "baelp", "baelh", "baem", "baeb", "baebs", "baes", "baess", "baeng", "baej", "baec", "baek", "baet", "baep", "baeh", "bya", "byag", "byagg", "byags", "byan", "byanj", "byanh", "byad", "byal", "byalg", "byalm", "byalb", "byals", "byalt", "byalp", "byalh", "byam", "byab", "byabs", "byas", "byass", "byang", "byaj", "byac", "byak", "byat", "byap", "byah", "byae", "byaeg", "byaegg", "byaegs", "byaen", "byaenj", "byaenh", "byaed", "byael", "byaelg", "byaelm", "byaelb", "byaels", "byaelt", "byaelp", "byaelh", "byaem", "byaeb", "byaebs", "byaes", "byaess", "byaeng", "byaej", "byaec", "byaek", "byaet", "byaep", "byaeh", "beo", "beog", "beogg", "beogs", "beon", "beonj", "beonh", "beod", "beol", "beolg", "beolm", "beolb", "beols", "beolt", "beolp", "beolh", "beom", "beob", "beobs", "beos", "beoss", "beong", "beoj", "beoc", "beok", "beot", "beop", "beoh", "be", "beg", "begg", "begs", "ben", "benj", "benh", "bed", "bel", "belg", "belm", "belb", "bels", "belt", "belp", "belh", "bem", "beb", "bebs", "bes", "bess", "beng", "bej", "bec", "bek", "bet", "bep", "beh", "byeo", "byeog", "byeogg", "byeogs", "byeon", "byeonj", "byeonh", "byeod", "byeol", "byeolg", "byeolm", "byeolb", "byeols", "byeolt", "byeolp", "byeolh", "byeom", "byeob", "byeobs", "byeos", "byeoss", "byeong", "byeoj", "byeoc", "byeok", "byeot", "byeop", "byeoh", "bye", "byeg", "byegg", "byegs", "byen", "byenj", "byenh", "byed", "byel", "byelg", "byelm", "byelb", "byels", "byelt", "byelp", "byelh", "byem", "byeb", "byebs", "byes", "byess", "byeng", "byej", "byec", "byek", "byet", "byep", "byeh", "bo", "bog", "bogg", "bogs", "bon", "bonj", "bonh", "bod", "bol", "bolg", "bolm", "bolb"];
  }
});

// node_modules/unidecode/data/xbd.js
var require_xbd = __commonJS({
  "node_modules/unidecode/data/xbd.js"(exports, module2) {
    module2.exports = ["bols", "bolt", "bolp", "bolh", "bom", "bob", "bobs", "bos", "boss", "bong", "boj", "boc", "bok", "bot", "bop", "boh", "bwa", "bwag", "bwagg", "bwags", "bwan", "bwanj", "bwanh", "bwad", "bwal", "bwalg", "bwalm", "bwalb", "bwals", "bwalt", "bwalp", "bwalh", "bwam", "bwab", "bwabs", "bwas", "bwass", "bwang", "bwaj", "bwac", "bwak", "bwat", "bwap", "bwah", "bwae", "bwaeg", "bwaegg", "bwaegs", "bwaen", "bwaenj", "bwaenh", "bwaed", "bwael", "bwaelg", "bwaelm", "bwaelb", "bwaels", "bwaelt", "bwaelp", "bwaelh", "bwaem", "bwaeb", "bwaebs", "bwaes", "bwaess", "bwaeng", "bwaej", "bwaec", "bwaek", "bwaet", "bwaep", "bwaeh", "boe", "boeg", "boegg", "boegs", "boen", "boenj", "boenh", "boed", "boel", "boelg", "boelm", "boelb", "boels", "boelt", "boelp", "boelh", "boem", "boeb", "boebs", "boes", "boess", "boeng", "boej", "boec", "boek", "boet", "boep", "boeh", "byo", "byog", "byogg", "byogs", "byon", "byonj", "byonh", "byod", "byol", "byolg", "byolm", "byolb", "byols", "byolt", "byolp", "byolh", "byom", "byob", "byobs", "byos", "byoss", "byong", "byoj", "byoc", "byok", "byot", "byop", "byoh", "bu", "bug", "bugg", "bugs", "bun", "bunj", "bunh", "bud", "bul", "bulg", "bulm", "bulb", "buls", "bult", "bulp", "bulh", "bum", "bub", "bubs", "bus", "buss", "bung", "buj", "buc", "buk", "but", "bup", "buh", "bweo", "bweog", "bweogg", "bweogs", "bweon", "bweonj", "bweonh", "bweod", "bweol", "bweolg", "bweolm", "bweolb", "bweols", "bweolt", "bweolp", "bweolh", "bweom", "bweob", "bweobs", "bweos", "bweoss", "bweong", "bweoj", "bweoc", "bweok", "bweot", "bweop", "bweoh", "bwe", "bweg", "bwegg", "bwegs", "bwen", "bwenj", "bwenh", "bwed", "bwel", "bwelg", "bwelm", "bwelb", "bwels", "bwelt", "bwelp", "bwelh", "bwem", "bweb", "bwebs", "bwes", "bwess", "bweng", "bwej", "bwec", "bwek", "bwet", "bwep", "bweh", "bwi", "bwig", "bwigg", "bwigs", "bwin", "bwinj", "bwinh", "bwid", "bwil", "bwilg", "bwilm", "bwilb", "bwils", "bwilt", "bwilp", "bwilh", "bwim", "bwib", "bwibs", "bwis", "bwiss", "bwing", "bwij", "bwic", "bwik", "bwit", "bwip", "bwih", "byu", "byug", "byugg", "byugs", "byun", "byunj", "byunh", "byud", "byul", "byulg", "byulm", "byulb", "byuls", "byult", "byulp", "byulh"];
  }
});

// node_modules/unidecode/data/xbe.js
var require_xbe = __commonJS({
  "node_modules/unidecode/data/xbe.js"(exports, module2) {
    module2.exports = ["byum", "byub", "byubs", "byus", "byuss", "byung", "byuj", "byuc", "byuk", "byut", "byup", "byuh", "beu", "beug", "beugg", "beugs", "beun", "beunj", "beunh", "beud", "beul", "beulg", "beulm", "beulb", "beuls", "beult", "beulp", "beulh", "beum", "beub", "beubs", "beus", "beuss", "beung", "beuj", "beuc", "beuk", "beut", "beup", "beuh", "byi", "byig", "byigg", "byigs", "byin", "byinj", "byinh", "byid", "byil", "byilg", "byilm", "byilb", "byils", "byilt", "byilp", "byilh", "byim", "byib", "byibs", "byis", "byiss", "bying", "byij", "byic", "byik", "byit", "byip", "byih", "bi", "big", "bigg", "bigs", "bin", "binj", "binh", "bid", "bil", "bilg", "bilm", "bilb", "bils", "bilt", "bilp", "bilh", "bim", "bib", "bibs", "bis", "biss", "bing", "bij", "bic", "bik", "bit", "bip", "bih", "bba", "bbag", "bbagg", "bbags", "bban", "bbanj", "bbanh", "bbad", "bbal", "bbalg", "bbalm", "bbalb", "bbals", "bbalt", "bbalp", "bbalh", "bbam", "bbab", "bbabs", "bbas", "bbass", "bbang", "bbaj", "bbac", "bbak", "bbat", "bbap", "bbah", "bbae", "bbaeg", "bbaegg", "bbaegs", "bbaen", "bbaenj", "bbaenh", "bbaed", "bbael", "bbaelg", "bbaelm", "bbaelb", "bbaels", "bbaelt", "bbaelp", "bbaelh", "bbaem", "bbaeb", "bbaebs", "bbaes", "bbaess", "bbaeng", "bbaej", "bbaec", "bbaek", "bbaet", "bbaep", "bbaeh", "bbya", "bbyag", "bbyagg", "bbyags", "bbyan", "bbyanj", "bbyanh", "bbyad", "bbyal", "bbyalg", "bbyalm", "bbyalb", "bbyals", "bbyalt", "bbyalp", "bbyalh", "bbyam", "bbyab", "bbyabs", "bbyas", "bbyass", "bbyang", "bbyaj", "bbyac", "bbyak", "bbyat", "bbyap", "bbyah", "bbyae", "bbyaeg", "bbyaegg", "bbyaegs", "bbyaen", "bbyaenj", "bbyaenh", "bbyaed", "bbyael", "bbyaelg", "bbyaelm", "bbyaelb", "bbyaels", "bbyaelt", "bbyaelp", "bbyaelh", "bbyaem", "bbyaeb", "bbyaebs", "bbyaes", "bbyaess", "bbyaeng", "bbyaej", "bbyaec", "bbyaek", "bbyaet", "bbyaep", "bbyaeh", "bbeo", "bbeog", "bbeogg", "bbeogs", "bbeon", "bbeonj", "bbeonh", "bbeod", "bbeol", "bbeolg", "bbeolm", "bbeolb", "bbeols", "bbeolt", "bbeolp", "bbeolh", "bbeom", "bbeob", "bbeobs", "bbeos", "bbeoss", "bbeong", "bbeoj", "bbeoc", "bbeok", "bbeot", "bbeop", "bbeoh", "bbe", "bbeg", "bbegg", "bbegs", "bben", "bbenj", "bbenh", "bbed", "bbel", "bbelg", "bbelm", "bbelb", "bbels", "bbelt", "bbelp", "bbelh", "bbem", "bbeb", "bbebs", "bbes"];
  }
});

// node_modules/unidecode/data/xbf.js
var require_xbf = __commonJS({
  "node_modules/unidecode/data/xbf.js"(exports, module2) {
    module2.exports = ["bbess", "bbeng", "bbej", "bbec", "bbek", "bbet", "bbep", "bbeh", "bbyeo", "bbyeog", "bbyeogg", "bbyeogs", "bbyeon", "bbyeonj", "bbyeonh", "bbyeod", "bbyeol", "bbyeolg", "bbyeolm", "bbyeolb", "bbyeols", "bbyeolt", "bbyeolp", "bbyeolh", "bbyeom", "bbyeob", "bbyeobs", "bbyeos", "bbyeoss", "bbyeong", "bbyeoj", "bbyeoc", "bbyeok", "bbyeot", "bbyeop", "bbyeoh", "bbye", "bbyeg", "bbyegg", "bbyegs", "bbyen", "bbyenj", "bbyenh", "bbyed", "bbyel", "bbyelg", "bbyelm", "bbyelb", "bbyels", "bbyelt", "bbyelp", "bbyelh", "bbyem", "bbyeb", "bbyebs", "bbyes", "bbyess", "bbyeng", "bbyej", "bbyec", "bbyek", "bbyet", "bbyep", "bbyeh", "bbo", "bbog", "bbogg", "bbogs", "bbon", "bbonj", "bbonh", "bbod", "bbol", "bbolg", "bbolm", "bbolb", "bbols", "bbolt", "bbolp", "bbolh", "bbom", "bbob", "bbobs", "bbos", "bboss", "bbong", "bboj", "bboc", "bbok", "bbot", "bbop", "bboh", "bbwa", "bbwag", "bbwagg", "bbwags", "bbwan", "bbwanj", "bbwanh", "bbwad", "bbwal", "bbwalg", "bbwalm", "bbwalb", "bbwals", "bbwalt", "bbwalp", "bbwalh", "bbwam", "bbwab", "bbwabs", "bbwas", "bbwass", "bbwang", "bbwaj", "bbwac", "bbwak", "bbwat", "bbwap", "bbwah", "bbwae", "bbwaeg", "bbwaegg", "bbwaegs", "bbwaen", "bbwaenj", "bbwaenh", "bbwaed", "bbwael", "bbwaelg", "bbwaelm", "bbwaelb", "bbwaels", "bbwaelt", "bbwaelp", "bbwaelh", "bbwaem", "bbwaeb", "bbwaebs", "bbwaes", "bbwaess", "bbwaeng", "bbwaej", "bbwaec", "bbwaek", "bbwaet", "bbwaep", "bbwaeh", "bboe", "bboeg", "bboegg", "bboegs", "bboen", "bboenj", "bboenh", "bboed", "bboel", "bboelg", "bboelm", "bboelb", "bboels", "bboelt", "bboelp", "bboelh", "bboem", "bboeb", "bboebs", "bboes", "bboess", "bboeng", "bboej", "bboec", "bboek", "bboet", "bboep", "bboeh", "bbyo", "bbyog", "bbyogg", "bbyogs", "bbyon", "bbyonj", "bbyonh", "bbyod", "bbyol", "bbyolg", "bbyolm", "bbyolb", "bbyols", "bbyolt", "bbyolp", "bbyolh", "bbyom", "bbyob", "bbyobs", "bbyos", "bbyoss", "bbyong", "bbyoj", "bbyoc", "bbyok", "bbyot", "bbyop", "bbyoh", "bbu", "bbug", "bbugg", "bbugs", "bbun", "bbunj", "bbunh", "bbud", "bbul", "bbulg", "bbulm", "bbulb", "bbuls", "bbult", "bbulp", "bbulh", "bbum", "bbub", "bbubs", "bbus", "bbuss", "bbung", "bbuj", "bbuc", "bbuk", "bbut", "bbup", "bbuh", "bbweo", "bbweog", "bbweogg", "bbweogs", "bbweon", "bbweonj", "bbweonh", "bbweod", "bbweol", "bbweolg", "bbweolm", "bbweolb", "bbweols", "bbweolt", "bbweolp", "bbweolh", "bbweom", "bbweob", "bbweobs", "bbweos", "bbweoss", "bbweong", "bbweoj", "bbweoc"];
  }
});

// node_modules/unidecode/data/xc0.js
var require_xc0 = __commonJS({
  "node_modules/unidecode/data/xc0.js"(exports, module2) {
    module2.exports = ["bbweok", "bbweot", "bbweop", "bbweoh", "bbwe", "bbweg", "bbwegg", "bbwegs", "bbwen", "bbwenj", "bbwenh", "bbwed", "bbwel", "bbwelg", "bbwelm", "bbwelb", "bbwels", "bbwelt", "bbwelp", "bbwelh", "bbwem", "bbweb", "bbwebs", "bbwes", "bbwess", "bbweng", "bbwej", "bbwec", "bbwek", "bbwet", "bbwep", "bbweh", "bbwi", "bbwig", "bbwigg", "bbwigs", "bbwin", "bbwinj", "bbwinh", "bbwid", "bbwil", "bbwilg", "bbwilm", "bbwilb", "bbwils", "bbwilt", "bbwilp", "bbwilh", "bbwim", "bbwib", "bbwibs", "bbwis", "bbwiss", "bbwing", "bbwij", "bbwic", "bbwik", "bbwit", "bbwip", "bbwih", "bbyu", "bbyug", "bbyugg", "bbyugs", "bbyun", "bbyunj", "bbyunh", "bbyud", "bbyul", "bbyulg", "bbyulm", "bbyulb", "bbyuls", "bbyult", "bbyulp", "bbyulh", "bbyum", "bbyub", "bbyubs", "bbyus", "bbyuss", "bbyung", "bbyuj", "bbyuc", "bbyuk", "bbyut", "bbyup", "bbyuh", "bbeu", "bbeug", "bbeugg", "bbeugs", "bbeun", "bbeunj", "bbeunh", "bbeud", "bbeul", "bbeulg", "bbeulm", "bbeulb", "bbeuls", "bbeult", "bbeulp", "bbeulh", "bbeum", "bbeub", "bbeubs", "bbeus", "bbeuss", "bbeung", "bbeuj", "bbeuc", "bbeuk", "bbeut", "bbeup", "bbeuh", "bbyi", "bbyig", "bbyigg", "bbyigs", "bbyin", "bbyinj", "bbyinh", "bbyid", "bbyil", "bbyilg", "bbyilm", "bbyilb", "bbyils", "bbyilt", "bbyilp", "bbyilh", "bbyim", "bbyib", "bbyibs", "bbyis", "bbyiss", "bbying", "bbyij", "bbyic", "bbyik", "bbyit", "bbyip", "bbyih", "bbi", "bbig", "bbigg", "bbigs", "bbin", "bbinj", "bbinh", "bbid", "bbil", "bbilg", "bbilm", "bbilb", "bbils", "bbilt", "bbilp", "bbilh", "bbim", "bbib", "bbibs", "bbis", "bbiss", "bbing", "bbij", "bbic", "bbik", "bbit", "bbip", "bbih", "sa", "sag", "sagg", "sags", "san", "sanj", "sanh", "sad", "sal", "salg", "salm", "salb", "sals", "salt", "salp", "salh", "sam", "sab", "sabs", "sas", "sass", "sang", "saj", "sac", "sak", "sat", "sap", "sah", "sae", "saeg", "saegg", "saegs", "saen", "saenj", "saenh", "saed", "sael", "saelg", "saelm", "saelb", "saels", "saelt", "saelp", "saelh", "saem", "saeb", "saebs", "saes", "saess", "saeng", "saej", "saec", "saek", "saet", "saep", "saeh", "sya", "syag", "syagg", "syags", "syan", "syanj", "syanh", "syad", "syal", "syalg", "syalm", "syalb", "syals", "syalt", "syalp", "syalh", "syam", "syab", "syabs", "syas", "syass", "syang", "syaj", "syac", "syak", "syat", "syap", "syah"];
  }
});

// node_modules/unidecode/data/xc1.js
var require_xc1 = __commonJS({
  "node_modules/unidecode/data/xc1.js"(exports, module2) {
    module2.exports = ["syae", "syaeg", "syaegg", "syaegs", "syaen", "syaenj", "syaenh", "syaed", "syael", "syaelg", "syaelm", "syaelb", "syaels", "syaelt", "syaelp", "syaelh", "syaem", "syaeb", "syaebs", "syaes", "syaess", "syaeng", "syaej", "syaec", "syaek", "syaet", "syaep", "syaeh", "seo", "seog", "seogg", "seogs", "seon", "seonj", "seonh", "seod", "seol", "seolg", "seolm", "seolb", "seols", "seolt", "seolp", "seolh", "seom", "seob", "seobs", "seos", "seoss", "seong", "seoj", "seoc", "seok", "seot", "seop", "seoh", "se", "seg", "segg", "segs", "sen", "senj", "senh", "sed", "sel", "selg", "selm", "selb", "sels", "selt", "selp", "selh", "sem", "seb", "sebs", "ses", "sess", "seng", "sej", "sec", "sek", "set", "sep", "seh", "syeo", "syeog", "syeogg", "syeogs", "syeon", "syeonj", "syeonh", "syeod", "syeol", "syeolg", "syeolm", "syeolb", "syeols", "syeolt", "syeolp", "syeolh", "syeom", "syeob", "syeobs", "syeos", "syeoss", "syeong", "syeoj", "syeoc", "syeok", "syeot", "syeop", "syeoh", "sye", "syeg", "syegg", "syegs", "syen", "syenj", "syenh", "syed", "syel", "syelg", "syelm", "syelb", "syels", "syelt", "syelp", "syelh", "syem", "syeb", "syebs", "syes", "syess", "syeng", "syej", "syec", "syek", "syet", "syep", "syeh", "so", "sog", "sogg", "sogs", "son", "sonj", "sonh", "sod", "sol", "solg", "solm", "solb", "sols", "solt", "solp", "solh", "som", "sob", "sobs", "sos", "soss", "song", "soj", "soc", "sok", "sot", "sop", "soh", "swa", "swag", "swagg", "swags", "swan", "swanj", "swanh", "swad", "swal", "swalg", "swalm", "swalb", "swals", "swalt", "swalp", "swalh", "swam", "swab", "swabs", "swas", "swass", "swang", "swaj", "swac", "swak", "swat", "swap", "swah", "swae", "swaeg", "swaegg", "swaegs", "swaen", "swaenj", "swaenh", "swaed", "swael", "swaelg", "swaelm", "swaelb", "swaels", "swaelt", "swaelp", "swaelh", "swaem", "swaeb", "swaebs", "swaes", "swaess", "swaeng", "swaej", "swaec", "swaek", "swaet", "swaep", "swaeh", "soe", "soeg", "soegg", "soegs", "soen", "soenj", "soenh", "soed", "soel", "soelg", "soelm", "soelb", "soels", "soelt", "soelp", "soelh", "soem", "soeb", "soebs", "soes", "soess", "soeng", "soej", "soec", "soek", "soet", "soep", "soeh", "syo", "syog", "syogg", "syogs"];
  }
});

// node_modules/unidecode/data/xc2.js
var require_xc2 = __commonJS({
  "node_modules/unidecode/data/xc2.js"(exports, module2) {
    module2.exports = ["syon", "syonj", "syonh", "syod", "syol", "syolg", "syolm", "syolb", "syols", "syolt", "syolp", "syolh", "syom", "syob", "syobs", "syos", "syoss", "syong", "syoj", "syoc", "syok", "syot", "syop", "syoh", "su", "sug", "sugg", "sugs", "sun", "sunj", "sunh", "sud", "sul", "sulg", "sulm", "sulb", "suls", "sult", "sulp", "sulh", "sum", "sub", "subs", "sus", "suss", "sung", "suj", "suc", "suk", "sut", "sup", "suh", "sweo", "sweog", "sweogg", "sweogs", "sweon", "sweonj", "sweonh", "sweod", "sweol", "sweolg", "sweolm", "sweolb", "sweols", "sweolt", "sweolp", "sweolh", "sweom", "sweob", "sweobs", "sweos", "sweoss", "sweong", "sweoj", "sweoc", "sweok", "sweot", "sweop", "sweoh", "swe", "sweg", "swegg", "swegs", "swen", "swenj", "swenh", "swed", "swel", "swelg", "swelm", "swelb", "swels", "swelt", "swelp", "swelh", "swem", "sweb", "swebs", "swes", "swess", "sweng", "swej", "swec", "swek", "swet", "swep", "sweh", "swi", "swig", "swigg", "swigs", "swin", "swinj", "swinh", "swid", "swil", "swilg", "swilm", "swilb", "swils", "swilt", "swilp", "swilh", "swim", "swib", "swibs", "swis", "swiss", "swing", "swij", "swic", "swik", "swit", "swip", "swih", "syu", "syug", "syugg", "syugs", "syun", "syunj", "syunh", "syud", "syul", "syulg", "syulm", "syulb", "syuls", "syult", "syulp", "syulh", "syum", "syub", "syubs", "syus", "syuss", "syung", "syuj", "syuc", "syuk", "syut", "syup", "syuh", "seu", "seug", "seugg", "seugs", "seun", "seunj", "seunh", "seud", "seul", "seulg", "seulm", "seulb", "seuls", "seult", "seulp", "seulh", "seum", "seub", "seubs", "seus", "seuss", "seung", "seuj", "seuc", "seuk", "seut", "seup", "seuh", "syi", "syig", "syigg", "syigs", "syin", "syinj", "syinh", "syid", "syil", "syilg", "syilm", "syilb", "syils", "syilt", "syilp", "syilh", "syim", "syib", "syibs", "syis", "syiss", "sying", "syij", "syic", "syik", "syit", "syip", "syih", "si", "sig", "sigg", "sigs", "sin", "sinj", "sinh", "sid", "sil", "silg", "silm", "silb", "sils", "silt", "silp", "silh", "sim", "sib", "sibs", "sis", "siss", "sing", "sij", "sic", "sik", "sit", "sip", "sih", "ssa", "ssag", "ssagg", "ssags", "ssan", "ssanj", "ssanh", "ssad"];
  }
});

// node_modules/unidecode/data/xc3.js
var require_xc3 = __commonJS({
  "node_modules/unidecode/data/xc3.js"(exports, module2) {
    module2.exports = ["ssal", "ssalg", "ssalm", "ssalb", "ssals", "ssalt", "ssalp", "ssalh", "ssam", "ssab", "ssabs", "ssas", "ssass", "ssang", "ssaj", "ssac", "ssak", "ssat", "ssap", "ssah", "ssae", "ssaeg", "ssaegg", "ssaegs", "ssaen", "ssaenj", "ssaenh", "ssaed", "ssael", "ssaelg", "ssaelm", "ssaelb", "ssaels", "ssaelt", "ssaelp", "ssaelh", "ssaem", "ssaeb", "ssaebs", "ssaes", "ssaess", "ssaeng", "ssaej", "ssaec", "ssaek", "ssaet", "ssaep", "ssaeh", "ssya", "ssyag", "ssyagg", "ssyags", "ssyan", "ssyanj", "ssyanh", "ssyad", "ssyal", "ssyalg", "ssyalm", "ssyalb", "ssyals", "ssyalt", "ssyalp", "ssyalh", "ssyam", "ssyab", "ssyabs", "ssyas", "ssyass", "ssyang", "ssyaj", "ssyac", "ssyak", "ssyat", "ssyap", "ssyah", "ssyae", "ssyaeg", "ssyaegg", "ssyaegs", "ssyaen", "ssyaenj", "ssyaenh", "ssyaed", "ssyael", "ssyaelg", "ssyaelm", "ssyaelb", "ssyaels", "ssyaelt", "ssyaelp", "ssyaelh", "ssyaem", "ssyaeb", "ssyaebs", "ssyaes", "ssyaess", "ssyaeng", "ssyaej", "ssyaec", "ssyaek", "ssyaet", "ssyaep", "ssyaeh", "sseo", "sseog", "sseogg", "sseogs", "sseon", "sseonj", "sseonh", "sseod", "sseol", "sseolg", "sseolm", "sseolb", "sseols", "sseolt", "sseolp", "sseolh", "sseom", "sseob", "sseobs", "sseos", "sseoss", "sseong", "sseoj", "sseoc", "sseok", "sseot", "sseop", "sseoh", "sse", "sseg", "ssegg", "ssegs", "ssen", "ssenj", "ssenh", "ssed", "ssel", "sselg", "sselm", "sselb", "ssels", "sselt", "sselp", "sselh", "ssem", "sseb", "ssebs", "sses", "ssess", "sseng", "ssej", "ssec", "ssek", "sset", "ssep", "sseh", "ssyeo", "ssyeog", "ssyeogg", "ssyeogs", "ssyeon", "ssyeonj", "ssyeonh", "ssyeod", "ssyeol", "ssyeolg", "ssyeolm", "ssyeolb", "ssyeols", "ssyeolt", "ssyeolp", "ssyeolh", "ssyeom", "ssyeob", "ssyeobs", "ssyeos", "ssyeoss", "ssyeong", "ssyeoj", "ssyeoc", "ssyeok", "ssyeot", "ssyeop", "ssyeoh", "ssye", "ssyeg", "ssyegg", "ssyegs", "ssyen", "ssyenj", "ssyenh", "ssyed", "ssyel", "ssyelg", "ssyelm", "ssyelb", "ssyels", "ssyelt", "ssyelp", "ssyelh", "ssyem", "ssyeb", "ssyebs", "ssyes", "ssyess", "ssyeng", "ssyej", "ssyec", "ssyek", "ssyet", "ssyep", "ssyeh", "sso", "ssog", "ssogg", "ssogs", "sson", "ssonj", "ssonh", "ssod", "ssol", "ssolg", "ssolm", "ssolb", "ssols", "ssolt", "ssolp", "ssolh", "ssom", "ssob", "ssobs", "ssos", "ssoss", "ssong", "ssoj", "ssoc", "ssok", "ssot", "ssop", "ssoh", "sswa", "sswag", "sswagg", "sswags", "sswan", "sswanj", "sswanh", "sswad", "sswal", "sswalg", "sswalm", "sswalb"];
  }
});

// node_modules/unidecode/data/xc4.js
var require_xc4 = __commonJS({
  "node_modules/unidecode/data/xc4.js"(exports, module2) {
    module2.exports = ["sswals", "sswalt", "sswalp", "sswalh", "sswam", "sswab", "sswabs", "sswas", "sswass", "sswang", "sswaj", "sswac", "sswak", "sswat", "sswap", "sswah", "sswae", "sswaeg", "sswaegg", "sswaegs", "sswaen", "sswaenj", "sswaenh", "sswaed", "sswael", "sswaelg", "sswaelm", "sswaelb", "sswaels", "sswaelt", "sswaelp", "sswaelh", "sswaem", "sswaeb", "sswaebs", "sswaes", "sswaess", "sswaeng", "sswaej", "sswaec", "sswaek", "sswaet", "sswaep", "sswaeh", "ssoe", "ssoeg", "ssoegg", "ssoegs", "ssoen", "ssoenj", "ssoenh", "ssoed", "ssoel", "ssoelg", "ssoelm", "ssoelb", "ssoels", "ssoelt", "ssoelp", "ssoelh", "ssoem", "ssoeb", "ssoebs", "ssoes", "ssoess", "ssoeng", "ssoej", "ssoec", "ssoek", "ssoet", "ssoep", "ssoeh", "ssyo", "ssyog", "ssyogg", "ssyogs", "ssyon", "ssyonj", "ssyonh", "ssyod", "ssyol", "ssyolg", "ssyolm", "ssyolb", "ssyols", "ssyolt", "ssyolp", "ssyolh", "ssyom", "ssyob", "ssyobs", "ssyos", "ssyoss", "ssyong", "ssyoj", "ssyoc", "ssyok", "ssyot", "ssyop", "ssyoh", "ssu", "ssug", "ssugg", "ssugs", "ssun", "ssunj", "ssunh", "ssud", "ssul", "ssulg", "ssulm", "ssulb", "ssuls", "ssult", "ssulp", "ssulh", "ssum", "ssub", "ssubs", "ssus", "ssuss", "ssung", "ssuj", "ssuc", "ssuk", "ssut", "ssup", "ssuh", "ssweo", "ssweog", "ssweogg", "ssweogs", "ssweon", "ssweonj", "ssweonh", "ssweod", "ssweol", "ssweolg", "ssweolm", "ssweolb", "ssweols", "ssweolt", "ssweolp", "ssweolh", "ssweom", "ssweob", "ssweobs", "ssweos", "ssweoss", "ssweong", "ssweoj", "ssweoc", "ssweok", "ssweot", "ssweop", "ssweoh", "sswe", "ssweg", "sswegg", "sswegs", "sswen", "sswenj", "sswenh", "sswed", "sswel", "sswelg", "sswelm", "sswelb", "sswels", "sswelt", "sswelp", "sswelh", "sswem", "ssweb", "sswebs", "sswes", "sswess", "ssweng", "sswej", "sswec", "sswek", "sswet", "sswep", "ssweh", "sswi", "sswig", "sswigg", "sswigs", "sswin", "sswinj", "sswinh", "sswid", "sswil", "sswilg", "sswilm", "sswilb", "sswils", "sswilt", "sswilp", "sswilh", "sswim", "sswib", "sswibs", "sswis", "sswiss", "sswing", "sswij", "sswic", "sswik", "sswit", "sswip", "sswih", "ssyu", "ssyug", "ssyugg", "ssyugs", "ssyun", "ssyunj", "ssyunh", "ssyud", "ssyul", "ssyulg", "ssyulm", "ssyulb", "ssyuls", "ssyult", "ssyulp", "ssyulh", "ssyum", "ssyub", "ssyubs", "ssyus", "ssyuss", "ssyung", "ssyuj", "ssyuc", "ssyuk", "ssyut", "ssyup", "ssyuh", "sseu", "sseug", "sseugg", "sseugs", "sseun", "sseunj", "sseunh", "sseud", "sseul", "sseulg", "sseulm", "sseulb", "sseuls", "sseult", "sseulp", "sseulh"];
  }
});

// node_modules/unidecode/data/xc5.js
var require_xc5 = __commonJS({
  "node_modules/unidecode/data/xc5.js"(exports, module2) {
    module2.exports = ["sseum", "sseub", "sseubs", "sseus", "sseuss", "sseung", "sseuj", "sseuc", "sseuk", "sseut", "sseup", "sseuh", "ssyi", "ssyig", "ssyigg", "ssyigs", "ssyin", "ssyinj", "ssyinh", "ssyid", "ssyil", "ssyilg", "ssyilm", "ssyilb", "ssyils", "ssyilt", "ssyilp", "ssyilh", "ssyim", "ssyib", "ssyibs", "ssyis", "ssyiss", "ssying", "ssyij", "ssyic", "ssyik", "ssyit", "ssyip", "ssyih", "ssi", "ssig", "ssigg", "ssigs", "ssin", "ssinj", "ssinh", "ssid", "ssil", "ssilg", "ssilm", "ssilb", "ssils", "ssilt", "ssilp", "ssilh", "ssim", "ssib", "ssibs", "ssis", "ssiss", "ssing", "ssij", "ssic", "ssik", "ssit", "ssip", "ssih", "a", "ag", "agg", "ags", "an", "anj", "anh", "ad", "al", "alg", "alm", "alb", "als", "alt", "alp", "alh", "am", "ab", "abs", "as", "ass", "ang", "aj", "ac", "ak", "at", "ap", "ah", "ae", "aeg", "aegg", "aegs", "aen", "aenj", "aenh", "aed", "ael", "aelg", "aelm", "aelb", "aels", "aelt", "aelp", "aelh", "aem", "aeb", "aebs", "aes", "aess", "aeng", "aej", "aec", "aek", "aet", "aep", "aeh", "ya", "yag", "yagg", "yags", "yan", "yanj", "yanh", "yad", "yal", "yalg", "yalm", "yalb", "yals", "yalt", "yalp", "yalh", "yam", "yab", "yabs", "yas", "yass", "yang", "yaj", "yac", "yak", "yat", "yap", "yah", "yae", "yaeg", "yaegg", "yaegs", "yaen", "yaenj", "yaenh", "yaed", "yael", "yaelg", "yaelm", "yaelb", "yaels", "yaelt", "yaelp", "yaelh", "yaem", "yaeb", "yaebs", "yaes", "yaess", "yaeng", "yaej", "yaec", "yaek", "yaet", "yaep", "yaeh", "eo", "eog", "eogg", "eogs", "eon", "eonj", "eonh", "eod", "eol", "eolg", "eolm", "eolb", "eols", "eolt", "eolp", "eolh", "eom", "eob", "eobs", "eos", "eoss", "eong", "eoj", "eoc", "eok", "eot", "eop", "eoh", "e", "eg", "egg", "egs", "en", "enj", "enh", "ed", "el", "elg", "elm", "elb", "els", "elt", "elp", "elh", "em", "eb", "ebs", "es", "ess", "eng", "ej", "ec", "ek", "et", "ep", "eh", "yeo", "yeog", "yeogg", "yeogs", "yeon", "yeonj", "yeonh", "yeod", "yeol", "yeolg", "yeolm", "yeolb", "yeols", "yeolt", "yeolp", "yeolh", "yeom", "yeob", "yeobs", "yeos"];
  }
});

// node_modules/unidecode/data/xc6.js
var require_xc6 = __commonJS({
  "node_modules/unidecode/data/xc6.js"(exports, module2) {
    module2.exports = ["yeoss", "yeong", "yeoj", "yeoc", "yeok", "yeot", "yeop", "yeoh", "ye", "yeg", "yegg", "yegs", "yen", "yenj", "yenh", "yed", "yel", "yelg", "yelm", "yelb", "yels", "yelt", "yelp", "yelh", "yem", "yeb", "yebs", "yes", "yess", "yeng", "yej", "yec", "yek", "yet", "yep", "yeh", "o", "og", "ogg", "ogs", "on", "onj", "onh", "od", "ol", "olg", "olm", "olb", "ols", "olt", "olp", "olh", "om", "ob", "obs", "os", "oss", "ong", "oj", "oc", "ok", "ot", "op", "oh", "wa", "wag", "wagg", "wags", "wan", "wanj", "wanh", "wad", "wal", "walg", "walm", "walb", "wals", "walt", "walp", "walh", "wam", "wab", "wabs", "was", "wass", "wang", "waj", "wac", "wak", "wat", "wap", "wah", "wae", "waeg", "waegg", "waegs", "waen", "waenj", "waenh", "waed", "wael", "waelg", "waelm", "waelb", "waels", "waelt", "waelp", "waelh", "waem", "waeb", "waebs", "waes", "waess", "waeng", "waej", "waec", "waek", "waet", "waep", "waeh", "oe", "oeg", "oegg", "oegs", "oen", "oenj", "oenh", "oed", "oel", "oelg", "oelm", "oelb", "oels", "oelt", "oelp", "oelh", "oem", "oeb", "oebs", "oes", "oess", "oeng", "oej", "oec", "oek", "oet", "oep", "oeh", "yo", "yog", "yogg", "yogs", "yon", "yonj", "yonh", "yod", "yol", "yolg", "yolm", "yolb", "yols", "yolt", "yolp", "yolh", "yom", "yob", "yobs", "yos", "yoss", "yong", "yoj", "yoc", "yok", "yot", "yop", "yoh", "u", "ug", "ugg", "ugs", "un", "unj", "unh", "ud", "ul", "ulg", "ulm", "ulb", "uls", "ult", "ulp", "ulh", "um", "ub", "ubs", "us", "uss", "ung", "uj", "uc", "uk", "ut", "up", "uh", "weo", "weog", "weogg", "weogs", "weon", "weonj", "weonh", "weod", "weol", "weolg", "weolm", "weolb", "weols", "weolt", "weolp", "weolh", "weom", "weob", "weobs", "weos", "weoss", "weong", "weoj", "weoc", "weok", "weot", "weop", "weoh", "we", "weg", "wegg", "wegs", "wen", "wenj", "wenh", "wed", "wel", "welg", "welm", "welb", "wels", "welt", "welp", "welh", "wem", "web", "webs", "wes", "wess", "weng", "wej", "wec"];
  }
});

// node_modules/unidecode/data/xc7.js
var require_xc7 = __commonJS({
  "node_modules/unidecode/data/xc7.js"(exports, module2) {
    module2.exports = ["wek", "wet", "wep", "weh", "wi", "wig", "wigg", "wigs", "win", "winj", "winh", "wid", "wil", "wilg", "wilm", "wilb", "wils", "wilt", "wilp", "wilh", "wim", "wib", "wibs", "wis", "wiss", "wing", "wij", "wic", "wik", "wit", "wip", "wih", "yu", "yug", "yugg", "yugs", "yun", "yunj", "yunh", "yud", "yul", "yulg", "yulm", "yulb", "yuls", "yult", "yulp", "yulh", "yum", "yub", "yubs", "yus", "yuss", "yung", "yuj", "yuc", "yuk", "yut", "yup", "yuh", "eu", "eug", "eugg", "eugs", "eun", "eunj", "eunh", "eud", "eul", "eulg", "eulm", "eulb", "euls", "eult", "eulp", "eulh", "eum", "eub", "eubs", "eus", "euss", "eung", "euj", "euc", "euk", "eut", "eup", "euh", "yi", "yig", "yigg", "yigs", "yin", "yinj", "yinh", "yid", "yil", "yilg", "yilm", "yilb", "yils", "yilt", "yilp", "yilh", "yim", "yib", "yibs", "yis", "yiss", "ying", "yij", "yic", "yik", "yit", "yip", "yih", "i", "ig", "igg", "igs", "in", "inj", "inh", "id", "il", "ilg", "ilm", "ilb", "ils", "ilt", "ilp", "ilh", "im", "ib", "ibs", "is", "iss", "ing", "ij", "ic", "ik", "it", "ip", "ih", "ja", "jag", "jagg", "jags", "jan", "janj", "janh", "jad", "jal", "jalg", "jalm", "jalb", "jals", "jalt", "jalp", "jalh", "jam", "jab", "jabs", "jas", "jass", "jang", "jaj", "jac", "jak", "jat", "jap", "jah", "jae", "jaeg", "jaegg", "jaegs", "jaen", "jaenj", "jaenh", "jaed", "jael", "jaelg", "jaelm", "jaelb", "jaels", "jaelt", "jaelp", "jaelh", "jaem", "jaeb", "jaebs", "jaes", "jaess", "jaeng", "jaej", "jaec", "jaek", "jaet", "jaep", "jaeh", "jya", "jyag", "jyagg", "jyags", "jyan", "jyanj", "jyanh", "jyad", "jyal", "jyalg", "jyalm", "jyalb", "jyals", "jyalt", "jyalp", "jyalh", "jyam", "jyab", "jyabs", "jyas", "jyass", "jyang", "jyaj", "jyac", "jyak", "jyat", "jyap", "jyah", "jyae", "jyaeg", "jyaegg", "jyaegs", "jyaen", "jyaenj", "jyaenh", "jyaed", "jyael", "jyaelg", "jyaelm", "jyaelb", "jyaels", "jyaelt", "jyaelp", "jyaelh", "jyaem", "jyaeb", "jyaebs", "jyaes", "jyaess", "jyaeng", "jyaej", "jyaec", "jyaek", "jyaet", "jyaep", "jyaeh"];
  }
});

// node_modules/unidecode/data/xc8.js
var require_xc8 = __commonJS({
  "node_modules/unidecode/data/xc8.js"(exports, module2) {
    module2.exports = ["jeo", "jeog", "jeogg", "jeogs", "jeon", "jeonj", "jeonh", "jeod", "jeol", "jeolg", "jeolm", "jeolb", "jeols", "jeolt", "jeolp", "jeolh", "jeom", "jeob", "jeobs", "jeos", "jeoss", "jeong", "jeoj", "jeoc", "jeok", "jeot", "jeop", "jeoh", "je", "jeg", "jegg", "jegs", "jen", "jenj", "jenh", "jed", "jel", "jelg", "jelm", "jelb", "jels", "jelt", "jelp", "jelh", "jem", "jeb", "jebs", "jes", "jess", "jeng", "jej", "jec", "jek", "jet", "jep", "jeh", "jyeo", "jyeog", "jyeogg", "jyeogs", "jyeon", "jyeonj", "jyeonh", "jyeod", "jyeol", "jyeolg", "jyeolm", "jyeolb", "jyeols", "jyeolt", "jyeolp", "jyeolh", "jyeom", "jyeob", "jyeobs", "jyeos", "jyeoss", "jyeong", "jyeoj", "jyeoc", "jyeok", "jyeot", "jyeop", "jyeoh", "jye", "jyeg", "jyegg", "jyegs", "jyen", "jyenj", "jyenh", "jyed", "jyel", "jyelg", "jyelm", "jyelb", "jyels", "jyelt", "jyelp", "jyelh", "jyem", "jyeb", "jyebs", "jyes", "jyess", "jyeng", "jyej", "jyec", "jyek", "jyet", "jyep", "jyeh", "jo", "jog", "jogg", "jogs", "jon", "jonj", "jonh", "jod", "jol", "jolg", "jolm", "jolb", "jols", "jolt", "jolp", "jolh", "jom", "job", "jobs", "jos", "joss", "jong", "joj", "joc", "jok", "jot", "jop", "joh", "jwa", "jwag", "jwagg", "jwags", "jwan", "jwanj", "jwanh", "jwad", "jwal", "jwalg", "jwalm", "jwalb", "jwals", "jwalt", "jwalp", "jwalh", "jwam", "jwab", "jwabs", "jwas", "jwass", "jwang", "jwaj", "jwac", "jwak", "jwat", "jwap", "jwah", "jwae", "jwaeg", "jwaegg", "jwaegs", "jwaen", "jwaenj", "jwaenh", "jwaed", "jwael", "jwaelg", "jwaelm", "jwaelb", "jwaels", "jwaelt", "jwaelp", "jwaelh", "jwaem", "jwaeb", "jwaebs", "jwaes", "jwaess", "jwaeng", "jwaej", "jwaec", "jwaek", "jwaet", "jwaep", "jwaeh", "joe", "joeg", "joegg", "joegs", "joen", "joenj", "joenh", "joed", "joel", "joelg", "joelm", "joelb", "joels", "joelt", "joelp", "joelh", "joem", "joeb", "joebs", "joes", "joess", "joeng", "joej", "joec", "joek", "joet", "joep", "joeh", "jyo", "jyog", "jyogg", "jyogs", "jyon", "jyonj", "jyonh", "jyod", "jyol", "jyolg", "jyolm", "jyolb", "jyols", "jyolt", "jyolp", "jyolh", "jyom", "jyob", "jyobs", "jyos", "jyoss", "jyong", "jyoj", "jyoc", "jyok", "jyot", "jyop", "jyoh", "ju", "jug", "jugg", "jugs"];
  }
});

// node_modules/unidecode/data/xc9.js
var require_xc9 = __commonJS({
  "node_modules/unidecode/data/xc9.js"(exports, module2) {
    module2.exports = ["jun", "junj", "junh", "jud", "jul", "julg", "julm", "julb", "juls", "jult", "julp", "julh", "jum", "jub", "jubs", "jus", "juss", "jung", "juj", "juc", "juk", "jut", "jup", "juh", "jweo", "jweog", "jweogg", "jweogs", "jweon", "jweonj", "jweonh", "jweod", "jweol", "jweolg", "jweolm", "jweolb", "jweols", "jweolt", "jweolp", "jweolh", "jweom", "jweob", "jweobs", "jweos", "jweoss", "jweong", "jweoj", "jweoc", "jweok", "jweot", "jweop", "jweoh", "jwe", "jweg", "jwegg", "jwegs", "jwen", "jwenj", "jwenh", "jwed", "jwel", "jwelg", "jwelm", "jwelb", "jwels", "jwelt", "jwelp", "jwelh", "jwem", "jweb", "jwebs", "jwes", "jwess", "jweng", "jwej", "jwec", "jwek", "jwet", "jwep", "jweh", "jwi", "jwig", "jwigg", "jwigs", "jwin", "jwinj", "jwinh", "jwid", "jwil", "jwilg", "jwilm", "jwilb", "jwils", "jwilt", "jwilp", "jwilh", "jwim", "jwib", "jwibs", "jwis", "jwiss", "jwing", "jwij", "jwic", "jwik", "jwit", "jwip", "jwih", "jyu", "jyug", "jyugg", "jyugs", "jyun", "jyunj", "jyunh", "jyud", "jyul", "jyulg", "jyulm", "jyulb", "jyuls", "jyult", "jyulp", "jyulh", "jyum", "jyub", "jyubs", "jyus", "jyuss", "jyung", "jyuj", "jyuc", "jyuk", "jyut", "jyup", "jyuh", "jeu", "jeug", "jeugg", "jeugs", "jeun", "jeunj", "jeunh", "jeud", "jeul", "jeulg", "jeulm", "jeulb", "jeuls", "jeult", "jeulp", "jeulh", "jeum", "jeub", "jeubs", "jeus", "jeuss", "jeung", "jeuj", "jeuc", "jeuk", "jeut", "jeup", "jeuh", "jyi", "jyig", "jyigg", "jyigs", "jyin", "jyinj", "jyinh", "jyid", "jyil", "jyilg", "jyilm", "jyilb", "jyils", "jyilt", "jyilp", "jyilh", "jyim", "jyib", "jyibs", "jyis", "jyiss", "jying", "jyij", "jyic", "jyik", "jyit", "jyip", "jyih", "ji", "jig", "jigg", "jigs", "jin", "jinj", "jinh", "jid", "jil", "jilg", "jilm", "jilb", "jils", "jilt", "jilp", "jilh", "jim", "jib", "jibs", "jis", "jiss", "jing", "jij", "jic", "jik", "jit", "jip", "jih", "jja", "jjag", "jjagg", "jjags", "jjan", "jjanj", "jjanh", "jjad", "jjal", "jjalg", "jjalm", "jjalb", "jjals", "jjalt", "jjalp", "jjalh", "jjam", "jjab", "jjabs", "jjas", "jjass", "jjang", "jjaj", "jjac", "jjak", "jjat", "jjap", "jjah", "jjae", "jjaeg", "jjaegg", "jjaegs", "jjaen", "jjaenj", "jjaenh", "jjaed"];
  }
});

// node_modules/unidecode/data/xca.js
var require_xca = __commonJS({
  "node_modules/unidecode/data/xca.js"(exports, module2) {
    module2.exports = ["jjael", "jjaelg", "jjaelm", "jjaelb", "jjaels", "jjaelt", "jjaelp", "jjaelh", "jjaem", "jjaeb", "jjaebs", "jjaes", "jjaess", "jjaeng", "jjaej", "jjaec", "jjaek", "jjaet", "jjaep", "jjaeh", "jjya", "jjyag", "jjyagg", "jjyags", "jjyan", "jjyanj", "jjyanh", "jjyad", "jjyal", "jjyalg", "jjyalm", "jjyalb", "jjyals", "jjyalt", "jjyalp", "jjyalh", "jjyam", "jjyab", "jjyabs", "jjyas", "jjyass", "jjyang", "jjyaj", "jjyac", "jjyak", "jjyat", "jjyap", "jjyah", "jjyae", "jjyaeg", "jjyaegg", "jjyaegs", "jjyaen", "jjyaenj", "jjyaenh", "jjyaed", "jjyael", "jjyaelg", "jjyaelm", "jjyaelb", "jjyaels", "jjyaelt", "jjyaelp", "jjyaelh", "jjyaem", "jjyaeb", "jjyaebs", "jjyaes", "jjyaess", "jjyaeng", "jjyaej", "jjyaec", "jjyaek", "jjyaet", "jjyaep", "jjyaeh", "jjeo", "jjeog", "jjeogg", "jjeogs", "jjeon", "jjeonj", "jjeonh", "jjeod", "jjeol", "jjeolg", "jjeolm", "jjeolb", "jjeols", "jjeolt", "jjeolp", "jjeolh", "jjeom", "jjeob", "jjeobs", "jjeos", "jjeoss", "jjeong", "jjeoj", "jjeoc", "jjeok", "jjeot", "jjeop", "jjeoh", "jje", "jjeg", "jjegg", "jjegs", "jjen", "jjenj", "jjenh", "jjed", "jjel", "jjelg", "jjelm", "jjelb", "jjels", "jjelt", "jjelp", "jjelh", "jjem", "jjeb", "jjebs", "jjes", "jjess", "jjeng", "jjej", "jjec", "jjek", "jjet", "jjep", "jjeh", "jjyeo", "jjyeog", "jjyeogg", "jjyeogs", "jjyeon", "jjyeonj", "jjyeonh", "jjyeod", "jjyeol", "jjyeolg", "jjyeolm", "jjyeolb", "jjyeols", "jjyeolt", "jjyeolp", "jjyeolh", "jjyeom", "jjyeob", "jjyeobs", "jjyeos", "jjyeoss", "jjyeong", "jjyeoj", "jjyeoc", "jjyeok", "jjyeot", "jjyeop", "jjyeoh", "jjye", "jjyeg", "jjyegg", "jjyegs", "jjyen", "jjyenj", "jjyenh", "jjyed", "jjyel", "jjyelg", "jjyelm", "jjyelb", "jjyels", "jjyelt", "jjyelp", "jjyelh", "jjyem", "jjyeb", "jjyebs", "jjyes", "jjyess", "jjyeng", "jjyej", "jjyec", "jjyek", "jjyet", "jjyep", "jjyeh", "jjo", "jjog", "jjogg", "jjogs", "jjon", "jjonj", "jjonh", "jjod", "jjol", "jjolg", "jjolm", "jjolb", "jjols", "jjolt", "jjolp", "jjolh", "jjom", "jjob", "jjobs", "jjos", "jjoss", "jjong", "jjoj", "jjoc", "jjok", "jjot", "jjop", "jjoh", "jjwa", "jjwag", "jjwagg", "jjwags", "jjwan", "jjwanj", "jjwanh", "jjwad", "jjwal", "jjwalg", "jjwalm", "jjwalb", "jjwals", "jjwalt", "jjwalp", "jjwalh", "jjwam", "jjwab", "jjwabs", "jjwas", "jjwass", "jjwang", "jjwaj", "jjwac", "jjwak", "jjwat", "jjwap", "jjwah", "jjwae", "jjwaeg", "jjwaegg", "jjwaegs", "jjwaen", "jjwaenj", "jjwaenh", "jjwaed", "jjwael", "jjwaelg", "jjwaelm", "jjwaelb"];
  }
});

// node_modules/unidecode/data/xcb.js
var require_xcb = __commonJS({
  "node_modules/unidecode/data/xcb.js"(exports, module2) {
    module2.exports = ["jjwaels", "jjwaelt", "jjwaelp", "jjwaelh", "jjwaem", "jjwaeb", "jjwaebs", "jjwaes", "jjwaess", "jjwaeng", "jjwaej", "jjwaec", "jjwaek", "jjwaet", "jjwaep", "jjwaeh", "jjoe", "jjoeg", "jjoegg", "jjoegs", "jjoen", "jjoenj", "jjoenh", "jjoed", "jjoel", "jjoelg", "jjoelm", "jjoelb", "jjoels", "jjoelt", "jjoelp", "jjoelh", "jjoem", "jjoeb", "jjoebs", "jjoes", "jjoess", "jjoeng", "jjoej", "jjoec", "jjoek", "jjoet", "jjoep", "jjoeh", "jjyo", "jjyog", "jjyogg", "jjyogs", "jjyon", "jjyonj", "jjyonh", "jjyod", "jjyol", "jjyolg", "jjyolm", "jjyolb", "jjyols", "jjyolt", "jjyolp", "jjyolh", "jjyom", "jjyob", "jjyobs", "jjyos", "jjyoss", "jjyong", "jjyoj", "jjyoc", "jjyok", "jjyot", "jjyop", "jjyoh", "jju", "jjug", "jjugg", "jjugs", "jjun", "jjunj", "jjunh", "jjud", "jjul", "jjulg", "jjulm", "jjulb", "jjuls", "jjult", "jjulp", "jjulh", "jjum", "jjub", "jjubs", "jjus", "jjuss", "jjung", "jjuj", "jjuc", "jjuk", "jjut", "jjup", "jjuh", "jjweo", "jjweog", "jjweogg", "jjweogs", "jjweon", "jjweonj", "jjweonh", "jjweod", "jjweol", "jjweolg", "jjweolm", "jjweolb", "jjweols", "jjweolt", "jjweolp", "jjweolh", "jjweom", "jjweob", "jjweobs", "jjweos", "jjweoss", "jjweong", "jjweoj", "jjweoc", "jjweok", "jjweot", "jjweop", "jjweoh", "jjwe", "jjweg", "jjwegg", "jjwegs", "jjwen", "jjwenj", "jjwenh", "jjwed", "jjwel", "jjwelg", "jjwelm", "jjwelb", "jjwels", "jjwelt", "jjwelp", "jjwelh", "jjwem", "jjweb", "jjwebs", "jjwes", "jjwess", "jjweng", "jjwej", "jjwec", "jjwek", "jjwet", "jjwep", "jjweh", "jjwi", "jjwig", "jjwigg", "jjwigs", "jjwin", "jjwinj", "jjwinh", "jjwid", "jjwil", "jjwilg", "jjwilm", "jjwilb", "jjwils", "jjwilt", "jjwilp", "jjwilh", "jjwim", "jjwib", "jjwibs", "jjwis", "jjwiss", "jjwing", "jjwij", "jjwic", "jjwik", "jjwit", "jjwip", "jjwih", "jjyu", "jjyug", "jjyugg", "jjyugs", "jjyun", "jjyunj", "jjyunh", "jjyud", "jjyul", "jjyulg", "jjyulm", "jjyulb", "jjyuls", "jjyult", "jjyulp", "jjyulh", "jjyum", "jjyub", "jjyubs", "jjyus", "jjyuss", "jjyung", "jjyuj", "jjyuc", "jjyuk", "jjyut", "jjyup", "jjyuh", "jjeu", "jjeug", "jjeugg", "jjeugs", "jjeun", "jjeunj", "jjeunh", "jjeud", "jjeul", "jjeulg", "jjeulm", "jjeulb", "jjeuls", "jjeult", "jjeulp", "jjeulh", "jjeum", "jjeub", "jjeubs", "jjeus", "jjeuss", "jjeung", "jjeuj", "jjeuc", "jjeuk", "jjeut", "jjeup", "jjeuh", "jjyi", "jjyig", "jjyigg", "jjyigs", "jjyin", "jjyinj", "jjyinh", "jjyid", "jjyil", "jjyilg", "jjyilm", "jjyilb", "jjyils", "jjyilt", "jjyilp", "jjyilh"];
  }
});

// node_modules/unidecode/data/xcc.js
var require_xcc = __commonJS({
  "node_modules/unidecode/data/xcc.js"(exports, module2) {
    module2.exports = ["jjyim", "jjyib", "jjyibs", "jjyis", "jjyiss", "jjying", "jjyij", "jjyic", "jjyik", "jjyit", "jjyip", "jjyih", "jji", "jjig", "jjigg", "jjigs", "jjin", "jjinj", "jjinh", "jjid", "jjil", "jjilg", "jjilm", "jjilb", "jjils", "jjilt", "jjilp", "jjilh", "jjim", "jjib", "jjibs", "jjis", "jjiss", "jjing", "jjij", "jjic", "jjik", "jjit", "jjip", "jjih", "ca", "cag", "cagg", "cags", "can", "canj", "canh", "cad", "cal", "calg", "calm", "calb", "cals", "calt", "calp", "calh", "cam", "cab", "cabs", "cas", "cass", "cang", "caj", "cac", "cak", "cat", "cap", "cah", "cae", "caeg", "caegg", "caegs", "caen", "caenj", "caenh", "caed", "cael", "caelg", "caelm", "caelb", "caels", "caelt", "caelp", "caelh", "caem", "caeb", "caebs", "caes", "caess", "caeng", "caej", "caec", "caek", "caet", "caep", "caeh", "cya", "cyag", "cyagg", "cyags", "cyan", "cyanj", "cyanh", "cyad", "cyal", "cyalg", "cyalm", "cyalb", "cyals", "cyalt", "cyalp", "cyalh", "cyam", "cyab", "cyabs", "cyas", "cyass", "cyang", "cyaj", "cyac", "cyak", "cyat", "cyap", "cyah", "cyae", "cyaeg", "cyaegg", "cyaegs", "cyaen", "cyaenj", "cyaenh", "cyaed", "cyael", "cyaelg", "cyaelm", "cyaelb", "cyaels", "cyaelt", "cyaelp", "cyaelh", "cyaem", "cyaeb", "cyaebs", "cyaes", "cyaess", "cyaeng", "cyaej", "cyaec", "cyaek", "cyaet", "cyaep", "cyaeh", "ceo", "ceog", "ceogg", "ceogs", "ceon", "ceonj", "ceonh", "ceod", "ceol", "ceolg", "ceolm", "ceolb", "ceols", "ceolt", "ceolp", "ceolh", "ceom", "ceob", "ceobs", "ceos", "ceoss", "ceong", "ceoj", "ceoc", "ceok", "ceot", "ceop", "ceoh", "ce", "ceg", "cegg", "cegs", "cen", "cenj", "cenh", "ced", "cel", "celg", "celm", "celb", "cels", "celt", "celp", "celh", "cem", "ceb", "cebs", "ces", "cess", "ceng", "cej", "cec", "cek", "cet", "cep", "ceh", "cyeo", "cyeog", "cyeogg", "cyeogs", "cyeon", "cyeonj", "cyeonh", "cyeod", "cyeol", "cyeolg", "cyeolm", "cyeolb", "cyeols", "cyeolt", "cyeolp", "cyeolh", "cyeom", "cyeob", "cyeobs", "cyeos", "cyeoss", "cyeong", "cyeoj", "cyeoc", "cyeok", "cyeot", "cyeop", "cyeoh", "cye", "cyeg", "cyegg", "cyegs", "cyen", "cyenj", "cyenh", "cyed", "cyel", "cyelg", "cyelm", "cyelb", "cyels", "cyelt", "cyelp", "cyelh", "cyem", "cyeb", "cyebs", "cyes"];
  }
});

// node_modules/unidecode/data/xcd.js
var require_xcd = __commonJS({
  "node_modules/unidecode/data/xcd.js"(exports, module2) {
    module2.exports = ["cyess", "cyeng", "cyej", "cyec", "cyek", "cyet", "cyep", "cyeh", "co", "cog", "cogg", "cogs", "con", "conj", "conh", "cod", "col", "colg", "colm", "colb", "cols", "colt", "colp", "colh", "com", "cob", "cobs", "cos", "coss", "cong", "coj", "coc", "cok", "cot", "cop", "coh", "cwa", "cwag", "cwagg", "cwags", "cwan", "cwanj", "cwanh", "cwad", "cwal", "cwalg", "cwalm", "cwalb", "cwals", "cwalt", "cwalp", "cwalh", "cwam", "cwab", "cwabs", "cwas", "cwass", "cwang", "cwaj", "cwac", "cwak", "cwat", "cwap", "cwah", "cwae", "cwaeg", "cwaegg", "cwaegs", "cwaen", "cwaenj", "cwaenh", "cwaed", "cwael", "cwaelg", "cwaelm", "cwaelb", "cwaels", "cwaelt", "cwaelp", "cwaelh", "cwaem", "cwaeb", "cwaebs", "cwaes", "cwaess", "cwaeng", "cwaej", "cwaec", "cwaek", "cwaet", "cwaep", "cwaeh", "coe", "coeg", "coegg", "coegs", "coen", "coenj", "coenh", "coed", "coel", "coelg", "coelm", "coelb", "coels", "coelt", "coelp", "coelh", "coem", "coeb", "coebs", "coes", "coess", "coeng", "coej", "coec", "coek", "coet", "coep", "coeh", "cyo", "cyog", "cyogg", "cyogs", "cyon", "cyonj", "cyonh", "cyod", "cyol", "cyolg", "cyolm", "cyolb", "cyols", "cyolt", "cyolp", "cyolh", "cyom", "cyob", "cyobs", "cyos", "cyoss", "cyong", "cyoj", "cyoc", "cyok", "cyot", "cyop", "cyoh", "cu", "cug", "cugg", "cugs", "cun", "cunj", "cunh", "cud", "cul", "culg", "culm", "culb", "culs", "cult", "culp", "culh", "cum", "cub", "cubs", "cus", "cuss", "cung", "cuj", "cuc", "cuk", "cut", "cup", "cuh", "cweo", "cweog", "cweogg", "cweogs", "cweon", "cweonj", "cweonh", "cweod", "cweol", "cweolg", "cweolm", "cweolb", "cweols", "cweolt", "cweolp", "cweolh", "cweom", "cweob", "cweobs", "cweos", "cweoss", "cweong", "cweoj", "cweoc", "cweok", "cweot", "cweop", "cweoh", "cwe", "cweg", "cwegg", "cwegs", "cwen", "cwenj", "cwenh", "cwed", "cwel", "cwelg", "cwelm", "cwelb", "cwels", "cwelt", "cwelp", "cwelh", "cwem", "cweb", "cwebs", "cwes", "cwess", "cweng", "cwej", "cwec", "cwek", "cwet", "cwep", "cweh", "cwi", "cwig", "cwigg", "cwigs", "cwin", "cwinj", "cwinh", "cwid", "cwil", "cwilg", "cwilm", "cwilb", "cwils", "cwilt", "cwilp", "cwilh", "cwim", "cwib", "cwibs", "cwis", "cwiss", "cwing", "cwij", "cwic"];
  }
});

// node_modules/unidecode/data/xce.js
var require_xce = __commonJS({
  "node_modules/unidecode/data/xce.js"(exports, module2) {
    module2.exports = ["cwik", "cwit", "cwip", "cwih", "cyu", "cyug", "cyugg", "cyugs", "cyun", "cyunj", "cyunh", "cyud", "cyul", "cyulg", "cyulm", "cyulb", "cyuls", "cyult", "cyulp", "cyulh", "cyum", "cyub", "cyubs", "cyus", "cyuss", "cyung", "cyuj", "cyuc", "cyuk", "cyut", "cyup", "cyuh", "ceu", "ceug", "ceugg", "ceugs", "ceun", "ceunj", "ceunh", "ceud", "ceul", "ceulg", "ceulm", "ceulb", "ceuls", "ceult", "ceulp", "ceulh", "ceum", "ceub", "ceubs", "ceus", "ceuss", "ceung", "ceuj", "ceuc", "ceuk", "ceut", "ceup", "ceuh", "cyi", "cyig", "cyigg", "cyigs", "cyin", "cyinj", "cyinh", "cyid", "cyil", "cyilg", "cyilm", "cyilb", "cyils", "cyilt", "cyilp", "cyilh", "cyim", "cyib", "cyibs", "cyis", "cyiss", "cying", "cyij", "cyic", "cyik", "cyit", "cyip", "cyih", "ci", "cig", "cigg", "cigs", "cin", "cinj", "cinh", "cid", "cil", "cilg", "cilm", "cilb", "cils", "cilt", "cilp", "cilh", "cim", "cib", "cibs", "cis", "ciss", "cing", "cij", "cic", "cik", "cit", "cip", "cih", "ka", "kag", "kagg", "kags", "kan", "kanj", "kanh", "kad", "kal", "kalg", "kalm", "kalb", "kals", "kalt", "kalp", "kalh", "kam", "kab", "kabs", "kas", "kass", "kang", "kaj", "kac", "kak", "kat", "kap", "kah", "kae", "kaeg", "kaegg", "kaegs", "kaen", "kaenj", "kaenh", "kaed", "kael", "kaelg", "kaelm", "kaelb", "kaels", "kaelt", "kaelp", "kaelh", "kaem", "kaeb", "kaebs", "kaes", "kaess", "kaeng", "kaej", "kaec", "kaek", "kaet", "kaep", "kaeh", "kya", "kyag", "kyagg", "kyags", "kyan", "kyanj", "kyanh", "kyad", "kyal", "kyalg", "kyalm", "kyalb", "kyals", "kyalt", "kyalp", "kyalh", "kyam", "kyab", "kyabs", "kyas", "kyass", "kyang", "kyaj", "kyac", "kyak", "kyat", "kyap", "kyah", "kyae", "kyaeg", "kyaegg", "kyaegs", "kyaen", "kyaenj", "kyaenh", "kyaed", "kyael", "kyaelg", "kyaelm", "kyaelb", "kyaels", "kyaelt", "kyaelp", "kyaelh", "kyaem", "kyaeb", "kyaebs", "kyaes", "kyaess", "kyaeng", "kyaej", "kyaec", "kyaek", "kyaet", "kyaep", "kyaeh", "keo", "keog", "keogg", "keogs", "keon", "keonj", "keonh", "keod", "keol", "keolg", "keolm", "keolb", "keols", "keolt", "keolp", "keolh", "keom", "keob", "keobs", "keos", "keoss", "keong", "keoj", "keoc", "keok", "keot", "keop", "keoh"];
  }
});

// node_modules/unidecode/data/xcf.js
var require_xcf = __commonJS({
  "node_modules/unidecode/data/xcf.js"(exports, module2) {
    module2.exports = ["ke", "keg", "kegg", "kegs", "ken", "kenj", "kenh", "ked", "kel", "kelg", "kelm", "kelb", "kels", "kelt", "kelp", "kelh", "kem", "keb", "kebs", "kes", "kess", "keng", "kej", "kec", "kek", "ket", "kep", "keh", "kyeo", "kyeog", "kyeogg", "kyeogs", "kyeon", "kyeonj", "kyeonh", "kyeod", "kyeol", "kyeolg", "kyeolm", "kyeolb", "kyeols", "kyeolt", "kyeolp", "kyeolh", "kyeom", "kyeob", "kyeobs", "kyeos", "kyeoss", "kyeong", "kyeoj", "kyeoc", "kyeok", "kyeot", "kyeop", "kyeoh", "kye", "kyeg", "kyegg", "kyegs", "kyen", "kyenj", "kyenh", "kyed", "kyel", "kyelg", "kyelm", "kyelb", "kyels", "kyelt", "kyelp", "kyelh", "kyem", "kyeb", "kyebs", "kyes", "kyess", "kyeng", "kyej", "kyec", "kyek", "kyet", "kyep", "kyeh", "ko", "kog", "kogg", "kogs", "kon", "konj", "konh", "kod", "kol", "kolg", "kolm", "kolb", "kols", "kolt", "kolp", "kolh", "kom", "kob", "kobs", "kos", "koss", "kong", "koj", "koc", "kok", "kot", "kop", "koh", "kwa", "kwag", "kwagg", "kwags", "kwan", "kwanj", "kwanh", "kwad", "kwal", "kwalg", "kwalm", "kwalb", "kwals", "kwalt", "kwalp", "kwalh", "kwam", "kwab", "kwabs", "kwas", "kwass", "kwang", "kwaj", "kwac", "kwak", "kwat", "kwap", "kwah", "kwae", "kwaeg", "kwaegg", "kwaegs", "kwaen", "kwaenj", "kwaenh", "kwaed", "kwael", "kwaelg", "kwaelm", "kwaelb", "kwaels", "kwaelt", "kwaelp", "kwaelh", "kwaem", "kwaeb", "kwaebs", "kwaes", "kwaess", "kwaeng", "kwaej", "kwaec", "kwaek", "kwaet", "kwaep", "kwaeh", "koe", "koeg", "koegg", "koegs", "koen", "koenj", "koenh", "koed", "koel", "koelg", "koelm", "koelb", "koels", "koelt", "koelp", "koelh", "koem", "koeb", "koebs", "koes", "koess", "koeng", "koej", "koec", "koek", "koet", "koep", "koeh", "kyo", "kyog", "kyogg", "kyogs", "kyon", "kyonj", "kyonh", "kyod", "kyol", "kyolg", "kyolm", "kyolb", "kyols", "kyolt", "kyolp", "kyolh", "kyom", "kyob", "kyobs", "kyos", "kyoss", "kyong", "kyoj", "kyoc", "kyok", "kyot", "kyop", "kyoh", "ku", "kug", "kugg", "kugs", "kun", "kunj", "kunh", "kud", "kul", "kulg", "kulm", "kulb", "kuls", "kult", "kulp", "kulh", "kum", "kub", "kubs", "kus", "kuss", "kung", "kuj", "kuc", "kuk", "kut", "kup", "kuh", "kweo", "kweog", "kweogg", "kweogs"];
  }
});

// node_modules/unidecode/data/xd0.js
var require_xd0 = __commonJS({
  "node_modules/unidecode/data/xd0.js"(exports, module2) {
    module2.exports = ["kweon", "kweonj", "kweonh", "kweod", "kweol", "kweolg", "kweolm", "kweolb", "kweols", "kweolt", "kweolp", "kweolh", "kweom", "kweob", "kweobs", "kweos", "kweoss", "kweong", "kweoj", "kweoc", "kweok", "kweot", "kweop", "kweoh", "kwe", "kweg", "kwegg", "kwegs", "kwen", "kwenj", "kwenh", "kwed", "kwel", "kwelg", "kwelm", "kwelb", "kwels", "kwelt", "kwelp", "kwelh", "kwem", "kweb", "kwebs", "kwes", "kwess", "kweng", "kwej", "kwec", "kwek", "kwet", "kwep", "kweh", "kwi", "kwig", "kwigg", "kwigs", "kwin", "kwinj", "kwinh", "kwid", "kwil", "kwilg", "kwilm", "kwilb", "kwils", "kwilt", "kwilp", "kwilh", "kwim", "kwib", "kwibs", "kwis", "kwiss", "kwing", "kwij", "kwic", "kwik", "kwit", "kwip", "kwih", "kyu", "kyug", "kyugg", "kyugs", "kyun", "kyunj", "kyunh", "kyud", "kyul", "kyulg", "kyulm", "kyulb", "kyuls", "kyult", "kyulp", "kyulh", "kyum", "kyub", "kyubs", "kyus", "kyuss", "kyung", "kyuj", "kyuc", "kyuk", "kyut", "kyup", "kyuh", "keu", "keug", "keugg", "keugs", "keun", "keunj", "keunh", "keud", "keul", "keulg", "keulm", "keulb", "keuls", "keult", "keulp", "keulh", "keum", "keub", "keubs", "keus", "keuss", "keung", "keuj", "keuc", "keuk", "keut", "keup", "keuh", "kyi", "kyig", "kyigg", "kyigs", "kyin", "kyinj", "kyinh", "kyid", "kyil", "kyilg", "kyilm", "kyilb", "kyils", "kyilt", "kyilp", "kyilh", "kyim", "kyib", "kyibs", "kyis", "kyiss", "kying", "kyij", "kyic", "kyik", "kyit", "kyip", "kyih", "ki", "kig", "kigg", "kigs", "kin", "kinj", "kinh", "kid", "kil", "kilg", "kilm", "kilb", "kils", "kilt", "kilp", "kilh", "kim", "kib", "kibs", "kis", "kiss", "king", "kij", "kic", "kik", "kit", "kip", "kih", "ta", "tag", "tagg", "tags", "tan", "tanj", "tanh", "tad", "tal", "talg", "talm", "talb", "tals", "talt", "talp", "talh", "tam", "tab", "tabs", "tas", "tass", "tang", "taj", "tac", "tak", "tat", "tap", "tah", "tae", "taeg", "taegg", "taegs", "taen", "taenj", "taenh", "taed", "tael", "taelg", "taelm", "taelb", "taels", "taelt", "taelp", "taelh", "taem", "taeb", "taebs", "taes", "taess", "taeng", "taej", "taec", "taek", "taet", "taep", "taeh", "tya", "tyag", "tyagg", "tyags", "tyan", "tyanj", "tyanh", "tyad"];
  }
});

// node_modules/unidecode/data/xd1.js
var require_xd1 = __commonJS({
  "node_modules/unidecode/data/xd1.js"(exports, module2) {
    module2.exports = ["tyal", "tyalg", "tyalm", "tyalb", "tyals", "tyalt", "tyalp", "tyalh", "tyam", "tyab", "tyabs", "tyas", "tyass", "tyang", "tyaj", "tyac", "tyak", "tyat", "tyap", "tyah", "tyae", "tyaeg", "tyaegg", "tyaegs", "tyaen", "tyaenj", "tyaenh", "tyaed", "tyael", "tyaelg", "tyaelm", "tyaelb", "tyaels", "tyaelt", "tyaelp", "tyaelh", "tyaem", "tyaeb", "tyaebs", "tyaes", "tyaess", "tyaeng", "tyaej", "tyaec", "tyaek", "tyaet", "tyaep", "tyaeh", "teo", "teog", "teogg", "teogs", "teon", "teonj", "teonh", "teod", "teol", "teolg", "teolm", "teolb", "teols", "teolt", "teolp", "teolh", "teom", "teob", "teobs", "teos", "teoss", "teong", "teoj", "teoc", "teok", "teot", "teop", "teoh", "te", "teg", "tegg", "tegs", "ten", "tenj", "tenh", "ted", "tel", "telg", "telm", "telb", "tels", "telt", "telp", "telh", "tem", "teb", "tebs", "tes", "tess", "teng", "tej", "tec", "tek", "tet", "tep", "teh", "tyeo", "tyeog", "tyeogg", "tyeogs", "tyeon", "tyeonj", "tyeonh", "tyeod", "tyeol", "tyeolg", "tyeolm", "tyeolb", "tyeols", "tyeolt", "tyeolp", "tyeolh", "tyeom", "tyeob", "tyeobs", "tyeos", "tyeoss", "tyeong", "tyeoj", "tyeoc", "tyeok", "tyeot", "tyeop", "tyeoh", "tye", "tyeg", "tyegg", "tyegs", "tyen", "tyenj", "tyenh", "tyed", "tyel", "tyelg", "tyelm", "tyelb", "tyels", "tyelt", "tyelp", "tyelh", "tyem", "tyeb", "tyebs", "tyes", "tyess", "tyeng", "tyej", "tyec", "tyek", "tyet", "tyep", "tyeh", "to", "tog", "togg", "togs", "ton", "tonj", "tonh", "tod", "tol", "tolg", "tolm", "tolb", "tols", "tolt", "tolp", "tolh", "tom", "tob", "tobs", "tos", "toss", "tong", "toj", "toc", "tok", "tot", "top", "toh", "twa", "twag", "twagg", "twags", "twan", "twanj", "twanh", "twad", "twal", "twalg", "twalm", "twalb", "twals", "twalt", "twalp", "twalh", "twam", "twab", "twabs", "twas", "twass", "twang", "twaj", "twac", "twak", "twat", "twap", "twah", "twae", "twaeg", "twaegg", "twaegs", "twaen", "twaenj", "twaenh", "twaed", "twael", "twaelg", "twaelm", "twaelb", "twaels", "twaelt", "twaelp", "twaelh", "twaem", "twaeb", "twaebs", "twaes", "twaess", "twaeng", "twaej", "twaec", "twaek", "twaet", "twaep", "twaeh", "toe", "toeg", "toegg", "toegs", "toen", "toenj", "toenh", "toed", "toel", "toelg", "toelm", "toelb"];
  }
});

// node_modules/unidecode/data/xd2.js
var require_xd2 = __commonJS({
  "node_modules/unidecode/data/xd2.js"(exports, module2) {
    module2.exports = ["toels", "toelt", "toelp", "toelh", "toem", "toeb", "toebs", "toes", "toess", "toeng", "toej", "toec", "toek", "toet", "toep", "toeh", "tyo", "tyog", "tyogg", "tyogs", "tyon", "tyonj", "tyonh", "tyod", "tyol", "tyolg", "tyolm", "tyolb", "tyols", "tyolt", "tyolp", "tyolh", "tyom", "tyob", "tyobs", "tyos", "tyoss", "tyong", "tyoj", "tyoc", "tyok", "tyot", "tyop", "tyoh", "tu", "tug", "tugg", "tugs", "tun", "tunj", "tunh", "tud", "tul", "tulg", "tulm", "tulb", "tuls", "tult", "tulp", "tulh", "tum", "tub", "tubs", "tus", "tuss", "tung", "tuj", "tuc", "tuk", "tut", "tup", "tuh", "tweo", "tweog", "tweogg", "tweogs", "tweon", "tweonj", "tweonh", "tweod", "tweol", "tweolg", "tweolm", "tweolb", "tweols", "tweolt", "tweolp", "tweolh", "tweom", "tweob", "tweobs", "tweos", "tweoss", "tweong", "tweoj", "tweoc", "tweok", "tweot", "tweop", "tweoh", "twe", "tweg", "twegg", "twegs", "twen", "twenj", "twenh", "twed", "twel", "twelg", "twelm", "twelb", "twels", "twelt", "twelp", "twelh", "twem", "tweb", "twebs", "twes", "twess", "tweng", "twej", "twec", "twek", "twet", "twep", "tweh", "twi", "twig", "twigg", "twigs", "twin", "twinj", "twinh", "twid", "twil", "twilg", "twilm", "twilb", "twils", "twilt", "twilp", "twilh", "twim", "twib", "twibs", "twis", "twiss", "twing", "twij", "twic", "twik", "twit", "twip", "twih", "tyu", "tyug", "tyugg", "tyugs", "tyun", "tyunj", "tyunh", "tyud", "tyul", "tyulg", "tyulm", "tyulb", "tyuls", "tyult", "tyulp", "tyulh", "tyum", "tyub", "tyubs", "tyus", "tyuss", "tyung", "tyuj", "tyuc", "tyuk", "tyut", "tyup", "tyuh", "teu", "teug", "teugg", "teugs", "teun", "teunj", "teunh", "teud", "teul", "teulg", "teulm", "teulb", "teuls", "teult", "teulp", "teulh", "teum", "teub", "teubs", "teus", "teuss", "teung", "teuj", "teuc", "teuk", "teut", "teup", "teuh", "tyi", "tyig", "tyigg", "tyigs", "tyin", "tyinj", "tyinh", "tyid", "tyil", "tyilg", "tyilm", "tyilb", "tyils", "tyilt", "tyilp", "tyilh", "tyim", "tyib", "tyibs", "tyis", "tyiss", "tying", "tyij", "tyic", "tyik", "tyit", "tyip", "tyih", "ti", "tig", "tigg", "tigs", "tin", "tinj", "tinh", "tid", "til", "tilg", "tilm", "tilb", "tils", "tilt", "tilp", "tilh"];
  }
});

// node_modules/unidecode/data/xd3.js
var require_xd3 = __commonJS({
  "node_modules/unidecode/data/xd3.js"(exports, module2) {
    module2.exports = ["tim", "tib", "tibs", "tis", "tiss", "ting", "tij", "tic", "tik", "tit", "tip", "tih", "pa", "pag", "pagg", "pags", "pan", "panj", "panh", "pad", "pal", "palg", "palm", "palb", "pals", "palt", "palp", "palh", "pam", "pab", "pabs", "pas", "pass", "pang", "paj", "pac", "pak", "pat", "pap", "pah", "pae", "paeg", "paegg", "paegs", "paen", "paenj", "paenh", "paed", "pael", "paelg", "paelm", "paelb", "paels", "paelt", "paelp", "paelh", "paem", "paeb", "paebs", "paes", "paess", "paeng", "paej", "paec", "paek", "paet", "paep", "paeh", "pya", "pyag", "pyagg", "pyags", "pyan", "pyanj", "pyanh", "pyad", "pyal", "pyalg", "pyalm", "pyalb", "pyals", "pyalt", "pyalp", "pyalh", "pyam", "pyab", "pyabs", "pyas", "pyass", "pyang", "pyaj", "pyac", "pyak", "pyat", "pyap", "pyah", "pyae", "pyaeg", "pyaegg", "pyaegs", "pyaen", "pyaenj", "pyaenh", "pyaed", "pyael", "pyaelg", "pyaelm", "pyaelb", "pyaels", "pyaelt", "pyaelp", "pyaelh", "pyaem", "pyaeb", "pyaebs", "pyaes", "pyaess", "pyaeng", "pyaej", "pyaec", "pyaek", "pyaet", "pyaep", "pyaeh", "peo", "peog", "peogg", "peogs", "peon", "peonj", "peonh", "peod", "peol", "peolg", "peolm", "peolb", "peols", "peolt", "peolp", "peolh", "peom", "peob", "peobs", "peos", "peoss", "peong", "peoj", "peoc", "peok", "peot", "peop", "peoh", "pe", "peg", "pegg", "pegs", "pen", "penj", "penh", "ped", "pel", "pelg", "pelm", "pelb", "pels", "pelt", "pelp", "pelh", "pem", "peb", "pebs", "pes", "pess", "peng", "pej", "pec", "pek", "pet", "pep", "peh", "pyeo", "pyeog", "pyeogg", "pyeogs", "pyeon", "pyeonj", "pyeonh", "pyeod", "pyeol", "pyeolg", "pyeolm", "pyeolb", "pyeols", "pyeolt", "pyeolp", "pyeolh", "pyeom", "pyeob", "pyeobs", "pyeos", "pyeoss", "pyeong", "pyeoj", "pyeoc", "pyeok", "pyeot", "pyeop", "pyeoh", "pye", "pyeg", "pyegg", "pyegs", "pyen", "pyenj", "pyenh", "pyed", "pyel", "pyelg", "pyelm", "pyelb", "pyels", "pyelt", "pyelp", "pyelh", "pyem", "pyeb", "pyebs", "pyes", "pyess", "pyeng", "pyej", "pyec", "pyek", "pyet", "pyep", "pyeh", "po", "pog", "pogg", "pogs", "pon", "ponj", "ponh", "pod", "pol", "polg", "polm", "polb", "pols", "polt", "polp", "polh", "pom", "pob", "pobs", "pos"];
  }
});

// node_modules/unidecode/data/xd4.js
var require_xd4 = __commonJS({
  "node_modules/unidecode/data/xd4.js"(exports, module2) {
    module2.exports = ["poss", "pong", "poj", "poc", "pok", "pot", "pop", "poh", "pwa", "pwag", "pwagg", "pwags", "pwan", "pwanj", "pwanh", "pwad", "pwal", "pwalg", "pwalm", "pwalb", "pwals", "pwalt", "pwalp", "pwalh", "pwam", "pwab", "pwabs", "pwas", "pwass", "pwang", "pwaj", "pwac", "pwak", "pwat", "pwap", "pwah", "pwae", "pwaeg", "pwaegg", "pwaegs", "pwaen", "pwaenj", "pwaenh", "pwaed", "pwael", "pwaelg", "pwaelm", "pwaelb", "pwaels", "pwaelt", "pwaelp", "pwaelh", "pwaem", "pwaeb", "pwaebs", "pwaes", "pwaess", "pwaeng", "pwaej", "pwaec", "pwaek", "pwaet", "pwaep", "pwaeh", "poe", "poeg", "poegg", "poegs", "poen", "poenj", "poenh", "poed", "poel", "poelg", "poelm", "poelb", "poels", "poelt", "poelp", "poelh", "poem", "poeb", "poebs", "poes", "poess", "poeng", "poej", "poec", "poek", "poet", "poep", "poeh", "pyo", "pyog", "pyogg", "pyogs", "pyon", "pyonj", "pyonh", "pyod", "pyol", "pyolg", "pyolm", "pyolb", "pyols", "pyolt", "pyolp", "pyolh", "pyom", "pyob", "pyobs", "pyos", "pyoss", "pyong", "pyoj", "pyoc", "pyok", "pyot", "pyop", "pyoh", "pu", "pug", "pugg", "pugs", "pun", "punj", "punh", "pud", "pul", "pulg", "pulm", "pulb", "puls", "pult", "pulp", "pulh", "pum", "pub", "pubs", "pus", "puss", "pung", "puj", "puc", "puk", "put", "pup", "puh", "pweo", "pweog", "pweogg", "pweogs", "pweon", "pweonj", "pweonh", "pweod", "pweol", "pweolg", "pweolm", "pweolb", "pweols", "pweolt", "pweolp", "pweolh", "pweom", "pweob", "pweobs", "pweos", "pweoss", "pweong", "pweoj", "pweoc", "pweok", "pweot", "pweop", "pweoh", "pwe", "pweg", "pwegg", "pwegs", "pwen", "pwenj", "pwenh", "pwed", "pwel", "pwelg", "pwelm", "pwelb", "pwels", "pwelt", "pwelp", "pwelh", "pwem", "pweb", "pwebs", "pwes", "pwess", "pweng", "pwej", "pwec", "pwek", "pwet", "pwep", "pweh", "pwi", "pwig", "pwigg", "pwigs", "pwin", "pwinj", "pwinh", "pwid", "pwil", "pwilg", "pwilm", "pwilb", "pwils", "pwilt", "pwilp", "pwilh", "pwim", "pwib", "pwibs", "pwis", "pwiss", "pwing", "pwij", "pwic", "pwik", "pwit", "pwip", "pwih", "pyu", "pyug", "pyugg", "pyugs", "pyun", "pyunj", "pyunh", "pyud", "pyul", "pyulg", "pyulm", "pyulb", "pyuls", "pyult", "pyulp", "pyulh", "pyum", "pyub", "pyubs", "pyus", "pyuss", "pyung", "pyuj", "pyuc"];
  }
});

// node_modules/unidecode/data/xd5.js
var require_xd5 = __commonJS({
  "node_modules/unidecode/data/xd5.js"(exports, module2) {
    module2.exports = ["pyuk", "pyut", "pyup", "pyuh", "peu", "peug", "peugg", "peugs", "peun", "peunj", "peunh", "peud", "peul", "peulg", "peulm", "peulb", "peuls", "peult", "peulp", "peulh", "peum", "peub", "peubs", "peus", "peuss", "peung", "peuj", "peuc", "peuk", "peut", "peup", "peuh", "pyi", "pyig", "pyigg", "pyigs", "pyin", "pyinj", "pyinh", "pyid", "pyil", "pyilg", "pyilm", "pyilb", "pyils", "pyilt", "pyilp", "pyilh", "pyim", "pyib", "pyibs", "pyis", "pyiss", "pying", "pyij", "pyic", "pyik", "pyit", "pyip", "pyih", "pi", "pig", "pigg", "pigs", "pin", "pinj", "pinh", "pid", "pil", "pilg", "pilm", "pilb", "pils", "pilt", "pilp", "pilh", "pim", "pib", "pibs", "pis", "piss", "ping", "pij", "pic", "pik", "pit", "pip", "pih", "ha", "hag", "hagg", "hags", "han", "hanj", "hanh", "had", "hal", "halg", "halm", "halb", "hals", "halt", "halp", "halh", "ham", "hab", "habs", "has", "hass", "hang", "haj", "hac", "hak", "hat", "hap", "hah", "hae", "haeg", "haegg", "haegs", "haen", "haenj", "haenh", "haed", "hael", "haelg", "haelm", "haelb", "haels", "haelt", "haelp", "haelh", "haem", "haeb", "haebs", "haes", "haess", "haeng", "haej", "haec", "haek", "haet", "haep", "haeh", "hya", "hyag", "hyagg", "hyags", "hyan", "hyanj", "hyanh", "hyad", "hyal", "hyalg", "hyalm", "hyalb", "hyals", "hyalt", "hyalp", "hyalh", "hyam", "hyab", "hyabs", "hyas", "hyass", "hyang", "hyaj", "hyac", "hyak", "hyat", "hyap", "hyah", "hyae", "hyaeg", "hyaegg", "hyaegs", "hyaen", "hyaenj", "hyaenh", "hyaed", "hyael", "hyaelg", "hyaelm", "hyaelb", "hyaels", "hyaelt", "hyaelp", "hyaelh", "hyaem", "hyaeb", "hyaebs", "hyaes", "hyaess", "hyaeng", "hyaej", "hyaec", "hyaek", "hyaet", "hyaep", "hyaeh", "heo", "heog", "heogg", "heogs", "heon", "heonj", "heonh", "heod", "heol", "heolg", "heolm", "heolb", "heols", "heolt", "heolp", "heolh", "heom", "heob", "heobs", "heos", "heoss", "heong", "heoj", "heoc", "heok", "heot", "heop", "heoh", "he", "heg", "hegg", "hegs", "hen", "henj", "henh", "hed", "hel", "helg", "helm", "helb", "hels", "helt", "help", "helh", "hem", "heb", "hebs", "hes", "hess", "heng", "hej", "hec", "hek", "het", "hep", "heh"];
  }
});

// node_modules/unidecode/data/xd6.js
var require_xd6 = __commonJS({
  "node_modules/unidecode/data/xd6.js"(exports, module2) {
    module2.exports = ["hyeo", "hyeog", "hyeogg", "hyeogs", "hyeon", "hyeonj", "hyeonh", "hyeod", "hyeol", "hyeolg", "hyeolm", "hyeolb", "hyeols", "hyeolt", "hyeolp", "hyeolh", "hyeom", "hyeob", "hyeobs", "hyeos", "hyeoss", "hyeong", "hyeoj", "hyeoc", "hyeok", "hyeot", "hyeop", "hyeoh", "hye", "hyeg", "hyegg", "hyegs", "hyen", "hyenj", "hyenh", "hyed", "hyel", "hyelg", "hyelm", "hyelb", "hyels", "hyelt", "hyelp", "hyelh", "hyem", "hyeb", "hyebs", "hyes", "hyess", "hyeng", "hyej", "hyec", "hyek", "hyet", "hyep", "hyeh", "ho", "hog", "hogg", "hogs", "hon", "honj", "honh", "hod", "hol", "holg", "holm", "holb", "hols", "holt", "holp", "holh", "hom", "hob", "hobs", "hos", "hoss", "hong", "hoj", "hoc", "hok", "hot", "hop", "hoh", "hwa", "hwag", "hwagg", "hwags", "hwan", "hwanj", "hwanh", "hwad", "hwal", "hwalg", "hwalm", "hwalb", "hwals", "hwalt", "hwalp", "hwalh", "hwam", "hwab", "hwabs", "hwas", "hwass", "hwang", "hwaj", "hwac", "hwak", "hwat", "hwap", "hwah", "hwae", "hwaeg", "hwaegg", "hwaegs", "hwaen", "hwaenj", "hwaenh", "hwaed", "hwael", "hwaelg", "hwaelm", "hwaelb", "hwaels", "hwaelt", "hwaelp", "hwaelh", "hwaem", "hwaeb", "hwaebs", "hwaes", "hwaess", "hwaeng", "hwaej", "hwaec", "hwaek", "hwaet", "hwaep", "hwaeh", "hoe", "hoeg", "hoegg", "hoegs", "hoen", "hoenj", "hoenh", "hoed", "hoel", "hoelg", "hoelm", "hoelb", "hoels", "hoelt", "hoelp", "hoelh", "hoem", "hoeb", "hoebs", "hoes", "hoess", "hoeng", "hoej", "hoec", "hoek", "hoet", "hoep", "hoeh", "hyo", "hyog", "hyogg", "hyogs", "hyon", "hyonj", "hyonh", "hyod", "hyol", "hyolg", "hyolm", "hyolb", "hyols", "hyolt", "hyolp", "hyolh", "hyom", "hyob", "hyobs", "hyos", "hyoss", "hyong", "hyoj", "hyoc", "hyok", "hyot", "hyop", "hyoh", "hu", "hug", "hugg", "hugs", "hun", "hunj", "hunh", "hud", "hul", "hulg", "hulm", "hulb", "huls", "hult", "hulp", "hulh", "hum", "hub", "hubs", "hus", "huss", "hung", "huj", "huc", "huk", "hut", "hup", "huh", "hweo", "hweog", "hweogg", "hweogs", "hweon", "hweonj", "hweonh", "hweod", "hweol", "hweolg", "hweolm", "hweolb", "hweols", "hweolt", "hweolp", "hweolh", "hweom", "hweob", "hweobs", "hweos", "hweoss", "hweong", "hweoj", "hweoc", "hweok", "hweot", "hweop", "hweoh", "hwe", "hweg", "hwegg", "hwegs"];
  }
});

// node_modules/unidecode/data/xd7.js
var require_xd7 = __commonJS({
  "node_modules/unidecode/data/xd7.js"(exports, module2) {
    module2.exports = ["hwen", "hwenj", "hwenh", "hwed", "hwel", "hwelg", "hwelm", "hwelb", "hwels", "hwelt", "hwelp", "hwelh", "hwem", "hweb", "hwebs", "hwes", "hwess", "hweng", "hwej", "hwec", "hwek", "hwet", "hwep", "hweh", "hwi", "hwig", "hwigg", "hwigs", "hwin", "hwinj", "hwinh", "hwid", "hwil", "hwilg", "hwilm", "hwilb", "hwils", "hwilt", "hwilp", "hwilh", "hwim", "hwib", "hwibs", "hwis", "hwiss", "hwing", "hwij", "hwic", "hwik", "hwit", "hwip", "hwih", "hyu", "hyug", "hyugg", "hyugs", "hyun", "hyunj", "hyunh", "hyud", "hyul", "hyulg", "hyulm", "hyulb", "hyuls", "hyult", "hyulp", "hyulh", "hyum", "hyub", "hyubs", "hyus", "hyuss", "hyung", "hyuj", "hyuc", "hyuk", "hyut", "hyup", "hyuh", "heu", "heug", "heugg", "heugs", "heun", "heunj", "heunh", "heud", "heul", "heulg", "heulm", "heulb", "heuls", "heult", "heulp", "heulh", "heum", "heub", "heubs", "heus", "heuss", "heung", "heuj", "heuc", "heuk", "heut", "heup", "heuh", "hyi", "hyig", "hyigg", "hyigs", "hyin", "hyinj", "hyinh", "hyid", "hyil", "hyilg", "hyilm", "hyilb", "hyils", "hyilt", "hyilp", "hyilh", "hyim", "hyib", "hyibs", "hyis", "hyiss", "hying", "hyij", "hyic", "hyik", "hyit", "hyip", "hyih", "hi", "hig", "higg", "higs", "hin", "hinj", "hinh", "hid", "hil", "hilg", "hilm", "hilb", "hils", "hilt", "hilp", "hilh", "him", "hib", "hibs", "his", "hiss", "hing", "hij", "hic", "hik", "hit", "hip", "hih", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xf9.js
var require_xf9 = __commonJS({
  "node_modules/unidecode/data/xf9.js"(exports, module2) {
    module2.exports = ["Kay ", "Kayng ", "Ke ", "Ko ", "Kol ", "Koc ", "Kwi ", "Kwi ", "Kyun ", "Kul ", "Kum ", "Na ", "Na ", "Na ", "La ", "Na ", "Na ", "Na ", "Na ", "Na ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nam ", "Nam ", "Nam ", "Nam ", "Nap ", "Nap ", "Nap ", "Nang ", "Nang ", "Nang ", "Nang ", "Nang ", "Nay ", "Nayng ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Non ", "Nong ", "Nong ", "Nong ", "Nong ", "Noy ", "Noy ", "Noy ", "Noy ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nuk ", "Nuk ", "Num ", "Nung ", "Nung ", "Nung ", "Nung ", "Nung ", "Twu ", "La ", "Lak ", "Lak ", "Lan ", "Lyeng ", "Lo ", "Lyul ", "Li ", "Pey ", "Pen ", "Pyen ", "Pwu ", "Pwul ", "Pi ", "Sak ", "Sak ", "Sam ", "Sayk ", "Sayng ", "Sep ", "Sey ", "Sway ", "Sin ", "Sim ", "Sip ", "Ya ", "Yak ", "Yak ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Yek ", "Yek ", "Yek ", "Yek ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yem ", "Yem ", "Yem ", "Yem ", "Yem ", "Yep ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yey ", "Yey ", "Yey ", "Yey ", "O ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yong ", "Wun ", "Wen ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yuk ", "Yuk ", "Yuk ", "Yun ", "Yun ", "Yun ", "Yun ", "Yul ", "Yul ", "Yul ", "Yul ", "Yung ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "Ik ", "Ik ", "In ", "In ", "In ", "In ", "In ", "In ", "In ", "Im ", "Im ", "Im ", "Ip ", "Ip ", "Ip ", "Cang ", "Cek ", "Ci ", "Cip ", "Cha ", "Chek "];
  }
});

// node_modules/unidecode/data/xfa.js
var require_xfa = __commonJS({
  "node_modules/unidecode/data/xfa.js"(exports, module2) {
    module2.exports = ["Chey ", "Thak ", "Thak ", "Thang ", "Thayk ", "Thong ", "Pho ", "Phok ", "Hang ", "Hang ", "Hyen ", "Hwak ", "Wu ", "Huo ", "[?] ", "[?] ", "Zhong ", "[?] ", "Qing ", "[?] ", "[?] ", "Xi ", "Zhu ", "Yi ", "Li ", "Shen ", "Xiang ", "Fu ", "Jing ", "Jing ", "Yu ", "[?] ", "Hagi ", "[?] ", "Zhu ", "[?] ", "[?] ", "Yi ", "Du ", "[?] ", "[?] ", "[?] ", "Fan ", "Si ", "Guan ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfb.js
var require_xfb = __commonJS({
  "node_modules/unidecode/data/xfb.js"(exports, module2) {
    module2.exports = ["ff", "fi", "fl", "ffi", "ffl", "st", "st", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "mn", "me", "mi", "vn", "mkh", "[?]", "[?]", "[?]", "[?]", "[?]", "yi", "", "ay", "`", "", "d", "h", "k", "l", "m", "m", "t", "+", "sh", "s", "sh", "s", "a", "a", "", "b", "g", "d", "h", "v", "z", "[?]", "t", "y", "k", "k", "l", "[?]", "l", "[?]", "n", "n", "[?]", "p", "p", "[?]", "ts", "ts", "r", "sh", "t", "vo", "b", "k", "p", "l", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfc.js
var require_xfc = __commonJS({
  "node_modules/unidecode/data/xfc.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfd.js
var require_xfd = __commonJS({
  "node_modules/unidecode/data/xfd.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfe.js
var require_xfe = __commonJS({
  "node_modules/unidecode/data/xfe.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "~", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "..", "--", "-", "_", "_", "(", ") ", "{", "} ", "[", "] ", "[(", ")] ", "<<", ">> ", "<", "> ", "[", "] ", "{", "}", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", ",", ",", ".", "", ";", ":", "?", "!", "-", "(", ")", "{", "}", "{", "}", "#", "&", "*", "+", "-", "<", ">", "=", "", "\\", "$", "%", "@", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", ""];
  }
});

// node_modules/unidecode/data/xff.js
var require_xff = __commonJS({
  "node_modules/unidecode/data/xff.js"(exports, module2) {
    module2.exports = ["[?]", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "[?]", "[?]", ".", "[", "]", ",", "*", "wo", "a", "i", "u", "e", "o", "ya", "yu", "yo", "tu", "+", "a", "i", "u", "e", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "n", ":", ";", "", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "[?]", "[?]", "[?]", "a", "ae", "ya", "yae", "eo", "e", "[?]", "[?]", "yeo", "ye", "o", "wa", "wae", "oe", "[?]", "[?]", "yo", "u", "weo", "we", "wi", "yu", "[?]", "[?]", "eu", "yi", "i", "[?]", "[?]", "[?]", "/C", "PS", "!", "-", "|", "Y=", "W=", "[?]", "|", "-", "|", "-", "|", "#", "O", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "{", "|", "}", "", "", "", ""];
  }
});

// node_modules/unidecode/unidecode.js
var require_unidecode = __commonJS({
  "node_modules/unidecode/unidecode.js"(exports, module2) {
    "use strict";
    var tr = {};
    var utf8_rx = /(?![\x00-\x7F]|[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3})./g;
    module2.exports = function(str) {
      return str.replace(utf8_rx, unidecode_internal_replace);
    };
    function unidecode_internal_replace(match) {
      var utf16 = utf8_to_utf16(match);
      if (utf16 > 65535) {
        return "_";
      } else {
        var h = utf16 >> 8;
        var l = utf16 & 255;
        if (h > 24 && h < 30)
          return "";
        if (h > 215 && h < 249)
          return "";
        if (!tr[h]) {
          switch (dec2hex(h)) {
            case "00":
              tr[h] = require_x00();
              break;
            case "01":
              tr[h] = require_x01();
              break;
            case "02":
              tr[h] = require_x02();
              break;
            case "03":
              tr[h] = require_x03();
              break;
            case "04":
              tr[h] = require_x04();
              break;
            case "05":
              tr[h] = require_x05();
              break;
            case "06":
              tr[h] = require_x06();
              break;
            case "07":
              tr[h] = require_x07();
              break;
            case "09":
              tr[h] = require_x09();
              break;
            case "0a":
              tr[h] = require_x0a();
              break;
            case "0b":
              tr[h] = require_x0b();
              break;
            case "0c":
              tr[h] = require_x0c();
              break;
            case "0d":
              tr[h] = require_x0d();
              break;
            case "0e":
              tr[h] = require_x0e();
              break;
            case "0f":
              tr[h] = require_x0f();
              break;
            case "10":
              tr[h] = require_x10();
              break;
            case "11":
              tr[h] = require_x11();
              break;
            case "12":
              tr[h] = require_x12();
              break;
            case "13":
              tr[h] = require_x13();
              break;
            case "14":
              tr[h] = require_x14();
              break;
            case "15":
              tr[h] = require_x15();
              break;
            case "16":
              tr[h] = require_x16();
              break;
            case "17":
              tr[h] = require_x17();
              break;
            case "18":
              tr[h] = require_x18();
              break;
            case "1e":
              tr[h] = require_x1e();
              break;
            case "1f":
              tr[h] = require_x1f();
              break;
            case "20":
              tr[h] = require_x20();
              break;
            case "21":
              tr[h] = require_x21();
              break;
            case "22":
              tr[h] = require_x22();
              break;
            case "23":
              tr[h] = require_x23();
              break;
            case "24":
              tr[h] = require_x24();
              break;
            case "25":
              tr[h] = require_x25();
              break;
            case "26":
              tr[h] = require_x26();
              break;
            case "27":
              tr[h] = require_x27();
              break;
            case "28":
              tr[h] = require_x28();
              break;
            case "2e":
              tr[h] = require_x2e();
              break;
            case "2f":
              tr[h] = require_x2f();
              break;
            case "30":
              tr[h] = require_x30();
              break;
            case "31":
              tr[h] = require_x31();
              break;
            case "32":
              tr[h] = require_x32();
              break;
            case "33":
              tr[h] = require_x33();
              break;
            case "4d":
              tr[h] = require_x4d();
              break;
            case "4e":
              tr[h] = require_x4e();
              break;
            case "4f":
              tr[h] = require_x4f();
              break;
            case "50":
              tr[h] = require_x50();
              break;
            case "51":
              tr[h] = require_x51();
              break;
            case "52":
              tr[h] = require_x52();
              break;
            case "53":
              tr[h] = require_x53();
              break;
            case "54":
              tr[h] = require_x54();
              break;
            case "55":
              tr[h] = require_x55();
              break;
            case "56":
              tr[h] = require_x56();
              break;
            case "57":
              tr[h] = require_x57();
              break;
            case "58":
              tr[h] = require_x58();
              break;
            case "59":
              tr[h] = require_x59();
              break;
            case "5a":
              tr[h] = require_x5a();
              break;
            case "5b":
              tr[h] = require_x5b();
              break;
            case "5c":
              tr[h] = require_x5c();
              break;
            case "5d":
              tr[h] = require_x5d();
              break;
            case "5e":
              tr[h] = require_x5e();
              break;
            case "5f":
              tr[h] = require_x5f();
              break;
            case "60":
              tr[h] = require_x60();
              break;
            case "61":
              tr[h] = require_x61();
              break;
            case "62":
              tr[h] = require_x62();
              break;
            case "63":
              tr[h] = require_x63();
              break;
            case "64":
              tr[h] = require_x64();
              break;
            case "65":
              tr[h] = require_x65();
              break;
            case "66":
              tr[h] = require_x66();
              break;
            case "67":
              tr[h] = require_x67();
              break;
            case "68":
              tr[h] = require_x68();
              break;
            case "69":
              tr[h] = require_x69();
              break;
            case "6a":
              tr[h] = require_x6a();
              break;
            case "6b":
              tr[h] = require_x6b();
              break;
            case "6c":
              tr[h] = require_x6c();
              break;
            case "6d":
              tr[h] = require_x6d();
              break;
            case "6e":
              tr[h] = require_x6e();
              break;
            case "6f":
              tr[h] = require_x6f();
              break;
            case "70":
              tr[h] = require_x70();
              break;
            case "71":
              tr[h] = require_x71();
              break;
            case "72":
              tr[h] = require_x72();
              break;
            case "73":
              tr[h] = require_x73();
              break;
            case "74":
              tr[h] = require_x74();
              break;
            case "75":
              tr[h] = require_x75();
              break;
            case "76":
              tr[h] = require_x76();
              break;
            case "77":
              tr[h] = require_x77();
              break;
            case "78":
              tr[h] = require_x78();
              break;
            case "79":
              tr[h] = require_x79();
              break;
            case "7a":
              tr[h] = require_x7a();
              break;
            case "7b":
              tr[h] = require_x7b();
              break;
            case "7c":
              tr[h] = require_x7c();
              break;
            case "7d":
              tr[h] = require_x7d();
              break;
            case "7e":
              tr[h] = require_x7e();
              break;
            case "7f":
              tr[h] = require_x7f();
              break;
            case "80":
              tr[h] = require_x80();
              break;
            case "81":
              tr[h] = require_x81();
              break;
            case "82":
              tr[h] = require_x82();
              break;
            case "83":
              tr[h] = require_x83();
              break;
            case "84":
              tr[h] = require_x84();
              break;
            case "85":
              tr[h] = require_x85();
              break;
            case "86":
              tr[h] = require_x86();
              break;
            case "87":
              tr[h] = require_x87();
              break;
            case "88":
              tr[h] = require_x88();
              break;
            case "89":
              tr[h] = require_x89();
              break;
            case "8a":
              tr[h] = require_x8a();
              break;
            case "8b":
              tr[h] = require_x8b();
              break;
            case "8c":
              tr[h] = require_x8c();
              break;
            case "8d":
              tr[h] = require_x8d();
              break;
            case "8e":
              tr[h] = require_x8e();
              break;
            case "8f":
              tr[h] = require_x8f();
              break;
            case "90":
              tr[h] = require_x90();
              break;
            case "91":
              tr[h] = require_x91();
              break;
            case "92":
              tr[h] = require_x92();
              break;
            case "93":
              tr[h] = require_x93();
              break;
            case "94":
              tr[h] = require_x94();
              break;
            case "95":
              tr[h] = require_x95();
              break;
            case "96":
              tr[h] = require_x96();
              break;
            case "97":
              tr[h] = require_x97();
              break;
            case "98":
              tr[h] = require_x98();
              break;
            case "99":
              tr[h] = require_x99();
              break;
            case "9a":
              tr[h] = require_x9a();
              break;
            case "9b":
              tr[h] = require_x9b();
              break;
            case "9c":
              tr[h] = require_x9c();
              break;
            case "9d":
              tr[h] = require_x9d();
              break;
            case "9e":
              tr[h] = require_x9e();
              break;
            case "9f":
              tr[h] = require_x9f();
              break;
            case "a0":
              tr[h] = require_xa0();
              break;
            case "a1":
              tr[h] = require_xa1();
              break;
            case "a2":
              tr[h] = require_xa2();
              break;
            case "a3":
              tr[h] = require_xa3();
              break;
            case "a4":
              tr[h] = require_xa4();
              break;
            case "ac":
              tr[h] = require_xac();
              break;
            case "ad":
              tr[h] = require_xad();
              break;
            case "ae":
              tr[h] = require_xae();
              break;
            case "af":
              tr[h] = require_xaf();
              break;
            case "b0":
              tr[h] = require_xb0();
              break;
            case "b1":
              tr[h] = require_xb1();
              break;
            case "b2":
              tr[h] = require_xb2();
              break;
            case "b3":
              tr[h] = require_xb3();
              break;
            case "b4":
              tr[h] = require_xb4();
              break;
            case "b5":
              tr[h] = require_xb5();
              break;
            case "b6":
              tr[h] = require_xb6();
              break;
            case "b7":
              tr[h] = require_xb7();
              break;
            case "b8":
              tr[h] = require_xb8();
              break;
            case "b9":
              tr[h] = require_xb9();
              break;
            case "ba":
              tr[h] = require_xba();
              break;
            case "bb":
              tr[h] = require_xbb();
              break;
            case "bc":
              tr[h] = require_xbc();
              break;
            case "bd":
              tr[h] = require_xbd();
              break;
            case "be":
              tr[h] = require_xbe();
              break;
            case "bf":
              tr[h] = require_xbf();
              break;
            case "c0":
              tr[h] = require_xc0();
              break;
            case "c1":
              tr[h] = require_xc1();
              break;
            case "c2":
              tr[h] = require_xc2();
              break;
            case "c3":
              tr[h] = require_xc3();
              break;
            case "c4":
              tr[h] = require_xc4();
              break;
            case "c5":
              tr[h] = require_xc5();
              break;
            case "c6":
              tr[h] = require_xc6();
              break;
            case "c7":
              tr[h] = require_xc7();
              break;
            case "c8":
              tr[h] = require_xc8();
              break;
            case "c9":
              tr[h] = require_xc9();
              break;
            case "ca":
              tr[h] = require_xca();
              break;
            case "cb":
              tr[h] = require_xcb();
              break;
            case "cc":
              tr[h] = require_xcc();
              break;
            case "cd":
              tr[h] = require_xcd();
              break;
            case "ce":
              tr[h] = require_xce();
              break;
            case "cf":
              tr[h] = require_xcf();
              break;
            case "d0":
              tr[h] = require_xd0();
              break;
            case "d1":
              tr[h] = require_xd1();
              break;
            case "d2":
              tr[h] = require_xd2();
              break;
            case "d3":
              tr[h] = require_xd3();
              break;
            case "d4":
              tr[h] = require_xd4();
              break;
            case "d5":
              tr[h] = require_xd5();
              break;
            case "d6":
              tr[h] = require_xd6();
              break;
            case "d7":
              tr[h] = require_xd7();
              break;
            case "f9":
              tr[h] = require_xf9();
              break;
            case "fa":
              tr[h] = require_xfa();
              break;
            case "fb":
              tr[h] = require_xfb();
              break;
            case "fc":
              tr[h] = require_xfc();
              break;
            case "fd":
              tr[h] = require_xfd();
              break;
            case "fe":
              tr[h] = require_xfe();
              break;
            case "ff":
              tr[h] = require_xff();
              break;
            default:
              return "";
          }
        }
        return tr[h][l];
      }
    }
    function dec2hex(i) {
      return (i + 256).toString(16).substr(-2);
    }
    function utf8_to_utf16(raw) {
      var b1, b2, b3, b4, x, y, z;
      while (Array.isArray(raw))
        raw = raw[0];
      switch (raw.length) {
        case 1:
          return ord(raw);
        case 2:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          x = (b1 & 3) << 6 | b2 & 63;
          y = (b1 & 28) >> 2;
          return y << 8 | x;
        case 3:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          x = (b2 & 3) << 6 | b3 & 63;
          y = (b1 & 15) << 4 | (b2 & 60) >> 2;
          return y << 8 | x;
        default:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          b4 = ord(raw.substr(3, 1));
          x = (b3 & 3) << 6 | b4 & 63;
          y = (b2 & 15) << 4 | (b3 & 60) >> 2;
          z = (b1 & 7) << 5 | (b2 & 48) >> 4;
          return z << 16 | y << 8 | x;
      }
    }
    function ord(string) {
      var str = string + "", code = str.charCodeAt(0);
      if (55296 <= code && code <= 56319) {
        var hi = code;
        if (str.length === 1) {
          return code;
        }
        var low = str.charCodeAt(1);
        return (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
      if (56320 <= code && code <= 57343) {
        return code;
      }
      return code;
    }
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module2) {
    (function(module3, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base2, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN.prototype._initArray = function _initArray(number, base2, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c3 = string.charCodeAt(index);
        if (c3 >= 48 && c3 <= 57) {
          return c3 - 48;
        } else if (c3 >= 65 && c3 <= 70) {
          return c3 - 55;
        } else if (c3 >= 97 && c3 <= 102) {
          return c3 - 87;
        } else {
          assert2(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c3 = str.charCodeAt(i) - 48;
          r *= mul;
          if (c3 >= 49) {
            b = c3 - 49 + 10;
          } else if (c3 >= 17) {
            b = c3 - 17 + 10;
          } else {
            b = c3;
          }
          assert2(c3 >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base2);
          for (i = 0; i < mod; i++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString3(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r = c3.modrn(groupBase).toString(base2);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length3) {
          return this.toArrayLike(Buffer2, endian, length3);
        };
      }
      BN.prototype.toArray = function toArray2(endian, length3) {
        return this.toArrayLike(Array, endian, length3);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length3 || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c3 !== 0) {
          o[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c3 = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c3 | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c3 = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c3, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c3 = b.redSqr();
          t = t.redMul(c3);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c3).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c3).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports);
  }
});

// node_modules/@ethersproject/logger/lib/_version.js
var require_version = __commonJS({
  "node_modules/@ethersproject/logger/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "logger/5.7.0";
  }
});

// node_modules/@ethersproject/logger/lib/index.js
var require_lib = __commonJS({
  "node_modules/@ethersproject/logger/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = exports.ErrorCode = exports.LogLevel = void 0;
    var _permanentCensorErrors = false;
    var _censorErrors = false;
    var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    var _logLevel = LogLevels["default"];
    var _version_1 = require_version();
    var _globalLogger = null;
    function _checkNormalize() {
      try {
        var missing_1 = [];
        ["NFD", "NFC", "NFKD", "NFKC"].forEach(function(form) {
          try {
            if ("test".normalize(form) !== "test") {
              throw new Error("bad normalize");
            }
            ;
          } catch (error) {
            missing_1.push(form);
          }
        });
        if (missing_1.length) {
          throw new Error("missing " + missing_1.join(", "));
        }
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
          throw new Error("broken implementation");
        }
      } catch (error) {
        return error.message;
      }
      return null;
    }
    var _normalizeError = _checkNormalize();
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    var ErrorCode;
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
    var HEX = "0123456789abcdef";
    var Logger = function() {
      function Logger2(version) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version,
          writable: false
        });
      }
      Logger2.prototype._log = function(logLevel, args) {
        var level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      };
      Logger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._log(Logger2.levels.DEBUG, args);
      };
      Logger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._log(Logger2.levels.INFO, args);
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._log(Logger2.levels.WARNING, args);
      };
      Logger2.prototype.makeError = function(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = Logger2.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        var messageDetails = [];
        Object.keys(params).forEach(function(key) {
          var value = params[key];
          try {
            if (value instanceof Uint8Array) {
              var hex = "";
              for (var i = 0; i < value.length; i++) {
                hex += HEX[value[i] >> 4];
                hex += HEX[value[i] & 15];
              }
              messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
          }
        });
        messageDetails.push("code=" + code);
        messageDetails.push("version=" + this.version);
        var reason = message;
        var url2 = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url2 = "NUMERIC_FAULT";
            var fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url2 += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url2 += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url2 += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url2 = code;
            break;
        }
        if (url2) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url2 + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        var error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
          error[key] = params[key];
        });
        return error;
      };
      Logger2.prototype.throwError = function(message, code, params) {
        throw this.makeError(message, code, params);
      };
      Logger2.prototype.throwArgumentError = function(message, name, value) {
        return this.throwError(message, Logger2.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      };
      Logger2.prototype.assert = function(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      };
      Logger2.prototype.assertArgument = function(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      };
      Logger2.prototype.checkNormalize = function(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", Logger2.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      };
      Logger2.prototype.checkSafeUint53 = function(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      };
      Logger2.prototype.checkArgumentCount = function(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, Logger2.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, Logger2.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      };
      Logger2.prototype.checkNew = function(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
        }
      };
      Logger2.prototype.checkAbstract = function(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger2.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
        }
      };
      Logger2.globalLogger = function() {
        if (!_globalLogger) {
          _globalLogger = new Logger2(_version_1.version);
        }
        return _globalLogger;
      };
      Logger2.setCensorship = function(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", Logger2.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", Logger2.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      };
      Logger2.setLogLevel = function(logLevel) {
        var level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          Logger2.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      };
      Logger2.from = function(version) {
        return new Logger2(version);
      };
      Logger2.errors = ErrorCode;
      Logger2.levels = LogLevel;
      return Logger2;
    }();
    exports.Logger = Logger;
  }
});

// node_modules/@ethersproject/bytes/lib/_version.js
var require_version2 = __commonJS({
  "node_modules/@ethersproject/bytes/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "bytes/5.7.0";
  }
});

// node_modules/@ethersproject/bytes/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@ethersproject/bytes/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version2();
    var logger = new logger_1.Logger(_version_1.version);
    function isHexable(value) {
      return !!value.toHexString;
    }
    function addSlice(array) {
      if (array.slice) {
        return array;
      }
      array.slice = function() {
        var args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
    function isBytesLike(value) {
      return isHexString(value) && !(value.length % 2) || isBytes(value);
    }
    exports.isBytesLike = isBytesLike;
    function isInteger(value) {
      return typeof value === "number" && value == value && value % 1 === 0;
    }
    function isBytes(value) {
      if (value == null) {
        return false;
      }
      if (value.constructor === Uint8Array) {
        return true;
      }
      if (typeof value === "string") {
        return false;
      }
      if (!isInteger(value.length) || value.length < 0) {
        return false;
      }
      for (var i = 0; i < value.length; i++) {
        var v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
          return false;
        }
      }
      return true;
    }
    exports.isBytes = isBytes;
    function arrayify(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        var result = [];
        while (value) {
          result.unshift(value & 255);
          value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
          result.push(0);
        }
        return addSlice(new Uint8Array(result));
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        value = value.toHexString();
      }
      if (isHexString(value)) {
        var hex = value.substring(2);
        if (hex.length % 2) {
          if (options.hexPad === "left") {
            hex = "0" + hex;
          } else if (options.hexPad === "right") {
            hex += "0";
          } else {
            logger.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        var result = [];
        for (var i = 0; i < hex.length; i += 2) {
          result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
      }
      return logger.throwArgumentError("invalid arrayify value", "value", value);
    }
    exports.arrayify = arrayify;
    function concat(items) {
      var objects = items.map(function(item) {
        return arrayify(item);
      });
      var length3 = objects.reduce(function(accum, item) {
        return accum + item.length;
      }, 0);
      var result = new Uint8Array(length3);
      objects.reduce(function(offset, object) {
        result.set(object, offset);
        return offset + object.length;
      }, 0);
      return addSlice(result);
    }
    exports.concat = concat;
    function stripZeros(value) {
      var result = arrayify(value);
      if (result.length === 0) {
        return result;
      }
      var start = 0;
      while (start < result.length && result[start] === 0) {
        start++;
      }
      if (start) {
        result = result.slice(start);
      }
      return result;
    }
    exports.stripZeros = stripZeros;
    function zeroPad(value, length3) {
      value = arrayify(value);
      if (value.length > length3) {
        logger.throwArgumentError("value out of range", "value", arguments[0]);
      }
      var result = new Uint8Array(length3);
      result.set(value, length3 - value.length);
      return addSlice(result);
    }
    exports.zeroPad = zeroPad;
    function isHexString(value, length3) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length3 && value.length !== 2 + 2 * length3) {
        return false;
      }
      return true;
    }
    exports.isHexString = isHexString;
    var HexCharacters = "0123456789abcdef";
    function hexlify(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        var hex = "";
        while (value) {
          hex = HexCharacters[value & 15] + hex;
          value = Math.floor(value / 16);
        }
        if (hex.length) {
          if (hex.length % 2) {
            hex = "0" + hex;
          }
          return "0x" + hex;
        }
        return "0x00";
      }
      if (typeof value === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
          return "0x0" + value;
        }
        return "0x" + value;
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        return value.toHexString();
      }
      if (isHexString(value)) {
        if (value.length % 2) {
          if (options.hexPad === "left") {
            value = "0x0" + value.substring(2);
          } else if (options.hexPad === "right") {
            value += "0";
          } else {
            logger.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        return value.toLowerCase();
      }
      if (isBytes(value)) {
        var result = "0x";
        for (var i = 0; i < value.length; i++) {
          var v = value[i];
          result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
        }
        return result;
      }
      return logger.throwArgumentError("invalid hexlify value", "value", value);
    }
    exports.hexlify = hexlify;
    function hexDataLength(data) {
      if (typeof data !== "string") {
        data = hexlify(data);
      } else if (!isHexString(data) || data.length % 2) {
        return null;
      }
      return (data.length - 2) / 2;
    }
    exports.hexDataLength = hexDataLength;
    function hexDataSlice(data, offset, endOffset) {
      if (typeof data !== "string") {
        data = hexlify(data);
      } else if (!isHexString(data) || data.length % 2) {
        logger.throwArgumentError("invalid hexData", "value", data);
      }
      offset = 2 + 2 * offset;
      if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
      }
      return "0x" + data.substring(offset);
    }
    exports.hexDataSlice = hexDataSlice;
    function hexConcat(items) {
      var result = "0x";
      items.forEach(function(item) {
        result += hexlify(item).substring(2);
      });
      return result;
    }
    exports.hexConcat = hexConcat;
    function hexValue(value) {
      var trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
      if (trimmed === "0x") {
        return "0x0";
      }
      return trimmed;
    }
    exports.hexValue = hexValue;
    function hexStripZeros(value) {
      if (typeof value !== "string") {
        value = hexlify(value);
      }
      if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
      }
      value = value.substring(2);
      var offset = 0;
      while (offset < value.length && value[offset] === "0") {
        offset++;
      }
      return "0x" + value.substring(offset);
    }
    exports.hexStripZeros = hexStripZeros;
    function hexZeroPad(value, length3) {
      if (typeof value !== "string") {
        value = hexlify(value);
      } else if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
      }
      if (value.length > 2 * length3 + 2) {
        logger.throwArgumentError("value out of range", "value", arguments[1]);
      }
      while (value.length < 2 * length3 + 2) {
        value = "0x0" + value.substring(2);
      }
      return value;
    }
    exports.hexZeroPad = hexZeroPad;
    function splitSignature(signature) {
      var result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
      };
      if (isBytesLike(signature)) {
        var bytes = arrayify(signature);
        if (bytes.length === 64) {
          result.v = 27 + (bytes[32] >> 7);
          bytes[32] &= 127;
          result.r = hexlify(bytes.slice(0, 32));
          result.s = hexlify(bytes.slice(32, 64));
        } else if (bytes.length === 65) {
          result.r = hexlify(bytes.slice(0, 32));
          result.s = hexlify(bytes.slice(32, 64));
          result.v = bytes[64];
        } else {
          logger.throwArgumentError("invalid signature string", "signature", signature);
        }
        if (result.v < 27) {
          if (result.v === 0 || result.v === 1) {
            result.v += 27;
          } else {
            logger.throwArgumentError("signature invalid v byte", "signature", signature);
          }
        }
        result.recoveryParam = 1 - result.v % 2;
        if (result.recoveryParam) {
          bytes[32] |= 128;
        }
        result._vs = hexlify(bytes.slice(32, 64));
      } else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        if (result._vs != null) {
          var vs_1 = zeroPad(arrayify(result._vs), 32);
          result._vs = hexlify(vs_1);
          var recoveryParam = vs_1[0] >= 128 ? 1 : 0;
          if (result.recoveryParam == null) {
            result.recoveryParam = recoveryParam;
          } else if (result.recoveryParam !== recoveryParam) {
            logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
          }
          vs_1[0] &= 127;
          var s = hexlify(vs_1);
          if (result.s == null) {
            result.s = s;
          } else if (result.s !== s) {
            logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
          }
        }
        if (result.recoveryParam == null) {
          if (result.v == null) {
            logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
          } else if (result.v === 0 || result.v === 1) {
            result.recoveryParam = result.v;
          } else {
            result.recoveryParam = 1 - result.v % 2;
          }
        } else {
          if (result.v == null) {
            result.v = 27 + result.recoveryParam;
          } else {
            var recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
            if (result.recoveryParam !== recId) {
              logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
            }
          }
        }
        if (result.r == null || !isHexString(result.r)) {
          logger.throwArgumentError("signature missing or invalid r", "signature", signature);
        } else {
          result.r = hexZeroPad(result.r, 32);
        }
        if (result.s == null || !isHexString(result.s)) {
          logger.throwArgumentError("signature missing or invalid s", "signature", signature);
        } else {
          result.s = hexZeroPad(result.s, 32);
        }
        var vs = arrayify(result.s);
        if (vs[0] >= 128) {
          logger.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
          vs[0] |= 128;
        }
        var _vs = hexlify(vs);
        if (result._vs) {
          if (!isHexString(result._vs)) {
            logger.throwArgumentError("signature invalid _vs", "signature", signature);
          }
          result._vs = hexZeroPad(result._vs, 32);
        }
        if (result._vs == null) {
          result._vs = _vs;
        } else if (result._vs !== _vs) {
          logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
      }
      result.yParityAndS = result._vs;
      result.compact = result.r + result.yParityAndS.substring(2);
      return result;
    }
    exports.splitSignature = splitSignature;
    function joinSignature(signature) {
      signature = splitSignature(signature);
      return hexlify(concat([
        signature.r,
        signature.s,
        signature.recoveryParam ? "0x1c" : "0x1b"
      ]));
    }
    exports.joinSignature = joinSignature;
  }
});

// node_modules/@ethersproject/bignumber/lib/_version.js
var require_version3 = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "bignumber/5.7.0";
  }
});

// node_modules/@ethersproject/bignumber/lib/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/bignumber.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var BN = bn_js_1.default.BN;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version3();
    var logger = new logger_1.Logger(_version_1.version);
    var _constructorGuard = {};
    var MAX_SAFE = 9007199254740991;
    function isBigNumberish(value) {
      return value != null && (BigNumber2.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, bytes_1.isHexString)(value) || typeof value === "bigint" || (0, bytes_1.isBytes)(value));
    }
    exports.isBigNumberish = isBigNumberish;
    var _warnedToStringRadix = false;
    var BigNumber2 = function() {
      function BigNumber3(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
          logger.throwError("cannot call constructor directly; use BigNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      BigNumber3.prototype.fromTwos = function(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      };
      BigNumber3.prototype.toTwos = function(value) {
        return toBigNumber(toBN(this).toTwos(value));
      };
      BigNumber3.prototype.abs = function() {
        if (this._hex[0] === "-") {
          return BigNumber3.from(this._hex.substring(1));
        }
        return this;
      };
      BigNumber3.prototype.add = function(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      };
      BigNumber3.prototype.sub = function(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      };
      BigNumber3.prototype.div = function(other) {
        var o = BigNumber3.from(other);
        if (o.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      };
      BigNumber3.prototype.mul = function(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      };
      BigNumber3.prototype.mod = function(other) {
        var value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      };
      BigNumber3.prototype.pow = function(other) {
        var value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      };
      BigNumber3.prototype.and = function(other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      };
      BigNumber3.prototype.or = function(other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      };
      BigNumber3.prototype.xor = function(other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      };
      BigNumber3.prototype.mask = function(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      };
      BigNumber3.prototype.shl = function(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      };
      BigNumber3.prototype.shr = function(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      };
      BigNumber3.prototype.eq = function(other) {
        return toBN(this).eq(toBN(other));
      };
      BigNumber3.prototype.lt = function(other) {
        return toBN(this).lt(toBN(other));
      };
      BigNumber3.prototype.lte = function(other) {
        return toBN(this).lte(toBN(other));
      };
      BigNumber3.prototype.gt = function(other) {
        return toBN(this).gt(toBN(other));
      };
      BigNumber3.prototype.gte = function(other) {
        return toBN(this).gte(toBN(other));
      };
      BigNumber3.prototype.isNegative = function() {
        return this._hex[0] === "-";
      };
      BigNumber3.prototype.isZero = function() {
        return toBN(this).isZero();
      };
      BigNumber3.prototype.toNumber = function() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      };
      BigNumber3.prototype.toBigInt = function() {
        try {
          return BigInt(this.toString());
        } catch (e) {
        }
        return logger.throwError("this platform does not support BigInt", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      };
      BigNumber3.prototype.toString = function() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger.throwError("BigNumber.toString does not accept parameters", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      };
      BigNumber3.prototype.toHexString = function() {
        return this._hex;
      };
      BigNumber3.prototype.toJSON = function(key) {
        return { type: "BigNumber", hex: this.toHexString() };
      };
      BigNumber3.from = function(value) {
        if (value instanceof BigNumber3) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new BigNumber3(_constructorGuard, toHex(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new BigNumber3(_constructorGuard, toHex(new BN(value)));
          }
          return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return BigNumber3.from(String(value));
        }
        var anyValue = value;
        if (typeof anyValue === "bigint") {
          return BigNumber3.from(anyValue.toString());
        }
        if ((0, bytes_1.isBytes)(anyValue)) {
          return BigNumber3.from((0, bytes_1.hexlify)(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            var hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return BigNumber3.from(hex);
            }
          } else {
            var hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if ((0, bytes_1.isHexString)(hex) || hex[0] === "-" && (0, bytes_1.isHexString)(hex.substring(1))) {
                return BigNumber3.from(hex);
              }
            }
          }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
      };
      BigNumber3.isBigNumber = function(value) {
        return !!(value && value._isBigNumber);
      };
      return BigNumber3;
    }();
    exports.BigNumber = BigNumber2;
    function toHex(value) {
      if (typeof value !== "string") {
        return toHex(value.toString(16));
      }
      if (value[0] === "-") {
        value = value.substring(1);
        if (value[0] === "-") {
          logger.throwArgumentError("invalid hex", "value", value);
        }
        value = toHex(value);
        if (value === "0x00") {
          return value;
        }
        return "-" + value;
      }
      if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (value === "0x") {
        return "0x00";
      }
      if (value.length % 2) {
        value = "0x0" + value.substring(2);
      }
      while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
      }
      return value;
    }
    function toBigNumber(value) {
      return BigNumber2.from(toHex(value));
    }
    function toBN(value) {
      var hex = BigNumber2.from(value).toHexString();
      if (hex[0] === "-") {
        return new BN("-" + hex.substring(3), 16);
      }
      return new BN(hex.substring(2), 16);
    }
    function throwFault(fault, operation, value) {
      var params = { fault, operation };
      if (value != null) {
        params.value = value;
      }
      return logger.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);
    }
    function _base36To16(value) {
      return new BN(value, 36).toString(16);
    }
    exports._base36To16 = _base36To16;
    function _base16To36(value) {
      return new BN(value, 16).toString(36);
    }
    exports._base16To36 = _base16To36;
  }
});

// node_modules/@ethersproject/bignumber/lib/fixednumber.js
var require_fixednumber = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/fixednumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version3();
    var logger = new logger_1.Logger(_version_1.version);
    var bignumber_1 = require_bignumber();
    var _constructorGuard = {};
    var Zero = bignumber_1.BigNumber.from(0);
    var NegativeOne = bignumber_1.BigNumber.from(-1);
    function throwFault(message, fault, operation, value) {
      var params = { fault, operation };
      if (value !== void 0) {
        params.value = value;
      }
      return logger.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);
    }
    var zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    function getMultiplier(decimals) {
      if (typeof decimals !== "number") {
        try {
          decimals = bignumber_1.BigNumber.from(decimals).toNumber();
        } catch (e) {
        }
      }
      if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return "1" + zeros.substring(0, decimals);
      }
      return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
    }
    function formatFixed(value, decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      var multiplier = getMultiplier(decimals);
      value = bignumber_1.BigNumber.from(value);
      var negative = value.lt(Zero);
      if (negative) {
        value = value.mul(NegativeOne);
      }
      var fraction = value.mod(multiplier).toString();
      while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
      }
      fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      var whole = value.div(multiplier).toString();
      if (multiplier.length === 1) {
        value = whole;
      } else {
        value = whole + "." + fraction;
      }
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    exports.formatFixed = formatFixed;
    function parseFixed(value, decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      var multiplier = getMultiplier(decimals);
      if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger.throwArgumentError("invalid decimal value", "value", value);
      }
      var negative = value.substring(0, 1) === "-";
      if (negative) {
        value = value.substring(1);
      }
      if (value === ".") {
        logger.throwArgumentError("missing value", "value", value);
      }
      var comps = value.split(".");
      if (comps.length > 2) {
        logger.throwArgumentError("too many decimal points", "value", value);
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
      }
      if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
      }
      if (fraction === "") {
        fraction = "0";
      }
      while (fraction.length < multiplier.length - 1) {
        fraction += "0";
      }
      var wholeValue = bignumber_1.BigNumber.from(whole);
      var fractionValue = bignumber_1.BigNumber.from(fraction);
      var wei = wholeValue.mul(multiplier).add(fractionValue);
      if (negative) {
        wei = wei.mul(NegativeOne);
      }
      return wei;
    }
    exports.parseFixed = parseFixed;
    var FixedFormat = function() {
      function FixedFormat2(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard) {
          logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      FixedFormat2.from = function(value) {
        if (value instanceof FixedFormat2) {
          return value;
        }
        if (typeof value === "number") {
          value = "fixed128x" + value;
        }
        var signed = true;
        var width = 128;
        var decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {
          } else if (value === "ufixed") {
            signed = false;
          } else {
            var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match) {
              logger.throwArgumentError("invalid fixed format", "format", value);
            }
            signed = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value) {
          var check = function(key, type, defaultValue) {
            if (value[key] == null) {
              return defaultValue;
            }
            if (typeof value[key] !== type) {
              logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
            }
            return value[key];
          };
          signed = check("signed", "boolean", signed);
          width = check("width", "number", width);
          decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
          logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat2(_constructorGuard, signed, width, decimals);
      };
      return FixedFormat2;
    }();
    exports.FixedFormat = FixedFormat;
    var FixedNumber = function() {
      function FixedNumber2(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard) {
          logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      FixedNumber2.prototype._checkFormat = function(other) {
        if (this.format.name !== other.format.name) {
          logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      };
      FixedNumber2.prototype.addUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.add(b), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.subUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.sub(b), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.mulUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.divUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.floor = function() {
        var comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        var result = FixedNumber2.from(comps[0], this.format);
        var hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
      };
      FixedNumber2.prototype.ceiling = function() {
        var comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        var result = FixedNumber2.from(comps[0], this.format);
        var hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
      };
      FixedNumber2.prototype.round = function(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        var comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        var factor = FixedNumber2.from("1" + zeros.substring(0, decimals), this.format);
        var bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      };
      FixedNumber2.prototype.isZero = function() {
        return this._value === "0.0" || this._value === "0";
      };
      FixedNumber2.prototype.isNegative = function() {
        return this._value[0] === "-";
      };
      FixedNumber2.prototype.toString = function() {
        return this._value;
      };
      FixedNumber2.prototype.toHexString = function(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger.throwArgumentError("invalid byte width", "width", width);
        }
        var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return (0, bytes_1.hexZeroPad)(hex, width / 8);
      };
      FixedNumber2.prototype.toUnsafeFloat = function() {
        return parseFloat(this.toString());
      };
      FixedNumber2.prototype.toFormat = function(format) {
        return FixedNumber2.fromString(this._value, format);
      };
      FixedNumber2.fromValue = function(value, decimals, format) {
        if (format == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return FixedNumber2.fromString(formatFixed(value, decimals), FixedFormat.from(format));
      };
      FixedNumber2.fromString = function(value, format) {
        if (format == null) {
          format = "fixed";
        }
        var fixedFormat = FixedFormat.from(format);
        var numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
          throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        var hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = (0, bytes_1.hexZeroPad)(hex, fixedFormat.width / 8);
        }
        var decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber2(_constructorGuard, hex, decimal, fixedFormat);
      };
      FixedNumber2.fromBytes = function(value, format) {
        if (format == null) {
          format = "fixed";
        }
        var fixedFormat = FixedFormat.from(format);
        if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        var numeric = bignumber_1.BigNumber.from(value);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        var decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber2(_constructorGuard, hex, decimal, fixedFormat);
      };
      FixedNumber2.from = function(value, format) {
        if (typeof value === "string") {
          return FixedNumber2.fromString(value, format);
        }
        if ((0, bytes_1.isBytes)(value)) {
          return FixedNumber2.fromBytes(value, format);
        }
        try {
          return FixedNumber2.fromValue(value, 0, format);
        } catch (error) {
          if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger.throwArgumentError("invalid FixedNumber value", "value", value);
      };
      FixedNumber2.isFixedNumber = function(value) {
        return !!(value && value._isFixedNumber);
      };
      return FixedNumber2;
    }();
    exports.FixedNumber = FixedNumber;
    var ONE = FixedNumber.from(1);
    var BUMP = FixedNumber.from("0.5");
  }
});

// node_modules/@ethersproject/bignumber/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@ethersproject/bignumber/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = void 0;
    var bignumber_1 = require_bignumber();
    Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function() {
      return bignumber_1.BigNumber;
    } });
    var fixednumber_1 = require_fixednumber();
    Object.defineProperty(exports, "formatFixed", { enumerable: true, get: function() {
      return fixednumber_1.formatFixed;
    } });
    Object.defineProperty(exports, "FixedFormat", { enumerable: true, get: function() {
      return fixednumber_1.FixedFormat;
    } });
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return fixednumber_1.FixedNumber;
    } });
    Object.defineProperty(exports, "parseFixed", { enumerable: true, get: function() {
      return fixednumber_1.parseFixed;
    } });
    var bignumber_2 = require_bignumber();
    Object.defineProperty(exports, "_base16To36", { enumerable: true, get: function() {
      return bignumber_2._base16To36;
    } });
    Object.defineProperty(exports, "_base36To16", { enumerable: true, get: function() {
      return bignumber_2._base36To16;
    } });
  }
});

// node_modules/@ethersproject/properties/lib/_version.js
var require_version4 = __commonJS({
  "node_modules/@ethersproject/properties/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "properties/5.7.0";
  }
});

// node_modules/@ethersproject/properties/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@ethersproject/properties/lib/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version4();
    var logger = new logger_1.Logger(_version_1.version);
    function defineReadOnly(object, name, value) {
      Object.defineProperty(object, name, {
        enumerable: true,
        value,
        writable: false
      });
    }
    exports.defineReadOnly = defineReadOnly;
    function getStatic(ctor, key) {
      for (var i = 0; i < 32; i++) {
        if (ctor[key]) {
          return ctor[key];
        }
        if (!ctor.prototype || typeof ctor.prototype !== "object") {
          break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
      }
      return null;
    }
    exports.getStatic = getStatic;
    function resolveProperties(object) {
      return __awaiter(this, void 0, void 0, function() {
        var promises, results;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              promises = Object.keys(object).map(function(key) {
                var value = object[key];
                return Promise.resolve(value).then(function(v) {
                  return { key, value: v };
                });
              });
              return [4, Promise.all(promises)];
            case 1:
              results = _a.sent();
              return [2, results.reduce(function(accum, result) {
                accum[result.key] = result.value;
                return accum;
              }, {})];
          }
        });
      });
    }
    exports.resolveProperties = resolveProperties;
    function checkProperties(object, properties) {
      if (!object || typeof object !== "object") {
        logger.throwArgumentError("invalid object", "object", object);
      }
      Object.keys(object).forEach(function(key) {
        if (!properties[key]) {
          logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
      });
    }
    exports.checkProperties = checkProperties;
    function shallowCopy(object) {
      var result = {};
      for (var key in object) {
        result[key] = object[key];
      }
      return result;
    }
    exports.shallowCopy = shallowCopy;
    var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
    function _isFrozen(object) {
      if (object === void 0 || object === null || opaque[typeof object]) {
        return true;
      }
      if (Array.isArray(object) || typeof object === "object") {
        if (!Object.isFrozen(object)) {
          return false;
        }
        var keys = Object.keys(object);
        for (var i = 0; i < keys.length; i++) {
          var value = null;
          try {
            value = object[keys[i]];
          } catch (error) {
            continue;
          }
          if (!_isFrozen(value)) {
            return false;
          }
        }
        return true;
      }
      return logger.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
    }
    function _deepCopy(object) {
      if (_isFrozen(object)) {
        return object;
      }
      if (Array.isArray(object)) {
        return Object.freeze(object.map(function(item) {
          return deepCopy(item);
        }));
      }
      if (typeof object === "object") {
        var result = {};
        for (var key in object) {
          var value = object[key];
          if (value === void 0) {
            continue;
          }
          defineReadOnly(result, key, deepCopy(value));
        }
        return result;
      }
      return logger.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
    }
    function deepCopy(object) {
      return _deepCopy(object);
    }
    exports.deepCopy = deepCopy;
    var Description = function() {
      function Description2(info) {
        for (var key in info) {
          this[key] = deepCopy(info[key]);
        }
      }
      return Description2;
    }();
    exports.Description = Description;
  }
});

// node_modules/@ethersproject/abi/lib/_version.js
var require_version5 = __commonJS({
  "node_modules/@ethersproject/abi/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abi/5.7.0";
  }
});

// node_modules/@ethersproject/abi/lib/fragments.js
var require_fragments = __commonJS({
  "node_modules/@ethersproject/abi/lib/fragments.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = void 0;
    var bignumber_1 = require_lib3();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger = new logger_1.Logger(_version_1.version);
    var _constructorGuard = {};
    var ModifiersBytes = { calldata: true, memory: true, storage: true };
    var ModifiersNest = { calldata: true, memory: true };
    function checkModifier(type, name) {
      if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
          return true;
        }
      } else if (type === "address") {
        if (name === "payable") {
          return true;
        }
      } else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
          return true;
        }
      }
      if (ModifiersBytes[name] || name === "payable") {
        logger.throwArgumentError("invalid modifier", "name", name);
      }
      return false;
    }
    function parseParamType(param, allowIndexed) {
      var originalParam = param;
      function throwError(i2) {
        logger.throwArgumentError("unexpected character at position " + i2, "param", param);
      }
      param = param.replace(/\s/g, " ");
      function newNode(parent2) {
        var node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
        if (allowIndexed) {
          node2.indexed = false;
        }
        return node2;
      }
      var parent = { type: "", name: "", state: { allowType: true } };
      var node = parent;
      for (var i = 0; i < param.length; i++) {
        var c3 = param[i];
        switch (c3) {
          case "(":
            if (node.state.allowType && node.type === "") {
              node.type = "tuple";
            } else if (!node.state.allowParams) {
              throwError(i);
            }
            node.state.allowType = false;
            node.type = verifyType(node.type);
            node.components = [newNode(node)];
            node = node.components[0];
            break;
          case ")":
            delete node.state;
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            }
            if (checkModifier(node.type, node.name)) {
              node.name = "";
            }
            node.type = verifyType(node.type);
            var child = node;
            node = node.parent;
            if (!node) {
              throwError(i);
            }
            delete child.parent;
            node.state.allowParams = false;
            node.state.allowName = true;
            node.state.allowArray = true;
            break;
          case ",":
            delete node.state;
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            }
            if (checkModifier(node.type, node.name)) {
              node.name = "";
            }
            node.type = verifyType(node.type);
            var sibling = newNode(node.parent);
            node.parent.components.push(sibling);
            delete node.parent;
            node = sibling;
            break;
          case " ":
            if (node.state.allowType) {
              if (node.type !== "") {
                node.type = verifyType(node.type);
                delete node.state.allowType;
                node.state.allowName = true;
                node.state.allowParams = true;
              }
            }
            if (node.state.allowName) {
              if (node.name !== "") {
                if (node.name === "indexed") {
                  if (!allowIndexed) {
                    throwError(i);
                  }
                  if (node.indexed) {
                    throwError(i);
                  }
                  node.indexed = true;
                  node.name = "";
                } else if (checkModifier(node.type, node.name)) {
                  node.name = "";
                } else {
                  node.state.allowName = false;
                }
              }
            }
            break;
          case "[":
            if (!node.state.allowArray) {
              throwError(i);
            }
            node.type += c3;
            node.state.allowArray = false;
            node.state.allowName = false;
            node.state.readArray = true;
            break;
          case "]":
            if (!node.state.readArray) {
              throwError(i);
            }
            node.type += c3;
            node.state.readArray = false;
            node.state.allowArray = true;
            node.state.allowName = true;
            break;
          default:
            if (node.state.allowType) {
              node.type += c3;
              node.state.allowParams = true;
              node.state.allowArray = true;
            } else if (node.state.allowName) {
              node.name += c3;
              delete node.state.allowArray;
            } else if (node.state.readArray) {
              node.type += c3;
            } else {
              throwError(i);
            }
        }
      }
      if (node.parent) {
        logger.throwArgumentError("unexpected eof", "param", param);
      }
      delete parent.state;
      if (node.name === "indexed") {
        if (!allowIndexed) {
          throwError(originalParam.length - 7);
        }
        if (node.indexed) {
          throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
      } else if (checkModifier(node.type, node.name)) {
        node.name = "";
      }
      parent.type = verifyType(parent.type);
      return parent;
    }
    function populate(object, params) {
      for (var key in params) {
        (0, properties_1.defineReadOnly)(object, key, params[key]);
      }
    }
    exports.FormatTypes = Object.freeze({
      sighash: "sighash",
      minimal: "minimal",
      full: "full",
      json: "json"
    });
    var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    var ParamType = function() {
      function ParamType2(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
          logger.throwError("use fromString", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          });
        }
        populate(this, params);
        var match = this.type.match(paramTypeArray);
        if (match) {
          populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: ParamType2.fromObject({
              type: match[1],
              components: this.components
            }),
            baseType: "array"
          });
        } else {
          populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
          });
        }
        this._isParamType = true;
        Object.freeze(this);
      }
      ParamType2.prototype.format = function(format) {
        if (!format) {
          format = exports.FormatTypes.sighash;
        }
        if (!exports.FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === exports.FormatTypes.json) {
          var result_1 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: this.name || void 0
          };
          if (typeof this.indexed === "boolean") {
            result_1.indexed = this.indexed;
          }
          if (this.components) {
            result_1.components = this.components.map(function(comp) {
              return JSON.parse(comp.format(format));
            });
          }
          return JSON.stringify(result_1);
        }
        var result = "";
        if (this.baseType === "array") {
          result += this.arrayChildren.format(format);
          result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else {
          if (this.baseType === "tuple") {
            if (format !== exports.FormatTypes.sighash) {
              result += this.type;
            }
            result += "(" + this.components.map(function(comp) {
              return comp.format(format);
            }).join(format === exports.FormatTypes.full ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== exports.FormatTypes.sighash) {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === exports.FormatTypes.full && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      };
      ParamType2.from = function(value, allowIndexed) {
        if (typeof value === "string") {
          return ParamType2.fromString(value, allowIndexed);
        }
        return ParamType2.fromObject(value);
      };
      ParamType2.fromObject = function(value) {
        if (ParamType2.isParamType(value)) {
          return value;
        }
        return new ParamType2(_constructorGuard, {
          name: value.name || null,
          type: verifyType(value.type),
          indexed: value.indexed == null ? null : !!value.indexed,
          components: value.components ? value.components.map(ParamType2.fromObject) : null
        });
      };
      ParamType2.fromString = function(value, allowIndexed) {
        function ParamTypify(node) {
          return ParamType2.fromObject({
            name: node.name,
            type: node.type,
            indexed: node.indexed,
            components: node.components
          });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
      };
      ParamType2.isParamType = function(value) {
        return !!(value != null && value._isParamType);
      };
      return ParamType2;
    }();
    exports.ParamType = ParamType;
    function parseParams(value, allowIndex) {
      return splitNesting(value).map(function(param) {
        return ParamType.fromString(param, allowIndex);
      });
    }
    var Fragment = function() {
      function Fragment2(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
          logger.throwError("use a static from method", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
      }
      Fragment2.from = function(value) {
        if (Fragment2.isFragment(value)) {
          return value;
        }
        if (typeof value === "string") {
          return Fragment2.fromString(value);
        }
        return Fragment2.fromObject(value);
      };
      Fragment2.fromObject = function(value) {
        if (Fragment2.isFragment(value)) {
          return value;
        }
        switch (value.type) {
          case "function":
            return FunctionFragment.fromObject(value);
          case "event":
            return EventFragment.fromObject(value);
          case "constructor":
            return ConstructorFragment.fromObject(value);
          case "error":
            return ErrorFragment.fromObject(value);
          case "fallback":
          case "receive":
            return null;
        }
        return logger.throwArgumentError("invalid fragment object", "value", value);
      };
      Fragment2.fromString = function(value) {
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
          return EventFragment.fromString(value.substring(5).trim());
        } else if (value.split(" ")[0] === "function") {
          return FunctionFragment.fromString(value.substring(8).trim());
        } else if (value.split("(")[0].trim() === "constructor") {
          return ConstructorFragment.fromString(value.trim());
        } else if (value.split(" ")[0] === "error") {
          return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger.throwArgumentError("unsupported fragment", "value", value);
      };
      Fragment2.isFragment = function(value) {
        return !!(value && value._isFragment);
      };
      return Fragment2;
    }();
    exports.Fragment = Fragment;
    var EventFragment = function(_super) {
      __extends(EventFragment2, _super);
      function EventFragment2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      EventFragment2.prototype.format = function(format) {
        if (!format) {
          format = exports.FormatTypes.sighash;
        }
        if (!exports.FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === exports.FormatTypes.json) {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(function(input) {
              return JSON.parse(input.format(format));
            })
          });
        }
        var result = "";
        if (format !== exports.FormatTypes.sighash) {
          result += "event ";
        }
        result += this.name + "(" + this.inputs.map(function(input) {
          return input.format(format);
        }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
        if (format !== exports.FormatTypes.sighash) {
          if (this.anonymous) {
            result += "anonymous ";
          }
        }
        return result.trim();
      };
      EventFragment2.from = function(value) {
        if (typeof value === "string") {
          return EventFragment2.fromString(value);
        }
        return EventFragment2.fromObject(value);
      };
      EventFragment2.fromObject = function(value) {
        if (EventFragment2.isEventFragment(value)) {
          return value;
        }
        if (value.type !== "event") {
          logger.throwArgumentError("invalid event object", "value", value);
        }
        var params = {
          name: verifyIdentifier(value.name),
          anonymous: value.anonymous,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          type: "event"
        };
        return new EventFragment2(_constructorGuard, params);
      };
      EventFragment2.fromString = function(value) {
        var match = value.match(regexParen);
        if (!match) {
          logger.throwArgumentError("invalid event string", "value", value);
        }
        var anonymous = false;
        match[3].split(" ").forEach(function(modifier) {
          switch (modifier.trim()) {
            case "anonymous":
              anonymous = true;
              break;
            case "":
              break;
            default:
              logger.warn("unknown modifier: " + modifier);
          }
        });
        return EventFragment2.fromObject({
          name: match[1].trim(),
          anonymous,
          inputs: parseParams(match[2], true),
          type: "event"
        });
      };
      EventFragment2.isEventFragment = function(value) {
        return value && value._isFragment && value.type === "event";
      };
      return EventFragment2;
    }(Fragment);
    exports.EventFragment = EventFragment;
    function parseGas(value, params) {
      params.gas = null;
      var comps = value.split("@");
      if (comps.length !== 1) {
        if (comps.length > 2) {
          logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
          logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = bignumber_1.BigNumber.from(comps[1]);
        return comps[0];
      }
      return value;
    }
    function parseModifiers(value, params) {
      params.constant = false;
      params.payable = false;
      params.stateMutability = "nonpayable";
      value.split(" ").forEach(function(modifier) {
        switch (modifier.trim()) {
          case "constant":
            params.constant = true;
            break;
          case "payable":
            params.payable = true;
            params.stateMutability = "payable";
            break;
          case "nonpayable":
            params.payable = false;
            params.stateMutability = "nonpayable";
            break;
          case "pure":
            params.constant = true;
            params.stateMutability = "pure";
            break;
          case "view":
            params.constant = true;
            params.stateMutability = "view";
            break;
          case "external":
          case "public":
          case "":
            break;
          default:
            console.log("unknown modifier: " + modifier);
        }
      });
    }
    function verifyState(value) {
      var result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
      };
      if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
        if (value.constant != null) {
          if (!!value.constant !== result.constant) {
            logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
          }
        }
        result.payable = result.stateMutability === "payable";
        if (value.payable != null) {
          if (!!value.payable !== result.payable) {
            logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
          }
        }
      } else if (value.payable != null) {
        result.payable = !!value.payable;
        if (value.constant == null && !result.payable && value.type !== "constructor") {
          logger.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
          result.stateMutability = "view";
        } else {
          result.stateMutability = result.payable ? "payable" : "nonpayable";
        }
        if (result.payable && result.constant) {
          logger.throwArgumentError("cannot have constant payable function", "value", value);
        }
      } else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = result.constant ? "view" : "payable";
      } else if (value.type !== "constructor") {
        logger.throwArgumentError("unable to determine stateMutability", "value", value);
      }
      return result;
    }
    var ConstructorFragment = function(_super) {
      __extends(ConstructorFragment2, _super);
      function ConstructorFragment2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ConstructorFragment2.prototype.format = function(format) {
        if (!format) {
          format = exports.FormatTypes.sighash;
        }
        if (!exports.FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === exports.FormatTypes.json) {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(function(input) {
              return JSON.parse(input.format(format));
            })
          });
        }
        if (format === exports.FormatTypes.sighash) {
          logger.throwError("cannot format a constructor for sighash", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
        }
        var result = "constructor(" + this.inputs.map(function(input) {
          return input.format(format);
        }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
        return result.trim();
      };
      ConstructorFragment2.from = function(value) {
        if (typeof value === "string") {
          return ConstructorFragment2.fromString(value);
        }
        return ConstructorFragment2.fromObject(value);
      };
      ConstructorFragment2.fromObject = function(value) {
        if (ConstructorFragment2.isConstructorFragment(value)) {
          return value;
        }
        if (value.type !== "constructor") {
          logger.throwArgumentError("invalid constructor object", "value", value);
        }
        var state = verifyState(value);
        if (state.constant) {
          logger.throwArgumentError("constructor cannot be constant", "value", value);
        }
        var params = {
          name: null,
          type: value.type,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
        };
        return new ConstructorFragment2(_constructorGuard, params);
      };
      ConstructorFragment2.fromString = function(value) {
        var params = { type: "constructor" };
        value = parseGas(value, params);
        var parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
          logger.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment2.fromObject(params);
      };
      ConstructorFragment2.isConstructorFragment = function(value) {
        return value && value._isFragment && value.type === "constructor";
      };
      return ConstructorFragment2;
    }(Fragment);
    exports.ConstructorFragment = ConstructorFragment;
    var FunctionFragment = function(_super) {
      __extends(FunctionFragment2, _super);
      function FunctionFragment2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FunctionFragment2.prototype.format = function(format) {
        if (!format) {
          format = exports.FormatTypes.sighash;
        }
        if (!exports.FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === exports.FormatTypes.json) {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(function(input) {
              return JSON.parse(input.format(format));
            }),
            outputs: this.outputs.map(function(output) {
              return JSON.parse(output.format(format));
            })
          });
        }
        var result = "";
        if (format !== exports.FormatTypes.sighash) {
          result += "function ";
        }
        result += this.name + "(" + this.inputs.map(function(input) {
          return input.format(format);
        }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
        if (format !== exports.FormatTypes.sighash) {
          if (this.stateMutability) {
            if (this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
          } else if (this.constant) {
            result += "view ";
          }
          if (this.outputs && this.outputs.length) {
            result += "returns (" + this.outputs.map(function(output) {
              return output.format(format);
            }).join(", ") + ") ";
          }
          if (this.gas != null) {
            result += "@" + this.gas.toString() + " ";
          }
        }
        return result.trim();
      };
      FunctionFragment2.from = function(value) {
        if (typeof value === "string") {
          return FunctionFragment2.fromString(value);
        }
        return FunctionFragment2.fromObject(value);
      };
      FunctionFragment2.fromObject = function(value) {
        if (FunctionFragment2.isFunctionFragment(value)) {
          return value;
        }
        if (value.type !== "function") {
          logger.throwArgumentError("invalid function object", "value", value);
        }
        var state = verifyState(value);
        var params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          constant: state.constant,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
        };
        return new FunctionFragment2(_constructorGuard, params);
      };
      FunctionFragment2.fromString = function(value) {
        var params = { type: "function" };
        value = parseGas(value, params);
        var comps = value.split(" returns ");
        if (comps.length > 2) {
          logger.throwArgumentError("invalid function string", "value", value);
        }
        var parens = comps[0].match(regexParen);
        if (!parens) {
          logger.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
          var returns = comps[1].match(regexParen);
          if (returns[1].trim() != "" || returns[3].trim() != "") {
            logger.throwArgumentError("unexpected tokens", "value", value);
          }
          params.outputs = parseParams(returns[2], false);
        } else {
          params.outputs = [];
        }
        return FunctionFragment2.fromObject(params);
      };
      FunctionFragment2.isFunctionFragment = function(value) {
        return value && value._isFragment && value.type === "function";
      };
      return FunctionFragment2;
    }(ConstructorFragment);
    exports.FunctionFragment = FunctionFragment;
    function checkForbidden(fragment) {
      var sig = fragment.format();
      if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger.throwArgumentError("cannot specify user defined " + sig + " error", "fragment", fragment);
      }
      return fragment;
    }
    var ErrorFragment = function(_super) {
      __extends(ErrorFragment2, _super);
      function ErrorFragment2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ErrorFragment2.prototype.format = function(format) {
        if (!format) {
          format = exports.FormatTypes.sighash;
        }
        if (!exports.FormatTypes[format]) {
          logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === exports.FormatTypes.json) {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(function(input) {
              return JSON.parse(input.format(format));
            })
          });
        }
        var result = "";
        if (format !== exports.FormatTypes.sighash) {
          result += "error ";
        }
        result += this.name + "(" + this.inputs.map(function(input) {
          return input.format(format);
        }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
      };
      ErrorFragment2.from = function(value) {
        if (typeof value === "string") {
          return ErrorFragment2.fromString(value);
        }
        return ErrorFragment2.fromObject(value);
      };
      ErrorFragment2.fromObject = function(value) {
        if (ErrorFragment2.isErrorFragment(value)) {
          return value;
        }
        if (value.type !== "error") {
          logger.throwArgumentError("invalid error object", "value", value);
        }
        var params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new ErrorFragment2(_constructorGuard, params));
      };
      ErrorFragment2.fromString = function(value) {
        var params = { type: "error" };
        var parens = value.match(regexParen);
        if (!parens) {
          logger.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment2.fromObject(params));
      };
      ErrorFragment2.isErrorFragment = function(value) {
        return value && value._isFragment && value.type === "error";
      };
      return ErrorFragment2;
    }(Fragment);
    exports.ErrorFragment = ErrorFragment;
    function verifyType(type) {
      if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
      } else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
      }
      return type;
    }
    var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
    function verifyIdentifier(value) {
      if (!value || !value.match(regexIdentifier)) {
        logger.throwArgumentError('invalid identifier "' + value + '"', "value", value);
      }
      return value;
    }
    var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
    function splitNesting(value) {
      value = value.trim();
      var result = [];
      var accum = "";
      var depth = 0;
      for (var offset = 0; offset < value.length; offset++) {
        var c3 = value[offset];
        if (c3 === "," && depth === 0) {
          result.push(accum);
          accum = "";
        } else {
          accum += c3;
          if (c3 === "(") {
            depth++;
          } else if (c3 === ")") {
            depth--;
            if (depth === -1) {
              logger.throwArgumentError("unbalanced parenthesis", "value", value);
            }
          }
        }
      }
      if (accum) {
        result.push(accum);
      }
      return result;
    }
  }
});

// node_modules/@ethersproject/abi/lib/coders/abstract-coder.js
var require_abstract_coder = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/abstract-coder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = void 0;
    var bytes_1 = require_lib2();
    var bignumber_1 = require_lib3();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger = new logger_1.Logger(_version_1.version);
    function checkResultErrors(result) {
      var errors = [];
      var checkErrors = function(path3, object) {
        if (!Array.isArray(object)) {
          return;
        }
        for (var key in object) {
          var childPath = path3.slice();
          childPath.push(key);
          try {
            checkErrors(childPath, object[key]);
          } catch (error) {
            errors.push({ path: childPath, error });
          }
        }
      };
      checkErrors([], result);
      return errors;
    }
    exports.checkResultErrors = checkResultErrors;
    var Coder = function() {
      function Coder2(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
      }
      Coder2.prototype._throwError = function(message, value) {
        logger.throwArgumentError(message, this.localName, value);
      };
      return Coder2;
    }();
    exports.Coder = Coder;
    var Writer = function() {
      function Writer2(wordSize) {
        (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
      }
      Object.defineProperty(Writer2.prototype, "data", {
        get: function() {
          return (0, bytes_1.hexConcat)(this._data);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Writer2.prototype, "length", {
        get: function() {
          return this._dataLength;
        },
        enumerable: false,
        configurable: true
      });
      Writer2.prototype._writeData = function(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
      };
      Writer2.prototype.appendWriter = function(writer) {
        return this._writeData((0, bytes_1.concat)(writer._data));
      };
      Writer2.prototype.writeBytes = function(value) {
        var bytes = (0, bytes_1.arrayify)(value);
        var paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
          bytes = (0, bytes_1.concat)([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
      };
      Writer2.prototype._getValue = function(value) {
        var bytes = (0, bytes_1.arrayify)(bignumber_1.BigNumber.from(value));
        if (bytes.length > this.wordSize) {
          logger.throwError("value out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes.length
          });
        }
        if (bytes.length % this.wordSize) {
          bytes = (0, bytes_1.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
      };
      Writer2.prototype.writeValue = function(value) {
        return this._writeData(this._getValue(value));
      };
      Writer2.prototype.writeUpdatableValue = function() {
        var _this = this;
        var offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return function(value) {
          _this._data[offset] = _this._getValue(value);
        };
      };
      return Writer2;
    }();
    exports.Writer = Writer;
    var Reader = function() {
      function Reader2(data, wordSize, coerceFunc, allowLoose) {
        (0, properties_1.defineReadOnly)(this, "_data", (0, bytes_1.arrayify)(data));
        (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
        (0, properties_1.defineReadOnly)(this, "_coerceFunc", coerceFunc);
        (0, properties_1.defineReadOnly)(this, "allowLoose", allowLoose);
        this._offset = 0;
      }
      Object.defineProperty(Reader2.prototype, "data", {
        get: function() {
          return (0, bytes_1.hexlify)(this._data);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Reader2.prototype, "consumed", {
        get: function() {
          return this._offset;
        },
        enumerable: false,
        configurable: true
      });
      Reader2.coerce = function(name, value) {
        var match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
          value = value.toNumber();
        }
        return value;
      };
      Reader2.prototype.coerce = function(name, value) {
        if (this._coerceFunc) {
          return this._coerceFunc(name, value);
        }
        return Reader2.coerce(name, value);
      };
      Reader2.prototype._peekBytes = function(offset, length3, loose) {
        var alignedLength = Math.ceil(length3 / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
          if (this.allowLoose && loose && this._offset + length3 <= this._data.length) {
            alignedLength = length3;
          } else {
            logger.throwError("data out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + alignedLength
            });
          }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
      };
      Reader2.prototype.subReader = function(offset) {
        return new Reader2(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      };
      Reader2.prototype.readBytes = function(length3, loose) {
        var bytes = this._peekBytes(0, length3, !!loose);
        this._offset += bytes.length;
        return bytes.slice(0, length3);
      };
      Reader2.prototype.readValue = function() {
        return bignumber_1.BigNumber.from(this.readBytes(this.wordSize));
      };
      return Reader2;
    }();
    exports.Reader = Reader;
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding2, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding2) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding2, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      };
      var createShakeMethod = function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      };
      var createCshakeMethod = function(bits2, padding2) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding2, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      };
      var createKmacMethod = function(bits2, padding2) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length3 = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length3) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length3 && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length3 && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes.push(n);
        } else {
          bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length3 = str.length;
        if (notString) {
          bytes = length3;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak.call(this, bits2, padding2, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c22, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c22 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c22 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c22 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c22 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@ethersproject/keccak256/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@ethersproject/keccak256/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = void 0;
    var js_sha3_1 = __importDefault(require_sha3());
    var bytes_1 = require_lib2();
    function keccak256(data) {
      return "0x" + js_sha3_1.default.keccak_256((0, bytes_1.arrayify)(data));
    }
    exports.keccak256 = keccak256;
  }
});

// node_modules/@ethersproject/rlp/lib/_version.js
var require_version6 = __commonJS({
  "node_modules/@ethersproject/rlp/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "rlp/5.7.0";
  }
});

// node_modules/@ethersproject/rlp/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@ethersproject/rlp/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version6();
    var logger = new logger_1.Logger(_version_1.version);
    function arrayifyInteger(value) {
      var result = [];
      while (value) {
        result.unshift(value & 255);
        value >>= 8;
      }
      return result;
    }
    function unarrayifyInteger(data, offset, length3) {
      var result = 0;
      for (var i = 0; i < length3; i++) {
        result = result * 256 + data[offset + i];
      }
      return result;
    }
    function _encode(object) {
      if (Array.isArray(object)) {
        var payload_1 = [];
        object.forEach(function(child) {
          payload_1 = payload_1.concat(_encode(child));
        });
        if (payload_1.length <= 55) {
          payload_1.unshift(192 + payload_1.length);
          return payload_1;
        }
        var length_1 = arrayifyInteger(payload_1.length);
        length_1.unshift(247 + length_1.length);
        return length_1.concat(payload_1);
      }
      if (!(0, bytes_1.isBytesLike)(object)) {
        logger.throwArgumentError("RLP object must be BytesLike", "object", object);
      }
      var data = Array.prototype.slice.call((0, bytes_1.arrayify)(object));
      if (data.length === 1 && data[0] <= 127) {
        return data;
      } else if (data.length <= 55) {
        data.unshift(128 + data.length);
        return data;
      }
      var length3 = arrayifyInteger(data.length);
      length3.unshift(183 + length3.length);
      return length3.concat(data);
    }
    function encode5(object) {
      return (0, bytes_1.hexlify)(_encode(object));
    }
    exports.encode = encode5;
    function _decodeChildren(data, offset, childOffset, length3) {
      var result = [];
      while (childOffset < offset + 1 + length3) {
        var decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length3) {
          logger.throwError("child data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
      }
      return { consumed: 1 + length3, result };
    }
    function _decode(data, offset) {
      if (data.length === 0) {
        logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      if (data[offset] >= 248) {
        var lengthLength = data[offset] - 247;
        if (offset + 1 + lengthLength > data.length) {
          logger.throwError("data short segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_2 > data.length) {
          logger.throwError("data long segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);
      } else if (data[offset] >= 192) {
        var length_3 = data[offset] - 192;
        if (offset + 1 + length_3 > data.length) {
          logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length_3);
      } else if (data[offset] >= 184) {
        var lengthLength = data[offset] - 183;
        if (offset + 1 + lengthLength > data.length) {
          logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_4 > data.length) {
          logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));
        return { consumed: 1 + lengthLength + length_4, result };
      } else if (data[offset] >= 128) {
        var length_5 = data[offset] - 128;
        if (offset + 1 + length_5 > data.length) {
          logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));
        return { consumed: 1 + length_5, result };
      }
      return { consumed: 1, result: (0, bytes_1.hexlify)(data[offset]) };
    }
    function decode2(data) {
      var bytes = (0, bytes_1.arrayify)(data);
      var decoded = _decode(bytes, 0);
      if (decoded.consumed !== bytes.length) {
        logger.throwArgumentError("invalid rlp data", "data", data);
      }
      return decoded.result;
    }
    exports.decode = decode2;
  }
});

// node_modules/@ethersproject/address/lib/_version.js
var require_version7 = __commonJS({
  "node_modules/@ethersproject/address/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "address/5.7.0";
  }
});

// node_modules/@ethersproject/address/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@ethersproject/address/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;
    var bytes_1 = require_lib2();
    var bignumber_1 = require_lib3();
    var keccak256_1 = require_lib5();
    var rlp_1 = require_lib6();
    var logger_1 = require_lib();
    var _version_1 = require_version7();
    var logger = new logger_1.Logger(_version_1.version);
    function getChecksumAddress(address) {
      if (!(0, bytes_1.isHexString)(address, 20)) {
        logger.throwArgumentError("invalid address", "address", address);
      }
      address = address.toLowerCase();
      var chars = address.substring(2).split("");
      var expanded = new Uint8Array(40);
      for (var i2 = 0; i2 < 40; i2++) {
        expanded[i2] = chars[i2].charCodeAt(0);
      }
      var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));
      for (var i2 = 0; i2 < 40; i2 += 2) {
        if (hashed[i2 >> 1] >> 4 >= 8) {
          chars[i2] = chars[i2].toUpperCase();
        }
        if ((hashed[i2 >> 1] & 15) >= 8) {
          chars[i2 + 1] = chars[i2 + 1].toUpperCase();
        }
      }
      return "0x" + chars.join("");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function log10(x) {
      if (Math.log10) {
        return Math.log10(x);
      }
      return Math.log(x) / Math.LN10;
    }
    var ibanLookup = {};
    for (i = 0; i < 10; i++) {
      ibanLookup[String(i)] = String(i);
    }
    var i;
    for (i = 0; i < 26; i++) {
      ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
    }
    var i;
    var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
    function ibanChecksum(address) {
      address = address.toUpperCase();
      address = address.substring(4) + address.substring(0, 2) + "00";
      var expanded = address.split("").map(function(c3) {
        return ibanLookup[c3];
      }).join("");
      while (expanded.length >= safeDigits) {
        var block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
      }
      var checksum = String(98 - parseInt(expanded, 10) % 97);
      while (checksum.length < 2) {
        checksum = "0" + checksum;
      }
      return checksum;
    }
    function getAddress(address) {
      var result = null;
      if (typeof address !== "string") {
        logger.throwArgumentError("invalid address", "address", address);
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        if (address.substring(0, 2) !== "0x") {
          address = "0x" + address;
        }
        result = getChecksumAddress(address);
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
          logger.throwArgumentError("bad address checksum", "address", address);
        }
      } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        if (address.substring(2, 4) !== ibanChecksum(address)) {
          logger.throwArgumentError("bad icap checksum", "address", address);
        }
        result = (0, bignumber_1._base36To16)(address.substring(4));
        while (result.length < 40) {
          result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
      } else {
        logger.throwArgumentError("invalid address", "address", address);
      }
      return result;
    }
    exports.getAddress = getAddress;
    function isAddress(address) {
      try {
        getAddress(address);
        return true;
      } catch (error) {
      }
      return false;
    }
    exports.isAddress = isAddress;
    function getIcapAddress(address) {
      var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();
      while (base36.length < 30) {
        base36 = "0" + base36;
      }
      return "XE" + ibanChecksum("XE00" + base36) + base36;
    }
    exports.getIcapAddress = getIcapAddress;
    function getContractAddress(transaction) {
      var from = null;
      try {
        from = getAddress(transaction.from);
      } catch (error) {
        logger.throwArgumentError("missing from address", "transaction", transaction);
      }
      var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));
      return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));
    }
    exports.getContractAddress = getContractAddress;
    function getCreate2Address(from, salt, initCodeHash) {
      if ((0, bytes_1.hexDataLength)(salt) !== 32) {
        logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
      }
      if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {
        logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
      }
      return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)(["0xff", getAddress(from), salt, initCodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address;
  }
});

// node_modules/@ethersproject/abi/lib/coders/address.js
var require_address = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/address.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressCoder = void 0;
    var address_1 = require_lib7();
    var bytes_1 = require_lib2();
    var abstract_coder_1 = require_abstract_coder();
    var AddressCoder = function(_super) {
      __extends(AddressCoder2, _super);
      function AddressCoder2(localName) {
        return _super.call(this, "address", "address", localName, false) || this;
      }
      AddressCoder2.prototype.defaultValue = function() {
        return "0x0000000000000000000000000000000000000000";
      };
      AddressCoder2.prototype.encode = function(writer, value) {
        try {
          value = (0, address_1.getAddress)(value);
        } catch (error) {
          this._throwError(error.message, value);
        }
        return writer.writeValue(value);
      };
      AddressCoder2.prototype.decode = function(reader) {
        return (0, address_1.getAddress)((0, bytes_1.hexZeroPad)(reader.readValue().toHexString(), 20));
      };
      return AddressCoder2;
    }(abstract_coder_1.Coder);
    exports.AddressCoder = AddressCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/anonymous.js
var require_anonymous = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/anonymous.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var AnonymousCoder = function(_super) {
      __extends(AnonymousCoder2, _super);
      function AnonymousCoder2(coder) {
        var _this = _super.call(this, coder.name, coder.type, void 0, coder.dynamic) || this;
        _this.coder = coder;
        return _this;
      }
      AnonymousCoder2.prototype.defaultValue = function() {
        return this.coder.defaultValue();
      };
      AnonymousCoder2.prototype.encode = function(writer, value) {
        return this.coder.encode(writer, value);
      };
      AnonymousCoder2.prototype.decode = function(reader) {
        return this.coder.decode(reader);
      };
      return AnonymousCoder2;
    }(abstract_coder_1.Coder);
    exports.AnonymousCoder = AnonymousCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/array.js
var require_array = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/array.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayCoder = exports.unpack = exports.pack = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger = new logger_1.Logger(_version_1.version);
    var abstract_coder_1 = require_abstract_coder();
    var anonymous_1 = require_anonymous();
    function pack(writer, coders, values) {
      var arrayValues = null;
      if (Array.isArray(values)) {
        arrayValues = values;
      } else if (values && typeof values === "object") {
        var unique_1 = {};
        arrayValues = coders.map(function(coder) {
          var name = coder.localName;
          if (!name) {
            logger.throwError("cannot encode object for signature with missing names", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "values",
              coder,
              value: values
            });
          }
          if (unique_1[name]) {
            logger.throwError("cannot encode object for signature with duplicate names", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "values",
              coder,
              value: values
            });
          }
          unique_1[name] = true;
          return values[name];
        });
      } else {
        logger.throwArgumentError("invalid tuple value", "tuple", values);
      }
      if (coders.length !== arrayValues.length) {
        logger.throwArgumentError("types/value length mismatch", "tuple", values);
      }
      var staticWriter = new abstract_coder_1.Writer(writer.wordSize);
      var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);
      var updateFuncs = [];
      coders.forEach(function(coder, index) {
        var value = arrayValues[index];
        if (coder.dynamic) {
          var dynamicOffset_1 = dynamicWriter.length;
          coder.encode(dynamicWriter, value);
          var updateFunc_1 = staticWriter.writeUpdatableValue();
          updateFuncs.push(function(baseOffset) {
            updateFunc_1(baseOffset + dynamicOffset_1);
          });
        } else {
          coder.encode(staticWriter, value);
        }
      });
      updateFuncs.forEach(function(func) {
        func(staticWriter.length);
      });
      var length3 = writer.appendWriter(staticWriter);
      length3 += writer.appendWriter(dynamicWriter);
      return length3;
    }
    exports.pack = pack;
    function unpack(reader, coders) {
      var values = [];
      var baseReader = reader.subReader(0);
      coders.forEach(function(coder) {
        var value = null;
        if (coder.dynamic) {
          var offset = reader.readValue();
          var offsetReader = baseReader.subReader(offset.toNumber());
          try {
            value = coder.decode(offsetReader);
          } catch (error) {
            if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
              throw error;
            }
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
          }
        } else {
          try {
            value = coder.decode(reader);
          } catch (error) {
            if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
              throw error;
            }
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
          }
        }
        if (value != void 0) {
          values.push(value);
        }
      });
      var uniqueNames = coders.reduce(function(accum, coder) {
        var name = coder.localName;
        if (name) {
          if (!accum[name]) {
            accum[name] = 0;
          }
          accum[name]++;
        }
        return accum;
      }, {});
      coders.forEach(function(coder, index) {
        var name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
          return;
        }
        if (name === "length") {
          name = "_length";
        }
        if (values[name] != null) {
          return;
        }
        var value = values[index];
        if (value instanceof Error) {
          Object.defineProperty(values, name, {
            enumerable: true,
            get: function() {
              throw value;
            }
          });
        } else {
          values[name] = value;
        }
      });
      var _loop_1 = function(i2) {
        var value = values[i2];
        if (value instanceof Error) {
          Object.defineProperty(values, i2, {
            enumerable: true,
            get: function() {
              throw value;
            }
          });
        }
      };
      for (var i = 0; i < values.length; i++) {
        _loop_1(i);
      }
      return Object.freeze(values);
    }
    exports.unpack = unpack;
    var ArrayCoder = function(_super) {
      __extends(ArrayCoder2, _super);
      function ArrayCoder2(coder, length3, localName) {
        var _this = this;
        var type = coder.type + "[" + (length3 >= 0 ? length3 : "") + "]";
        var dynamic = length3 === -1 || coder.dynamic;
        _this = _super.call(this, "array", type, localName, dynamic) || this;
        _this.coder = coder;
        _this.length = length3;
        return _this;
      }
      ArrayCoder2.prototype.defaultValue = function() {
        var defaultChild = this.coder.defaultValue();
        var result = [];
        for (var i = 0; i < this.length; i++) {
          result.push(defaultChild);
        }
        return result;
      };
      ArrayCoder2.prototype.encode = function(writer, value) {
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        var count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        var coders = [];
        for (var i = 0; i < value.length; i++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      };
      ArrayCoder2.prototype.decode = function(reader) {
        var count = this.length;
        if (count === -1) {
          count = reader.readValue().toNumber();
          if (count * 32 > reader._data.length) {
            logger.throwError("insufficient data length", logger_1.Logger.errors.BUFFER_OVERRUN, {
              length: reader._data.length,
              count
            });
          }
        }
        var coders = [];
        for (var i = 0; i < count; i++) {
          coders.push(new anonymous_1.AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
      };
      return ArrayCoder2;
    }(abstract_coder_1.Coder);
    exports.ArrayCoder = ArrayCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/boolean.js
var require_boolean = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/boolean.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var BooleanCoder = function(_super) {
      __extends(BooleanCoder2, _super);
      function BooleanCoder2(localName) {
        return _super.call(this, "bool", "bool", localName, false) || this;
      }
      BooleanCoder2.prototype.defaultValue = function() {
        return false;
      };
      BooleanCoder2.prototype.encode = function(writer, value) {
        return writer.writeValue(value ? 1 : 0);
      };
      BooleanCoder2.prototype.decode = function(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
      };
      return BooleanCoder2;
    }(abstract_coder_1.Coder);
    exports.BooleanCoder = BooleanCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/bytes.js
var require_bytes = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/bytes.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesCoder = exports.DynamicBytesCoder = void 0;
    var bytes_1 = require_lib2();
    var abstract_coder_1 = require_abstract_coder();
    var DynamicBytesCoder = function(_super) {
      __extends(DynamicBytesCoder2, _super);
      function DynamicBytesCoder2(type, localName) {
        return _super.call(this, type, type, localName, true) || this;
      }
      DynamicBytesCoder2.prototype.defaultValue = function() {
        return "0x";
      };
      DynamicBytesCoder2.prototype.encode = function(writer, value) {
        value = (0, bytes_1.arrayify)(value);
        var length3 = writer.writeValue(value.length);
        length3 += writer.writeBytes(value);
        return length3;
      };
      DynamicBytesCoder2.prototype.decode = function(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
      };
      return DynamicBytesCoder2;
    }(abstract_coder_1.Coder);
    exports.DynamicBytesCoder = DynamicBytesCoder;
    var BytesCoder = function(_super) {
      __extends(BytesCoder2, _super);
      function BytesCoder2(localName) {
        return _super.call(this, "bytes", localName) || this;
      }
      BytesCoder2.prototype.decode = function(reader) {
        return reader.coerce(this.name, (0, bytes_1.hexlify)(_super.prototype.decode.call(this, reader)));
      };
      return BytesCoder2;
    }(DynamicBytesCoder);
    exports.BytesCoder = BytesCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/fixed-bytes.js
var require_fixed_bytes = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/fixed-bytes.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixedBytesCoder = void 0;
    var bytes_1 = require_lib2();
    var abstract_coder_1 = require_abstract_coder();
    var FixedBytesCoder = function(_super) {
      __extends(FixedBytesCoder2, _super);
      function FixedBytesCoder2(size, localName) {
        var _this = this;
        var name = "bytes" + String(size);
        _this = _super.call(this, name, name, localName, false) || this;
        _this.size = size;
        return _this;
      }
      FixedBytesCoder2.prototype.defaultValue = function() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      };
      FixedBytesCoder2.prototype.encode = function(writer, value) {
        var data = (0, bytes_1.arrayify)(value);
        if (data.length !== this.size) {
          this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
      };
      FixedBytesCoder2.prototype.decode = function(reader) {
        return reader.coerce(this.name, (0, bytes_1.hexlify)(reader.readBytes(this.size)));
      };
      return FixedBytesCoder2;
    }(abstract_coder_1.Coder);
    exports.FixedBytesCoder = FixedBytesCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/null.js
var require_null = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/null.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var NullCoder = function(_super) {
      __extends(NullCoder2, _super);
      function NullCoder2(localName) {
        return _super.call(this, "null", "", localName, false) || this;
      }
      NullCoder2.prototype.defaultValue = function() {
        return null;
      };
      NullCoder2.prototype.encode = function(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes([]);
      };
      NullCoder2.prototype.decode = function(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
      };
      return NullCoder2;
    }(abstract_coder_1.Coder);
    exports.NullCoder = NullCoder;
  }
});

// node_modules/@ethersproject/constants/lib/addresses.js
var require_addresses = __commonJS({
  "node_modules/@ethersproject/constants/lib/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressZero = void 0;
    exports.AddressZero = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib/bignumbers.js
var require_bignumbers = __commonJS({
  "node_modules/@ethersproject/constants/lib/bignumbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;
    var bignumber_1 = require_lib3();
    var NegativeOne = /* @__PURE__ */ bignumber_1.BigNumber.from(-1);
    exports.NegativeOne = NegativeOne;
    var Zero = /* @__PURE__ */ bignumber_1.BigNumber.from(0);
    exports.Zero = Zero;
    var One = /* @__PURE__ */ bignumber_1.BigNumber.from(1);
    exports.One = One;
    var Two = /* @__PURE__ */ bignumber_1.BigNumber.from(2);
    exports.Two = Two;
    var WeiPerEther = /* @__PURE__ */ bignumber_1.BigNumber.from("1000000000000000000");
    exports.WeiPerEther = WeiPerEther;
    var MaxUint256 = /* @__PURE__ */ bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MaxUint256 = MaxUint256;
    var MinInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
    exports.MinInt256 = MinInt256;
    var MaxInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MaxInt256 = MaxInt256;
  }
});

// node_modules/@ethersproject/constants/lib/hashes.js
var require_hashes = __commonJS({
  "node_modules/@ethersproject/constants/lib/hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashZero = void 0;
    exports.HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib/strings.js
var require_strings = __commonJS({
  "node_modules/@ethersproject/constants/lib/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherSymbol = void 0;
    exports.EtherSymbol = "\u039E";
  }
});

// node_modules/@ethersproject/constants/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@ethersproject/constants/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "AddressZero", { enumerable: true, get: function() {
      return addresses_1.AddressZero;
    } });
    var bignumbers_1 = require_bignumbers();
    Object.defineProperty(exports, "NegativeOne", { enumerable: true, get: function() {
      return bignumbers_1.NegativeOne;
    } });
    Object.defineProperty(exports, "Zero", { enumerable: true, get: function() {
      return bignumbers_1.Zero;
    } });
    Object.defineProperty(exports, "One", { enumerable: true, get: function() {
      return bignumbers_1.One;
    } });
    Object.defineProperty(exports, "Two", { enumerable: true, get: function() {
      return bignumbers_1.Two;
    } });
    Object.defineProperty(exports, "WeiPerEther", { enumerable: true, get: function() {
      return bignumbers_1.WeiPerEther;
    } });
    Object.defineProperty(exports, "MaxUint256", { enumerable: true, get: function() {
      return bignumbers_1.MaxUint256;
    } });
    Object.defineProperty(exports, "MinInt256", { enumerable: true, get: function() {
      return bignumbers_1.MinInt256;
    } });
    Object.defineProperty(exports, "MaxInt256", { enumerable: true, get: function() {
      return bignumbers_1.MaxInt256;
    } });
    var hashes_1 = require_hashes();
    Object.defineProperty(exports, "HashZero", { enumerable: true, get: function() {
      return hashes_1.HashZero;
    } });
    var strings_1 = require_strings();
    Object.defineProperty(exports, "EtherSymbol", { enumerable: true, get: function() {
      return strings_1.EtherSymbol;
    } });
  }
});

// node_modules/@ethersproject/abi/lib/coders/number.js
var require_number = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/number.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumberCoder = void 0;
    var bignumber_1 = require_lib3();
    var constants_1 = require_lib8();
    var abstract_coder_1 = require_abstract_coder();
    var NumberCoder = function(_super) {
      __extends(NumberCoder2, _super);
      function NumberCoder2(size, signed, localName) {
        var _this = this;
        var name = (signed ? "int" : "uint") + size * 8;
        _this = _super.call(this, name, name, localName, false) || this;
        _this.size = size;
        _this.signed = signed;
        return _this;
      }
      NumberCoder2.prototype.defaultValue = function() {
        return 0;
      };
      NumberCoder2.prototype.encode = function(writer, value) {
        var v = bignumber_1.BigNumber.from(value);
        var maxUintValue = constants_1.MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
          var bounds2 = maxUintValue.mask(this.size * 8 - 1);
          if (v.gt(bounds2) || v.lt(bounds2.add(constants_1.One).mul(constants_1.NegativeOne))) {
            this._throwError("value out-of-bounds", value);
          }
        } else if (v.lt(constants_1.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
          this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
          v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
      };
      NumberCoder2.prototype.decode = function(reader) {
        var value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
          value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
      };
      return NumberCoder2;
    }(abstract_coder_1.Coder);
    exports.NumberCoder = NumberCoder;
  }
});

// node_modules/@ethersproject/strings/lib/_version.js
var require_version8 = __commonJS({
  "node_modules/@ethersproject/strings/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "strings/5.7.0";
  }
});

// node_modules/@ethersproject/strings/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@ethersproject/strings/lib/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version8();
    var logger = new logger_1.Logger(_version_1.version);
    var UnicodeNormalizationForm;
    (function(UnicodeNormalizationForm2) {
      UnicodeNormalizationForm2["current"] = "";
      UnicodeNormalizationForm2["NFC"] = "NFC";
      UnicodeNormalizationForm2["NFD"] = "NFD";
      UnicodeNormalizationForm2["NFKC"] = "NFKC";
      UnicodeNormalizationForm2["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));
    var Utf8ErrorReason;
    (function(Utf8ErrorReason2) {
      Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason2["OVERRUN"] = "string overrun";
      Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason2["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));
    function errorFunc(reason, offset, bytes, output, badCodepoint) {
      return logger.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes);
    }
    function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
      if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        var i = 0;
        for (var o = offset + 1; o < bytes.length; o++) {
          if (bytes[o] >> 6 !== 2) {
            break;
          }
          i++;
        }
        return i;
      }
      if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
      }
      return 0;
    }
    function replaceFunc(reason, offset, bytes, output, badCodepoint) {
      if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
      }
      output.push(65533);
      return ignoreFunc(reason, offset, bytes, output, badCodepoint);
    }
    exports.Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
    function getUtf8CodePoints(bytes, onError) {
      if (onError == null) {
        onError = exports.Utf8ErrorFuncs.error;
      }
      bytes = (0, bytes_1.arrayify)(bytes);
      var result = [];
      var i = 0;
      while (i < bytes.length) {
        var c3 = bytes[i++];
        if (c3 >> 7 === 0) {
          result.push(c3);
          continue;
        }
        var extraLength = null;
        var overlongMask = null;
        if ((c3 & 224) === 192) {
          extraLength = 1;
          overlongMask = 127;
        } else if ((c3 & 240) === 224) {
          extraLength = 2;
          overlongMask = 2047;
        } else if ((c3 & 248) === 240) {
          extraLength = 3;
          overlongMask = 65535;
        } else {
          if ((c3 & 192) === 128) {
            i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
          } else {
            i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
          }
          continue;
        }
        if (i - 1 + extraLength >= bytes.length) {
          i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
          continue;
        }
        var res = c3 & (1 << 8 - extraLength - 1) - 1;
        for (var j = 0; j < extraLength; j++) {
          var nextChar = bytes[i];
          if ((nextChar & 192) != 128) {
            i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
            res = null;
            break;
          }
          ;
          res = res << 6 | nextChar & 63;
          i++;
        }
        if (res === null) {
          continue;
        }
        if (res > 1114111) {
          i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
          continue;
        }
        if (res >= 55296 && res <= 57343) {
          i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
          continue;
        }
        if (res <= overlongMask) {
          i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
          continue;
        }
        result.push(res);
      }
      return result;
    }
    function toUtf8Bytes(str, form) {
      if (form === void 0) {
        form = UnicodeNormalizationForm.current;
      }
      if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
      }
      var result = [];
      for (var i = 0; i < str.length; i++) {
        var c3 = str.charCodeAt(i);
        if (c3 < 128) {
          result.push(c3);
        } else if (c3 < 2048) {
          result.push(c3 >> 6 | 192);
          result.push(c3 & 63 | 128);
        } else if ((c3 & 64512) == 55296) {
          i++;
          var c22 = str.charCodeAt(i);
          if (i >= str.length || (c22 & 64512) !== 56320) {
            throw new Error("invalid utf-8 string");
          }
          var pair = 65536 + ((c3 & 1023) << 10) + (c22 & 1023);
          result.push(pair >> 18 | 240);
          result.push(pair >> 12 & 63 | 128);
          result.push(pair >> 6 & 63 | 128);
          result.push(pair & 63 | 128);
        } else {
          result.push(c3 >> 12 | 224);
          result.push(c3 >> 6 & 63 | 128);
          result.push(c3 & 63 | 128);
        }
      }
      return (0, bytes_1.arrayify)(result);
    }
    exports.toUtf8Bytes = toUtf8Bytes;
    function escapeChar(value) {
      var hex = "0000" + value.toString(16);
      return "\\u" + hex.substring(hex.length - 4);
    }
    function _toEscapedUtf8String(bytes, onError) {
      return '"' + getUtf8CodePoints(bytes, onError).map(function(codePoint) {
        if (codePoint < 256) {
          switch (codePoint) {
            case 8:
              return "\\b";
            case 9:
              return "\\t";
            case 10:
              return "\\n";
            case 13:
              return "\\r";
            case 34:
              return '\\"';
            case 92:
              return "\\\\";
          }
          if (codePoint >= 32 && codePoint < 127) {
            return String.fromCharCode(codePoint);
          }
        }
        if (codePoint <= 65535) {
          return escapeChar(codePoint);
        }
        codePoint -= 65536;
        return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
      }).join("") + '"';
    }
    exports._toEscapedUtf8String = _toEscapedUtf8String;
    function _toUtf8String(codePoints) {
      return codePoints.map(function(codePoint) {
        if (codePoint <= 65535) {
          return String.fromCharCode(codePoint);
        }
        codePoint -= 65536;
        return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
      }).join("");
    }
    exports._toUtf8String = _toUtf8String;
    function toUtf8String(bytes, onError) {
      return _toUtf8String(getUtf8CodePoints(bytes, onError));
    }
    exports.toUtf8String = toUtf8String;
    function toUtf8CodePoints(str, form) {
      if (form === void 0) {
        form = UnicodeNormalizationForm.current;
      }
      return getUtf8CodePoints(toUtf8Bytes(str, form));
    }
    exports.toUtf8CodePoints = toUtf8CodePoints;
  }
});

// node_modules/@ethersproject/strings/lib/bytes32.js
var require_bytes32 = __commonJS({
  "node_modules/@ethersproject/strings/lib/bytes32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseBytes32String = exports.formatBytes32String = void 0;
    var constants_1 = require_lib8();
    var bytes_1 = require_lib2();
    var utf8_1 = require_utf8();
    function formatBytes32String(text) {
      var bytes = (0, utf8_1.toUtf8Bytes)(text);
      if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
      }
      return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes, constants_1.HashZero]).slice(0, 32));
    }
    exports.formatBytes32String = formatBytes32String;
    function parseBytes32String(bytes) {
      var data = (0, bytes_1.arrayify)(bytes);
      if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
      }
      if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
      }
      var length3 = 31;
      while (data[length3 - 1] === 0) {
        length3--;
      }
      return (0, utf8_1.toUtf8String)(data.slice(0, length3));
    }
    exports.parseBytes32String = parseBytes32String;
  }
});

// node_modules/@ethersproject/strings/lib/idna.js
var require_idna = __commonJS({
  "node_modules/@ethersproject/strings/lib/idna.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = void 0;
    var utf8_1 = require_utf8();
    function bytes2(data) {
      if (data.length % 4 !== 0) {
        throw new Error("bad data");
      }
      var result = [];
      for (var i = 0; i < data.length; i += 4) {
        result.push(parseInt(data.substring(i, i + 4), 16));
      }
      return result;
    }
    function createTable(data, func) {
      if (!func) {
        func = function(value) {
          return [parseInt(value, 16)];
        };
      }
      var lo = 0;
      var result = {};
      data.split(",").forEach(function(pair) {
        var comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
      });
      return result;
    }
    function createRangeTable(data) {
      var hi = 0;
      return data.split(",").map(function(v) {
        var comps = v.split("-");
        if (comps.length === 1) {
          comps[1] = "0";
        } else if (comps[1] === "") {
          comps[1] = "1";
        }
        var lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo, h: hi };
      });
    }
    function matchMap(value, ranges) {
      var lo = 0;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        lo += range.l;
        if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
          if (range.e && range.e.indexOf(value - lo) !== -1) {
            continue;
          }
          return range;
        }
      }
      return null;
    }
    var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function(v) {
      return parseInt(v, 16);
    });
    var Table_B_2_ranges = [
      { h: 25, s: 32, l: 65 },
      { h: 30, s: 32, e: [23], l: 127 },
      { h: 54, s: 1, e: [48], l: 64, d: 2 },
      { h: 14, s: 1, l: 57, d: 2 },
      { h: 44, s: 1, l: 17, d: 2 },
      { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
      { h: 16, s: 1, l: 68, d: 2 },
      { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
      { h: 26, s: 32, e: [17], l: 435 },
      { h: 22, s: 1, l: 71, d: 2 },
      { h: 15, s: 80, l: 40 },
      { h: 31, s: 32, l: 16 },
      { h: 32, s: 1, l: 80, d: 2 },
      { h: 52, s: 1, l: 42, d: 2 },
      { h: 12, s: 1, l: 55, d: 2 },
      { h: 40, s: 1, e: [38], l: 15, d: 2 },
      { h: 14, s: 1, l: 48, d: 2 },
      { h: 37, s: 48, l: 49 },
      { h: 148, s: 1, l: 6351, d: 2 },
      { h: 88, s: 1, l: 160, d: 2 },
      { h: 15, s: 16, l: 704 },
      { h: 25, s: 26, l: 854 },
      { h: 25, s: 32, l: 55915 },
      { h: 37, s: 40, l: 1247 },
      { h: 25, s: -119711, l: 53248 },
      { h: 25, s: -119763, l: 52 },
      { h: 25, s: -119815, l: 52 },
      { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
      { h: 25, s: -119919, l: 52 },
      { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
      { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
      { h: 25, s: -120075, l: 52 },
      { h: 25, s: -120127, l: 52 },
      { h: 25, s: -120179, l: 52 },
      { h: 25, s: -120231, l: 52 },
      { h: 25, s: -120283, l: 52 },
      { h: 25, s: -120335, l: 52 },
      { h: 24, s: -119543, e: [17], l: 56 },
      { h: 24, s: -119601, e: [17], l: 58 },
      { h: 24, s: -119659, e: [17], l: 58 },
      { h: 24, s: -119717, e: [17], l: 58 },
      { h: 24, s: -119775, e: [17], l: 58 }
    ];
    var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
    var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
    function flatten(values) {
      return values.reduce(function(accum, value) {
        value.forEach(function(value2) {
          accum.push(value2);
        });
        return accum;
      }, []);
    }
    function _nameprepTableA1(codepoint) {
      return !!matchMap(codepoint, Table_A_1_ranges);
    }
    exports._nameprepTableA1 = _nameprepTableA1;
    function _nameprepTableB2(codepoint) {
      var range = matchMap(codepoint, Table_B_2_ranges);
      if (range) {
        return [codepoint + range.s];
      }
      var codes = Table_B_2_lut_abs[codepoint];
      if (codes) {
        return codes;
      }
      var shift = Table_B_2_lut_rel[codepoint];
      if (shift) {
        return [codepoint + shift[0]];
      }
      var complex = Table_B_2_complex[codepoint];
      if (complex) {
        return complex;
      }
      return null;
    }
    exports._nameprepTableB2 = _nameprepTableB2;
    function _nameprepTableC(codepoint) {
      return !!matchMap(codepoint, Table_C_ranges);
    }
    exports._nameprepTableC = _nameprepTableC;
    function nameprep(value) {
      if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
        return value.toLowerCase();
      }
      var codes = (0, utf8_1.toUtf8CodePoints)(value);
      codes = flatten(codes.map(function(code) {
        if (Table_B_1_flags.indexOf(code) >= 0) {
          return [];
        }
        if (code >= 65024 && code <= 65039) {
          return [];
        }
        var codesTableB2 = _nameprepTableB2(code);
        if (codesTableB2) {
          return codesTableB2;
        }
        return [code];
      }));
      codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);
      codes.forEach(function(code) {
        if (_nameprepTableC(code)) {
          throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }
      });
      codes.forEach(function(code) {
        if (_nameprepTableA1(code)) {
          throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        }
      });
      var name = (0, utf8_1._toUtf8String)(codes);
      if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
        throw new Error("invalid hyphen");
      }
      return name;
    }
    exports.nameprep = nameprep;
  }
});

// node_modules/@ethersproject/strings/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@ethersproject/strings/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = void 0;
    var bytes32_1 = require_bytes32();
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return bytes32_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return bytes32_1.parseBytes32String;
    } });
    var idna_1 = require_idna();
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return idna_1.nameprep;
    } });
    var utf8_1 = require_utf8();
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return utf8_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return utf8_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return utf8_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return utf8_1.toUtf8String;
    } });
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return utf8_1.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return utf8_1.Utf8ErrorFuncs;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return utf8_1.Utf8ErrorReason;
    } });
  }
});

// node_modules/@ethersproject/abi/lib/coders/string.js
var require_string = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/string.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringCoder = void 0;
    var strings_1 = require_lib9();
    var bytes_1 = require_bytes();
    var StringCoder = function(_super) {
      __extends(StringCoder2, _super);
      function StringCoder2(localName) {
        return _super.call(this, "string", localName) || this;
      }
      StringCoder2.prototype.defaultValue = function() {
        return "";
      };
      StringCoder2.prototype.encode = function(writer, value) {
        return _super.prototype.encode.call(this, writer, (0, strings_1.toUtf8Bytes)(value));
      };
      StringCoder2.prototype.decode = function(reader) {
        return (0, strings_1.toUtf8String)(_super.prototype.decode.call(this, reader));
      };
      return StringCoder2;
    }(bytes_1.DynamicBytesCoder);
    exports.StringCoder = StringCoder;
  }
});

// node_modules/@ethersproject/abi/lib/coders/tuple.js
var require_tuple = __commonJS({
  "node_modules/@ethersproject/abi/lib/coders/tuple.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleCoder = void 0;
    var abstract_coder_1 = require_abstract_coder();
    var array_1 = require_array();
    var TupleCoder = function(_super) {
      __extends(TupleCoder2, _super);
      function TupleCoder2(coders, localName) {
        var _this = this;
        var dynamic = false;
        var types = [];
        coders.forEach(function(coder) {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        var type = "tuple(" + types.join(",") + ")";
        _this = _super.call(this, "tuple", type, localName, dynamic) || this;
        _this.coders = coders;
        return _this;
      }
      TupleCoder2.prototype.defaultValue = function() {
        var values = [];
        this.coders.forEach(function(coder) {
          values.push(coder.defaultValue());
        });
        var uniqueNames = this.coders.reduce(function(accum, coder) {
          var name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        this.coders.forEach(function(coder, index) {
          var name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values[name] != null) {
            return;
          }
          values[name] = values[index];
        });
        return Object.freeze(values);
      };
      TupleCoder2.prototype.encode = function(writer, value) {
        return (0, array_1.pack)(writer, this.coders, value);
      };
      TupleCoder2.prototype.decode = function(reader) {
        return reader.coerce(this.name, (0, array_1.unpack)(reader, this.coders));
      };
      return TupleCoder2;
    }(abstract_coder_1.Coder);
    exports.TupleCoder = TupleCoder;
  }
});

// node_modules/@ethersproject/abi/lib/abi-coder.js
var require_abi_coder = __commonJS({
  "node_modules/@ethersproject/abi/lib/abi-coder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultAbiCoder = exports.AbiCoder = void 0;
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger = new logger_1.Logger(_version_1.version);
    var abstract_coder_1 = require_abstract_coder();
    var address_1 = require_address();
    var array_1 = require_array();
    var boolean_1 = require_boolean();
    var bytes_2 = require_bytes();
    var fixed_bytes_1 = require_fixed_bytes();
    var null_1 = require_null();
    var number_1 = require_number();
    var string_1 = require_string();
    var tuple_1 = require_tuple();
    var fragments_1 = require_fragments();
    var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    var AbiCoder = function() {
      function AbiCoder2(coerceFunc) {
        (0, properties_1.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
      }
      AbiCoder2.prototype._getCoder = function(param) {
        var _this = this;
        switch (param.baseType) {
          case "address":
            return new address_1.AddressCoder(param.name);
          case "bool":
            return new boolean_1.BooleanCoder(param.name);
          case "string":
            return new string_1.StringCoder(param.name);
          case "bytes":
            return new bytes_2.BytesCoder(param.name);
          case "array":
            return new array_1.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
          case "tuple":
            return new tuple_1.TupleCoder((param.components || []).map(function(component) {
              return _this._getCoder(component);
            }), param.name);
          case "":
            return new null_1.NullCoder(param.name);
        }
        var match = param.type.match(paramTypeNumber);
        if (match) {
          var size = parseInt(match[2] || "256");
          if (size === 0 || size > 256 || size % 8 !== 0) {
            logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
          }
          return new number_1.NumberCoder(size / 8, match[1] === "int", param.name);
        }
        match = param.type.match(paramTypeBytes);
        if (match) {
          var size = parseInt(match[1]);
          if (size === 0 || size > 32) {
            logger.throwArgumentError("invalid bytes length", "param", param);
          }
          return new fixed_bytes_1.FixedBytesCoder(size, param.name);
        }
        return logger.throwArgumentError("invalid type", "type", param.type);
      };
      AbiCoder2.prototype._getWordSize = function() {
        return 32;
      };
      AbiCoder2.prototype._getReader = function(data, allowLoose) {
        return new abstract_coder_1.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
      };
      AbiCoder2.prototype._getWriter = function() {
        return new abstract_coder_1.Writer(this._getWordSize());
      };
      AbiCoder2.prototype.getDefaultValue = function(types) {
        var _this = this;
        var coders = types.map(function(type) {
          return _this._getCoder(fragments_1.ParamType.from(type));
        });
        var coder = new tuple_1.TupleCoder(coders, "_");
        return coder.defaultValue();
      };
      AbiCoder2.prototype.encode = function(types, values) {
        var _this = this;
        if (types.length !== values.length) {
          logger.throwError("types/values length mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, {
            count: { types: types.length, values: values.length },
            value: { types, values }
          });
        }
        var coders = types.map(function(type) {
          return _this._getCoder(fragments_1.ParamType.from(type));
        });
        var coder = new tuple_1.TupleCoder(coders, "_");
        var writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
      };
      AbiCoder2.prototype.decode = function(types, data, loose) {
        var _this = this;
        var coders = types.map(function(type) {
          return _this._getCoder(fragments_1.ParamType.from(type));
        });
        var coder = new tuple_1.TupleCoder(coders, "_");
        return coder.decode(this._getReader((0, bytes_1.arrayify)(data), loose));
      };
      return AbiCoder2;
    }();
    exports.AbiCoder = AbiCoder;
    exports.defaultAbiCoder = new AbiCoder();
  }
});

// node_modules/@ethersproject/hash/lib/id.js
var require_id = __commonJS({
  "node_modules/@ethersproject/hash/lib/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id = void 0;
    var keccak256_1 = require_lib5();
    var strings_1 = require_lib9();
    function id(text) {
      return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));
    }
    exports.id = id;
  }
});

// node_modules/@ethersproject/hash/lib/_version.js
var require_version9 = __commonJS({
  "node_modules/@ethersproject/hash/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "hash/5.7.0";
  }
});

// node_modules/@ethersproject/base64/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/@ethersproject/base64/lib/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var bytes_1 = require_lib2();
    function decode2(textData) {
      return (0, bytes_1.arrayify)(new Uint8Array(Buffer.from(textData, "base64")));
    }
    exports.decode = decode2;
    function encode5(data) {
      return Buffer.from((0, bytes_1.arrayify)(data)).toString("base64");
    }
    exports.encode = encode5;
  }
});

// node_modules/@ethersproject/base64/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/@ethersproject/base64/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var base64_1 = require_base64();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return base64_1.decode;
    } });
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return base64_1.encode;
    } });
  }
});

// node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js
var require_decoder = __commonJS({
  "node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read_emoji_trie = exports.read_zero_terminated_array = exports.read_mapped_map = exports.read_member_array = exports.signed = exports.read_compressed_payload = exports.read_payload = exports.decode_arithmetic = void 0;
    function flat(array, depth) {
      if (depth == null) {
        depth = 1;
      }
      var result = [];
      var forEach2 = result.forEach;
      var flatDeep = function(arr, depth2) {
        forEach2.call(arr, function(val) {
          if (depth2 > 0 && Array.isArray(val)) {
            flatDeep(val, depth2 - 1);
          } else {
            result.push(val);
          }
        });
      };
      flatDeep(array, depth);
      return result;
    }
    function fromEntries(array) {
      var result = {};
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        result[value[0]] = value[1];
      }
      return result;
    }
    function decode_arithmetic(bytes) {
      var pos = 0;
      function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
      }
      var symbol_count = u16();
      var total = 1;
      var acc = [0, 1];
      for (var i = 1; i < symbol_count; i++) {
        acc.push(total += u16());
      }
      var skip = u16();
      var pos_payload = pos;
      pos += skip;
      var read_width = 0;
      var read_buffer = 0;
      function read_bit() {
        if (read_width == 0) {
          read_buffer = read_buffer << 8 | bytes[pos++];
          read_width = 8;
        }
        return read_buffer >> --read_width & 1;
      }
      var N = 31;
      var FULL = Math.pow(2, N);
      var HALF = FULL >>> 1;
      var QRTR = HALF >> 1;
      var MASK = FULL - 1;
      var register = 0;
      for (var i = 0; i < N; i++)
        register = register << 1 | read_bit();
      var symbols = [];
      var low = 0;
      var range = FULL;
      while (true) {
        var value = Math.floor(((register - low + 1) * total - 1) / range);
        var start = 0;
        var end = symbol_count;
        while (end - start > 1) {
          var mid = start + end >>> 1;
          if (value < acc[mid]) {
            end = mid;
          } else {
            start = mid;
          }
        }
        if (start == 0)
          break;
        symbols.push(start);
        var a = low + Math.floor(range * acc[start] / total);
        var b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a ^ b) & HALF) == 0) {
          register = register << 1 & MASK | read_bit();
          a = a << 1 & MASK;
          b = b << 1 & MASK | 1;
        }
        while (a & ~b & QRTR) {
          register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
          a = a << 1 ^ HALF;
          b = (b ^ HALF) << 1 | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
      }
      var offset = symbol_count - 4;
      return symbols.map(function(x) {
        switch (x - offset) {
          case 3:
            return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 2:
            return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 1:
            return offset + bytes[pos_payload++];
          default:
            return x - 1;
        }
      });
    }
    exports.decode_arithmetic = decode_arithmetic;
    function read_payload(v) {
      var pos = 0;
      return function() {
        return v[pos++];
      };
    }
    exports.read_payload = read_payload;
    function read_compressed_payload(bytes) {
      return read_payload(decode_arithmetic(bytes));
    }
    exports.read_compressed_payload = read_compressed_payload;
    function signed(i) {
      return i & 1 ? ~i >> 1 : i >> 1;
    }
    exports.signed = signed;
    function read_counts(n, next) {
      var v = Array(n);
      for (var i = 0; i < n; i++)
        v[i] = 1 + next();
      return v;
    }
    function read_ascending(n, next) {
      var v = Array(n);
      for (var i = 0, x = -1; i < n; i++)
        v[i] = x += 1 + next();
      return v;
    }
    function read_deltas(n, next) {
      var v = Array(n);
      for (var i = 0, x = 0; i < n; i++)
        v[i] = x += signed(next());
      return v;
    }
    function read_member_array(next, lookup) {
      var v = read_ascending(next(), next);
      var n = next();
      var vX = read_ascending(n, next);
      var vN = read_counts(n, next);
      for (var i = 0; i < n; i++) {
        for (var j = 0; j < vN[i]; j++) {
          v.push(vX[i] + j);
        }
      }
      return lookup ? v.map(function(x) {
        return lookup[x];
      }) : v;
    }
    exports.read_member_array = read_member_array;
    function read_mapped_map(next) {
      var ret = [];
      while (true) {
        var w = next();
        if (w == 0)
          break;
        ret.push(read_linear_table(w, next));
      }
      while (true) {
        var w = next() - 1;
        if (w < 0)
          break;
        ret.push(read_replacement_table(w, next));
      }
      return fromEntries(flat(ret));
    }
    exports.read_mapped_map = read_mapped_map;
    function read_zero_terminated_array(next) {
      var v = [];
      while (true) {
        var i = next();
        if (i == 0)
          break;
        v.push(i);
      }
      return v;
    }
    exports.read_zero_terminated_array = read_zero_terminated_array;
    function read_transposed(n, w, next) {
      var m = Array(n).fill(void 0).map(function() {
        return [];
      });
      for (var i = 0; i < w; i++) {
        read_deltas(n, next).forEach(function(x, j) {
          return m[j].push(x);
        });
      }
      return m;
    }
    function read_linear_table(w, next) {
      var dx = 1 + next();
      var dy = next();
      var vN = read_zero_terminated_array(next);
      var m = read_transposed(vN.length, 1 + w, next);
      return flat(m.map(function(v, i) {
        var x = v[0], ys = v.slice(1);
        return Array(vN[i]).fill(void 0).map(function(_, j) {
          var j_dy = j * dy;
          return [x + j * dx, ys.map(function(y) {
            return y + j_dy;
          })];
        });
      }));
    }
    function read_replacement_table(w, next) {
      var n = 1 + next();
      var m = read_transposed(n, 1 + w, next);
      return m.map(function(v) {
        return [v[0], v.slice(1)];
      });
    }
    function read_emoji_trie(next) {
      var sorted = read_member_array(next).sort(function(a, b) {
        return a - b;
      });
      return read2();
      function read2() {
        var branches = [];
        while (true) {
          var keys = read_member_array(next, sorted);
          if (keys.length == 0)
            break;
          branches.push({ set: new Set(keys), node: read2() });
        }
        branches.sort(function(a, b) {
          return b.set.size - a.set.size;
        });
        var temp = next();
        var valid = temp % 3;
        temp = temp / 3 | 0;
        var fe0f = !!(temp & 1);
        temp >>= 1;
        var save = temp == 1;
        var check = temp == 2;
        return { branches, valid, fe0f, save, check };
      }
    }
    exports.read_emoji_trie = read_emoji_trie;
  }
});

// node_modules/@ethersproject/hash/lib/ens-normalize/include.js
var require_include = __commonJS({
  "node_modules/@ethersproject/hash/lib/ens-normalize/include.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = void 0;
    var base64_1 = require_lib10();
    var decoder_js_1 = require_decoder();
    function getData() {
      return (0, decoder_js_1.read_compressed_payload)((0, base64_1.decode)("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
    }
    exports.getData = getData;
  }
});

// node_modules/@ethersproject/hash/lib/ens-normalize/lib.js
var require_lib11 = __commonJS({
  "node_modules/@ethersproject/hash/lib/ens-normalize/lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ens_normalize = exports.ens_normalize_post_check = void 0;
    var strings_1 = require_lib9();
    var include_js_1 = require_include();
    var r = (0, include_js_1.getData)();
    var decoder_js_1 = require_decoder();
    var VALID = new Set((0, decoder_js_1.read_member_array)(r));
    var IGNORED = new Set((0, decoder_js_1.read_member_array)(r));
    var MAPPED = (0, decoder_js_1.read_mapped_map)(r);
    var EMOJI_ROOT = (0, decoder_js_1.read_emoji_trie)(r);
    var HYPHEN = 45;
    var UNDERSCORE = 95;
    function explode_cp(name) {
      return (0, strings_1.toUtf8CodePoints)(name);
    }
    function filter_fe0f(cps) {
      return cps.filter(function(cp) {
        return cp != 65039;
      });
    }
    function ens_normalize_post_check(name) {
      for (var _i = 0, _a = name.split("."); _i < _a.length; _i++) {
        var label = _a[_i];
        var cps = explode_cp(label);
        try {
          for (var i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
            if (cps[i] !== UNDERSCORE) {
              throw new Error("underscore only allowed at start");
            }
          }
          if (cps.length >= 4 && cps.every(function(cp) {
            return cp < 128;
          }) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
            throw new Error("invalid label extension");
          }
        } catch (err) {
          throw new Error('Invalid label "' + label + '": ' + err.message);
        }
      }
      return name;
    }
    exports.ens_normalize_post_check = ens_normalize_post_check;
    function ens_normalize(name) {
      return ens_normalize_post_check(normalize(name, filter_fe0f));
    }
    exports.ens_normalize = ens_normalize;
    function normalize(name, emoji_filter) {
      var input = explode_cp(name).reverse();
      var output = [];
      while (input.length) {
        var emoji = consume_emoji_reversed(input);
        if (emoji) {
          output.push.apply(output, emoji_filter(emoji));
          continue;
        }
        var cp = input.pop();
        if (VALID.has(cp)) {
          output.push(cp);
          continue;
        }
        if (IGNORED.has(cp)) {
          continue;
        }
        var cps = MAPPED[cp];
        if (cps) {
          output.push.apply(output, cps);
          continue;
        }
        throw new Error("Disallowed codepoint: 0x" + cp.toString(16).toUpperCase());
      }
      return ens_normalize_post_check(nfc(String.fromCodePoint.apply(String, output)));
    }
    function nfc(s) {
      return s.normalize("NFC");
    }
    function consume_emoji_reversed(cps, eaten) {
      var _a;
      var node = EMOJI_ROOT;
      var emoji;
      var saved;
      var stack = [];
      var pos = cps.length;
      if (eaten)
        eaten.length = 0;
      var _loop_1 = function() {
        var cp = cps[--pos];
        node = (_a = node.branches.find(function(x) {
          return x.set.has(cp);
        })) === null || _a === void 0 ? void 0 : _a.node;
        if (!node)
          return "break";
        if (node.save) {
          saved = cp;
        } else if (node.check) {
          if (cp === saved)
            return "break";
        }
        stack.push(cp);
        if (node.fe0f) {
          stack.push(65039);
          if (pos > 0 && cps[pos - 1] == 65039)
            pos--;
        }
        if (node.valid) {
          emoji = stack.slice();
          if (node.valid == 2)
            emoji.splice(1, 1);
          if (eaten)
            eaten.push.apply(eaten, cps.slice(pos).reverse());
          cps.length = pos;
        }
      };
      while (pos) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
      return emoji;
    }
  }
});

// node_modules/@ethersproject/hash/lib/namehash.js
var require_namehash = __commonJS({
  "node_modules/@ethersproject/hash/lib/namehash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
    var bytes_1 = require_lib2();
    var strings_1 = require_lib9();
    var keccak256_1 = require_lib5();
    var logger_1 = require_lib();
    var _version_1 = require_version9();
    var logger = new logger_1.Logger(_version_1.version);
    var lib_1 = require_lib11();
    var Zeros = new Uint8Array(32);
    Zeros.fill(0);
    function checkComponent(comp) {
      if (comp.length === 0) {
        throw new Error("invalid ENS name; empty component");
      }
      return comp;
    }
    function ensNameSplit(name) {
      var bytes = (0, strings_1.toUtf8Bytes)((0, lib_1.ens_normalize)(name));
      var comps = [];
      if (name.length === 0) {
        return comps;
      }
      var last = 0;
      for (var i = 0; i < bytes.length; i++) {
        var d = bytes[i];
        if (d === 46) {
          comps.push(checkComponent(bytes.slice(last, i)));
          last = i + 1;
        }
      }
      if (last >= bytes.length) {
        throw new Error("invalid ENS name; empty component");
      }
      comps.push(checkComponent(bytes.slice(last)));
      return comps;
    }
    function ensNormalize(name) {
      return ensNameSplit(name).map(function(comp) {
        return (0, strings_1.toUtf8String)(comp);
      }).join(".");
    }
    exports.ensNormalize = ensNormalize;
    function isValidName(name) {
      try {
        return ensNameSplit(name).length !== 0;
      } catch (error) {
      }
      return false;
    }
    exports.isValidName = isValidName;
    function namehash(name) {
      if (typeof name !== "string") {
        logger.throwArgumentError("invalid ENS name; not a string", "name", name);
      }
      var result = Zeros;
      var comps = ensNameSplit(name);
      while (comps.length) {
        result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(comps.pop())]));
      }
      return (0, bytes_1.hexlify)(result);
    }
    exports.namehash = namehash;
    function dnsEncode(name) {
      return (0, bytes_1.hexlify)((0, bytes_1.concat)(ensNameSplit(name).map(function(comp) {
        if (comp.length > 63) {
          throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        }
        var bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
      }))) + "00";
    }
    exports.dnsEncode = dnsEncode;
  }
});

// node_modules/@ethersproject/hash/lib/message.js
var require_message = __commonJS({
  "node_modules/@ethersproject/hash/lib/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashMessage = exports.messagePrefix = void 0;
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var strings_1 = require_lib9();
    exports.messagePrefix = "Ethereum Signed Message:\n";
    function hashMessage(message) {
      if (typeof message === "string") {
        message = (0, strings_1.toUtf8Bytes)(message);
      }
      return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
        (0, strings_1.toUtf8Bytes)(exports.messagePrefix),
        (0, strings_1.toUtf8Bytes)(String(message.length)),
        message
      ]));
    }
    exports.hashMessage = hashMessage;
  }
});

// node_modules/@ethersproject/hash/lib/typed-data.js
var require_typed_data = __commonJS({
  "node_modules/@ethersproject/hash/lib/typed-data.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypedDataEncoder = void 0;
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version9();
    var logger = new logger_1.Logger(_version_1.version);
    var id_1 = require_id();
    var padding2 = new Uint8Array(32);
    padding2.fill(0);
    var NegativeOne = bignumber_1.BigNumber.from(-1);
    var Zero = bignumber_1.BigNumber.from(0);
    var One = bignumber_1.BigNumber.from(1);
    var MaxUint256 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    function hexPadRight(value) {
      var bytes = (0, bytes_1.arrayify)(value);
      var padOffset = bytes.length % 32;
      if (padOffset) {
        return (0, bytes_1.hexConcat)([bytes, padding2.slice(padOffset)]);
      }
      return (0, bytes_1.hexlify)(bytes);
    }
    var hexTrue = (0, bytes_1.hexZeroPad)(One.toHexString(), 32);
    var hexFalse = (0, bytes_1.hexZeroPad)(Zero.toHexString(), 32);
    var domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    var domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    function checkString(key) {
      return function(value) {
        if (typeof value !== "string") {
          logger.throwArgumentError("invalid domain value for " + JSON.stringify(key), "domain." + key, value);
        }
        return value;
      };
    }
    var domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(value) {
        try {
          return bignumber_1.BigNumber.from(value).toString();
        } catch (error) {
        }
        return logger.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", value);
      },
      verifyingContract: function(value) {
        try {
          return (0, address_1.getAddress)(value).toLowerCase();
        } catch (error) {
        }
        return logger.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", value);
      },
      salt: function(value) {
        try {
          var bytes = (0, bytes_1.arrayify)(value);
          if (bytes.length !== 32) {
            throw new Error("bad length");
          }
          return (0, bytes_1.hexlify)(bytes);
        } catch (error) {
        }
        return logger.throwArgumentError('invalid domain value "salt"', "domain.salt", value);
      }
    };
    function getBaseEncoder(type) {
      {
        var match = type.match(/^(u?)int(\d*)$/);
        if (match) {
          var signed = match[1] === "";
          var width = parseInt(match[2] || "256");
          if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
            logger.throwArgumentError("invalid numeric width", "type", type);
          }
          var boundsUpper_1 = MaxUint256.mask(signed ? width - 1 : width);
          var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;
          return function(value) {
            var v = bignumber_1.BigNumber.from(value);
            if (v.lt(boundsLower_1) || v.gt(boundsUpper_1)) {
              logger.throwArgumentError("value out-of-bounds for " + type, "value", value);
            }
            return (0, bytes_1.hexZeroPad)(v.toTwos(256).toHexString(), 32);
          };
        }
      }
      {
        var match = type.match(/^bytes(\d+)$/);
        if (match) {
          var width_1 = parseInt(match[1]);
          if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {
            logger.throwArgumentError("invalid bytes width", "type", type);
          }
          return function(value) {
            var bytes = (0, bytes_1.arrayify)(value);
            if (bytes.length !== width_1) {
              logger.throwArgumentError("invalid length for " + type, "value", value);
            }
            return hexPadRight(value);
          };
        }
      }
      switch (type) {
        case "address":
          return function(value) {
            return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);
          };
        case "bool":
          return function(value) {
            return !value ? hexFalse : hexTrue;
          };
        case "bytes":
          return function(value) {
            return (0, keccak256_1.keccak256)(value);
          };
        case "string":
          return function(value) {
            return (0, id_1.id)(value);
          };
      }
      return null;
    }
    function encodeType(name, fields) {
      return name + "(" + fields.map(function(_a) {
        var name2 = _a.name, type = _a.type;
        return type + " " + name2;
      }).join(",") + ")";
    }
    var TypedDataEncoder = function() {
      function TypedDataEncoder2(types) {
        (0, properties_1.defineReadOnly)(this, "types", Object.freeze((0, properties_1.deepCopy)(types)));
        (0, properties_1.defineReadOnly)(this, "_encoderCache", {});
        (0, properties_1.defineReadOnly)(this, "_types", {});
        var links = {};
        var parents = {};
        var subtypes = {};
        Object.keys(types).forEach(function(type) {
          links[type] = {};
          parents[type] = [];
          subtypes[type] = {};
        });
        var _loop_1 = function(name_12) {
          var uniqueNames = {};
          types[name_12].forEach(function(field) {
            if (uniqueNames[field.name]) {
              logger.throwArgumentError("duplicate variable name " + JSON.stringify(field.name) + " in " + JSON.stringify(name_12), "types", types);
            }
            uniqueNames[field.name] = true;
            var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
            if (baseType === name_12) {
              logger.throwArgumentError("circular type reference to " + JSON.stringify(baseType), "types", types);
            }
            var encoder = getBaseEncoder(baseType);
            if (encoder) {
              return;
            }
            if (!parents[baseType]) {
              logger.throwArgumentError("unknown type " + JSON.stringify(baseType), "types", types);
            }
            parents[baseType].push(name_12);
            links[name_12][baseType] = true;
          });
        };
        for (var name_1 in types) {
          _loop_1(name_1);
        }
        var primaryTypes = Object.keys(parents).filter(function(n) {
          return parents[n].length === 0;
        });
        if (primaryTypes.length === 0) {
          logger.throwArgumentError("missing primary type", "types", types);
        } else if (primaryTypes.length > 1) {
          logger.throwArgumentError("ambiguous primary types or unused types: " + primaryTypes.map(function(t) {
            return JSON.stringify(t);
          }).join(", "), "types", types);
        }
        (0, properties_1.defineReadOnly)(this, "primaryType", primaryTypes[0]);
        function checkCircular(type, found) {
          if (found[type]) {
            logger.throwArgumentError("circular type reference to " + JSON.stringify(type), "types", types);
          }
          found[type] = true;
          Object.keys(links[type]).forEach(function(child) {
            if (!parents[child]) {
              return;
            }
            checkCircular(child, found);
            Object.keys(found).forEach(function(subtype) {
              subtypes[subtype][child] = true;
            });
          });
          delete found[type];
        }
        checkCircular(this.primaryType, {});
        for (var name_2 in subtypes) {
          var st = Object.keys(subtypes[name_2]);
          st.sort();
          this._types[name_2] = encodeType(name_2, types[name_2]) + st.map(function(t) {
            return encodeType(t, types[t]);
          }).join("");
        }
      }
      TypedDataEncoder2.prototype.getEncoder = function(type) {
        var encoder = this._encoderCache[type];
        if (!encoder) {
          encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
      };
      TypedDataEncoder2.prototype._getEncoder = function(type) {
        var _this = this;
        {
          var encoder = getBaseEncoder(type);
          if (encoder) {
            return encoder;
          }
        }
        var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          var subtype_1 = match[1];
          var subEncoder_1 = this.getEncoder(subtype_1);
          var length_1 = parseInt(match[3]);
          return function(value) {
            if (length_1 >= 0 && value.length !== length_1) {
              logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            var result = value.map(subEncoder_1);
            if (_this._types[subtype_1]) {
              result = result.map(keccak256_1.keccak256);
            }
            return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));
          };
        }
        var fields = this.types[type];
        if (fields) {
          var encodedType_1 = (0, id_1.id)(this._types[type]);
          return function(value) {
            var values = fields.map(function(_a) {
              var name = _a.name, type2 = _a.type;
              var result = _this.getEncoder(type2)(value[name]);
              if (_this._types[type2]) {
                return (0, keccak256_1.keccak256)(result);
              }
              return result;
            });
            values.unshift(encodedType_1);
            return (0, bytes_1.hexConcat)(values);
          };
        }
        return logger.throwArgumentError("unknown type: " + type, "type", type);
      };
      TypedDataEncoder2.prototype.encodeType = function(name) {
        var result = this._types[name];
        if (!result) {
          logger.throwArgumentError("unknown type: " + JSON.stringify(name), "name", name);
        }
        return result;
      };
      TypedDataEncoder2.prototype.encodeData = function(type, value) {
        return this.getEncoder(type)(value);
      };
      TypedDataEncoder2.prototype.hashStruct = function(name, value) {
        return (0, keccak256_1.keccak256)(this.encodeData(name, value));
      };
      TypedDataEncoder2.prototype.encode = function(value) {
        return this.encodeData(this.primaryType, value);
      };
      TypedDataEncoder2.prototype.hash = function(value) {
        return this.hashStruct(this.primaryType, value);
      };
      TypedDataEncoder2.prototype._visit = function(type, value, callback) {
        var _this = this;
        {
          var encoder = getBaseEncoder(type);
          if (encoder) {
            return callback(type, value);
          }
        }
        var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          var subtype_2 = match[1];
          var length_2 = parseInt(match[3]);
          if (length_2 >= 0 && value.length !== length_2) {
            logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          return value.map(function(v) {
            return _this._visit(subtype_2, v, callback);
          });
        }
        var fields = this.types[type];
        if (fields) {
          return fields.reduce(function(accum, _a) {
            var name = _a.name, type2 = _a.type;
            accum[name] = _this._visit(type2, value[name], callback);
            return accum;
          }, {});
        }
        return logger.throwArgumentError("unknown type: " + type, "type", type);
      };
      TypedDataEncoder2.prototype.visit = function(value, callback) {
        return this._visit(this.primaryType, value, callback);
      };
      TypedDataEncoder2.from = function(types) {
        return new TypedDataEncoder2(types);
      };
      TypedDataEncoder2.getPrimaryType = function(types) {
        return TypedDataEncoder2.from(types).primaryType;
      };
      TypedDataEncoder2.hashStruct = function(name, types, value) {
        return TypedDataEncoder2.from(types).hashStruct(name, value);
      };
      TypedDataEncoder2.hashDomain = function(domain) {
        var domainFields = [];
        for (var name_3 in domain) {
          var type = domainFieldTypes[name_3];
          if (!type) {
            logger.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(name_3), "domain", domain);
          }
          domainFields.push({ name: name_3, type });
        }
        domainFields.sort(function(a, b) {
          return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder2.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
      };
      TypedDataEncoder2.encode = function(domain, types, value) {
        return (0, bytes_1.hexConcat)([
          "0x1901",
          TypedDataEncoder2.hashDomain(domain),
          TypedDataEncoder2.from(types).hash(value)
        ]);
      };
      TypedDataEncoder2.hash = function(domain, types, value) {
        return (0, keccak256_1.keccak256)(TypedDataEncoder2.encode(domain, types, value));
      };
      TypedDataEncoder2.resolveNames = function(domain, types, value, resolveName) {
        return __awaiter(this, void 0, void 0, function() {
          var ensCache, encoder, _a, _b, _i, name_4, _c, _d;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                domain = (0, properties_1.shallowCopy)(domain);
                ensCache = {};
                if (domain.verifyingContract && !(0, bytes_1.isHexString)(domain.verifyingContract, 20)) {
                  ensCache[domain.verifyingContract] = "0x";
                }
                encoder = TypedDataEncoder2.from(types);
                encoder.visit(value, function(type, value2) {
                  if (type === "address" && !(0, bytes_1.isHexString)(value2, 20)) {
                    ensCache[value2] = "0x";
                  }
                  return value2;
                });
                _a = [];
                for (_b in ensCache)
                  _a.push(_b);
                _i = 0;
                _e.label = 1;
              case 1:
                if (!(_i < _a.length))
                  return [3, 4];
                name_4 = _a[_i];
                _c = ensCache;
                _d = name_4;
                return [4, resolveName(name_4)];
              case 2:
                _c[_d] = _e.sent();
                _e.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                  domain.verifyingContract = ensCache[domain.verifyingContract];
                }
                value = encoder.visit(value, function(type, value2) {
                  if (type === "address" && ensCache[value2]) {
                    return ensCache[value2];
                  }
                  return value2;
                });
                return [2, { domain, value }];
            }
          });
        });
      };
      TypedDataEncoder2.getPayload = function(domain, types, value) {
        TypedDataEncoder2.hashDomain(domain);
        var domainValues = {};
        var domainTypes = [];
        domainFieldNames.forEach(function(name) {
          var value2 = domain[name];
          if (value2 == null) {
            return;
          }
          domainValues[name] = domainChecks[name](value2);
          domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        var encoder = TypedDataEncoder2.from(types);
        var typesWithDomain = (0, properties_1.shallowCopy)(types);
        if (typesWithDomain.EIP712Domain) {
          logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        } else {
          typesWithDomain.EIP712Domain = domainTypes;
        }
        encoder.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder.primaryType,
          message: encoder.visit(value, function(type, value2) {
            if (type.match(/^bytes(\d*)/)) {
              return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value2));
            }
            if (type.match(/^u?int/)) {
              return bignumber_1.BigNumber.from(value2).toString();
            }
            switch (type) {
              case "address":
                return value2.toLowerCase();
              case "bool":
                return !!value2;
              case "string":
                if (typeof value2 !== "string") {
                  logger.throwArgumentError("invalid string", "value", value2);
                }
                return value2;
            }
            return logger.throwArgumentError("unsupported type", "type", type);
          })
        };
      };
      return TypedDataEncoder2;
    }();
    exports.TypedDataEncoder = TypedDataEncoder;
  }
});

// node_modules/@ethersproject/hash/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@ethersproject/hash/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.ensNormalize = exports.isValidName = exports.namehash = exports.dnsEncode = exports.id = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return id_1.id;
    } });
    var namehash_1 = require_namehash();
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return namehash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return namehash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_1.namehash;
    } });
    var message_1 = require_message();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return message_1.hashMessage;
    } });
    Object.defineProperty(exports, "messagePrefix", { enumerable: true, get: function() {
      return message_1.messagePrefix;
    } });
    var namehash_2 = require_namehash();
    Object.defineProperty(exports, "ensNormalize", { enumerable: true, get: function() {
      return namehash_2.ensNormalize;
    } });
    var typed_data_1 = require_typed_data();
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return typed_data_1.TypedDataEncoder;
    } });
  }
});

// node_modules/@ethersproject/abi/lib/interface.js
var require_interface = __commonJS({
  "node_modules/@ethersproject/abi/lib/interface.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = void 0;
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var hash_1 = require_lib12();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var abi_coder_1 = require_abi_coder();
    var abstract_coder_1 = require_abstract_coder();
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abstract_coder_1.checkResultErrors;
    } });
    var fragments_1 = require_fragments();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger = new logger_1.Logger(_version_1.version);
    var LogDescription = function(_super) {
      __extends(LogDescription2, _super);
      function LogDescription2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return LogDescription2;
    }(properties_1.Description);
    exports.LogDescription = LogDescription;
    var TransactionDescription = function(_super) {
      __extends(TransactionDescription2, _super);
      function TransactionDescription2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return TransactionDescription2;
    }(properties_1.Description);
    exports.TransactionDescription = TransactionDescription;
    var ErrorDescription = function(_super) {
      __extends(ErrorDescription2, _super);
      function ErrorDescription2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return ErrorDescription2;
    }(properties_1.Description);
    exports.ErrorDescription = ErrorDescription;
    var Indexed = function(_super) {
      __extends(Indexed2, _super);
      function Indexed2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Indexed2.isIndexed = function(value) {
        return !!(value && value._isIndexed);
      };
      return Indexed2;
    }(properties_1.Description);
    exports.Indexed = Indexed;
    var BuiltinErrors = {
      "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
      "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
    };
    function wrapAccessError(property, error) {
      var wrap = new Error("deferred error during ABI decoding triggered accessing " + property);
      wrap.error = error;
      return wrap;
    }
    var Interface = function() {
      function Interface2(fragments) {
        var _newTarget = this.constructor;
        var _this = this;
        var abi3 = [];
        if (typeof fragments === "string") {
          abi3 = JSON.parse(fragments);
        } else {
          abi3 = fragments;
        }
        (0, properties_1.defineReadOnly)(this, "fragments", abi3.map(function(fragment) {
          return fragments_1.Fragment.from(fragment);
        }).filter(function(fragment) {
          return fragment != null;
        }));
        (0, properties_1.defineReadOnly)(this, "_abiCoder", (0, properties_1.getStatic)(_newTarget, "getAbiCoder")());
        (0, properties_1.defineReadOnly)(this, "functions", {});
        (0, properties_1.defineReadOnly)(this, "errors", {});
        (0, properties_1.defineReadOnly)(this, "events", {});
        (0, properties_1.defineReadOnly)(this, "structs", {});
        this.fragments.forEach(function(fragment) {
          var bucket = null;
          switch (fragment.type) {
            case "constructor":
              if (_this.deploy) {
                logger.warn("duplicate definition - constructor");
                return;
              }
              (0, properties_1.defineReadOnly)(_this, "deploy", fragment);
              return;
            case "function":
              bucket = _this.functions;
              break;
            case "event":
              bucket = _this.events;
              break;
            case "error":
              bucket = _this.errors;
              break;
            default:
              return;
          }
          var signature = fragment.format();
          if (bucket[signature]) {
            logger.warn("duplicate definition - " + signature);
            return;
          }
          bucket[signature] = fragment;
        });
        if (!this.deploy) {
          (0, properties_1.defineReadOnly)(this, "deploy", fragments_1.ConstructorFragment.from({
            payable: false,
            type: "constructor"
          }));
        }
        (0, properties_1.defineReadOnly)(this, "_isInterface", true);
      }
      Interface2.prototype.format = function(format) {
        if (!format) {
          format = fragments_1.FormatTypes.full;
        }
        if (format === fragments_1.FormatTypes.sighash) {
          logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        var abi3 = this.fragments.map(function(fragment) {
          return fragment.format(format);
        });
        if (format === fragments_1.FormatTypes.json) {
          return JSON.stringify(abi3.map(function(j) {
            return JSON.parse(j);
          }));
        }
        return abi3;
      };
      Interface2.getAbiCoder = function() {
        return abi_coder_1.defaultAbiCoder;
      };
      Interface2.getAddress = function(address) {
        return (0, address_1.getAddress)(address);
      };
      Interface2.getSighash = function(fragment) {
        return (0, bytes_1.hexDataSlice)((0, hash_1.id)(fragment.format()), 0, 4);
      };
      Interface2.getEventTopic = function(eventFragment) {
        return (0, hash_1.id)(eventFragment.format());
      };
      Interface2.prototype.getFunction = function(nameOrSignatureOrSighash) {
        if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
          for (var name_1 in this.functions) {
            if (nameOrSignatureOrSighash === this.getSighash(name_1)) {
              return this.functions[name_1];
            }
          }
          logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          var name_2 = nameOrSignatureOrSighash.trim();
          var matching = Object.keys(this.functions).filter(function(f) {
            return f.split("(")[0] === name_2;
          });
          if (matching.length === 0) {
            logger.throwArgumentError("no matching function", "name", name_2);
          } else if (matching.length > 1) {
            logger.throwArgumentError("multiple matching functions", "name", name_2);
          }
          return this.functions[matching[0]];
        }
        var result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
      };
      Interface2.prototype.getEvent = function(nameOrSignatureOrTopic) {
        if ((0, bytes_1.isHexString)(nameOrSignatureOrTopic)) {
          var topichash = nameOrSignatureOrTopic.toLowerCase();
          for (var name_3 in this.events) {
            if (topichash === this.getEventTopic(name_3)) {
              return this.events[name_3];
            }
          }
          logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
          var name_4 = nameOrSignatureOrTopic.trim();
          var matching = Object.keys(this.events).filter(function(f) {
            return f.split("(")[0] === name_4;
          });
          if (matching.length === 0) {
            logger.throwArgumentError("no matching event", "name", name_4);
          } else if (matching.length > 1) {
            logger.throwArgumentError("multiple matching events", "name", name_4);
          }
          return this.events[matching[0]];
        }
        var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
          logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
      };
      Interface2.prototype.getError = function(nameOrSignatureOrSighash) {
        if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
          var getSighash = (0, properties_1.getStatic)(this.constructor, "getSighash");
          for (var name_5 in this.errors) {
            var error = this.errors[name_5];
            if (nameOrSignatureOrSighash === getSighash(error)) {
              return this.errors[name_5];
            }
          }
          logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          var name_6 = nameOrSignatureOrSighash.trim();
          var matching = Object.keys(this.errors).filter(function(f) {
            return f.split("(")[0] === name_6;
          });
          if (matching.length === 0) {
            logger.throwArgumentError("no matching error", "name", name_6);
          } else if (matching.length > 1) {
            logger.throwArgumentError("multiple matching errors", "name", name_6);
          }
          return this.errors[matching[0]];
        }
        var result = this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
      };
      Interface2.prototype.getSighash = function(fragment) {
        if (typeof fragment === "string") {
          try {
            fragment = this.getFunction(fragment);
          } catch (error) {
            try {
              fragment = this.getError(fragment);
            } catch (_) {
              throw error;
            }
          }
        }
        return (0, properties_1.getStatic)(this.constructor, "getSighash")(fragment);
      };
      Interface2.prototype.getEventTopic = function(eventFragment) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        return (0, properties_1.getStatic)(this.constructor, "getEventTopic")(eventFragment);
      };
      Interface2.prototype._decodeParams = function(params, data) {
        return this._abiCoder.decode(params, data);
      };
      Interface2.prototype._encodeParams = function(params, values) {
        return this._abiCoder.encode(params, values);
      };
      Interface2.prototype.encodeDeploy = function(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
      };
      Interface2.prototype.decodeErrorResult = function(fragment, data) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        var bytes = (0, bytes_1.arrayify)(data);
        if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
          logger.throwArgumentError("data signature does not match error " + fragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
      };
      Interface2.prototype.encodeErrorResult = function(fragment, values) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        return (0, bytes_1.hexlify)((0, bytes_1.concat)([
          this.getSighash(fragment),
          this._encodeParams(fragment.inputs, values || [])
        ]));
      };
      Interface2.prototype.decodeFunctionData = function(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        var bytes = (0, bytes_1.arrayify)(data);
        if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
          logger.throwArgumentError("data signature does not match function " + functionFragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
      };
      Interface2.prototype.encodeFunctionData = function(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return (0, bytes_1.hexlify)((0, bytes_1.concat)([
          this.getSighash(functionFragment),
          this._encodeParams(functionFragment.inputs, values || [])
        ]));
      };
      Interface2.prototype.decodeFunctionResult = function(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        var bytes = (0, bytes_1.arrayify)(data);
        var reason = null;
        var message = "";
        var errorArgs = null;
        var errorName = null;
        var errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(functionFragment.outputs, bytes);
            } catch (error2) {
            }
            break;
          case 4: {
            var selector = (0, bytes_1.hexlify)(bytes.slice(0, 4));
            var builtin = BuiltinErrors[selector];
            if (builtin) {
              errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
              errorName = builtin.name;
              errorSignature = builtin.signature;
              if (builtin.reason) {
                reason = errorArgs[0];
              }
              if (errorName === "Error") {
                message = "; VM Exception while processing transaction: reverted with reason string " + JSON.stringify(errorArgs[0]);
              } else if (errorName === "Panic") {
                message = "; VM Exception while processing transaction: reverted with panic code " + errorArgs[0];
              }
            } else {
              try {
                var error = this.getError(selector);
                errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                errorName = error.name;
                errorSignature = error.format();
              } catch (error2) {
              }
            }
            break;
          }
        }
        return logger.throwError("call revert exception" + message, logger_1.Logger.errors.CALL_EXCEPTION, {
          method: functionFragment.format(),
          data: (0, bytes_1.hexlify)(data),
          errorArgs,
          errorName,
          errorSignature,
          reason
        });
      };
      Interface2.prototype.encodeFunctionResult = function(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return (0, bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
      };
      Interface2.prototype.encodeFilterTopics = function(eventFragment, values) {
        var _this = this;
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
          logger.throwError("too many arguments for " + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
          });
        }
        var topics = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        var encodeTopic = function(param, value) {
          if (param.type === "string") {
            return (0, hash_1.id)(value);
          } else if (param.type === "bytes") {
            return (0, keccak256_1.keccak256)((0, bytes_1.hexlify)(value));
          }
          if (param.type === "bool" && typeof value === "boolean") {
            value = value ? "0x01" : "0x00";
          }
          if (param.type.match(/^u?int/)) {
            value = bignumber_1.BigNumber.from(value).toHexString();
          }
          if (param.type === "address") {
            _this._abiCoder.encode(["address"], [value]);
          }
          return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
        };
        values.forEach(function(value, index) {
          var param = eventFragment.inputs[index];
          if (!param.indexed) {
            if (value != null) {
              logger.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            }
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            logger.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map(function(value2) {
              return encodeTopic(param, value2);
            }));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      };
      Interface2.prototype.encodeEventLog = function(eventFragment, values) {
        var _this = this;
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        var topics = [];
        var dataTypes = [];
        var dataValues = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
          logger.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach(function(param, index) {
          var value = values[index];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push((0, hash_1.id)(value));
            } else if (param.type === "bytes") {
              topics.push((0, keccak256_1.keccak256)(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(_this._abiCoder.encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: this._abiCoder.encode(dataTypes, dataValues),
          topics
        };
      };
      Interface2.prototype.decodeEventLog = function(eventFragment, data, topics) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
          var topicHash = this.getEventTopic(eventFragment);
          if (!(0, bytes_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
            logger.throwError("fragment/topic mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
          }
          topics = topics.slice(1);
        }
        var indexed = [];
        var nonIndexed = [];
        var dynamic = [];
        eventFragment.inputs.forEach(function(param, index) {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(fragments_1.ParamType.fromObject({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        var resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, bytes_1.concat)(topics)) : null;
        var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        var result = [];
        var nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach(function(param, index) {
          if (param.indexed) {
            if (resultIndexed == null) {
              result[index] = new Indexed({ _isIndexed: true, hash: null });
            } else if (dynamic[index]) {
              result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
            } else {
              try {
                result[index] = resultIndexed[indexedIndex++];
              } catch (error) {
                result[index] = error;
              }
            }
          } else {
            try {
              result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
          if (param.name && result[param.name] == null) {
            var value_1 = result[index];
            if (value_1 instanceof Error) {
              Object.defineProperty(result, param.name, {
                enumerable: true,
                get: function() {
                  throw wrapAccessError("property " + JSON.stringify(param.name), value_1);
                }
              });
            } else {
              result[param.name] = value_1;
            }
          }
        });
        var _loop_1 = function(i2) {
          var value = result[i2];
          if (value instanceof Error) {
            Object.defineProperty(result, i2, {
              enumerable: true,
              get: function() {
                throw wrapAccessError("index " + i2, value);
              }
            });
          }
        };
        for (var i = 0; i < result.length; i++) {
          _loop_1(i);
        }
        return Object.freeze(result);
      };
      Interface2.prototype.parseTransaction = function(tx) {
        var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new TransactionDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
          functionFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment),
          value: bignumber_1.BigNumber.from(tx.value || "0")
        });
      };
      Interface2.prototype.parseLog = function(log) {
        var fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription({
          eventFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          topic: this.getEventTopic(fragment),
          args: this.decodeEventLog(fragment, log.data, log.topics)
        });
      };
      Interface2.prototype.parseError = function(data) {
        var hexData = (0, bytes_1.hexlify)(data);
        var fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new ErrorDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
          errorFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment)
        });
      };
      Interface2.isInterface = function(value) {
        return !!(value && value._isInterface);
      };
      return Interface2;
    }();
    exports.Interface = Interface;
  }
});

// node_modules/@ethersproject/abi/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/@ethersproject/abi/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = exports.Indexed = exports.Interface = exports.defaultAbiCoder = exports.AbiCoder = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = void 0;
    var fragments_1 = require_fragments();
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return fragments_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return fragments_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return fragments_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return fragments_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return fragments_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return fragments_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return fragments_1.ParamType;
    } });
    var abi_coder_1 = require_abi_coder();
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_coder_1.AbiCoder;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_coder_1.defaultAbiCoder;
    } });
    var interface_1 = require_interface();
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return interface_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return interface_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return interface_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return interface_1.LogDescription;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return interface_1.TransactionDescription;
    } });
  }
});

// node_modules/@ethersproject/abstract-provider/lib/_version.js
var require_version10 = __commonJS({
  "node_modules/@ethersproject/abstract-provider/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abstract-provider/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-provider/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/@ethersproject/abstract-provider/lib/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Provider = exports.TransactionOrderForkEvent = exports.TransactionForkEvent = exports.BlockForkEvent = exports.ForkEvent = void 0;
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version10();
    var logger = new logger_1.Logger(_version_1.version);
    var ForkEvent = function(_super) {
      __extends(ForkEvent2, _super);
      function ForkEvent2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ForkEvent2.isForkEvent = function(value) {
        return !!(value && value._isForkEvent);
      };
      return ForkEvent2;
    }(properties_1.Description);
    exports.ForkEvent = ForkEvent;
    var BlockForkEvent = function(_super) {
      __extends(BlockForkEvent2, _super);
      function BlockForkEvent2(blockHash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(blockHash, 32)) {
          logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        }
        _this = _super.call(this, {
          _isForkEvent: true,
          _isBlockForkEvent: true,
          expiry: expiry || 0,
          blockHash
        }) || this;
        return _this;
      }
      return BlockForkEvent2;
    }(ForkEvent);
    exports.BlockForkEvent = BlockForkEvent;
    var TransactionForkEvent = function(_super) {
      __extends(TransactionForkEvent2, _super);
      function TransactionForkEvent2(hash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(hash, 32)) {
          logger.throwArgumentError("invalid transaction hash", "hash", hash);
        }
        _this = _super.call(this, {
          _isForkEvent: true,
          _isTransactionForkEvent: true,
          expiry: expiry || 0,
          hash
        }) || this;
        return _this;
      }
      return TransactionForkEvent2;
    }(ForkEvent);
    exports.TransactionForkEvent = TransactionForkEvent;
    var TransactionOrderForkEvent = function(_super) {
      __extends(TransactionOrderForkEvent2, _super);
      function TransactionOrderForkEvent2(beforeHash, afterHash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(beforeHash, 32)) {
          logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        }
        if (!(0, bytes_1.isHexString)(afterHash, 32)) {
          logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        }
        _this = _super.call(this, {
          _isForkEvent: true,
          _isTransactionOrderForkEvent: true,
          expiry: expiry || 0,
          beforeHash,
          afterHash
        }) || this;
        return _this;
      }
      return TransactionOrderForkEvent2;
    }(ForkEvent);
    exports.TransactionOrderForkEvent = TransactionOrderForkEvent;
    var Provider = function() {
      function Provider2() {
        var _newTarget = this.constructor;
        logger.checkAbstract(_newTarget, Provider2);
        (0, properties_1.defineReadOnly)(this, "_isProvider", true);
      }
      Provider2.prototype.getFeeData = function() {
        return __awaiter(this, void 0, void 0, function() {
          var _a, block, gasPrice, lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, (0, properties_1.resolveProperties)({
                  block: this.getBlock("latest"),
                  gasPrice: this.getGasPrice().catch(function(error) {
                    return null;
                  })
                })];
              case 1:
                _a = _b.sent(), block = _a.block, gasPrice = _a.gasPrice;
                lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
                if (block && block.baseFeePerGas) {
                  lastBaseFeePerGas = block.baseFeePerGas;
                  maxPriorityFeePerGas = bignumber_1.BigNumber.from("1500000000");
                  maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
                }
                return [2, { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice }];
            }
          });
        });
      };
      Provider2.prototype.addListener = function(eventName, listener) {
        return this.on(eventName, listener);
      };
      Provider2.prototype.removeListener = function(eventName, listener) {
        return this.off(eventName, listener);
      };
      Provider2.isProvider = function(value) {
        return !!(value && value._isProvider);
      };
      return Provider2;
    }();
    exports.Provider = Provider;
  }
});

// node_modules/@ethersproject/abstract-signer/lib/_version.js
var require_version11 = __commonJS({
  "node_modules/@ethersproject/abstract-signer/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abstract-signer/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-signer/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/@ethersproject/abstract-signer/lib/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoidSigner = exports.Signer = void 0;
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version11();
    var logger = new logger_1.Logger(_version_1.version);
    var allowedTransactionKeys = [
      "accessList",
      "ccipReadEnabled",
      "chainId",
      "customData",
      "data",
      "from",
      "gasLimit",
      "gasPrice",
      "maxFeePerGas",
      "maxPriorityFeePerGas",
      "nonce",
      "to",
      "type",
      "value"
    ];
    var forwardErrors = [
      logger_1.Logger.errors.INSUFFICIENT_FUNDS,
      logger_1.Logger.errors.NONCE_EXPIRED,
      logger_1.Logger.errors.REPLACEMENT_UNDERPRICED
    ];
    var Signer2 = function() {
      function Signer3() {
        var _newTarget = this.constructor;
        logger.checkAbstract(_newTarget, Signer3);
        (0, properties_1.defineReadOnly)(this, "_isSigner", true);
      }
      Signer3.prototype.getBalance = function(blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getBalance");
                return [4, this.provider.getBalance(this.getAddress(), blockTag)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.getTransactionCount = function(blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getTransactionCount");
                return [4, this.provider.getTransactionCount(this.getAddress(), blockTag)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.estimateGas = function(transaction) {
        return __awaiter(this, void 0, void 0, function() {
          var tx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("estimateGas");
                return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
              case 1:
                tx = _a.sent();
                return [4, this.provider.estimateGas(tx)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.call = function(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          var tx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("call");
                return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
              case 1:
                tx = _a.sent();
                return [4, this.provider.call(tx, blockTag)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.sendTransaction = function(transaction) {
        return __awaiter(this, void 0, void 0, function() {
          var tx, signedTx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("sendTransaction");
                return [4, this.populateTransaction(transaction)];
              case 1:
                tx = _a.sent();
                return [4, this.signTransaction(tx)];
              case 2:
                signedTx = _a.sent();
                return [4, this.provider.sendTransaction(signedTx)];
              case 3:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.getChainId = function() {
        return __awaiter(this, void 0, void 0, function() {
          var network;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getChainId");
                return [4, this.provider.getNetwork()];
              case 1:
                network = _a.sent();
                return [2, network.chainId];
            }
          });
        });
      };
      Signer3.prototype.getGasPrice = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getGasPrice");
                return [4, this.provider.getGasPrice()];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.getFeeData = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getFeeData");
                return [4, this.provider.getFeeData()];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.resolveName = function(name) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("resolveName");
                return [4, this.provider.resolveName(name)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype.checkTransaction = function(transaction) {
        for (var key in transaction) {
          if (allowedTransactionKeys.indexOf(key) === -1) {
            logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
          }
        }
        var tx = (0, properties_1.shallowCopy)(transaction);
        if (tx.from == null) {
          tx.from = this.getAddress();
        } else {
          tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
          ]).then(function(result) {
            if (result[0].toLowerCase() !== result[1].toLowerCase()) {
              logger.throwArgumentError("from address mismatch", "transaction", transaction);
            }
            return result[0];
          });
        }
        return tx;
      };
      Signer3.prototype.populateTransaction = function(transaction) {
        return __awaiter(this, void 0, void 0, function() {
          var tx, hasEip1559, feeData, gasPrice;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
              case 1:
                tx = _a.sent();
                if (tx.to != null) {
                  tx.to = Promise.resolve(tx.to).then(function(to) {
                    return __awaiter(_this, void 0, void 0, function() {
                      var address;
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            if (to == null) {
                              return [2, null];
                            }
                            return [4, this.resolveName(to)];
                          case 1:
                            address = _a2.sent();
                            if (address == null) {
                              logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                            }
                            return [2, address];
                        }
                      });
                    });
                  });
                  tx.to.catch(function(error) {
                  });
                }
                hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
                if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                  logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
                } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                  logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
                }
                if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)))
                  return [3, 2];
                tx.type = 2;
                return [3, 5];
              case 2:
                if (!(tx.type === 0 || tx.type === 1))
                  return [3, 3];
                if (tx.gasPrice == null) {
                  tx.gasPrice = this.getGasPrice();
                }
                return [3, 5];
              case 3:
                return [4, this.getFeeData()];
              case 4:
                feeData = _a.sent();
                if (tx.type == null) {
                  if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                    tx.type = 2;
                    if (tx.gasPrice != null) {
                      gasPrice = tx.gasPrice;
                      delete tx.gasPrice;
                      tx.maxFeePerGas = gasPrice;
                      tx.maxPriorityFeePerGas = gasPrice;
                    } else {
                      if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                      }
                      if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                      }
                    }
                  } else if (feeData.gasPrice != null) {
                    if (hasEip1559) {
                      logger.throwError("network does not support EIP-1559", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "populateTransaction"
                      });
                    }
                    if (tx.gasPrice == null) {
                      tx.gasPrice = feeData.gasPrice;
                    }
                    tx.type = 0;
                  } else {
                    logger.throwError("failed to get consistent fee data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                      operation: "signer.getFeeData"
                    });
                  }
                } else if (tx.type === 2) {
                  if (tx.maxFeePerGas == null) {
                    tx.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (tx.maxPriorityFeePerGas == null) {
                    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
                _a.label = 5;
              case 5:
                if (tx.nonce == null) {
                  tx.nonce = this.getTransactionCount("pending");
                }
                if (tx.gasLimit == null) {
                  tx.gasLimit = this.estimateGas(tx).catch(function(error) {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                      throw error;
                    }
                    return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                      error,
                      tx
                    });
                  });
                }
                if (tx.chainId == null) {
                  tx.chainId = this.getChainId();
                } else {
                  tx.chainId = Promise.all([
                    Promise.resolve(tx.chainId),
                    this.getChainId()
                  ]).then(function(results) {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                      logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }
                    return results[0];
                  });
                }
                return [4, (0, properties_1.resolveProperties)(tx)];
              case 6:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer3.prototype._checkProvider = function(operation) {
        if (!this.provider) {
          logger.throwError("missing provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
          });
        }
      };
      Signer3.isSigner = function(value) {
        return !!(value && value._isSigner);
      };
      return Signer3;
    }();
    exports.Signer = Signer2;
    var VoidSigner = function(_super) {
      __extends(VoidSigner2, _super);
      function VoidSigner2(address, provider) {
        var _this = _super.call(this) || this;
        (0, properties_1.defineReadOnly)(_this, "address", address);
        (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
        return _this;
      }
      VoidSigner2.prototype.getAddress = function() {
        return Promise.resolve(this.address);
      };
      VoidSigner2.prototype._fail = function(message, operation) {
        return Promise.resolve().then(function() {
          logger.throwError(message, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation });
        });
      };
      VoidSigner2.prototype.signMessage = function(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
      };
      VoidSigner2.prototype.signTransaction = function(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
      };
      VoidSigner2.prototype._signTypedData = function(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
      };
      VoidSigner2.prototype.connect = function(provider) {
        return new VoidSigner2(this.address, provider);
      };
      return VoidSigner2;
    }(Signer2);
    exports.VoidSigner = VoidSigner;
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports, module2) {
    (function(module3, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base2, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base2, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base2, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base2 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base2, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN.prototype._initArray = function _initArray(number, base2, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c3 = string.charCodeAt(index);
        if (c3 >= 65 && c3 <= 70) {
          return c3 - 55;
        } else if (c3 >= 97 && c3 <= 102) {
          return c3 - 87;
        } else {
          return c3 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c3 = str.charCodeAt(i) - 48;
          r *= mul;
          if (c3 >= 49) {
            r += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r += c3 - 17 + 10;
          } else {
            r += c3;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base2);
          for (i = 0; i < mod; i++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString3(base2, padding2) {
        base2 = base2 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r = c3.modn(groupBase).toString(base2);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON2() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length3) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length3);
      };
      BN.prototype.toArray = function toArray2(endian, length3) {
        return this.toArrayLike(Array, endian, length3);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
        var byteLength = this.byteLength();
        var reqLength = length3 || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c3 !== 0) {
          o[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c3 = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c3 | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c3 = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c3, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c3 = b.redSqr();
          t = t.redMul(c3);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c3).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c3 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c3).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module2) {
    module2.exports = assert2;
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert2.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c3 = msg.charCodeAt(i);
          var hi = c3 >> 8;
          var lo = c3 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray2;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode5(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z = (ws >> 1) - mod;
          else
            z = mod;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module2) {
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto = require("crypto");
        if (typeof crypto.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert2 = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert2(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert2(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          null,
          null,
          points[b]
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert2(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert2(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode5(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn2();
    var inherits2 = require_inherits();
    var Base = require_base();
    var assert2 = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits2(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c22 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c22.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c22.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits2(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON2() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c3 = this.y.redSub(p.y);
      if (c3.cmpn(0) !== 0)
        c3 = c3.redMul(this.x.redSub(p.x).redInvm());
      var nx = c3.redSqr().redISub(this.x).redISub(p.x);
      var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c3 = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c3.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits2(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c3.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c3.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c3 = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c3);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c3.redIAdd(c3);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c3.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c3.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module2) {
    "use strict";
    var BN = require_bn2();
    var inherits2 = require_inherits();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits2(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits2(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c3 = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c3.redMul(bb.redAdd(this.curve.a24.redMul(c3)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c3 = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c3.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c3 = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c3);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c3);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn2();
    var inherits2 = require_inherits();
    var Base = require_base();
    var assert2 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits2(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits2(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c3 = this.z.redSqr();
      c3 = c3.redIAdd(c3);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c3);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c3 = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c3);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c3).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c3).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c3.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c3.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c3 = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c3);
      var g = d.redAdd(c3);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c3 = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c3).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c3).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c3)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c3));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert2 = require_minimalistic_assert();
    var inherits2 = require_inherits();
    exports.inherits = inherits2;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c3 = msg.charCodeAt(i);
            if (c3 < 128) {
              res[p++] = c3;
            } else if (c3 < 2048) {
              res[p++] = c3 >> 6 | 192;
              res[p++] = c3 & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c3 = 65536 + ((c3 & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c3 >> 18 | 240;
              res[p++] = c3 >> 12 & 63 | 128;
              res[p++] = c3 >> 6 & 63 | 128;
              res[p++] = c3 & 63 | 128;
            } else {
              res[p++] = c3 >> 12 | 224;
              res[p++] = c3 >> 6 & 63 | 128;
              res[p++] = c3 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports.toArray = toArray2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert2(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b, c3) {
      return a + b + c3 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c3, d) {
      return a + b + c3 + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c3, d, e) {
      return a + b + c3 + d + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var assert2 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert2(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad2() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c3 = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c3, d), e, W[i], sha1_K[s]);
        e = d;
        d = c3;
        c3 = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c3);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert2 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c3 = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert2(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c3));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c3;
        c3 = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c3);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var assert2 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert2(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module2) {
    "use strict";
    var utils = require_utils3();
    var assert2 = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert2(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash = exports;
    hash.utils = require_utils3();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module2) {
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module2) {
    "use strict";
    var hash = require_hash();
    var utils = require_utils();
    var assert2 = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert2(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert2(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert2(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert2 = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert2(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module2) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert2 = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert2(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert2((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert2(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert2(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module2) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils2();
    var assert2 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert2(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module2) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils2();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert2(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/@ethersproject/signing-key/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/@ethersproject/signing-key/lib/elliptic.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EC = void 0;
    var elliptic_1 = __importDefault(require_elliptic());
    var EC = elliptic_1.default.ec;
    exports.EC = EC;
  }
});

// node_modules/@ethersproject/signing-key/lib/_version.js
var require_version12 = __commonJS({
  "node_modules/@ethersproject/signing-key/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "signing-key/5.7.0";
  }
});

// node_modules/@ethersproject/signing-key/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/@ethersproject/signing-key/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;
    var elliptic_1 = require_elliptic2();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version12();
    var logger = new logger_1.Logger(_version_1.version);
    var _curve = null;
    function getCurve() {
      if (!_curve) {
        _curve = new elliptic_1.EC("secp256k1");
      }
      return _curve;
    }
    var SigningKey = function() {
      function SigningKey2(privateKey) {
        (0, properties_1.defineReadOnly)(this, "curve", "secp256k1");
        (0, properties_1.defineReadOnly)(this, "privateKey", (0, bytes_1.hexlify)(privateKey));
        if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {
          logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        (0, properties_1.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        (0, properties_1.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        (0, properties_1.defineReadOnly)(this, "_isSigningKey", true);
      }
      SigningKey2.prototype._addPoint = function(other) {
        var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));
        var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
      };
      SigningKey2.prototype.signDigest = function(digest) {
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        var digestBytes = (0, bytes_1.arrayify)(digest);
        if (digestBytes.length !== 32) {
          logger.throwArgumentError("bad digest length", "digest", digest);
        }
        var signature = keyPair.sign(digestBytes, { canonical: true });
        return (0, bytes_1.splitSignature)({
          recoveryParam: signature.recoveryParam,
          r: (0, bytes_1.hexZeroPad)("0x" + signature.r.toString(16), 32),
          s: (0, bytes_1.hexZeroPad)("0x" + signature.s.toString(16), 32)
        });
      };
      SigningKey2.prototype.computeSharedSecret = function(otherKey) {
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey(otherKey)));
        return (0, bytes_1.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
      };
      SigningKey2.isSigningKey = function(value) {
        return !!(value && value._isSigningKey);
      };
      return SigningKey2;
    }();
    exports.SigningKey = SigningKey;
    function recoverPublicKey(digest, signature) {
      var sig = (0, bytes_1.splitSignature)(signature);
      var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };
      return "0x" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function computePublicKey(key, compressed) {
      var bytes = (0, bytes_1.arrayify)(key);
      if (bytes.length === 32) {
        var signingKey = new SigningKey(bytes);
        if (compressed) {
          return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }
        return signingKey.publicKey;
      } else if (bytes.length === 33) {
        if (compressed) {
          return (0, bytes_1.hexlify)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
      } else if (bytes.length === 65) {
        if (!compressed) {
          return (0, bytes_1.hexlify)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
      }
      return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
    }
    exports.computePublicKey = computePublicKey;
  }
});

// node_modules/@ethersproject/transactions/lib/_version.js
var require_version13 = __commonJS({
  "node_modules/@ethersproject/transactions/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "transactions/5.7.0";
  }
});

// node_modules/@ethersproject/transactions/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/@ethersproject/transactions/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.serialize = exports.accessListify = exports.recoverAddress = exports.computeAddress = exports.TransactionTypes = void 0;
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var constants_1 = require_lib8();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var RLP = __importStar(require_lib6());
    var signing_key_1 = require_lib16();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger = new logger_1.Logger(_version_1.version);
    var TransactionTypes;
    (function(TransactionTypes2) {
      TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
      TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
      TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
    })(TransactionTypes = exports.TransactionTypes || (exports.TransactionTypes = {}));
    function handleAddress(value) {
      if (value === "0x") {
        return null;
      }
      return (0, address_1.getAddress)(value);
    }
    function handleNumber(value) {
      if (value === "0x") {
        return constants_1.Zero;
      }
      return bignumber_1.BigNumber.from(value);
    }
    var transactionFields = [
      { name: "nonce", maxLength: 32, numeric: true },
      { name: "gasPrice", maxLength: 32, numeric: true },
      { name: "gasLimit", maxLength: 32, numeric: true },
      { name: "to", length: 20 },
      { name: "value", maxLength: 32, numeric: true },
      { name: "data" }
    ];
    var allowedTransactionKeys = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      type: true,
      value: true
    };
    function computeAddress(key) {
      var publicKey = (0, signing_key_1.computePublicKey)(key);
      return (0, address_1.getAddress)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.hexDataSlice)(publicKey, 1)), 12));
    }
    exports.computeAddress = computeAddress;
    function recoverAddress(digest, signature) {
      return computeAddress((0, signing_key_1.recoverPublicKey)((0, bytes_1.arrayify)(digest), signature));
    }
    exports.recoverAddress = recoverAddress;
    function formatNumber(value, name) {
      var result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());
      if (result.length > 32) {
        logger.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
      }
      return result;
    }
    function accessSetify(addr, storageKeys) {
      return {
        address: (0, address_1.getAddress)(addr),
        storageKeys: (storageKeys || []).map(function(storageKey, index) {
          if ((0, bytes_1.hexDataLength)(storageKey) !== 32) {
            logger.throwArgumentError("invalid access list storageKey", "accessList[" + addr + ":" + index + "]", storageKey);
          }
          return storageKey.toLowerCase();
        })
      };
    }
    function accessListify(value) {
      if (Array.isArray(value)) {
        return value.map(function(set, index) {
          if (Array.isArray(set)) {
            if (set.length > 2) {
              logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", "value[" + index + "]", set);
            }
            return accessSetify(set[0], set[1]);
          }
          return accessSetify(set.address, set.storageKeys);
        });
      }
      var result = Object.keys(value).map(function(addr) {
        var storageKeys = value[addr].reduce(function(accum, storageKey) {
          accum[storageKey] = true;
          return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
      });
      result.sort(function(a, b) {
        return a.address.localeCompare(b.address);
      });
      return result;
    }
    exports.accessListify = accessListify;
    function formatAccessList(value) {
      return accessListify(value).map(function(set) {
        return [set.address, set.storageKeys];
      });
    }
    function _serializeEip1559(transaction, signature) {
      if (transaction.gasPrice != null) {
        var gasPrice = bignumber_1.BigNumber.from(transaction.gasPrice);
        var maxFeePerGas = bignumber_1.BigNumber.from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
          logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice,
            maxFeePerGas
          });
        }
      }
      var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
      ];
      if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
      }
      return (0, bytes_1.hexConcat)(["0x02", RLP.encode(fields)]);
    }
    function _serializeEip2930(transaction, signature) {
      var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
      ];
      if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
      }
      return (0, bytes_1.hexConcat)(["0x01", RLP.encode(fields)]);
    }
    function _serialize(transaction, signature) {
      (0, properties_1.checkProperties)(transaction, allowedTransactionKeys);
      var raw = [];
      transactionFields.forEach(function(fieldInfo) {
        var value = transaction[fieldInfo.name] || [];
        var options = {};
        if (fieldInfo.numeric) {
          options.hexPad = "left";
        }
        value = (0, bytes_1.arrayify)((0, bytes_1.hexlify)(value, options));
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
          logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
        if (fieldInfo.maxLength) {
          value = (0, bytes_1.stripZeros)(value);
          if (value.length > fieldInfo.maxLength) {
            logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
          }
        }
        raw.push((0, bytes_1.hexlify)(value));
      });
      var chainId = 0;
      if (transaction.chainId != null) {
        chainId = transaction.chainId;
        if (typeof chainId !== "number") {
          logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
      } else if (signature && !(0, bytes_1.isBytesLike)(signature) && signature.v > 28) {
        chainId = Math.floor((signature.v - 35) / 2);
      }
      if (chainId !== 0) {
        raw.push((0, bytes_1.hexlify)(chainId));
        raw.push("0x");
        raw.push("0x");
      }
      if (!signature) {
        return RLP.encode(raw);
      }
      var sig = (0, bytes_1.splitSignature)(signature);
      var v = 27 + sig.recoveryParam;
      if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        if (sig.v > 28 && sig.v !== v) {
          logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
      } else if (sig.v !== v) {
        logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
      }
      raw.push((0, bytes_1.hexlify)(v));
      raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.r)));
      raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.s)));
      return RLP.encode(raw);
    }
    function serialize3(transaction, signature) {
      if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
          logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
      }
      switch (transaction.type) {
        case 1:
          return _serializeEip2930(transaction, signature);
        case 2:
          return _serializeEip1559(transaction, signature);
        default:
          break;
      }
      return logger.throwError("unsupported transaction type: " + transaction.type, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
      });
    }
    exports.serialize = serialize3;
    function _parseEipSignature(tx, fields, serialize4) {
      try {
        var recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
          throw new Error("bad recid");
        }
        tx.v = recid;
      } catch (error) {
        logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
      }
      tx.r = (0, bytes_1.hexZeroPad)(fields[1], 32);
      tx.s = (0, bytes_1.hexZeroPad)(fields[2], 32);
      try {
        var digest = (0, keccak256_1.keccak256)(serialize4(tx));
        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
      } catch (error) {
      }
    }
    function _parseEip1559(payload) {
      var transaction = RLP.decode(payload.slice(1));
      if (transaction.length !== 9 && transaction.length !== 12) {
        logger.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, bytes_1.hexlify)(payload));
      }
      var maxPriorityFeePerGas = handleNumber(transaction[2]);
      var maxFeePerGas = handleNumber(transaction[3]);
      var tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas,
        maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8])
      };
      if (transaction.length === 9) {
        return tx;
      }
      tx.hash = (0, keccak256_1.keccak256)(payload);
      _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
      return tx;
    }
    function _parseEip2930(payload) {
      var transaction = RLP.decode(payload.slice(1));
      if (transaction.length !== 8 && transaction.length !== 11) {
        logger.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, bytes_1.hexlify)(payload));
      }
      var tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
      };
      if (transaction.length === 8) {
        return tx;
      }
      tx.hash = (0, keccak256_1.keccak256)(payload);
      _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
      return tx;
    }
    function _parse(rawTransaction) {
      var transaction = RLP.decode(rawTransaction);
      if (transaction.length !== 9 && transaction.length !== 6) {
        logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
      }
      var tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
      };
      if (transaction.length === 6) {
        return tx;
      }
      try {
        tx.v = bignumber_1.BigNumber.from(transaction[6]).toNumber();
      } catch (error) {
        return tx;
      }
      tx.r = (0, bytes_1.hexZeroPad)(transaction[7], 32);
      tx.s = (0, bytes_1.hexZeroPad)(transaction[8], 32);
      if (bignumber_1.BigNumber.from(tx.r).isZero() && bignumber_1.BigNumber.from(tx.s).isZero()) {
        tx.chainId = tx.v;
        tx.v = 0;
      } else {
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
          tx.chainId = 0;
        }
        var recoveryParam = tx.v - 27;
        var raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
          raw.push((0, bytes_1.hexlify)(tx.chainId));
          raw.push("0x");
          raw.push("0x");
          recoveryParam -= tx.chainId * 2 + 8;
        }
        var digest = (0, keccak256_1.keccak256)(RLP.encode(raw));
        try {
          tx.from = recoverAddress(digest, { r: (0, bytes_1.hexlify)(tx.r), s: (0, bytes_1.hexlify)(tx.s), recoveryParam });
        } catch (error) {
        }
        tx.hash = (0, keccak256_1.keccak256)(rawTransaction);
      }
      tx.type = null;
      return tx;
    }
    function parse2(rawTransaction) {
      var payload = (0, bytes_1.arrayify)(rawTransaction);
      if (payload[0] > 127) {
        return _parse(payload);
      }
      switch (payload[0]) {
        case 1:
          return _parseEip2930(payload);
        case 2:
          return _parseEip1559(payload);
        default:
          break;
      }
      return logger.throwError("unsupported transaction type: " + payload[0], logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
      });
    }
    exports.parse = parse2;
  }
});

// node_modules/@ethersproject/contracts/lib/_version.js
var require_version14 = __commonJS({
  "node_modules/@ethersproject/contracts/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "contracts/5.7.0";
  }
});

// node_modules/@ethersproject/contracts/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/@ethersproject/contracts/lib/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;
    var abi_1 = require_lib13();
    var abstract_provider_1 = require_lib14();
    var abstract_signer_1 = require_lib15();
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var transactions_1 = require_lib17();
    var logger_1 = require_lib();
    var _version_1 = require_version14();
    var logger = new logger_1.Logger(_version_1.version);
    var allowedTransactionKeys = {
      chainId: true,
      data: true,
      from: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true,
      customData: true,
      ccipReadEnabled: true
    };
    function resolveName(resolver, nameOrPromise) {
      return __awaiter(this, void 0, void 0, function() {
        var name, address;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, nameOrPromise];
            case 1:
              name = _a.sent();
              if (typeof name !== "string") {
                logger.throwArgumentError("invalid address or ENS name", "name", name);
              }
              try {
                return [2, (0, address_1.getAddress)(name)];
              } catch (error) {
              }
              if (!resolver) {
                logger.throwError("a provider or signer is needed to resolve ENS names", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "resolveName"
                });
              }
              return [4, resolver.resolveName(name)];
            case 2:
              address = _a.sent();
              if (address == null) {
                logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
              }
              return [2, address];
          }
        });
      });
    }
    function resolveAddresses(resolver, value, paramType) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!Array.isArray(paramType))
                return [3, 2];
              return [4, Promise.all(paramType.map(function(paramType2, index) {
                return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
              }))];
            case 1:
              return [2, _a.sent()];
            case 2:
              if (!(paramType.type === "address"))
                return [3, 4];
              return [4, resolveName(resolver, value)];
            case 3:
              return [2, _a.sent()];
            case 4:
              if (!(paramType.type === "tuple"))
                return [3, 6];
              return [4, resolveAddresses(resolver, value, paramType.components)];
            case 5:
              return [2, _a.sent()];
            case 6:
              if (!(paramType.baseType === "array"))
                return [3, 8];
              if (!Array.isArray(value)) {
                return [2, Promise.reject(logger.makeError("invalid value for array", logger_1.Logger.errors.INVALID_ARGUMENT, {
                  argument: "value",
                  value
                }))];
              }
              return [4, Promise.all(value.map(function(v) {
                return resolveAddresses(resolver, v, paramType.arrayChildren);
              }))];
            case 7:
              return [2, _a.sent()];
            case 8:
              return [2, value];
          }
        });
      });
    }
    function populateTransaction(contract, fragment, args) {
      return __awaiter(this, void 0, void 0, function() {
        var overrides, resolved, data, tx, ro, intrinsic, bytes, i, roValue, leftovers;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              overrides = {};
              if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
                overrides = (0, properties_1.shallowCopy)(args.pop());
              }
              logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
              if (contract.signer) {
                if (overrides.from) {
                  overrides.from = (0, properties_1.resolveProperties)({
                    override: resolveName(contract.signer, overrides.from),
                    signer: contract.signer.getAddress()
                  }).then(function(check) {
                    return __awaiter(_this, void 0, void 0, function() {
                      return __generator(this, function(_a2) {
                        if ((0, address_1.getAddress)(check.signer) !== check.override) {
                          logger.throwError("Contract with a Signer cannot override from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "overrides.from"
                          });
                        }
                        return [2, check.override];
                      });
                    });
                  });
                } else {
                  overrides.from = contract.signer.getAddress();
                }
              } else if (overrides.from) {
                overrides.from = resolveName(contract.provider, overrides.from);
              }
              return [4, (0, properties_1.resolveProperties)({
                args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
                address: contract.resolvedAddress,
                overrides: (0, properties_1.resolveProperties)(overrides) || {}
              })];
            case 1:
              resolved = _a.sent();
              data = contract.interface.encodeFunctionData(fragment, resolved.args);
              tx = {
                data,
                to: resolved.address
              };
              ro = resolved.overrides;
              if (ro.nonce != null) {
                tx.nonce = bignumber_1.BigNumber.from(ro.nonce).toNumber();
              }
              if (ro.gasLimit != null) {
                tx.gasLimit = bignumber_1.BigNumber.from(ro.gasLimit);
              }
              if (ro.gasPrice != null) {
                tx.gasPrice = bignumber_1.BigNumber.from(ro.gasPrice);
              }
              if (ro.maxFeePerGas != null) {
                tx.maxFeePerGas = bignumber_1.BigNumber.from(ro.maxFeePerGas);
              }
              if (ro.maxPriorityFeePerGas != null) {
                tx.maxPriorityFeePerGas = bignumber_1.BigNumber.from(ro.maxPriorityFeePerGas);
              }
              if (ro.from != null) {
                tx.from = ro.from;
              }
              if (ro.type != null) {
                tx.type = ro.type;
              }
              if (ro.accessList != null) {
                tx.accessList = (0, transactions_1.accessListify)(ro.accessList);
              }
              if (tx.gasLimit == null && fragment.gas != null) {
                intrinsic = 21e3;
                bytes = (0, bytes_1.arrayify)(data);
                for (i = 0; i < bytes.length; i++) {
                  intrinsic += 4;
                  if (bytes[i]) {
                    intrinsic += 64;
                  }
                }
                tx.gasLimit = bignumber_1.BigNumber.from(fragment.gas).add(intrinsic);
              }
              if (ro.value) {
                roValue = bignumber_1.BigNumber.from(ro.value);
                if (!roValue.isZero() && !fragment.payable) {
                  logger.throwError("non-payable method cannot override value", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: overrides.value
                  });
                }
                tx.value = roValue;
              }
              if (ro.customData) {
                tx.customData = (0, properties_1.shallowCopy)(ro.customData);
              }
              if (ro.ccipReadEnabled) {
                tx.ccipReadEnabled = !!ro.ccipReadEnabled;
              }
              delete overrides.nonce;
              delete overrides.gasLimit;
              delete overrides.gasPrice;
              delete overrides.from;
              delete overrides.value;
              delete overrides.type;
              delete overrides.accessList;
              delete overrides.maxFeePerGas;
              delete overrides.maxPriorityFeePerGas;
              delete overrides.customData;
              delete overrides.ccipReadEnabled;
              leftovers = Object.keys(overrides).filter(function(key) {
                return overrides[key] != null;
              });
              if (leftovers.length) {
                logger.throwError("cannot override " + leftovers.map(function(l) {
                  return JSON.stringify(l);
                }).join(","), logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "overrides",
                  overrides: leftovers
                });
              }
              return [2, tx];
          }
        });
      });
    }
    function buildPopulate(contract, fragment) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return populateTransaction(contract, fragment, args);
      };
    }
    function buildEstimate(contract, fragment) {
      var signerOrProvider = contract.signer || contract.provider;
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var tx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!signerOrProvider) {
                  logger.throwError("estimate require a provider or signer", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "estimateGas"
                  });
                }
                return [4, populateTransaction(contract, fragment, args)];
              case 1:
                tx = _a.sent();
                return [4, signerOrProvider.estimateGas(tx)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
    }
    function addContractWait(contract, tx) {
      var wait = tx.wait.bind(tx);
      tx.wait = function(confirmations) {
        return wait(confirmations).then(function(receipt) {
          receipt.events = receipt.logs.map(function(log) {
            var event = (0, properties_1.deepCopy)(log);
            var parsed = null;
            try {
              parsed = contract.interface.parseLog(log);
            } catch (e) {
            }
            if (parsed) {
              event.args = parsed.args;
              event.decode = function(data, topics) {
                return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
              };
              event.event = parsed.name;
              event.eventSignature = parsed.signature;
            }
            event.removeListener = function() {
              return contract.provider;
            };
            event.getBlock = function() {
              return contract.provider.getBlock(receipt.blockHash);
            };
            event.getTransaction = function() {
              return contract.provider.getTransaction(receipt.transactionHash);
            };
            event.getTransactionReceipt = function() {
              return Promise.resolve(receipt);
            };
            return event;
          });
          return receipt;
        });
      };
    }
    function buildCall(contract, fragment, collapseSimple) {
      var signerOrProvider = contract.signer || contract.provider;
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var blockTag, overrides, tx, result, value;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                blockTag = void 0;
                if (!(args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object"))
                  return [3, 3];
                overrides = (0, properties_1.shallowCopy)(args.pop());
                if (!(overrides.blockTag != null))
                  return [3, 2];
                return [4, overrides.blockTag];
              case 1:
                blockTag = _a.sent();
                _a.label = 2;
              case 2:
                delete overrides.blockTag;
                args.push(overrides);
                _a.label = 3;
              case 3:
                if (!(contract.deployTransaction != null))
                  return [3, 5];
                return [4, contract._deployed(blockTag)];
              case 4:
                _a.sent();
                _a.label = 5;
              case 5:
                return [4, populateTransaction(contract, fragment, args)];
              case 6:
                tx = _a.sent();
                return [4, signerOrProvider.call(tx, blockTag)];
              case 7:
                result = _a.sent();
                try {
                  value = contract.interface.decodeFunctionResult(fragment, result);
                  if (collapseSimple && fragment.outputs.length === 1) {
                    value = value[0];
                  }
                  return [2, value];
                } catch (error) {
                  if (error.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                    error.address = contract.address;
                    error.args = args;
                    error.transaction = tx;
                  }
                  throw error;
                }
                return [2];
            }
          });
        });
      };
    }
    function buildSend(contract, fragment) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var txRequest, tx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!contract.signer) {
                  logger.throwError("sending a transaction requires a signer", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "sendTransaction"
                  });
                }
                if (!(contract.deployTransaction != null))
                  return [3, 2];
                return [4, contract._deployed()];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                return [4, populateTransaction(contract, fragment, args)];
              case 3:
                txRequest = _a.sent();
                return [4, contract.signer.sendTransaction(txRequest)];
              case 4:
                tx = _a.sent();
                addContractWait(contract, tx);
                return [2, tx];
            }
          });
        });
      };
    }
    function buildDefault(contract, fragment, collapseSimple) {
      if (fragment.constant) {
        return buildCall(contract, fragment, collapseSimple);
      }
      return buildSend(contract, fragment);
    }
    function getEventTag(filter2) {
      if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
        return "*";
      }
      return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map(function(topic) {
        if (Array.isArray(topic)) {
          return topic.join("|");
        }
        return topic;
      }).join(":") : "");
    }
    var RunningEvent = function() {
      function RunningEvent2(tag, filter2) {
        (0, properties_1.defineReadOnly)(this, "tag", tag);
        (0, properties_1.defineReadOnly)(this, "filter", filter2);
        this._listeners = [];
      }
      RunningEvent2.prototype.addListener = function(listener, once) {
        this._listeners.push({ listener, once });
      };
      RunningEvent2.prototype.removeListener = function(listener) {
        var done = false;
        this._listeners = this._listeners.filter(function(item) {
          if (done || item.listener !== listener) {
            return true;
          }
          done = true;
          return false;
        });
      };
      RunningEvent2.prototype.removeAllListeners = function() {
        this._listeners = [];
      };
      RunningEvent2.prototype.listeners = function() {
        return this._listeners.map(function(i) {
          return i.listener;
        });
      };
      RunningEvent2.prototype.listenerCount = function() {
        return this._listeners.length;
      };
      RunningEvent2.prototype.run = function(args) {
        var _this = this;
        var listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter(function(item) {
          var argsCopy = args.slice();
          setTimeout(function() {
            item.listener.apply(_this, argsCopy);
          }, 0);
          return !item.once;
        });
        return listenerCount;
      };
      RunningEvent2.prototype.prepareEvent = function(event) {
      };
      RunningEvent2.prototype.getEmit = function(event) {
        return [event];
      };
      return RunningEvent2;
    }();
    var ErrorRunningEvent = function(_super) {
      __extends(ErrorRunningEvent2, _super);
      function ErrorRunningEvent2() {
        return _super.call(this, "error", null) || this;
      }
      return ErrorRunningEvent2;
    }(RunningEvent);
    var FragmentRunningEvent = function(_super) {
      __extends(FragmentRunningEvent2, _super);
      function FragmentRunningEvent2(address, contractInterface, fragment, topics) {
        var _this = this;
        var filter2 = {
          address
        };
        var topic = contractInterface.getEventTopic(fragment);
        if (topics) {
          if (topic !== topics[0]) {
            logger.throwArgumentError("topic mismatch", "topics", topics);
          }
          filter2.topics = topics.slice();
        } else {
          filter2.topics = [topic];
        }
        _this = _super.call(this, getEventTag(filter2), filter2) || this;
        (0, properties_1.defineReadOnly)(_this, "address", address);
        (0, properties_1.defineReadOnly)(_this, "interface", contractInterface);
        (0, properties_1.defineReadOnly)(_this, "fragment", fragment);
        return _this;
      }
      FragmentRunningEvent2.prototype.prepareEvent = function(event) {
        var _this = this;
        _super.prototype.prepareEvent.call(this, event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = function(data, topics) {
          return _this.interface.decodeEventLog(_this.fragment, data, topics);
        };
        try {
          event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
          event.args = null;
          event.decodeError = error;
        }
      };
      FragmentRunningEvent2.prototype.getEmit = function(event) {
        var errors = (0, abi_1.checkResultErrors)(event.args);
        if (errors.length) {
          throw errors[0].error;
        }
        var args = (event.args || []).slice();
        args.push(event);
        return args;
      };
      return FragmentRunningEvent2;
    }(RunningEvent);
    var WildcardRunningEvent = function(_super) {
      __extends(WildcardRunningEvent2, _super);
      function WildcardRunningEvent2(address, contractInterface) {
        var _this = _super.call(this, "*", { address }) || this;
        (0, properties_1.defineReadOnly)(_this, "address", address);
        (0, properties_1.defineReadOnly)(_this, "interface", contractInterface);
        return _this;
      }
      WildcardRunningEvent2.prototype.prepareEvent = function(event) {
        var _this = this;
        _super.prototype.prepareEvent.call(this, event);
        try {
          var parsed_1 = this.interface.parseLog(event);
          event.event = parsed_1.name;
          event.eventSignature = parsed_1.signature;
          event.decode = function(data, topics) {
            return _this.interface.decodeEventLog(parsed_1.eventFragment, data, topics);
          };
          event.args = parsed_1.args;
        } catch (error) {
        }
      };
      return WildcardRunningEvent2;
    }(RunningEvent);
    var BaseContract = function() {
      function BaseContract2(addressOrName, contractInterface, signerOrProvider) {
        var _newTarget = this.constructor;
        var _this = this;
        (0, properties_1.defineReadOnly)(this, "interface", (0, properties_1.getStatic)(_newTarget, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
          (0, properties_1.defineReadOnly)(this, "provider", null);
          (0, properties_1.defineReadOnly)(this, "signer", null);
        } else if (abstract_signer_1.Signer.isSigner(signerOrProvider)) {
          (0, properties_1.defineReadOnly)(this, "provider", signerOrProvider.provider || null);
          (0, properties_1.defineReadOnly)(this, "signer", signerOrProvider);
        } else if (abstract_provider_1.Provider.isProvider(signerOrProvider)) {
          (0, properties_1.defineReadOnly)(this, "provider", signerOrProvider);
          (0, properties_1.defineReadOnly)(this, "signer", null);
        } else {
          logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        (0, properties_1.defineReadOnly)(this, "callStatic", {});
        (0, properties_1.defineReadOnly)(this, "estimateGas", {});
        (0, properties_1.defineReadOnly)(this, "functions", {});
        (0, properties_1.defineReadOnly)(this, "populateTransaction", {});
        (0, properties_1.defineReadOnly)(this, "filters", {});
        {
          var uniqueFilters_1 = {};
          Object.keys(this.interface.events).forEach(function(eventSignature) {
            var event = _this.interface.events[eventSignature];
            (0, properties_1.defineReadOnly)(_this.filters, eventSignature, function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return {
                address: _this.address,
                topics: _this.interface.encodeFilterTopics(event, args)
              };
            });
            if (!uniqueFilters_1[event.name]) {
              uniqueFilters_1[event.name] = [];
            }
            uniqueFilters_1[event.name].push(eventSignature);
          });
          Object.keys(uniqueFilters_1).forEach(function(name) {
            var filters = uniqueFilters_1[name];
            if (filters.length === 1) {
              (0, properties_1.defineReadOnly)(_this.filters, name, _this.filters[filters[0]]);
            } else {
              logger.warn("Duplicate definition of " + name + " (" + filters.join(", ") + ")");
            }
          });
        }
        (0, properties_1.defineReadOnly)(this, "_runningEvents", {});
        (0, properties_1.defineReadOnly)(this, "_wrappedEmits", {});
        if (addressOrName == null) {
          logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        (0, properties_1.defineReadOnly)(this, "address", addressOrName);
        if (this.provider) {
          (0, properties_1.defineReadOnly)(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        } else {
          try {
            (0, properties_1.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0, address_1.getAddress)(addressOrName)));
          } catch (error) {
            logger.throwError("provider is required to use ENS name as contract address", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new Contract"
            });
          }
        }
        this.resolvedAddress.catch(function(e) {
        });
        var uniqueNames = {};
        var uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach(function(signature) {
          var fragment = _this.interface.functions[signature];
          if (uniqueSignatures[signature]) {
            logger.warn("Duplicate ABI entry for " + JSON.stringify(signature));
            return;
          }
          uniqueSignatures[signature] = true;
          {
            var name_1 = fragment.name;
            if (!uniqueNames["%" + name_1]) {
              uniqueNames["%" + name_1] = [];
            }
            uniqueNames["%" + name_1].push(signature);
          }
          if (_this[signature] == null) {
            (0, properties_1.defineReadOnly)(_this, signature, buildDefault(_this, fragment, true));
          }
          if (_this.functions[signature] == null) {
            (0, properties_1.defineReadOnly)(_this.functions, signature, buildDefault(_this, fragment, false));
          }
          if (_this.callStatic[signature] == null) {
            (0, properties_1.defineReadOnly)(_this.callStatic, signature, buildCall(_this, fragment, true));
          }
          if (_this.populateTransaction[signature] == null) {
            (0, properties_1.defineReadOnly)(_this.populateTransaction, signature, buildPopulate(_this, fragment));
          }
          if (_this.estimateGas[signature] == null) {
            (0, properties_1.defineReadOnly)(_this.estimateGas, signature, buildEstimate(_this, fragment));
          }
        });
        Object.keys(uniqueNames).forEach(function(name) {
          var signatures = uniqueNames[name];
          if (signatures.length > 1) {
            return;
          }
          name = name.substring(1);
          var signature = signatures[0];
          try {
            if (_this[name] == null) {
              (0, properties_1.defineReadOnly)(_this, name, _this[signature]);
            }
          } catch (e) {
          }
          if (_this.functions[name] == null) {
            (0, properties_1.defineReadOnly)(_this.functions, name, _this.functions[signature]);
          }
          if (_this.callStatic[name] == null) {
            (0, properties_1.defineReadOnly)(_this.callStatic, name, _this.callStatic[signature]);
          }
          if (_this.populateTransaction[name] == null) {
            (0, properties_1.defineReadOnly)(_this.populateTransaction, name, _this.populateTransaction[signature]);
          }
          if (_this.estimateGas[name] == null) {
            (0, properties_1.defineReadOnly)(_this.estimateGas, name, _this.estimateGas[signature]);
          }
        });
      }
      BaseContract2.getContractAddress = function(transaction) {
        return (0, address_1.getContractAddress)(transaction);
      };
      BaseContract2.getInterface = function(contractInterface) {
        if (abi_1.Interface.isInterface(contractInterface)) {
          return contractInterface;
        }
        return new abi_1.Interface(contractInterface);
      };
      BaseContract2.prototype.deployed = function() {
        return this._deployed();
      };
      BaseContract2.prototype._deployed = function(blockTag) {
        var _this = this;
        if (!this._deployedPromise) {
          if (this.deployTransaction) {
            this._deployedPromise = this.deployTransaction.wait().then(function() {
              return _this;
            });
          } else {
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then(function(code) {
              if (code === "0x") {
                logger.throwError("contract not deployed", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                  contractAddress: _this.address,
                  operation: "getDeployed"
                });
              }
              return _this;
            });
          }
        }
        return this._deployedPromise;
      };
      BaseContract2.prototype.fallback = function(overrides) {
        var _this = this;
        if (!this.signer) {
          logger.throwError("sending a transactions require a signer", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        var tx = (0, properties_1.shallowCopy)(overrides || {});
        ["from", "to"].forEach(function(key) {
          if (tx[key] == null) {
            return;
          }
          logger.throwError("cannot override " + key, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(function() {
          return _this.signer.sendTransaction(tx);
        });
      };
      BaseContract2.prototype.connect = function(signerOrProvider) {
        if (typeof signerOrProvider === "string") {
          signerOrProvider = new abstract_signer_1.VoidSigner(signerOrProvider, this.provider);
        }
        var contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
          (0, properties_1.defineReadOnly)(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
      };
      BaseContract2.prototype.attach = function(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
      };
      BaseContract2.isIndexed = function(value) {
        return abi_1.Indexed.isIndexed(value);
      };
      BaseContract2.prototype._normalizeRunningEvent = function(runningEvent) {
        if (this._runningEvents[runningEvent.tag]) {
          return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
      };
      BaseContract2.prototype._getRunningEvent = function(eventName) {
        if (typeof eventName === "string") {
          if (eventName === "error") {
            return this._normalizeRunningEvent(new ErrorRunningEvent());
          }
          if (eventName === "event") {
            return this._normalizeRunningEvent(new RunningEvent("event", null));
          }
          if (eventName === "*") {
            return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
          }
          var fragment = this.interface.getEvent(eventName);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        if (eventName.topics && eventName.topics.length > 0) {
          try {
            var topic = eventName.topics[0];
            if (typeof topic !== "string") {
              throw new Error("invalid topic");
            }
            var fragment = this.interface.getEvent(topic);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
          } catch (error) {
          }
          var filter2 = {
            address: this.address,
            topics: eventName.topics
          };
          return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      };
      BaseContract2.prototype._checkRunningEvents = function(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
          delete this._runningEvents[runningEvent.tag];
          var emit = this._wrappedEmits[runningEvent.tag];
          if (emit && runningEvent.filter) {
            this.provider.off(runningEvent.filter, emit);
            delete this._wrappedEmits[runningEvent.tag];
          }
        }
      };
      BaseContract2.prototype._wrapEvent = function(runningEvent, log, listener) {
        var _this = this;
        var event = (0, properties_1.deepCopy)(log);
        event.removeListener = function() {
          if (!listener) {
            return;
          }
          runningEvent.removeListener(listener);
          _this._checkRunningEvents(runningEvent);
        };
        event.getBlock = function() {
          return _this.provider.getBlock(log.blockHash);
        };
        event.getTransaction = function() {
          return _this.provider.getTransaction(log.transactionHash);
        };
        event.getTransactionReceipt = function() {
          return _this.provider.getTransactionReceipt(log.transactionHash);
        };
        runningEvent.prepareEvent(event);
        return event;
      };
      BaseContract2.prototype._addEventListener = function(runningEvent, listener, once) {
        var _this = this;
        if (!this.provider) {
          logger.throwError("events require a provider or a signer with a provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        this._runningEvents[runningEvent.tag] = runningEvent;
        if (!this._wrappedEmits[runningEvent.tag]) {
          var wrappedEmit = function(log) {
            var event = _this._wrapEvent(runningEvent, log, listener);
            if (event.decodeError == null) {
              try {
                var args = runningEvent.getEmit(event);
                _this.emit.apply(_this, __spreadArray([runningEvent.filter], args, false));
              } catch (error) {
                event.decodeError = error.error;
              }
            }
            if (runningEvent.filter != null) {
              _this.emit("event", event);
            }
            if (event.decodeError != null) {
              _this.emit("error", event.decodeError, event);
            }
          };
          this._wrappedEmits[runningEvent.tag] = wrappedEmit;
          if (runningEvent.filter != null) {
            this.provider.on(runningEvent.filter, wrappedEmit);
          }
        }
      };
      BaseContract2.prototype.queryFilter = function(event, fromBlockOrBlockhash, toBlock) {
        var _this = this;
        var runningEvent = this._getRunningEvent(event);
        var filter2 = (0, properties_1.shallowCopy)(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && (0, bytes_1.isHexString)(fromBlockOrBlockhash, 32)) {
          if (toBlock != null) {
            logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
          }
          filter2.blockHash = fromBlockOrBlockhash;
        } else {
          filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
          filter2.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter2).then(function(logs) {
          return logs.map(function(log) {
            return _this._wrapEvent(runningEvent, log, null);
          });
        });
      };
      BaseContract2.prototype.on = function(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
      };
      BaseContract2.prototype.once = function(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
      };
      BaseContract2.prototype.emit = function(eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (!this.provider) {
          return false;
        }
        var runningEvent = this._getRunningEvent(eventName);
        var result = runningEvent.run(args) > 0;
        this._checkRunningEvents(runningEvent);
        return result;
      };
      BaseContract2.prototype.listenerCount = function(eventName) {
        var _this = this;
        if (!this.provider) {
          return 0;
        }
        if (eventName == null) {
          return Object.keys(this._runningEvents).reduce(function(accum, key) {
            return accum + _this._runningEvents[key].listenerCount();
          }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
      };
      BaseContract2.prototype.listeners = function(eventName) {
        if (!this.provider) {
          return [];
        }
        if (eventName == null) {
          var result_1 = [];
          for (var tag in this._runningEvents) {
            this._runningEvents[tag].listeners().forEach(function(listener) {
              result_1.push(listener);
            });
          }
          return result_1;
        }
        return this._getRunningEvent(eventName).listeners();
      };
      BaseContract2.prototype.removeAllListeners = function(eventName) {
        if (!this.provider) {
          return this;
        }
        if (eventName == null) {
          for (var tag in this._runningEvents) {
            var runningEvent_1 = this._runningEvents[tag];
            runningEvent_1.removeAllListeners();
            this._checkRunningEvents(runningEvent_1);
          }
          return this;
        }
        var runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
      };
      BaseContract2.prototype.off = function(eventName, listener) {
        if (!this.provider) {
          return this;
        }
        var runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
      };
      BaseContract2.prototype.removeListener = function(eventName, listener) {
        return this.off(eventName, listener);
      };
      return BaseContract2;
    }();
    exports.BaseContract = BaseContract;
    var Contract = function(_super) {
      __extends(Contract2, _super);
      function Contract2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return Contract2;
    }(BaseContract);
    exports.Contract = Contract;
    var ContractFactory = function() {
      function ContractFactory2(contractInterface, bytecode, signer) {
        var _newTarget = this.constructor;
        var bytecodeHex = null;
        if (typeof bytecode === "string") {
          bytecodeHex = bytecode;
        } else if ((0, bytes_1.isBytes)(bytecode)) {
          bytecodeHex = (0, bytes_1.hexlify)(bytecode);
        } else if (bytecode && typeof bytecode.object === "string") {
          bytecodeHex = bytecode.object;
        } else {
          bytecodeHex = "!";
        }
        if (bytecodeHex.substring(0, 2) !== "0x") {
          bytecodeHex = "0x" + bytecodeHex;
        }
        if (!(0, bytes_1.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {
          logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        if (signer && !abstract_signer_1.Signer.isSigner(signer)) {
          logger.throwArgumentError("invalid signer", "signer", signer);
        }
        (0, properties_1.defineReadOnly)(this, "bytecode", bytecodeHex);
        (0, properties_1.defineReadOnly)(this, "interface", (0, properties_1.getStatic)(_newTarget, "getInterface")(contractInterface));
        (0, properties_1.defineReadOnly)(this, "signer", signer || null);
      }
      ContractFactory2.prototype.getDeployTransaction = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var tx = {};
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          tx = (0, properties_1.shallowCopy)(args.pop());
          for (var key in tx) {
            if (!allowedTransactionKeys[key]) {
              throw new Error("unknown transaction override " + key);
            }
          }
        }
        ["data", "from", "to"].forEach(function(key2) {
          if (tx[key2] == null) {
            return;
          }
          logger.throwError("cannot override " + key2, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
        });
        if (tx.value) {
          var value = bignumber_1.BigNumber.from(tx.value);
          if (!value.isZero() && !this.interface.deploy.payable) {
            logger.throwError("non-payable constructor cannot override value", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.value",
              value: tx.value
            });
          }
        }
        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        tx.data = (0, bytes_1.hexlify)((0, bytes_1.concat)([
          this.bytecode,
          this.interface.encodeDeploy(args)
        ]));
        return tx;
      };
      ContractFactory2.prototype.deploy = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var overrides, params, unsignedTx, tx, address, contract;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                overrides = {};
                if (args.length === this.interface.deploy.inputs.length + 1) {
                  overrides = args.pop();
                }
                logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
                return [4, resolveAddresses(this.signer, args, this.interface.deploy.inputs)];
              case 1:
                params = _a.sent();
                params.push(overrides);
                unsignedTx = this.getDeployTransaction.apply(this, params);
                return [4, this.signer.sendTransaction(unsignedTx)];
              case 2:
                tx = _a.sent();
                address = (0, properties_1.getStatic)(this.constructor, "getContractAddress")(tx);
                contract = (0, properties_1.getStatic)(this.constructor, "getContract")(address, this.interface, this.signer);
                addContractWait(contract, tx);
                (0, properties_1.defineReadOnly)(contract, "deployTransaction", tx);
                return [2, contract];
            }
          });
        });
      };
      ContractFactory2.prototype.attach = function(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
      };
      ContractFactory2.prototype.connect = function(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
      };
      ContractFactory2.fromSolidity = function(compilerOutput, signer) {
        if (compilerOutput == null) {
          logger.throwError("missing compiler output", logger_1.Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof compilerOutput === "string") {
          compilerOutput = JSON.parse(compilerOutput);
        }
        var abi3 = compilerOutput.abi;
        var bytecode = null;
        if (compilerOutput.bytecode) {
          bytecode = compilerOutput.bytecode;
        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
          bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi3, bytecode, signer);
      };
      ContractFactory2.getInterface = function(contractInterface) {
        return Contract.getInterface(contractInterface);
      };
      ContractFactory2.getContractAddress = function(tx) {
        return (0, address_1.getContractAddress)(tx);
      };
      ContractFactory2.getContract = function(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
      };
      return ContractFactory2;
    }();
    exports.ContractFactory = ContractFactory;
  }
});

// node_modules/@ethersproject/basex/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/@ethersproject/basex/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base58 = exports.Base32 = exports.BaseX = void 0;
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var BaseX = function() {
      function BaseX2(alphabet) {
        (0, properties_1.defineReadOnly)(this, "alphabet", alphabet);
        (0, properties_1.defineReadOnly)(this, "base", alphabet.length);
        (0, properties_1.defineReadOnly)(this, "_alphabetMap", {});
        (0, properties_1.defineReadOnly)(this, "_leader", alphabet.charAt(0));
        for (var i = 0; i < alphabet.length; i++) {
          this._alphabetMap[alphabet.charAt(i)] = i;
        }
      }
      BaseX2.prototype.encode = function(value) {
        var source = (0, bytes_1.arrayify)(value);
        if (source.length === 0) {
          return "";
        }
        var digits = [0];
        for (var i = 0; i < source.length; ++i) {
          var carry = source[i];
          for (var j = 0; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % this.base;
            carry = carry / this.base | 0;
          }
          while (carry > 0) {
            digits.push(carry % this.base);
            carry = carry / this.base | 0;
          }
        }
        var string = "";
        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
          string += this._leader;
        }
        for (var q = digits.length - 1; q >= 0; --q) {
          string += this.alphabet[digits[q]];
        }
        return string;
      };
      BaseX2.prototype.decode = function(value) {
        if (typeof value !== "string") {
          throw new TypeError("Expected String");
        }
        var bytes = [];
        if (value.length === 0) {
          return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (var i = 0; i < value.length; i++) {
          var byte = this._alphabetMap[value[i]];
          if (byte === void 0) {
            throw new Error("Non-base" + this.base + " character");
          }
          var carry = byte;
          for (var j = 0; j < bytes.length; ++j) {
            carry += bytes[j] * this.base;
            bytes[j] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 255);
            carry >>= 8;
          }
        }
        for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
          bytes.push(0);
        }
        return (0, bytes_1.arrayify)(new Uint8Array(bytes.reverse()));
      };
      return BaseX2;
    }();
    exports.BaseX = BaseX;
    var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    exports.Base32 = Base32;
    var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.Base58 = Base58;
  }
});

// node_modules/@ethersproject/pbkdf2/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@ethersproject/pbkdf2/lib/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = void 0;
    var crypto_1 = require("crypto");
    var bytes_1 = require_lib2();
    function bufferify(value) {
      return Buffer.from((0, bytes_1.arrayify)(value));
    }
    function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
      return (0, bytes_1.hexlify)((0, crypto_1.pbkdf2Sync)(bufferify(password), bufferify(salt), iterations, keylen, hashAlgorithm));
    }
    exports.pbkdf2 = pbkdf2;
  }
});

// node_modules/@ethersproject/pbkdf2/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/@ethersproject/pbkdf2/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = void 0;
    var pbkdf2_1 = require_pbkdf2();
    Object.defineProperty(exports, "pbkdf2", { enumerable: true, get: function() {
      return pbkdf2_1.pbkdf2;
    } });
  }
});

// node_modules/@ethersproject/sha2/lib/types.js
var require_types2 = __commonJS({
  "node_modules/@ethersproject/sha2/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedAlgorithm = void 0;
    var SupportedAlgorithm;
    (function(SupportedAlgorithm2) {
      SupportedAlgorithm2["sha256"] = "sha256";
      SupportedAlgorithm2["sha512"] = "sha512";
    })(SupportedAlgorithm = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));
  }
});

// node_modules/@ethersproject/sha2/lib/_version.js
var require_version15 = __commonJS({
  "node_modules/@ethersproject/sha2/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "sha2/5.7.0";
  }
});

// node_modules/@ethersproject/sha2/lib/sha2.js
var require_sha2 = __commonJS({
  "node_modules/@ethersproject/sha2/lib/sha2.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeHmac = exports.sha512 = exports.sha256 = exports.ripemd160 = void 0;
    var crypto_1 = require("crypto");
    var hash_js_1 = __importDefault(require_hash());
    var bytes_1 = require_lib2();
    var types_1 = require_types2();
    var logger_1 = require_lib();
    var _version_1 = require_version15();
    var logger = new logger_1.Logger(_version_1.version);
    function ripemd160(data) {
      return "0x" + hash_js_1.default.ripemd160().update((0, bytes_1.arrayify)(data)).digest("hex");
    }
    exports.ripemd160 = ripemd160;
    function sha256(data) {
      return "0x" + (0, crypto_1.createHash)("sha256").update(Buffer.from((0, bytes_1.arrayify)(data))).digest("hex");
    }
    exports.sha256 = sha256;
    function sha512(data) {
      return "0x" + (0, crypto_1.createHash)("sha512").update(Buffer.from((0, bytes_1.arrayify)(data))).digest("hex");
    }
    exports.sha512 = sha512;
    function computeHmac(algorithm, key, data) {
      if (!types_1.SupportedAlgorithm[algorithm]) {
        logger.throwError("unsupported algorithm - " + algorithm, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "computeHmac",
          algorithm
        });
      }
      return "0x" + (0, crypto_1.createHmac)(algorithm, Buffer.from((0, bytes_1.arrayify)(key))).update(Buffer.from((0, bytes_1.arrayify)(data))).digest("hex");
    }
    exports.computeHmac = computeHmac;
  }
});

// node_modules/@ethersproject/sha2/lib/index.js
var require_lib21 = __commonJS({
  "node_modules/@ethersproject/sha2/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedAlgorithm = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.computeHmac = void 0;
    var sha2_1 = require_sha2();
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var types_1 = require_types2();
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return types_1.SupportedAlgorithm;
    } });
  }
});

// node_modules/@ethersproject/wordlists/lib/_version.js
var require_version16 = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "wordlists/5.7.0";
  }
});

// node_modules/@ethersproject/wordlists/lib/wordlist.js
var require_wordlist = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/wordlist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wordlist = exports.logger = void 0;
    var exportWordlist = false;
    var hash_1 = require_lib12();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version16();
    exports.logger = new logger_1.Logger(_version_1.version);
    var Wordlist = function() {
      function Wordlist2(locale) {
        var _newTarget = this.constructor;
        exports.logger.checkAbstract(_newTarget, Wordlist2);
        (0, properties_1.defineReadOnly)(this, "locale", locale);
      }
      Wordlist2.prototype.split = function(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
      };
      Wordlist2.prototype.join = function(words) {
        return words.join(" ");
      };
      Wordlist2.check = function(wordlist) {
        var words = [];
        for (var i = 0; i < 2048; i++) {
          var word = wordlist.getWord(i);
          if (i !== wordlist.getWordIndex(word)) {
            return "0x";
          }
          words.push(word);
        }
        return (0, hash_1.id)(words.join("\n") + "\n");
      };
      Wordlist2.register = function(lang, name) {
        if (!name) {
          name = lang.locale;
        }
        if (exportWordlist) {
          try {
            var anyGlobal = window;
            if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
              if (!anyGlobal._ethers.wordlists[name]) {
                (0, properties_1.defineReadOnly)(anyGlobal._ethers.wordlists, name, lang);
              }
            }
          } catch (error) {
          }
        }
      };
      return Wordlist2;
    }();
    exports.Wordlist = Wordlist;
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-cz.js
var require_lang_cz = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-cz.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langCz = void 0;
    var wordlist_1 = require_wordlist();
    var words = "AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk";
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
      if (wordlist_1.Wordlist.check(lang) !== "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
      }
    }
    var LangCz = function(_super) {
      __extends(LangCz2, _super);
      function LangCz2() {
        return _super.call(this, "cz") || this;
      }
      LangCz2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[index];
      };
      LangCz2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      };
      return LangCz2;
    }(wordlist_1.Wordlist);
    var langCz = new LangCz();
    exports.langCz = langCz;
    wordlist_1.Wordlist.register(langCz);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-en.js
var require_lang_en = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-en.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langEn = void 0;
    var wordlist_1 = require_wordlist();
    var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
      if (wordlist_1.Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
      }
    }
    var LangEn = function(_super) {
      __extends(LangEn2, _super);
      function LangEn2() {
        return _super.call(this, "en") || this;
      }
      LangEn2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[index];
      };
      LangEn2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      };
      return LangEn2;
    }(wordlist_1.Wordlist);
    var langEn = new LangEn();
    exports.langEn = langEn;
    wordlist_1.Wordlist.register(langEn);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-es.js
var require_lang_es = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-es.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langEs = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var words = "A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo";
    var lookup = {};
    var wordlist = null;
    function dropDiacritic(word) {
      wordlist_1.logger.checkNormalize();
      return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c3) {
        return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 123;
      }));
    }
    function expand(word) {
      var output = [];
      Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c3) {
        if (c3 === 47) {
          output.push(204);
          output.push(129);
        } else if (c3 === 126) {
          output.push(110);
          output.push(204);
          output.push(131);
        } else {
          output.push(c3);
        }
      });
      return (0, strings_1.toUtf8String)(output);
    }
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w) {
        return expand(w);
      });
      wordlist.forEach(function(word, index) {
        lookup[dropDiacritic(word)] = index;
      });
      if (wordlist_1.Wordlist.check(lang) !== "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for es (Spanish) FAILED");
      }
    }
    var LangEs = function(_super) {
      __extends(LangEs2, _super);
      function LangEs2() {
        return _super.call(this, "es") || this;
      }
      LangEs2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[index];
      };
      LangEs2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return lookup[dropDiacritic(word)];
      };
      return LangEs2;
    }(wordlist_1.Wordlist);
    var langEs = new LangEs();
    exports.langEs = langEs;
    wordlist_1.Wordlist.register(langEs);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-fr.js
var require_lang_fr = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-fr.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langFr = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var words = "AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie";
    var wordlist = null;
    var lookup = {};
    function dropDiacritic(word) {
      wordlist_1.logger.checkNormalize();
      return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c3) {
        return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 123;
      }));
    }
    function expand(word) {
      var output = [];
      Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c3) {
        if (c3 === 47) {
          output.push(204);
          output.push(129);
        } else if (c3 === 45) {
          output.push(204);
          output.push(128);
        } else {
          output.push(c3);
        }
      });
      return (0, strings_1.toUtf8String)(output);
    }
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w) {
        return expand(w);
      });
      wordlist.forEach(function(word, index) {
        lookup[dropDiacritic(word)] = index;
      });
      if (wordlist_1.Wordlist.check(lang) !== "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for fr (French) FAILED");
      }
    }
    var LangFr = function(_super) {
      __extends(LangFr2, _super);
      function LangFr2() {
        return _super.call(this, "fr") || this;
      }
      LangFr2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[index];
      };
      LangFr2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return lookup[dropDiacritic(word)];
      };
      return LangFr2;
    }(wordlist_1.Wordlist);
    var langFr = new LangFr();
    exports.langFr = langFr;
    wordlist_1.Wordlist.register(langFr);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-ja.js
var require_lang_ja = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-ja.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langJa = void 0;
    var bytes_1 = require_lib2();
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var data = [
      "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
      "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
      "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
      "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
      "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
      "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
      "IJBEJqXZJ"
    ];
    var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
    var wordlist = null;
    function hex(word) {
      return (0, bytes_1.hexlify)((0, strings_1.toUtf8Bytes)(word));
    }
    var KiYoKu = "0xe3818de38284e3818f";
    var KyoKu = "0xe3818de38283e3818f";
    function loadWords(lang) {
      if (wordlist !== null) {
        return;
      }
      wordlist = [];
      var transform = {};
      transform[(0, strings_1.toUtf8String)([227, 130, 154])] = false;
      transform[(0, strings_1.toUtf8String)([227, 130, 153])] = false;
      transform[(0, strings_1.toUtf8String)([227, 130, 133])] = (0, strings_1.toUtf8String)([227, 130, 134]);
      transform[(0, strings_1.toUtf8String)([227, 129, 163])] = (0, strings_1.toUtf8String)([227, 129, 164]);
      transform[(0, strings_1.toUtf8String)([227, 130, 131])] = (0, strings_1.toUtf8String)([227, 130, 132]);
      transform[(0, strings_1.toUtf8String)([227, 130, 135])] = (0, strings_1.toUtf8String)([227, 130, 136]);
      function normalize(word2) {
        var result = "";
        for (var i2 = 0; i2 < word2.length; i2++) {
          var kana = word2[i2];
          var target = transform[kana];
          if (target === false) {
            continue;
          }
          if (target) {
            kana = target;
          }
          result += kana;
        }
        return result;
      }
      function sortJapanese(a, b) {
        a = normalize(a);
        b = normalize(b);
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      }
      for (var length_1 = 3; length_1 <= 9; length_1++) {
        var d = data[length_1 - 3];
        for (var offset = 0; offset < d.length; offset += length_1) {
          var word = [];
          for (var i = 0; i < length_1; i++) {
            var k = mapping.indexOf(d[offset + i]);
            word.push(227);
            word.push(k & 64 ? 130 : 129);
            word.push((k & 63) + 128);
          }
          wordlist.push((0, strings_1.toUtf8String)(word));
        }
      }
      wordlist.sort(sortJapanese);
      if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {
        var tmp = wordlist[442];
        wordlist[442] = wordlist[443];
        wordlist[443] = tmp;
      }
      if (wordlist_1.Wordlist.check(lang) !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
      }
    }
    var LangJa = function(_super) {
      __extends(LangJa2, _super);
      function LangJa2() {
        return _super.call(this, "ja") || this;
      }
      LangJa2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[index];
      };
      LangJa2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      };
      LangJa2.prototype.split = function(mnemonic) {
        wordlist_1.logger.checkNormalize();
        return mnemonic.split(/(?:\u3000| )+/g);
      };
      LangJa2.prototype.join = function(words) {
        return words.join("\u3000");
      };
      return LangJa2;
    }(wordlist_1.Wordlist);
    var langJa = new LangJa();
    exports.langJa = langJa;
    wordlist_1.Wordlist.register(langJa);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-ko.js
var require_lang_ko = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-ko.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langKo = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var data = [
      "OYAa",
      "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
      "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
      "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
      "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
      "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
      "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
      "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
    ];
    var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
    function getHangul(code) {
      if (code >= 40) {
        code = code + 168 - 40;
      } else if (code >= 19) {
        code = code + 97 - 19;
      }
      return (0, strings_1.toUtf8String)([225, (code >> 6) + 132, (code & 63) + 128]);
    }
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = [];
      data.forEach(function(data2, length3) {
        length3 += 4;
        for (var i = 0; i < data2.length; i += length3) {
          var word = "";
          for (var j = 0; j < length3; j++) {
            word += getHangul(codes.indexOf(data2[i + j]));
          }
          wordlist.push(word);
        }
      });
      wordlist.sort();
      if (wordlist_1.Wordlist.check(lang) !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
      }
    }
    var LangKo = function(_super) {
      __extends(LangKo2, _super);
      function LangKo2() {
        return _super.call(this, "ko") || this;
      }
      LangKo2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[index];
      };
      LangKo2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      };
      return LangKo2;
    }(wordlist_1.Wordlist);
    var langKo = new LangKo();
    exports.langKo = langKo;
    wordlist_1.Wordlist.register(langKo);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-it.js
var require_lang_it = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-it.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langIt = void 0;
    var wordlist_1 = require_wordlist();
    var words = "AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa";
    var wordlist = null;
    function loadWords(lang) {
      if (wordlist != null) {
        return;
      }
      wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
      if (wordlist_1.Wordlist.check(lang) !== "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for it (Italian) FAILED");
      }
    }
    var LangIt = function(_super) {
      __extends(LangIt2, _super);
      function LangIt2() {
        return _super.call(this, "it") || this;
      }
      LangIt2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[index];
      };
      LangIt2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      };
      return LangIt2;
    }(wordlist_1.Wordlist);
    var langIt = new LangIt();
    exports.langIt = langIt;
    wordlist_1.Wordlist.register(langIt);
  }
});

// node_modules/@ethersproject/wordlists/lib/lang-zh.js
var require_lang_zh = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/lang-zh.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.langZhTw = exports.langZhCn = void 0;
    var strings_1 = require_lib9();
    var wordlist_1 = require_wordlist();
    var data = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
    var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
    var wordlist = {
      zh_cn: null,
      zh_tw: null
    };
    var Checks = {
      zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
      zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
    };
    var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
    function loadWords(lang) {
      if (wordlist[lang.locale] !== null) {
        return;
      }
      wordlist[lang.locale] = [];
      var deltaOffset = 0;
      for (var i = 0; i < 2048; i++) {
        var s = style.indexOf(data[i * 3]);
        var bytes = [
          228 + (s >> 2),
          128 + codes.indexOf(data[i * 3 + 1]),
          128 + codes.indexOf(data[i * 3 + 2])
        ];
        if (lang.locale === "zh_tw") {
          var common = s % 4;
          for (var i_1 = common; i_1 < 3; i_1++) {
            bytes[i_1] = codes.indexOf(deltaData[deltaOffset++]) + (i_1 == 0 ? 228 : 128);
          }
        }
        wordlist[lang.locale].push((0, strings_1.toUtf8String)(bytes));
      }
      if (wordlist_1.Wordlist.check(lang) !== Checks[lang.locale]) {
        wordlist[lang.locale] = null;
        throw new Error("BIP39 Wordlist for " + lang.locale + " (Chinese) FAILED");
      }
    }
    var LangZh = function(_super) {
      __extends(LangZh2, _super);
      function LangZh2(country) {
        return _super.call(this, "zh_" + country) || this;
      }
      LangZh2.prototype.getWord = function(index) {
        loadWords(this);
        return wordlist[this.locale][index];
      };
      LangZh2.prototype.getWordIndex = function(word) {
        loadWords(this);
        return wordlist[this.locale].indexOf(word);
      };
      LangZh2.prototype.split = function(mnemonic) {
        mnemonic = mnemonic.replace(/(?:\u3000| )+/g, "");
        return mnemonic.split("");
      };
      return LangZh2;
    }(wordlist_1.Wordlist);
    var langZhCn = new LangZh("cn");
    exports.langZhCn = langZhCn;
    wordlist_1.Wordlist.register(langZhCn);
    wordlist_1.Wordlist.register(langZhCn, "zh");
    var langZhTw = new LangZh("tw");
    exports.langZhTw = langZhTw;
    wordlist_1.Wordlist.register(langZhTw);
  }
});

// node_modules/@ethersproject/wordlists/lib/wordlists.js
var require_wordlists = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/wordlists.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlists = void 0;
    var lang_cz_1 = require_lang_cz();
    var lang_en_1 = require_lang_en();
    var lang_es_1 = require_lang_es();
    var lang_fr_1 = require_lang_fr();
    var lang_ja_1 = require_lang_ja();
    var lang_ko_1 = require_lang_ko();
    var lang_it_1 = require_lang_it();
    var lang_zh_1 = require_lang_zh();
    exports.wordlists = {
      cz: lang_cz_1.langCz,
      en: lang_en_1.langEn,
      es: lang_es_1.langEs,
      fr: lang_fr_1.langFr,
      it: lang_it_1.langIt,
      ja: lang_ja_1.langJa,
      ko: lang_ko_1.langKo,
      zh: lang_zh_1.langZhCn,
      zh_cn: lang_zh_1.langZhCn,
      zh_tw: lang_zh_1.langZhTw
    };
  }
});

// node_modules/@ethersproject/wordlists/lib/index.js
var require_lib22 = __commonJS({
  "node_modules/@ethersproject/wordlists/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlists = exports.Wordlist = exports.logger = void 0;
    var wordlist_1 = require_wordlist();
    Object.defineProperty(exports, "logger", { enumerable: true, get: function() {
      return wordlist_1.logger;
    } });
    Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
      return wordlist_1.Wordlist;
    } });
    var wordlists_1 = require_wordlists();
    Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
      return wordlists_1.wordlists;
    } });
  }
});

// node_modules/@ethersproject/hdnode/lib/_version.js
var require_version17 = __commonJS({
  "node_modules/@ethersproject/hdnode/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "hdnode/5.7.0";
  }
});

// node_modules/@ethersproject/hdnode/lib/index.js
var require_lib23 = __commonJS({
  "node_modules/@ethersproject/hdnode/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAccountPath = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.mnemonicToSeed = exports.HDNode = exports.defaultPath = void 0;
    var basex_1 = require_lib19();
    var bytes_1 = require_lib2();
    var bignumber_1 = require_lib3();
    var strings_1 = require_lib9();
    var pbkdf2_1 = require_lib20();
    var properties_1 = require_lib4();
    var signing_key_1 = require_lib16();
    var sha2_1 = require_lib21();
    var transactions_1 = require_lib17();
    var wordlists_1 = require_lib22();
    var logger_1 = require_lib();
    var _version_1 = require_version17();
    var logger = new logger_1.Logger(_version_1.version);
    var N = bignumber_1.BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var MasterSecret = (0, strings_1.toUtf8Bytes)("Bitcoin seed");
    var HardenedBit = 2147483648;
    function getUpperMask(bits) {
      return (1 << bits) - 1 << 8 - bits;
    }
    function getLowerMask(bits) {
      return (1 << bits) - 1;
    }
    function bytes32(value) {
      return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
    }
    function base58check(data) {
      return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));
    }
    function getWordlist(wordlist) {
      if (wordlist == null) {
        return wordlists_1.wordlists["en"];
      }
      if (typeof wordlist === "string") {
        var words = wordlists_1.wordlists[wordlist];
        if (words == null) {
          logger.throwArgumentError("unknown locale", "wordlist", wordlist);
        }
        return words;
      }
      return wordlist;
    }
    var _constructorGuard = {};
    exports.defaultPath = "m/44'/60'/0'/0/0";
    var HDNode = function() {
      function HDNode2(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        if (constructorGuard !== _constructorGuard) {
          throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
          var signingKey = new signing_key_1.SigningKey(privateKey);
          (0, properties_1.defineReadOnly)(this, "privateKey", signingKey.privateKey);
          (0, properties_1.defineReadOnly)(this, "publicKey", signingKey.compressedPublicKey);
        } else {
          (0, properties_1.defineReadOnly)(this, "privateKey", null);
          (0, properties_1.defineReadOnly)(this, "publicKey", (0, bytes_1.hexlify)(publicKey));
        }
        (0, properties_1.defineReadOnly)(this, "parentFingerprint", parentFingerprint);
        (0, properties_1.defineReadOnly)(this, "fingerprint", (0, bytes_1.hexDataSlice)((0, sha2_1.ripemd160)((0, sha2_1.sha256)(this.publicKey)), 0, 4));
        (0, properties_1.defineReadOnly)(this, "address", (0, transactions_1.computeAddress)(this.publicKey));
        (0, properties_1.defineReadOnly)(this, "chainCode", chainCode);
        (0, properties_1.defineReadOnly)(this, "index", index);
        (0, properties_1.defineReadOnly)(this, "depth", depth);
        if (mnemonicOrPath == null) {
          (0, properties_1.defineReadOnly)(this, "mnemonic", null);
          (0, properties_1.defineReadOnly)(this, "path", null);
        } else if (typeof mnemonicOrPath === "string") {
          (0, properties_1.defineReadOnly)(this, "mnemonic", null);
          (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath);
        } else {
          (0, properties_1.defineReadOnly)(this, "mnemonic", mnemonicOrPath);
          (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath.path);
        }
      }
      Object.defineProperty(HDNode2.prototype, "extendedKey", {
        get: function() {
          if (this.depth >= 256) {
            throw new Error("Depth too large!");
          }
          return base58check((0, bytes_1.concat)([
            this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
            (0, bytes_1.hexlify)(this.depth),
            this.parentFingerprint,
            (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(this.index), 4),
            this.chainCode,
            this.privateKey != null ? (0, bytes_1.concat)(["0x00", this.privateKey]) : this.publicKey
          ]));
        },
        enumerable: false,
        configurable: true
      });
      HDNode2.prototype.neuter = function() {
        return new HDNode2(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
      };
      HDNode2.prototype._derive = function(index) {
        if (index > 4294967295) {
          throw new Error("invalid index - " + String(index));
        }
        var path3 = this.path;
        if (path3) {
          path3 += "/" + (index & ~HardenedBit);
        }
        var data = new Uint8Array(37);
        if (index & HardenedBit) {
          if (!this.privateKey) {
            throw new Error("cannot derive child of neutered node");
          }
          data.set((0, bytes_1.arrayify)(this.privateKey), 1);
          if (path3) {
            path3 += "'";
          }
        } else {
          data.set((0, bytes_1.arrayify)(this.publicKey));
        }
        for (var i = 24; i >= 0; i -= 8) {
          data[33 + (i >> 3)] = index >> 24 - i & 255;
        }
        var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, this.chainCode, data));
        var IL = I.slice(0, 32);
        var IR = I.slice(32);
        var ki = null;
        var Ki = null;
        if (this.privateKey) {
          ki = bytes32(bignumber_1.BigNumber.from(IL).add(this.privateKey).mod(N));
        } else {
          var ek = new signing_key_1.SigningKey((0, bytes_1.hexlify)(IL));
          Ki = ek._addPoint(this.publicKey);
        }
        var mnemonicOrPath = path3;
        var srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
          mnemonicOrPath = Object.freeze({
            phrase: srcMnemonic.phrase,
            path: path3,
            locale: srcMnemonic.locale || "en"
          });
        }
        return new HDNode2(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
      };
      HDNode2.prototype.derivePath = function(path3) {
        var components = path3.split("/");
        if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
          throw new Error("invalid path - " + path3);
        }
        if (components[0] === "m") {
          components.shift();
        }
        var result = this;
        for (var i = 0; i < components.length; i++) {
          var component = components[i];
          if (component.match(/^[0-9]+'$/)) {
            var index = parseInt(component.substring(0, component.length - 1));
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(HardenedBit + index);
          } else if (component.match(/^[0-9]+$/)) {
            var index = parseInt(component);
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(index);
          } else {
            throw new Error("invalid path component - " + component);
          }
        }
        return result;
      };
      HDNode2._fromSeed = function(seed, mnemonic) {
        var seedArray = (0, bytes_1.arrayify)(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
          throw new Error("invalid seed");
        }
        var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, MasterSecret, seedArray));
        return new HDNode2(_constructorGuard, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
      };
      HDNode2.fromMnemonic = function(mnemonic, password, wordlist) {
        wordlist = getWordlist(wordlist);
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
        return HDNode2._fromSeed(mnemonicToSeed(mnemonic, password), {
          phrase: mnemonic,
          path: "m",
          locale: wordlist.locale
        });
      };
      HDNode2.fromSeed = function(seed) {
        return HDNode2._fromSeed(seed, null);
      };
      HDNode2.fromExtendedKey = function(extendedKey) {
        var bytes = basex_1.Base58.decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
          logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        var depth = bytes[4];
        var parentFingerprint = (0, bytes_1.hexlify)(bytes.slice(5, 9));
        var index = parseInt((0, bytes_1.hexlify)(bytes.slice(9, 13)).substring(2), 16);
        var chainCode = (0, bytes_1.hexlify)(bytes.slice(13, 45));
        var key = bytes.slice(45, 78);
        switch ((0, bytes_1.hexlify)(bytes.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf":
            return new HDNode2(_constructorGuard, null, (0, bytes_1.hexlify)(key), parentFingerprint, chainCode, index, depth, null);
          case "0x0488ade4":
          case "0x04358394 ":
            if (key[0] !== 0) {
              break;
            }
            return new HDNode2(_constructorGuard, (0, bytes_1.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      };
      return HDNode2;
    }();
    exports.HDNode = HDNode;
    function mnemonicToSeed(mnemonic, password) {
      if (!password) {
        password = "";
      }
      var salt = (0, strings_1.toUtf8Bytes)("mnemonic" + password, strings_1.UnicodeNormalizationForm.NFKD);
      return (0, pbkdf2_1.pbkdf2)((0, strings_1.toUtf8Bytes)(mnemonic, strings_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    function mnemonicToEntropy(mnemonic, wordlist) {
      wordlist = getWordlist(wordlist);
      logger.checkNormalize();
      var words = wordlist.split(mnemonic);
      if (words.length % 3 !== 0) {
        throw new Error("invalid mnemonic");
      }
      var entropy = (0, bytes_1.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));
      var offset = 0;
      for (var i = 0; i < words.length; i++) {
        var index = wordlist.getWordIndex(words[i].normalize("NFKD"));
        if (index === -1) {
          throw new Error("invalid mnemonic");
        }
        for (var bit = 0; bit < 11; bit++) {
          if (index & 1 << 10 - bit) {
            entropy[offset >> 3] |= 1 << 7 - offset % 8;
          }
          offset++;
        }
      }
      var entropyBits = 32 * words.length / 3;
      var checksumBits = words.length / 3;
      var checksumMask = getUpperMask(checksumBits);
      var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
      if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
        throw new Error("invalid checksum");
      }
      return (0, bytes_1.hexlify)(entropy.slice(0, entropyBits / 8));
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      wordlist = getWordlist(wordlist);
      entropy = (0, bytes_1.arrayify)(entropy);
      if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
        throw new Error("invalid entropy");
      }
      var indices = [0];
      var remainingBits = 11;
      for (var i = 0; i < entropy.length; i++) {
        if (remainingBits > 8) {
          indices[indices.length - 1] <<= 8;
          indices[indices.length - 1] |= entropy[i];
          remainingBits -= 8;
        } else {
          indices[indices.length - 1] <<= remainingBits;
          indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
          indices.push(entropy[i] & getLowerMask(8 - remainingBits));
          remainingBits += 3;
        }
      }
      var checksumBits = entropy.length / 4;
      var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy))[0] & getUpperMask(checksumBits);
      indices[indices.length - 1] <<= checksumBits;
      indices[indices.length - 1] |= checksum >> 8 - checksumBits;
      return wordlist.join(indices.map(function(index) {
        return wordlist.getWord(index);
      }));
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function isValidMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
        return true;
      } catch (error) {
      }
      return false;
    }
    exports.isValidMnemonic = isValidMnemonic;
    function getAccountPath(index) {
      if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
        logger.throwArgumentError("invalid account index", "index", index);
      }
      return "m/44'/60'/" + index + "'/0/0";
    }
    exports.getAccountPath = getAccountPath;
  }
});

// node_modules/@ethersproject/random/lib/random.js
var require_random = __commonJS({
  "node_modules/@ethersproject/random/lib/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = void 0;
    var crypto_1 = require("crypto");
    var bytes_1 = require_lib2();
    function randomBytes(length3) {
      return (0, bytes_1.arrayify)((0, crypto_1.randomBytes)(length3));
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@ethersproject/random/lib/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/@ethersproject/random/lib/shuffle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffled = void 0;
    function shuffled(array) {
      array = array.slice();
      for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
      }
      return array;
    }
    exports.shuffled = shuffled;
  }
});

// node_modules/@ethersproject/random/lib/index.js
var require_lib24 = __commonJS({
  "node_modules/@ethersproject/random/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffled = exports.randomBytes = void 0;
    var random_1 = require_random();
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    var shuffle_1 = require_shuffle();
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return shuffle_1.shuffled;
    } });
  }
});

// node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "node_modules/aes-js/index.js"(exports, module2) {
    "use strict";
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i = 0; i < arrayish.length; i++) {
          if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length3) {
        return new Uint8Array(length3);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes(text) {
          var result = [], i = 0;
          text = encodeURI(text);
          while (i < text.length) {
            var c3 = text.charCodeAt(i++);
            if (c3 === 37) {
              result.push(parseInt(text.substr(i, 2), 16));
              i += 2;
            } else {
              result.push(c3);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes) {
          var result = [], i = 0;
          while (i < bytes.length) {
            var c3 = bytes[i];
            if (c3 < 128) {
              result.push(String.fromCharCode(c3));
              i++;
            } else if (c3 > 191 && c3 < 224) {
              result.push(String.fromCharCode((c3 & 31) << 6 | bytes[i + 1] & 63));
              i += 2;
            } else {
              result.push(String.fromCharCode((c3 & 15) << 12 | (bytes[i + 1] & 63) << 6 | bytes[i + 2] & 63));
              i += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes(text) {
          var result = [];
          for (var i = 0; i < text.length; i += 2) {
            result.push(parseInt(text.substr(i, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
          var result = [];
          for (var i = 0; i < bytes.length; i++) {
            var v = bytes[i];
            result.push(Hex[(v & 240) >> 4] + Hex[v & 15]);
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i += 4) {
          result.push(
            bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]
          );
        }
        return result;
      }
      var AES = function(key) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i = 0; i <= rounds; i++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i = 0; i < KC; i++) {
          index = i >> 2;
          this._Ke[index][i % 4] = tk[i];
          this._Kd[rounds - index][i % 4] = tk[i];
        }
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i = 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          } else {
            for (var i = 1; i < KC / 2; i++) {
              tk[i] ^= tk[i - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
            for (var i = KC / 2 + 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          }
          var i = 0, r, c3;
          while (i < KC && t < roundKeyCount) {
            r = t >> 2;
            c3 = t % 4;
            this._Ke[r][c3] = tk[i];
            this._Kd[rounds - r][c3] = tk[i++];
            t++;
          }
        }
        for (var r = 1; r < rounds; r++) {
          for (var c3 = 0; c3 < 4; c3++) {
            tt = this._Kd[r][c3];
            this._Kd[r][c3] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Ke[0][i];
        }
        for (var r = 1; r < rounds; r++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ this._Ke[r][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Ke[rounds][i];
          result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Kd[0][i];
        }
        for (var r = 1; r < rounds; r++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ this._Kd[r][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Kd[rounds][i];
          result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          for (var j = 0; j < 16; j++) {
            block[j] ^= this._lastCipherblock[j];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          for (var j = 0; j < 16; j++) {
            plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            encrypted[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            plaintext[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
          if (this._counter[i] === 255) {
            this._counter[i] = 0;
          } else {
            this._counter[i]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
          result[i] = padder;
        }
        return result;
      }
      function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length3 = data.length - padder;
        for (var i = 0; i < padder; i++) {
          if (data[length3 + i] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length3);
        copyArray(data, result, 0, 0, length3);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module2.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib/_version.js
var require_version18 = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "json-wallets/5.7.0";
  }
});

// node_modules/@ethersproject/json-wallets/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uuidV4 = exports.searchPath = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;
    var bytes_1 = require_lib2();
    var strings_1 = require_lib9();
    function looseArrayify(hexString) {
      if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
        hexString = "0x" + hexString;
      }
      return (0, bytes_1.arrayify)(hexString);
    }
    exports.looseArrayify = looseArrayify;
    function zpad(value, length3) {
      value = String(value);
      while (value.length < length3) {
        value = "0" + value;
      }
      return value;
    }
    exports.zpad = zpad;
    function getPassword(password) {
      if (typeof password === "string") {
        return (0, strings_1.toUtf8Bytes)(password, strings_1.UnicodeNormalizationForm.NFKC);
      }
      return (0, bytes_1.arrayify)(password);
    }
    exports.getPassword = getPassword;
    function searchPath(object, path3) {
      var currentChild = object;
      var comps = path3.toLowerCase().split("/");
      for (var i = 0; i < comps.length; i++) {
        var matchingChild = null;
        for (var key in currentChild) {
          if (key.toLowerCase() === comps[i]) {
            matchingChild = currentChild[key];
            break;
          }
        }
        if (matchingChild === null) {
          return null;
        }
        currentChild = matchingChild;
      }
      return currentChild;
    }
    exports.searchPath = searchPath;
    function uuidV4(randomBytes) {
      var bytes = (0, bytes_1.arrayify)(randomBytes);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      var value = (0, bytes_1.hexlify)(bytes);
      return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34)
      ].join("-");
    }
    exports.uuidV4 = uuidV4;
  }
});

// node_modules/@ethersproject/json-wallets/lib/crowdsale.js
var require_crowdsale = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/crowdsale.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.CrowdsaleAccount = void 0;
    var aes_js_1 = __importDefault(require_aes_js());
    var address_1 = require_lib7();
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var pbkdf2_1 = require_lib20();
    var strings_1 = require_lib9();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version18();
    var logger = new logger_1.Logger(_version_1.version);
    var utils_1 = require_utils4();
    var CrowdsaleAccount = function(_super) {
      __extends(CrowdsaleAccount2, _super);
      function CrowdsaleAccount2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CrowdsaleAccount2.prototype.isCrowdsaleAccount = function(value) {
        return !!(value && value._isCrowdsaleAccount);
      };
      return CrowdsaleAccount2;
    }(properties_1.Description);
    exports.CrowdsaleAccount = CrowdsaleAccount;
    function decrypt(json, password) {
      var data = JSON.parse(json);
      password = (0, utils_1.getPassword)(password);
      var ethaddr = (0, address_1.getAddress)((0, utils_1.searchPath)(data, "ethaddr"));
      var encseed = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "encseed"));
      if (!encseed || encseed.length % 16 !== 0) {
        logger.throwArgumentError("invalid encseed", "json", json);
      }
      var key = (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(password, password, 2e3, 32, "sha256")).slice(0, 16);
      var iv = encseed.slice(0, 16);
      var encryptedSeed = encseed.slice(16);
      var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
      var seed = aes_js_1.default.padding.pkcs7.strip((0, bytes_1.arrayify)(aesCbc.decrypt(encryptedSeed)));
      var seedHex = "";
      for (var i = 0; i < seed.length; i++) {
        seedHex += String.fromCharCode(seed[i]);
      }
      var seedHexBytes = (0, strings_1.toUtf8Bytes)(seedHex);
      var privateKey = (0, keccak256_1.keccak256)(seedHexBytes);
      return new CrowdsaleAccount({
        _isCrowdsaleAccount: true,
        address: ethaddr,
        privateKey
      });
    }
    exports.decrypt = decrypt;
  }
});

// node_modules/@ethersproject/json-wallets/lib/inspect.js
var require_inspect = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/inspect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = void 0;
    var address_1 = require_lib7();
    function isCrowdsaleWallet(json) {
      var data = null;
      try {
        data = JSON.parse(json);
      } catch (error) {
        return false;
      }
      return data.encseed && data.ethaddr;
    }
    exports.isCrowdsaleWallet = isCrowdsaleWallet;
    function isKeystoreWallet(json) {
      var data = null;
      try {
        data = JSON.parse(json);
      } catch (error) {
        return false;
      }
      if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
        return false;
      }
      return true;
    }
    exports.isKeystoreWallet = isKeystoreWallet;
    function getJsonWalletAddress(json) {
      if (isCrowdsaleWallet(json)) {
        try {
          return (0, address_1.getAddress)(JSON.parse(json).ethaddr);
        } catch (error) {
          return null;
        }
      }
      if (isKeystoreWallet(json)) {
        try {
          return (0, address_1.getAddress)(JSON.parse(json).address);
        } catch (error) {
          return null;
        }
      }
      return null;
    }
    exports.getJsonWalletAddress = getJsonWalletAddress;
  }
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/scrypt-js/scrypt.js"(exports, module2) {
    "use strict";
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA256(m) {
        const K = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
        let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w = new Uint32Array(64);
        function blocks(p2) {
          let off = 0, len = p2.length;
          while (len >= 64) {
            let a = h0, b = h1, c3 = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i2, j, t1, t2;
            for (i2 = 0; i2 < 16; i2++) {
              j = off + i2 * 4;
              w[i2] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
            }
            for (i2 = 16; i2 < 64; i2++) {
              u = w[i2 - 2];
              t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
              u = w[i2 - 15];
              t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
              w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0) | 0;
            }
            for (i2 = 0; i2 < 64; i2++) {
              t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i2] + w[i2] | 0) | 0) | 0;
              t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c3 ^ b & c3) | 0;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c3;
              c3 = b;
              b = a;
              a = t1 + t2 | 0;
            }
            h0 = h0 + a | 0;
            h1 = h1 + b | 0;
            h2 = h2 + c3 | 0;
            h3 = h3 + d | 0;
            h4 = h4 + e | 0;
            h5 = h5 + f | 0;
            h6 = h6 + g | 0;
            h7 = h7 + h | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m);
        let i, bytesLeft = m.length % 64, bitLenHi = m.length / 536870912 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
        p.push(128);
        for (i = bytesLeft + 1; i < numZeros; i++) {
          p.push(0);
        }
        p.push(bitLenHi >>> 24 & 255);
        p.push(bitLenHi >>> 16 & 255);
        p.push(bitLenHi >>> 8 & 255);
        p.push(bitLenHi >>> 0 & 255);
        p.push(bitLenLo >>> 24 & 255);
        p.push(bitLenLo >>> 16 & 255);
        p.push(bitLenLo >>> 8 & 255);
        p.push(bitLenLo >>> 0 & 255);
        blocks(p);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i;
        let dk = [];
        for (i = 0; i < 64; i++) {
          inner[i] = 54;
        }
        for (i = 0; i < password.length; i++) {
          inner[i] ^= password[i];
        }
        for (i = 0; i < salt.length; i++) {
          inner[64 + i] = salt[i];
        }
        for (i = innerLen - 4; i < innerLen; i++) {
          inner[i] = 0;
        }
        for (i = 0; i < 64; i++)
          outerKey[i] = 92;
        for (i = 0; i < password.length; i++)
          outerKey[i] ^= password[i];
        function incrementCounter() {
          for (let i2 = innerLen - 1; i2 >= innerLen - 4; i2--) {
            inner[i2]++;
            if (inner[i2] <= 255)
              return;
            inner[i2] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;
        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r; i++) {
          blockxor(BY, i * 16, _X, 16);
          salsa20_8(_X, x);
          arraycopy(_X, 0, BY, Yi + i * 16, 16);
        }
        for (i = 0; i < r; i++) {
          arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
        }
        for (i = 0; i < r; i++) {
          arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
      }
      function R(a, b) {
        return a << b | a >>> 32 - b;
      }
      function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);
        for (let i = 8; i > 0; i -= 2) {
          x[4] ^= R(x[0] + x[12], 7);
          x[8] ^= R(x[4] + x[0], 9);
          x[12] ^= R(x[8] + x[4], 13);
          x[0] ^= R(x[12] + x[8], 18);
          x[9] ^= R(x[5] + x[1], 7);
          x[13] ^= R(x[9] + x[5], 9);
          x[1] ^= R(x[13] + x[9], 13);
          x[5] ^= R(x[1] + x[13], 18);
          x[14] ^= R(x[10] + x[6], 7);
          x[2] ^= R(x[14] + x[10], 9);
          x[6] ^= R(x[2] + x[14], 13);
          x[10] ^= R(x[6] + x[2], 18);
          x[3] ^= R(x[15] + x[11], 7);
          x[7] ^= R(x[3] + x[15], 9);
          x[11] ^= R(x[7] + x[3], 13);
          x[15] ^= R(x[11] + x[7], 18);
          x[1] ^= R(x[0] + x[3], 7);
          x[2] ^= R(x[1] + x[0], 9);
          x[3] ^= R(x[2] + x[1], 13);
          x[0] ^= R(x[3] + x[2], 18);
          x[6] ^= R(x[5] + x[4], 7);
          x[7] ^= R(x[6] + x[5], 9);
          x[4] ^= R(x[7] + x[6], 13);
          x[5] ^= R(x[4] + x[7], 18);
          x[11] ^= R(x[10] + x[9], 7);
          x[8] ^= R(x[11] + x[10], 9);
          x[9] ^= R(x[8] + x[11], 13);
          x[10] ^= R(x[9] + x[8], 18);
          x[12] ^= R(x[15] + x[14], 7);
          x[13] ^= R(x[12] + x[15], 9);
          x[14] ^= R(x[13] + x[12], 13);
          x[15] ^= R(x[14] + x[13], 18);
        }
        for (let i = 0; i < 16; ++i) {
          B[i] += x[i];
        }
      }
      function blockxor(S, Si, D, len) {
        for (let i = 0; i < len; i++) {
          D[i] ^= S[Si + i];
        }
      }
      function arraycopy(src, srcPos, dest, destPos, length3) {
        while (length3--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      function checkBufferish(o) {
        if (!o || typeof o.length !== "number") {
          return false;
        }
        for (let i = 0; i < o.length; i++) {
          const v = o[i];
          if (typeof v !== "number" || v % 1 || v < 0 || v >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value, name) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name);
        }
        return value;
      }
      function _scrypt(password, salt, N, r, p, dkLen, callback) {
        N = ensureInteger(N, "N");
        r = ensureInteger(r, "r");
        p = ensureInteger(p, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N === 0 || (N & N - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N > MAX_VALUE / 128 / r) {
          throw new Error("N too large");
        }
        if (r > MAX_VALUE / 128 / p) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r);
        for (let i = 0; i < B.length; i++) {
          const j = i * 4;
          B[i] = (b[j + 3] & 255) << 24 | (b[j + 2] & 255) << 16 | (b[j + 1] & 255) << 8 | (b[j + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);
        const Yi = 32 * r;
        const x = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        const limit = callback ? parseInt(1e3 / r) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state) {
            case 0:
              Bi = i0 * 32 * r;
              arraycopy(B, Bi, XY, 0, Yi);
              state = 1;
              i1 = 0;
            case 1:
              steps = N - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i = 0; i < steps; i++) {
                arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);
                blockmix_salsa8(XY, Yi, r, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps = N - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i = 0; i < steps; i++) {
                const offset = (2 * r - 1) * 16;
                const j = XY[offset] & N - 1;
                blockxor(V, j * Yi, XY, Yi);
                blockmix_salsa8(XY, Yi, r, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N) {
                break;
              }
              arraycopy(XY, 0, B, Bi, Yi);
              i0++;
              if (i0 < p) {
                state = 0;
                break;
              }
              b = [];
              for (let i = 0; i < B.length; i++) {
                b.push(B[i] >> 0 & 255);
                b.push(B[i] >> 8 & 255);
                b.push(B[i] >> 16 & 255);
                b.push(B[i] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
              if (error) {
                reject(error);
              } else if (key) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module2.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib/keystore.js
var require_keystore = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/keystore.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encrypt = exports.decrypt = exports.decryptSync = exports.KeystoreAccount = void 0;
    var aes_js_1 = __importDefault(require_aes_js());
    var scrypt_js_1 = __importDefault(require_scrypt());
    var address_1 = require_lib7();
    var bytes_1 = require_lib2();
    var hdnode_1 = require_lib23();
    var keccak256_1 = require_lib5();
    var pbkdf2_1 = require_lib20();
    var random_1 = require_lib24();
    var properties_1 = require_lib4();
    var transactions_1 = require_lib17();
    var utils_1 = require_utils4();
    var logger_1 = require_lib();
    var _version_1 = require_version18();
    var logger = new logger_1.Logger(_version_1.version);
    function hasMnemonic(value) {
      return value != null && value.mnemonic && value.mnemonic.phrase;
    }
    var KeystoreAccount = function(_super) {
      __extends(KeystoreAccount2, _super);
      function KeystoreAccount2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      KeystoreAccount2.prototype.isKeystoreAccount = function(value) {
        return !!(value && value._isKeystoreAccount);
      };
      return KeystoreAccount2;
    }(properties_1.Description);
    exports.KeystoreAccount = KeystoreAccount;
    function _decrypt(data, key, ciphertext) {
      var cipher = (0, utils_1.searchPath)(data, "crypto/cipher");
      if (cipher === "aes-128-ctr") {
        var iv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/cipherparams/iv"));
        var counter = new aes_js_1.default.Counter(iv);
        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);
        return (0, bytes_1.arrayify)(aesCtr.decrypt(ciphertext));
      }
      return null;
    }
    function _getAccount(data, key) {
      var ciphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/ciphertext"));
      var computedMAC = (0, bytes_1.hexlify)((0, keccak256_1.keccak256)((0, bytes_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
      if (computedMAC !== (0, utils_1.searchPath)(data, "crypto/mac").toLowerCase()) {
        throw new Error("invalid password");
      }
      var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
      if (!privateKey) {
        logger.throwError("unsupported cipher", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "decrypt"
        });
      }
      var mnemonicKey = key.slice(32, 64);
      var address = (0, transactions_1.computeAddress)(privateKey);
      if (data.address) {
        var check = data.address.toLowerCase();
        if (check.substring(0, 2) !== "0x") {
          check = "0x" + check;
        }
        if ((0, address_1.getAddress)(check) !== address) {
          throw new Error("address mismatch");
        }
      }
      var account = {
        _isKeystoreAccount: true,
        address,
        privateKey: (0, bytes_1.hexlify)(privateKey)
      };
      if ((0, utils_1.searchPath)(data, "x-ethers/version") === "0.1") {
        var mnemonicCiphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCiphertext"));
        var mnemonicIv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCounter"));
        var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
        var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        var path3 = (0, utils_1.searchPath)(data, "x-ethers/path") || hdnode_1.defaultPath;
        var locale = (0, utils_1.searchPath)(data, "x-ethers/locale") || "en";
        var entropy = (0, bytes_1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
        try {
          var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, locale);
          var node = hdnode_1.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path3);
          if (node.privateKey != account.privateKey) {
            throw new Error("mnemonic mismatch");
          }
          account.mnemonic = node.mnemonic;
        } catch (error) {
          if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
            throw error;
          }
        }
      }
      return new KeystoreAccount(account);
    }
    function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
      return (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
    }
    function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
      return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
    }
    function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
      var passwordBytes = (0, utils_1.getPassword)(password);
      var kdf = (0, utils_1.searchPath)(data, "crypto/kdf");
      if (kdf && typeof kdf === "string") {
        var throwError = function(name, value) {
          return logger.throwArgumentError("invalid key-derivation function parameters", name, value);
        };
        if (kdf.toLowerCase() === "scrypt") {
          var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
          var N = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/n"));
          var r = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/r"));
          var p = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/p"));
          if (!N || !r || !p) {
            throwError("kdf", kdf);
          }
          if ((N & N - 1) !== 0) {
            throwError("N", N);
          }
          var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
          if (dkLen !== 32) {
            throwError("dklen", dkLen);
          }
          return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
        } else if (kdf.toLowerCase() === "pbkdf2") {
          var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
          var prfFunc = null;
          var prf = (0, utils_1.searchPath)(data, "crypto/kdfparams/prf");
          if (prf === "hmac-sha256") {
            prfFunc = "sha256";
          } else if (prf === "hmac-sha512") {
            prfFunc = "sha512";
          } else {
            throwError("prf", prf);
          }
          var count = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/c"));
          var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
          if (dkLen !== 32) {
            throwError("dklen", dkLen);
          }
          return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
      }
      return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
    }
    function decryptSync(json, password) {
      var data = JSON.parse(json);
      var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt_js_1.default.syncScrypt);
      return _getAccount(data, key);
    }
    exports.decryptSync = decryptSync;
    function decrypt(json, password, progressCallback) {
      return __awaiter(this, void 0, void 0, function() {
        var data, key;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              data = JSON.parse(json);
              return [4, _computeKdfKey(data, password, pbkdf2, scrypt_js_1.default.scrypt, progressCallback)];
            case 1:
              key = _a.sent();
              return [2, _getAccount(data, key)];
          }
        });
      });
    }
    exports.decrypt = decrypt;
    function encrypt(account, password, options, progressCallback) {
      try {
        if ((0, address_1.getAddress)(account.address) !== (0, transactions_1.computeAddress)(account.privateKey)) {
          throw new Error("address/privateKey mismatch");
        }
        if (hasMnemonic(account)) {
          var mnemonic = account.mnemonic;
          var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || hdnode_1.defaultPath);
          if (node.privateKey != account.privateKey) {
            throw new Error("mnemonic mismatch");
          }
        }
      } catch (e) {
        return Promise.reject(e);
      }
      if (typeof options === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      var privateKey = (0, bytes_1.arrayify)(account.privateKey);
      var passwordBytes = (0, utils_1.getPassword)(password);
      var entropy = null;
      var path3 = null;
      var locale = null;
      if (hasMnemonic(account)) {
        var srcMnemonic = account.mnemonic;
        entropy = (0, bytes_1.arrayify)((0, hdnode_1.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
        path3 = srcMnemonic.path || hdnode_1.defaultPath;
        locale = srcMnemonic.locale || "en";
      }
      var client = options.client;
      if (!client) {
        client = "ethers.js";
      }
      var salt = null;
      if (options.salt) {
        salt = (0, bytes_1.arrayify)(options.salt);
      } else {
        salt = (0, random_1.randomBytes)(32);
        ;
      }
      var iv = null;
      if (options.iv) {
        iv = (0, bytes_1.arrayify)(options.iv);
        if (iv.length !== 16) {
          throw new Error("invalid iv");
        }
      } else {
        iv = (0, random_1.randomBytes)(16);
      }
      var uuidRandom = null;
      if (options.uuid) {
        uuidRandom = (0, bytes_1.arrayify)(options.uuid);
        if (uuidRandom.length !== 16) {
          throw new Error("invalid uuid");
        }
      } else {
        uuidRandom = (0, random_1.randomBytes)(16);
      }
      var N = 1 << 17, r = 8, p = 1;
      if (options.scrypt) {
        if (options.scrypt.N) {
          N = options.scrypt.N;
        }
        if (options.scrypt.r) {
          r = options.scrypt.r;
        }
        if (options.scrypt.p) {
          p = options.scrypt.p;
        }
      }
      return scrypt_js_1.default.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function(key) {
        key = (0, bytes_1.arrayify)(key);
        var derivedKey = key.slice(0, 16);
        var macPrefix = key.slice(16, 32);
        var mnemonicKey = key.slice(32, 64);
        var counter = new aes_js_1.default.Counter(iv);
        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);
        var ciphertext = (0, bytes_1.arrayify)(aesCtr.encrypt(privateKey));
        var mac = (0, keccak256_1.keccak256)((0, bytes_1.concat)([macPrefix, ciphertext]));
        var data = {
          address: account.address.substring(2).toLowerCase(),
          id: (0, utils_1.uuidV4)(uuidRandom),
          version: 3,
          crypto: {
            cipher: "aes-128-ctr",
            cipherparams: {
              iv: (0, bytes_1.hexlify)(iv).substring(2)
            },
            ciphertext: (0, bytes_1.hexlify)(ciphertext).substring(2),
            kdf: "scrypt",
            kdfparams: {
              salt: (0, bytes_1.hexlify)(salt).substring(2),
              n: N,
              dklen: 32,
              p,
              r
            },
            mac: mac.substring(2)
          }
        };
        if (entropy) {
          var mnemonicIv = (0, random_1.randomBytes)(16);
          var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
          var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
          var mnemonicCiphertext = (0, bytes_1.arrayify)(mnemonicAesCtr.encrypt(entropy));
          var now = new Date();
          var timestamp = now.getUTCFullYear() + "-" + (0, utils_1.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0, utils_1.zpad)(now.getUTCDate(), 2) + "T" + (0, utils_1.zpad)(now.getUTCHours(), 2) + "-" + (0, utils_1.zpad)(now.getUTCMinutes(), 2) + "-" + (0, utils_1.zpad)(now.getUTCSeconds(), 2) + ".0Z";
          data["x-ethers"] = {
            client,
            gethFilename: "UTC--" + timestamp + "--" + data.address,
            mnemonicCounter: (0, bytes_1.hexlify)(mnemonicIv).substring(2),
            mnemonicCiphertext: (0, bytes_1.hexlify)(mnemonicCiphertext).substring(2),
            path: path3,
            locale,
            version: "0.1"
          };
        }
        return JSON.stringify(data);
      });
    }
    exports.encrypt = encrypt;
  }
});

// node_modules/@ethersproject/json-wallets/lib/index.js
var require_lib25 = __commonJS({
  "node_modules/@ethersproject/json-wallets/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptJsonWalletSync = exports.decryptJsonWallet = exports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = exports.encryptKeystore = exports.decryptKeystoreSync = exports.decryptKeystore = exports.decryptCrowdsale = void 0;
    var crowdsale_1 = require_crowdsale();
    Object.defineProperty(exports, "decryptCrowdsale", { enumerable: true, get: function() {
      return crowdsale_1.decrypt;
    } });
    var inspect_1 = require_inspect();
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return inspect_1.getJsonWalletAddress;
    } });
    Object.defineProperty(exports, "isCrowdsaleWallet", { enumerable: true, get: function() {
      return inspect_1.isCrowdsaleWallet;
    } });
    Object.defineProperty(exports, "isKeystoreWallet", { enumerable: true, get: function() {
      return inspect_1.isKeystoreWallet;
    } });
    var keystore_1 = require_keystore();
    Object.defineProperty(exports, "decryptKeystore", { enumerable: true, get: function() {
      return keystore_1.decrypt;
    } });
    Object.defineProperty(exports, "decryptKeystoreSync", { enumerable: true, get: function() {
      return keystore_1.decryptSync;
    } });
    Object.defineProperty(exports, "encryptKeystore", { enumerable: true, get: function() {
      return keystore_1.encrypt;
    } });
    function decryptJsonWallet(json, password, progressCallback) {
      if ((0, inspect_1.isCrowdsaleWallet)(json)) {
        if (progressCallback) {
          progressCallback(0);
        }
        var account = (0, crowdsale_1.decrypt)(json, password);
        if (progressCallback) {
          progressCallback(1);
        }
        return Promise.resolve(account);
      }
      if ((0, inspect_1.isKeystoreWallet)(json)) {
        return (0, keystore_1.decrypt)(json, password, progressCallback);
      }
      return Promise.reject(new Error("invalid JSON wallet"));
    }
    exports.decryptJsonWallet = decryptJsonWallet;
    function decryptJsonWalletSync(json, password) {
      if ((0, inspect_1.isCrowdsaleWallet)(json)) {
        return (0, crowdsale_1.decrypt)(json, password);
      }
      if ((0, inspect_1.isKeystoreWallet)(json)) {
        return (0, keystore_1.decryptSync)(json, password);
      }
      throw new Error("invalid JSON wallet");
    }
    exports.decryptJsonWalletSync = decryptJsonWalletSync;
  }
});

// node_modules/@ethersproject/wallet/lib/_version.js
var require_version19 = __commonJS({
  "node_modules/@ethersproject/wallet/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "wallet/5.7.0";
  }
});

// node_modules/@ethersproject/wallet/lib/index.js
var require_lib26 = __commonJS({
  "node_modules/@ethersproject/wallet/lib/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = exports.verifyMessage = exports.Wallet = void 0;
    var address_1 = require_lib7();
    var abstract_provider_1 = require_lib14();
    var abstract_signer_1 = require_lib15();
    var bytes_1 = require_lib2();
    var hash_1 = require_lib12();
    var hdnode_1 = require_lib23();
    var keccak256_1 = require_lib5();
    var properties_1 = require_lib4();
    var random_1 = require_lib24();
    var signing_key_1 = require_lib16();
    var json_wallets_1 = require_lib25();
    var transactions_1 = require_lib17();
    var logger_1 = require_lib();
    var _version_1 = require_version19();
    var logger = new logger_1.Logger(_version_1.version);
    function isAccount(value) {
      return value != null && (0, bytes_1.isHexString)(value.privateKey, 32) && value.address != null;
    }
    function hasMnemonic(value) {
      var mnemonic = value.mnemonic;
      return mnemonic && mnemonic.phrase;
    }
    var Wallet = function(_super) {
      __extends(Wallet2, _super);
      function Wallet2(privateKey, provider) {
        var _this = _super.call(this) || this;
        if (isAccount(privateKey)) {
          var signingKey_1 = new signing_key_1.SigningKey(privateKey.privateKey);
          (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
            return signingKey_1;
          });
          (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
          if (_this.address !== (0, address_1.getAddress)(privateKey.address)) {
            logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic(privateKey)) {
            var srcMnemonic_1 = privateKey.mnemonic;
            (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
              return {
                phrase: srcMnemonic_1.phrase,
                path: srcMnemonic_1.path || hdnode_1.defaultPath,
                locale: srcMnemonic_1.locale || "en"
              };
            });
            var mnemonic = _this.mnemonic;
            var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if ((0, transactions_1.computeAddress)(node.privateKey) !== _this.address) {
              logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
              return null;
            });
          }
        } else {
          if (signing_key_1.SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
              return privateKey;
            });
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            var signingKey_2 = new signing_key_1.SigningKey(privateKey);
            (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
              return signingKey_2;
            });
          }
          (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
            return null;
          });
          (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
        }
        if (provider && !abstract_provider_1.Provider.isProvider(provider)) {
          logger.throwArgumentError("invalid provider", "provider", provider);
        }
        (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
        return _this;
      }
      Object.defineProperty(Wallet2.prototype, "mnemonic", {
        get: function() {
          return this._mnemonic();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Wallet2.prototype, "privateKey", {
        get: function() {
          return this._signingKey().privateKey;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Wallet2.prototype, "publicKey", {
        get: function() {
          return this._signingKey().publicKey;
        },
        enumerable: false,
        configurable: true
      });
      Wallet2.prototype.getAddress = function() {
        return Promise.resolve(this.address);
      };
      Wallet2.prototype.connect = function(provider) {
        return new Wallet2(this, provider);
      };
      Wallet2.prototype.signTransaction = function(transaction) {
        var _this = this;
        return (0, properties_1.resolveProperties)(transaction).then(function(tx) {
          if (tx.from != null) {
            if ((0, address_1.getAddress)(tx.from) !== _this.address) {
              logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          var signature = _this._signingKey().signDigest((0, keccak256_1.keccak256)((0, transactions_1.serialize)(tx)));
          return (0, transactions_1.serialize)(tx, signature);
        });
      };
      Wallet2.prototype.signMessage = function(message) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest((0, hash_1.hashMessage)(message)))];
          });
        });
      };
      Wallet2.prototype._signTypedData = function(domain, types, value) {
        return __awaiter(this, void 0, void 0, function() {
          var populated;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function(name) {
                  if (_this.provider == null) {
                    logger.throwError("cannot resolve ENS names without a provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                      operation: "resolveName",
                      value: name
                    });
                  }
                  return _this.provider.resolveName(name);
                })];
              case 1:
                populated = _a.sent();
                return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest(hash_1._TypedDataEncoder.hash(populated.domain, types, populated.value)))];
            }
          });
        });
      };
      Wallet2.prototype.encrypt = function(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return (0, json_wallets_1.encryptKeystore)(this, password, options, progressCallback);
      };
      Wallet2.createRandom = function(options) {
        var entropy = (0, random_1.randomBytes)(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = (0, bytes_1.arrayify)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([entropy, options.extraEntropy])), 0, 16));
        }
        var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, options.locale);
        return Wallet2.fromMnemonic(mnemonic, options.path, options.locale);
      };
      Wallet2.fromEncryptedJson = function(json, password, progressCallback) {
        return (0, json_wallets_1.decryptJsonWallet)(json, password, progressCallback).then(function(account) {
          return new Wallet2(account);
        });
      };
      Wallet2.fromEncryptedJsonSync = function(json, password) {
        return new Wallet2((0, json_wallets_1.decryptJsonWalletSync)(json, password));
      };
      Wallet2.fromMnemonic = function(mnemonic, path3, wordlist) {
        if (!path3) {
          path3 = hdnode_1.defaultPath;
        }
        return new Wallet2(hdnode_1.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path3));
      };
      return Wallet2;
    }(abstract_signer_1.Signer);
    exports.Wallet = Wallet;
    function verifyMessage(message, signature) {
      return (0, transactions_1.recoverAddress)((0, hash_1.hashMessage)(message), signature);
    }
    exports.verifyMessage = verifyMessage;
    function verifyTypedData(domain, types, value, signature) {
      return (0, transactions_1.recoverAddress)(hash_1._TypedDataEncoder.hash(domain, types, value), signature);
    }
    exports.verifyTypedData = verifyTypedData;
  }
});

// node_modules/@ethersproject/networks/lib/_version.js
var require_version20 = __commonJS({
  "node_modules/@ethersproject/networks/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "networks/5.7.1";
  }
});

// node_modules/@ethersproject/networks/lib/index.js
var require_lib27 = __commonJS({
  "node_modules/@ethersproject/networks/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNetwork = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version20();
    var logger = new logger_1.Logger(_version_1.version);
    function isRenetworkable(value) {
      return value && typeof value.renetwork === "function";
    }
    function ethDefaultProvider(network) {
      var func = function(providers2, options) {
        if (options == null) {
          options = {};
        }
        var providerList = [];
        if (providers2.InfuraProvider && options.infura !== "-") {
          try {
            providerList.push(new providers2.InfuraProvider(network, options.infura));
          } catch (error) {
          }
        }
        if (providers2.EtherscanProvider && options.etherscan !== "-") {
          try {
            providerList.push(new providers2.EtherscanProvider(network, options.etherscan));
          } catch (error) {
          }
        }
        if (providers2.AlchemyProvider && options.alchemy !== "-") {
          try {
            providerList.push(new providers2.AlchemyProvider(network, options.alchemy));
          } catch (error) {
          }
        }
        if (providers2.PocketProvider && options.pocket !== "-") {
          var skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
          try {
            var provider = new providers2.PocketProvider(network, options.pocket);
            if (provider.network && skip.indexOf(provider.network.name) === -1) {
              providerList.push(provider);
            }
          } catch (error) {
          }
        }
        if (providers2.CloudflareProvider && options.cloudflare !== "-") {
          try {
            providerList.push(new providers2.CloudflareProvider(network));
          } catch (error) {
          }
        }
        if (providers2.AnkrProvider && options.ankr !== "-") {
          try {
            var skip = ["ropsten"];
            var provider = new providers2.AnkrProvider(network, options.ankr);
            if (provider.network && skip.indexOf(provider.network.name) === -1) {
              providerList.push(provider);
            }
          } catch (error) {
          }
        }
        if (providerList.length === 0) {
          return null;
        }
        if (providers2.FallbackProvider) {
          var quorum = 1;
          if (options.quorum != null) {
            quorum = options.quorum;
          } else if (network === "homestead") {
            quorum = 2;
          }
          return new providers2.FallbackProvider(providerList, quorum);
        }
        return providerList[0];
      };
      func.renetwork = function(network2) {
        return ethDefaultProvider(network2);
      };
      return func;
    }
    function etcDefaultProvider(url2, network) {
      var func = function(providers2, options) {
        if (providers2.JsonRpcProvider) {
          return new providers2.JsonRpcProvider(url2, network);
        }
        return null;
      };
      func.renetwork = function(network2) {
        return etcDefaultProvider(url2, network2);
      };
      return func;
    }
    var homestead = {
      chainId: 1,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "homestead",
      _defaultProvider: ethDefaultProvider("homestead")
    };
    var ropsten = {
      chainId: 3,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "ropsten",
      _defaultProvider: ethDefaultProvider("ropsten")
    };
    var classicMordor = {
      chainId: 63,
      name: "classicMordor",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
    };
    var networks = {
      unspecified: { chainId: 0, name: "unspecified" },
      homestead,
      mainnet: homestead,
      morden: { chainId: 2, name: "morden" },
      ropsten,
      testnet: ropsten,
      rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
      },
      kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
      },
      goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
      },
      kintsugi: { chainId: 1337702, name: "kintsugi" },
      sepolia: {
        chainId: 11155111,
        name: "sepolia",
        _defaultProvider: ethDefaultProvider("sepolia")
      },
      classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
      },
      classicMorden: { chainId: 62, name: "classicMorden" },
      classicMordor,
      classicTestnet: classicMordor,
      classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
      },
      xdai: { chainId: 100, name: "xdai" },
      matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: ethDefaultProvider("matic")
      },
      maticmum: { chainId: 80001, name: "maticmum" },
      optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: ethDefaultProvider("optimism")
      },
      "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
      "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
      arbitrum: { chainId: 42161, name: "arbitrum" },
      "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
      "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
      bnb: { chainId: 56, name: "bnb" },
      bnbt: { chainId: 97, name: "bnbt" }
    };
    function getNetwork(network) {
      if (network == null) {
        return null;
      }
      if (typeof network === "number") {
        for (var name_1 in networks) {
          var standard_1 = networks[name_1];
          if (standard_1.chainId === network) {
            return {
              name: standard_1.name,
              chainId: standard_1.chainId,
              ensAddress: standard_1.ensAddress || null,
              _defaultProvider: standard_1._defaultProvider || null
            };
          }
        }
        return {
          chainId: network,
          name: "unknown"
        };
      }
      if (typeof network === "string") {
        var standard_2 = networks[network];
        if (standard_2 == null) {
          return null;
        }
        return {
          name: standard_2.name,
          chainId: standard_2.chainId,
          ensAddress: standard_2.ensAddress,
          _defaultProvider: standard_2._defaultProvider || null
        };
      }
      var standard = networks[network.name];
      if (!standard) {
        if (typeof network.chainId !== "number") {
          logger.throwArgumentError("invalid network chainId", "network", network);
        }
        return network;
      }
      if (network.chainId !== 0 && network.chainId !== standard.chainId) {
        logger.throwArgumentError("network chainId mismatch", "network", network);
      }
      var defaultProvider = network._defaultProvider || null;
      if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) {
          defaultProvider = standard._defaultProvider.renetwork(network);
        } else {
          defaultProvider = standard._defaultProvider;
        }
      }
      return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: network.ensAddress || standard.ensAddress || null,
        _defaultProvider: defaultProvider
      };
    }
    exports.getNetwork = getNetwork;
  }
});

// node_modules/@ethersproject/web/lib/_version.js
var require_version21 = __commonJS({
  "node_modules/@ethersproject/web/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "web/5.7.1";
  }
});

// node_modules/@ethersproject/web/lib/geturl.js
var require_geturl = __commonJS({
  "node_modules/@ethersproject/web/lib/geturl.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUrl = void 0;
    var http_1 = __importDefault(require("http"));
    var https_1 = __importDefault(require("https"));
    var zlib_1 = require("zlib");
    var url_1 = require("url");
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version21();
    var logger = new logger_1.Logger(_version_1.version);
    function getResponse(request2) {
      return new Promise(function(resolve, reject) {
        request2.once("response", function(resp) {
          var response = {
            statusCode: resp.statusCode,
            statusMessage: resp.statusMessage,
            headers: Object.keys(resp.headers).reduce(function(accum, name) {
              var value = resp.headers[name];
              if (Array.isArray(value)) {
                value = value.join(", ");
              }
              accum[name] = value;
              return accum;
            }, {}),
            body: null
          };
          resp.on("data", function(chunk) {
            if (response.body == null) {
              response.body = new Uint8Array(0);
            }
            response.body = (0, bytes_1.concat)([response.body, chunk]);
          });
          resp.on("end", function() {
            if (response.headers["content-encoding"] === "gzip") {
              response.body = (0, bytes_1.arrayify)((0, zlib_1.gunzipSync)(response.body));
            }
            resolve(response);
          });
          resp.on("error", function(error) {
            error.response = response;
            reject(error);
          });
        });
        request2.on("error", function(error) {
          reject(error);
        });
      });
    }
    function nonnull(value) {
      if (value == null) {
        return "";
      }
      return value;
    }
    function getUrl(href, options) {
      return __awaiter(this, void 0, void 0, function() {
        var url2, request2, req, response;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (options == null) {
                options = {};
              }
              url2 = (0, url_1.parse)(href);
              request2 = {
                protocol: nonnull(url2.protocol),
                hostname: nonnull(url2.hostname),
                port: nonnull(url2.port),
                path: nonnull(url2.pathname) + nonnull(url2.search),
                method: options.method || "GET",
                headers: (0, properties_1.shallowCopy)(options.headers || {})
              };
              if (options.allowGzip) {
                request2.headers["accept-encoding"] = "gzip";
              }
              req = null;
              switch (nonnull(url2.protocol)) {
                case "http:":
                  req = http_1.default.request(request2);
                  break;
                case "https:":
                  req = https_1.default.request(request2);
                  break;
                default:
                  logger.throwError("unsupported protocol " + url2.protocol, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    protocol: url2.protocol,
                    operation: "request"
                  });
              }
              if (options.body) {
                req.write(Buffer.from(options.body));
              }
              req.end();
              return [4, getResponse(req)];
            case 1:
              response = _a.sent();
              return [2, response];
          }
        });
      });
    }
    exports.getUrl = getUrl;
  }
});

// node_modules/@ethersproject/web/lib/index.js
var require_lib28 = __commonJS({
  "node_modules/@ethersproject/web/lib/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poll = exports.fetchJson = exports._fetchData = void 0;
    var base64_1 = require_lib10();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var strings_1 = require_lib9();
    var logger_1 = require_lib();
    var _version_1 = require_version21();
    var logger = new logger_1.Logger(_version_1.version);
    var geturl_1 = require_geturl();
    function staller(duration) {
      return new Promise(function(resolve) {
        setTimeout(resolve, duration);
      });
    }
    function bodyify(value, type) {
      if (value == null) {
        return null;
      }
      if (typeof value === "string") {
        return value;
      }
      if ((0, bytes_1.isBytesLike)(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
          try {
            return (0, strings_1.toUtf8String)(value);
          } catch (error) {
          }
          ;
        }
        return (0, bytes_1.hexlify)(value);
      }
      return value;
    }
    function unpercent(value) {
      return (0, strings_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function(all3, code) {
        return String.fromCharCode(parseInt(code, 16));
      }));
    }
    function _fetchData(connection, body, processFunc) {
      var attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
      logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
      var throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
      var throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
      logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
      var errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
      var headers = {};
      var url2 = null;
      var options = {
        method: "GET"
      };
      var allow304 = false;
      var timeout = 2 * 60 * 1e3;
      if (typeof connection === "string") {
        url2 = connection;
      } else if (typeof connection === "object") {
        if (connection == null || connection.url == null) {
          logger.throwArgumentError("missing URL", "connection.url", connection);
        }
        url2 = connection.url;
        if (typeof connection.timeout === "number" && connection.timeout > 0) {
          timeout = connection.timeout;
        }
        if (connection.headers) {
          for (var key in connection.headers) {
            headers[key.toLowerCase()] = { key, value: String(connection.headers[key]) };
            if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
              allow304 = true;
            }
          }
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
          if (url2.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
            logger.throwError("basic authentication requires a secure https url", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "url", url: url2, user: connection.user, password: "[REDACTED]" });
          }
          var authorization = connection.user + ":" + connection.password;
          headers["authorization"] = {
            key: "Authorization",
            value: "Basic " + (0, base64_1.encode)((0, strings_1.toUtf8Bytes)(authorization))
          };
        }
        if (connection.skipFetchSetup != null) {
          options.skipFetchSetup = !!connection.skipFetchSetup;
        }
        if (connection.fetchOptions != null) {
          options.fetchOptions = (0, properties_1.shallowCopy)(connection.fetchOptions);
        }
      }
      var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
      var dataMatch = url2 ? url2.match(reData) : null;
      if (dataMatch) {
        try {
          var response = {
            statusCode: 200,
            statusMessage: "OK",
            headers: { "content-type": dataMatch[1] || "text/plain" },
            body: dataMatch[2] ? (0, base64_1.decode)(dataMatch[3]) : unpercent(dataMatch[3])
          };
          var result = response.body;
          if (processFunc) {
            result = processFunc(response.body, response);
          }
          return Promise.resolve(result);
        } catch (error) {
          logger.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
            body: bodyify(dataMatch[1], dataMatch[2]),
            error,
            requestBody: null,
            requestMethod: "GET",
            url: url2
          });
        }
      }
      if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) {
          headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
        }
        if (headers["content-length"] == null) {
          headers["content-length"] = { key: "Content-Length", value: String(body.length) };
        }
      }
      var flatHeaders = {};
      Object.keys(headers).forEach(function(key2) {
        var header = headers[key2];
        flatHeaders[header.key] = header.value;
      });
      options.headers = flatHeaders;
      var runningTimeout = function() {
        var timer = null;
        var promise = new Promise(function(resolve, reject) {
          if (timeout) {
            timer = setTimeout(function() {
              if (timer == null) {
                return;
              }
              timer = null;
              reject(logger.makeError("timeout", logger_1.Logger.errors.TIMEOUT, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                timeout,
                url: url2
              }));
            }, timeout);
          }
        });
        var cancel = function() {
          if (timer == null) {
            return;
          }
          clearTimeout(timer);
          timer = null;
        };
        return { promise, cancel };
      }();
      var runningFetch = function() {
        return __awaiter(this, void 0, void 0, function() {
          var attempt, response2, location_1, tryAgain, stall, retryAfter, error_1, body_1, result2, error_2, tryAgain, timeout_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                attempt = 0;
                _a.label = 1;
              case 1:
                if (!(attempt < attemptLimit))
                  return [3, 20];
                response2 = null;
                _a.label = 2;
              case 2:
                _a.trys.push([2, 9, , 10]);
                return [4, (0, geturl_1.getUrl)(url2, options)];
              case 3:
                response2 = _a.sent();
                if (!(attempt < attemptLimit))
                  return [3, 8];
                if (!(response2.statusCode === 301 || response2.statusCode === 302))
                  return [3, 4];
                location_1 = response2.headers.location || "";
                if (options.method === "GET" && location_1.match(/^https:/)) {
                  url2 = response2.headers.location;
                  return [3, 19];
                }
                return [3, 8];
              case 4:
                if (!(response2.statusCode === 429))
                  return [3, 8];
                tryAgain = true;
                if (!throttleCallback)
                  return [3, 6];
                return [4, throttleCallback(attempt, url2)];
              case 5:
                tryAgain = _a.sent();
                _a.label = 6;
              case 6:
                if (!tryAgain)
                  return [3, 8];
                stall = 0;
                retryAfter = response2.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall = parseInt(retryAfter) * 1e3;
                } else {
                  stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                return [4, staller(stall)];
              case 7:
                _a.sent();
                return [3, 19];
              case 8:
                return [3, 10];
              case 9:
                error_1 = _a.sent();
                response2 = error_1.response;
                if (response2 == null) {
                  runningTimeout.cancel();
                  logger.throwError("missing response", logger_1.Logger.errors.SERVER_ERROR, {
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    serverError: error_1,
                    url: url2
                  });
                }
                return [3, 10];
              case 10:
                body_1 = response2.body;
                if (allow304 && response2.statusCode === 304) {
                  body_1 = null;
                } else if (!errorPassThrough && (response2.statusCode < 200 || response2.statusCode >= 300)) {
                  runningTimeout.cancel();
                  logger.throwError("bad response", logger_1.Logger.errors.SERVER_ERROR, {
                    status: response2.statusCode,
                    headers: response2.headers,
                    body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    url: url2
                  });
                }
                if (!processFunc)
                  return [3, 18];
                _a.label = 11;
              case 11:
                _a.trys.push([11, 13, , 18]);
                return [4, processFunc(body_1, response2)];
              case 12:
                result2 = _a.sent();
                runningTimeout.cancel();
                return [2, result2];
              case 13:
                error_2 = _a.sent();
                if (!(error_2.throttleRetry && attempt < attemptLimit))
                  return [3, 17];
                tryAgain = true;
                if (!throttleCallback)
                  return [3, 15];
                return [4, throttleCallback(attempt, url2)];
              case 14:
                tryAgain = _a.sent();
                _a.label = 15;
              case 15:
                if (!tryAgain)
                  return [3, 17];
                timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                return [4, staller(timeout_1)];
              case 16:
                _a.sent();
                return [3, 19];
              case 17:
                runningTimeout.cancel();
                logger.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
                  body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                  error: error_2,
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url: url2
                });
                return [3, 18];
              case 18:
                runningTimeout.cancel();
                return [2, body_1];
              case 19:
                attempt++;
                return [3, 1];
              case 20:
                return [2, logger.throwError("failed response", logger_1.Logger.errors.SERVER_ERROR, {
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url: url2
                })];
            }
          });
        });
      }();
      return Promise.race([runningTimeout.promise, runningFetch]);
    }
    exports._fetchData = _fetchData;
    function fetchJson(connection, json, processFunc) {
      var processJsonFunc = function(value, response) {
        var result = null;
        if (value != null) {
          try {
            result = JSON.parse((0, strings_1.toUtf8String)(value));
          } catch (error) {
            logger.throwError("invalid JSON", logger_1.Logger.errors.SERVER_ERROR, {
              body: value,
              error
            });
          }
        }
        if (processFunc) {
          result = processFunc(result, response);
        }
        return result;
      };
      var body = null;
      if (json != null) {
        body = (0, strings_1.toUtf8Bytes)(json);
        var updated = typeof connection === "string" ? { url: connection } : (0, properties_1.shallowCopy)(connection);
        if (updated.headers) {
          var hasContentType = Object.keys(updated.headers).filter(function(k) {
            return k.toLowerCase() === "content-type";
          }).length !== 0;
          if (!hasContentType) {
            updated.headers = (0, properties_1.shallowCopy)(updated.headers);
            updated.headers["content-type"] = "application/json";
          }
        } else {
          updated.headers = { "content-type": "application/json" };
        }
        connection = updated;
      }
      return _fetchData(connection, body, processJsonFunc);
    }
    exports.fetchJson = fetchJson;
    function poll(func, options) {
      if (!options) {
        options = {};
      }
      options = (0, properties_1.shallowCopy)(options);
      if (options.floor == null) {
        options.floor = 0;
      }
      if (options.ceiling == null) {
        options.ceiling = 1e4;
      }
      if (options.interval == null) {
        options.interval = 250;
      }
      return new Promise(function(resolve, reject) {
        var timer = null;
        var done = false;
        var cancel = function() {
          if (done) {
            return false;
          }
          done = true;
          if (timer) {
            clearTimeout(timer);
          }
          return true;
        };
        if (options.timeout) {
          timer = setTimeout(function() {
            if (cancel()) {
              reject(new Error("timeout"));
            }
          }, options.timeout);
        }
        var retryLimit = options.retryLimit;
        var attempt = 0;
        function check() {
          return func().then(function(result) {
            if (result !== void 0) {
              if (cancel()) {
                resolve(result);
              }
            } else if (options.oncePoll) {
              options.oncePoll.once("poll", check);
            } else if (options.onceBlock) {
              options.onceBlock.once("block", check);
            } else if (!done) {
              attempt++;
              if (attempt > retryLimit) {
                if (cancel()) {
                  reject(new Error("retry limit reached"));
                }
                return;
              }
              var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
              if (timeout < options.floor) {
                timeout = options.floor;
              }
              if (timeout > options.ceiling) {
                timeout = options.ceiling;
              }
              setTimeout(check, timeout);
            }
            return null;
          }, function(error) {
            if (cancel()) {
              reject(error);
            }
          });
        }
        check();
      });
    }
    exports.poll = poll;
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports, module2) {
    "use strict";
    var ALPHABET2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET2.length; z++) {
      x = ALPHABET2.charAt(z);
      if (ALPHABET_MAP[x] !== void 0)
        throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c3 = prefix.charCodeAt(i);
        if (c3 < 33 || c3 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c3 >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode5(prefix, words, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i = 0; i < words.length; ++i) {
        var x2 = words[i];
        if (x2 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result += ALPHABET2.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result += ALPHABET2.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c3 = wordChars.charAt(i);
        var v = ALPHABET_MAP[c3];
        if (v === void 0)
          return "Unknown character " + c3;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length)
          continue;
        words.push(v);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode2(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad2) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i = 0; i < data.length; ++i) {
        value = value << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad2) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      var res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module2.exports = {
      decodeUnsafe,
      decode: decode2,
      encode: encode5,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/@ethersproject/providers/lib/_version.js
var require_version22 = __commonJS({
  "node_modules/@ethersproject/providers/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "providers/5.7.2";
  }
});

// node_modules/@ethersproject/providers/lib/formatter.js
var require_formatter = __commonJS({
  "node_modules/@ethersproject/providers/lib/formatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.showThrottleMessage = exports.isCommunityResource = exports.isCommunityResourcable = exports.Formatter = void 0;
    var address_1 = require_lib7();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var constants_1 = require_lib8();
    var properties_1 = require_lib4();
    var transactions_1 = require_lib17();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var Formatter = function() {
      function Formatter2() {
        this.formats = this.getDefaultFormats();
      }
      Formatter2.prototype.getDefaultFormats = function() {
        var _this = this;
        var formats = {};
        var address = this.address.bind(this);
        var bigNumber = this.bigNumber.bind(this);
        var blockTag = this.blockTag.bind(this);
        var data = this.data.bind(this);
        var hash = this.hash.bind(this);
        var hex = this.hex.bind(this);
        var number = this.number.bind(this);
        var type = this.type.bind(this);
        var strictData = function(v) {
          return _this.data(v, true);
        };
        formats.transaction = {
          hash,
          type,
          accessList: Formatter2.allowNull(this.accessList.bind(this), null),
          blockHash: Formatter2.allowNull(hash, null),
          blockNumber: Formatter2.allowNull(number, null),
          transactionIndex: Formatter2.allowNull(number, null),
          confirmations: Formatter2.allowNull(number, null),
          from: address,
          gasPrice: Formatter2.allowNull(bigNumber),
          maxPriorityFeePerGas: Formatter2.allowNull(bigNumber),
          maxFeePerGas: Formatter2.allowNull(bigNumber),
          gasLimit: bigNumber,
          to: Formatter2.allowNull(address, null),
          value: bigNumber,
          nonce: number,
          data,
          r: Formatter2.allowNull(this.uint256),
          s: Formatter2.allowNull(this.uint256),
          v: Formatter2.allowNull(number),
          creates: Formatter2.allowNull(address, null),
          raw: Formatter2.allowNull(data)
        };
        formats.transactionRequest = {
          from: Formatter2.allowNull(address),
          nonce: Formatter2.allowNull(number),
          gasLimit: Formatter2.allowNull(bigNumber),
          gasPrice: Formatter2.allowNull(bigNumber),
          maxPriorityFeePerGas: Formatter2.allowNull(bigNumber),
          maxFeePerGas: Formatter2.allowNull(bigNumber),
          to: Formatter2.allowNull(address),
          value: Formatter2.allowNull(bigNumber),
          data: Formatter2.allowNull(strictData),
          type: Formatter2.allowNull(number),
          accessList: Formatter2.allowNull(this.accessList.bind(this), null)
        };
        formats.receiptLog = {
          transactionIndex: number,
          blockNumber: number,
          transactionHash: hash,
          address,
          topics: Formatter2.arrayOf(hash),
          data,
          logIndex: number,
          blockHash: hash
        };
        formats.receipt = {
          to: Formatter2.allowNull(this.address, null),
          from: Formatter2.allowNull(this.address, null),
          contractAddress: Formatter2.allowNull(address, null),
          transactionIndex: number,
          root: Formatter2.allowNull(hex),
          gasUsed: bigNumber,
          logsBloom: Formatter2.allowNull(data),
          blockHash: hash,
          transactionHash: hash,
          logs: Formatter2.arrayOf(this.receiptLog.bind(this)),
          blockNumber: number,
          confirmations: Formatter2.allowNull(number, null),
          cumulativeGasUsed: bigNumber,
          effectiveGasPrice: Formatter2.allowNull(bigNumber),
          status: Formatter2.allowNull(number),
          type
        };
        formats.block = {
          hash: Formatter2.allowNull(hash),
          parentHash: hash,
          number,
          timestamp: number,
          nonce: Formatter2.allowNull(hex),
          difficulty: this.difficulty.bind(this),
          gasLimit: bigNumber,
          gasUsed: bigNumber,
          miner: Formatter2.allowNull(address),
          extraData: data,
          transactions: Formatter2.allowNull(Formatter2.arrayOf(hash)),
          baseFeePerGas: Formatter2.allowNull(bigNumber)
        };
        formats.blockWithTransactions = (0, properties_1.shallowCopy)(formats.block);
        formats.blockWithTransactions.transactions = Formatter2.allowNull(Formatter2.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
          fromBlock: Formatter2.allowNull(blockTag, void 0),
          toBlock: Formatter2.allowNull(blockTag, void 0),
          blockHash: Formatter2.allowNull(hash, void 0),
          address: Formatter2.allowNull(address, void 0),
          topics: Formatter2.allowNull(this.topics.bind(this), void 0)
        };
        formats.filterLog = {
          blockNumber: Formatter2.allowNull(number),
          blockHash: Formatter2.allowNull(hash),
          transactionIndex: number,
          removed: Formatter2.allowNull(this.boolean.bind(this)),
          address,
          data: Formatter2.allowFalsish(data, "0x"),
          topics: Formatter2.arrayOf(hash),
          transactionHash: hash,
          logIndex: number
        };
        return formats;
      };
      Formatter2.prototype.accessList = function(accessList) {
        return (0, transactions_1.accessListify)(accessList || []);
      };
      Formatter2.prototype.number = function(number) {
        if (number === "0x") {
          return 0;
        }
        return bignumber_1.BigNumber.from(number).toNumber();
      };
      Formatter2.prototype.type = function(number) {
        if (number === "0x" || number == null) {
          return 0;
        }
        return bignumber_1.BigNumber.from(number).toNumber();
      };
      Formatter2.prototype.bigNumber = function(value) {
        return bignumber_1.BigNumber.from(value);
      };
      Formatter2.prototype.boolean = function(value) {
        if (typeof value === "boolean") {
          return value;
        }
        if (typeof value === "string") {
          value = value.toLowerCase();
          if (value === "true") {
            return true;
          }
          if (value === "false") {
            return false;
          }
        }
        throw new Error("invalid boolean - " + value);
      };
      Formatter2.prototype.hex = function(value, strict) {
        if (typeof value === "string") {
          if (!strict && value.substring(0, 2) !== "0x") {
            value = "0x" + value;
          }
          if ((0, bytes_1.isHexString)(value)) {
            return value.toLowerCase();
          }
        }
        return logger.throwArgumentError("invalid hash", "value", value);
      };
      Formatter2.prototype.data = function(value, strict) {
        var result = this.hex(value, strict);
        if (result.length % 2 !== 0) {
          throw new Error("invalid data; odd-length - " + value);
        }
        return result;
      };
      Formatter2.prototype.address = function(value) {
        return (0, address_1.getAddress)(value);
      };
      Formatter2.prototype.callAddress = function(value) {
        if (!(0, bytes_1.isHexString)(value, 32)) {
          return null;
        }
        var address = (0, address_1.getAddress)((0, bytes_1.hexDataSlice)(value, 12));
        return address === constants_1.AddressZero ? null : address;
      };
      Formatter2.prototype.contractAddress = function(value) {
        return (0, address_1.getContractAddress)(value);
      };
      Formatter2.prototype.blockTag = function(blockTag) {
        if (blockTag == null) {
          return "latest";
        }
        if (blockTag === "earliest") {
          return "0x0";
        }
        switch (blockTag) {
          case "earliest":
            return "0x0";
          case "latest":
          case "pending":
          case "safe":
          case "finalized":
            return blockTag;
        }
        if (typeof blockTag === "number" || (0, bytes_1.isHexString)(blockTag)) {
          return (0, bytes_1.hexValue)(blockTag);
        }
        throw new Error("invalid blockTag");
      };
      Formatter2.prototype.hash = function(value, strict) {
        var result = this.hex(value, strict);
        if ((0, bytes_1.hexDataLength)(result) !== 32) {
          return logger.throwArgumentError("invalid hash", "value", value);
        }
        return result;
      };
      Formatter2.prototype.difficulty = function(value) {
        if (value == null) {
          return null;
        }
        var v = bignumber_1.BigNumber.from(value);
        try {
          return v.toNumber();
        } catch (error) {
        }
        return null;
      };
      Formatter2.prototype.uint256 = function(value) {
        if (!(0, bytes_1.isHexString)(value)) {
          throw new Error("invalid uint256");
        }
        return (0, bytes_1.hexZeroPad)(value, 32);
      };
      Formatter2.prototype._block = function(value, format) {
        if (value.author != null && value.miner == null) {
          value.miner = value.author;
        }
        var difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
        var result = Formatter2.check(format, value);
        result._difficulty = difficulty == null ? null : bignumber_1.BigNumber.from(difficulty);
        return result;
      };
      Formatter2.prototype.block = function(value) {
        return this._block(value, this.formats.block);
      };
      Formatter2.prototype.blockWithTransactions = function(value) {
        return this._block(value, this.formats.blockWithTransactions);
      };
      Formatter2.prototype.transactionRequest = function(value) {
        return Formatter2.check(this.formats.transactionRequest, value);
      };
      Formatter2.prototype.transactionResponse = function(transaction) {
        if (transaction.gas != null && transaction.gasLimit == null) {
          transaction.gasLimit = transaction.gas;
        }
        if (transaction.to && bignumber_1.BigNumber.from(transaction.to).isZero()) {
          transaction.to = "0x0000000000000000000000000000000000000000";
        }
        if (transaction.input != null && transaction.data == null) {
          transaction.data = transaction.input;
        }
        if (transaction.to == null && transaction.creates == null) {
          transaction.creates = this.contractAddress(transaction);
        }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
          transaction.accessList = [];
        }
        var result = Formatter2.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
          var chainId = transaction.chainId;
          if ((0, bytes_1.isHexString)(chainId)) {
            chainId = bignumber_1.BigNumber.from(chainId).toNumber();
          }
          result.chainId = chainId;
        } else {
          var chainId = transaction.networkId;
          if (chainId == null && result.v == null) {
            chainId = transaction.chainId;
          }
          if ((0, bytes_1.isHexString)(chainId)) {
            chainId = bignumber_1.BigNumber.from(chainId).toNumber();
          }
          if (typeof chainId !== "number" && result.v != null) {
            chainId = (result.v - 35) / 2;
            if (chainId < 0) {
              chainId = 0;
            }
            chainId = parseInt(chainId);
          }
          if (typeof chainId !== "number") {
            chainId = 0;
          }
          result.chainId = chainId;
        }
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
          result.blockHash = null;
        }
        return result;
      };
      Formatter2.prototype.transaction = function(value) {
        return (0, transactions_1.parse)(value);
      };
      Formatter2.prototype.receiptLog = function(value) {
        return Formatter2.check(this.formats.receiptLog, value);
      };
      Formatter2.prototype.receipt = function(value) {
        var result = Formatter2.check(this.formats.receipt, value);
        if (result.root != null) {
          if (result.root.length <= 4) {
            var value_1 = bignumber_1.BigNumber.from(result.root).toNumber();
            if (value_1 === 0 || value_1 === 1) {
              if (result.status != null && result.status !== value_1) {
                logger.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
              }
              result.status = value_1;
              delete result.root;
            } else {
              logger.throwArgumentError("invalid alt-root-status", "value.root", result.root);
            }
          } else if (result.root.length !== 66) {
            logger.throwArgumentError("invalid root hash", "value.root", result.root);
          }
        }
        if (result.status != null) {
          result.byzantium = true;
        }
        return result;
      };
      Formatter2.prototype.topics = function(value) {
        var _this = this;
        if (Array.isArray(value)) {
          return value.map(function(v) {
            return _this.topics(v);
          });
        } else if (value != null) {
          return this.hash(value, true);
        }
        return null;
      };
      Formatter2.prototype.filter = function(value) {
        return Formatter2.check(this.formats.filter, value);
      };
      Formatter2.prototype.filterLog = function(value) {
        return Formatter2.check(this.formats.filterLog, value);
      };
      Formatter2.check = function(format, object) {
        var result = {};
        for (var key in format) {
          try {
            var value = format[key](object[key]);
            if (value !== void 0) {
              result[key] = value;
            }
          } catch (error) {
            error.checkKey = key;
            error.checkValue = object[key];
            throw error;
          }
        }
        return result;
      };
      Formatter2.allowNull = function(format, nullValue) {
        return function(value) {
          if (value == null) {
            return nullValue;
          }
          return format(value);
        };
      };
      Formatter2.allowFalsish = function(format, replaceValue) {
        return function(value) {
          if (!value) {
            return replaceValue;
          }
          return format(value);
        };
      };
      Formatter2.arrayOf = function(format) {
        return function(array) {
          if (!Array.isArray(array)) {
            throw new Error("not an array");
          }
          var result = [];
          array.forEach(function(value) {
            result.push(format(value));
          });
          return result;
        };
      };
      return Formatter2;
    }();
    exports.Formatter = Formatter;
    function isCommunityResourcable(value) {
      return value && typeof value.isCommunityResource === "function";
    }
    exports.isCommunityResourcable = isCommunityResourcable;
    function isCommunityResource(value) {
      return isCommunityResourcable(value) && value.isCommunityResource();
    }
    exports.isCommunityResource = isCommunityResource;
    var throttleMessage = false;
    function showThrottleMessage() {
      if (throttleMessage) {
        return;
      }
      throttleMessage = true;
      console.log("========= NOTICE =========");
      console.log("Request-Rate Exceeded  (this message will not be repeated)");
      console.log("");
      console.log("The default API keys for each service are provided as a highly-throttled,");
      console.log("community resource for low-traffic projects and early prototyping.");
      console.log("");
      console.log("While your application will continue to function, we highly recommended");
      console.log("signing up for your own API keys to improve performance, increase your");
      console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
      console.log("");
      console.log("For more details: https://docs.ethers.io/api-keys/");
      console.log("==========================");
    }
    exports.showThrottleMessage = showThrottleMessage;
  }
});

// node_modules/@ethersproject/providers/lib/base-provider.js
var require_base_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/base-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseProvider = exports.Resolver = exports.Event = void 0;
    var abstract_provider_1 = require_lib14();
    var base64_1 = require_lib10();
    var basex_1 = require_lib19();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var constants_1 = require_lib8();
    var hash_1 = require_lib12();
    var networks_1 = require_lib27();
    var properties_1 = require_lib4();
    var sha2_1 = require_lib21();
    var strings_1 = require_lib9();
    var web_1 = require_lib28();
    var bech32_1 = __importDefault(require_bech32());
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var formatter_1 = require_formatter();
    var MAX_CCIP_REDIRECTS = 10;
    function checkTopic(topic) {
      if (topic == null) {
        return "null";
      }
      if ((0, bytes_1.hexDataLength)(topic) !== 32) {
        logger.throwArgumentError("invalid topic", "topic", topic);
      }
      return topic.toLowerCase();
    }
    function serializeTopics(topics) {
      topics = topics.slice();
      while (topics.length > 0 && topics[topics.length - 1] == null) {
        topics.pop();
      }
      return topics.map(function(topic) {
        if (Array.isArray(topic)) {
          var unique_1 = {};
          topic.forEach(function(topic2) {
            unique_1[checkTopic(topic2)] = true;
          });
          var sorted = Object.keys(unique_1);
          sorted.sort();
          return sorted.join("|");
        } else {
          return checkTopic(topic);
        }
      }).join("&");
    }
    function deserializeTopics(data) {
      if (data === "") {
        return [];
      }
      return data.split(/&/g).map(function(topic) {
        if (topic === "") {
          return [];
        }
        var comps = topic.split("|").map(function(topic2) {
          return topic2 === "null" ? null : topic2;
        });
        return comps.length === 1 ? comps[0] : comps;
      });
    }
    function getEventTag(eventName) {
      if (typeof eventName === "string") {
        eventName = eventName.toLowerCase();
        if ((0, bytes_1.hexDataLength)(eventName) === 32) {
          return "tx:" + eventName;
        }
        if (eventName.indexOf(":") === -1) {
          return eventName;
        }
      } else if (Array.isArray(eventName)) {
        return "filter:*:" + serializeTopics(eventName);
      } else if (abstract_provider_1.ForkEvent.isForkEvent(eventName)) {
        logger.warn("not implemented");
        throw new Error("not implemented");
      } else if (eventName && typeof eventName === "object") {
        return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
      }
      throw new Error("invalid event - " + eventName);
    }
    function getTime() {
      return new Date().getTime();
    }
    function stall(duration) {
      return new Promise(function(resolve) {
        setTimeout(resolve, duration);
      });
    }
    var PollableEvents = ["block", "network", "pending", "poll"];
    var Event = function() {
      function Event2(tag, listener, once) {
        (0, properties_1.defineReadOnly)(this, "tag", tag);
        (0, properties_1.defineReadOnly)(this, "listener", listener);
        (0, properties_1.defineReadOnly)(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
      }
      Object.defineProperty(Event2.prototype, "event", {
        get: function() {
          switch (this.type) {
            case "tx":
              return this.hash;
            case "filter":
              return this.filter;
          }
          return this.tag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Event2.prototype, "type", {
        get: function() {
          return this.tag.split(":")[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Event2.prototype, "hash", {
        get: function() {
          var comps = this.tag.split(":");
          if (comps[0] !== "tx") {
            return null;
          }
          return comps[1];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Event2.prototype, "filter", {
        get: function() {
          var comps = this.tag.split(":");
          if (comps[0] !== "filter") {
            return null;
          }
          var address = comps[1];
          var topics = deserializeTopics(comps[2]);
          var filter2 = {};
          if (topics.length > 0) {
            filter2.topics = topics;
          }
          if (address && address !== "*") {
            filter2.address = address;
          }
          return filter2;
        },
        enumerable: false,
        configurable: true
      });
      Event2.prototype.pollable = function() {
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
      };
      return Event2;
    }();
    exports.Event = Event;
    var coinInfos = {
      "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
      "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
      "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
      "60": { symbol: "eth", ilk: "eth" },
      "61": { symbol: "etc", ilk: "eth" },
      "700": { symbol: "xdai", ilk: "eth" }
    };
    function bytes32ify(value) {
      return (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(value).toHexString(), 32);
    }
    function base58Encode(data) {
      return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));
    }
    var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
    var matchers = [
      new RegExp("^(https)://(.*)$", "i"),
      new RegExp("^(data):(.*)$", "i"),
      matcherIpfs,
      new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
    ];
    function _parseString(result, start) {
      try {
        return (0, strings_1.toUtf8String)(_parseBytes(result, start));
      } catch (error) {
      }
      return null;
    }
    function _parseBytes(result, start) {
      if (result === "0x") {
        return null;
      }
      var offset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, start, start + 32)).toNumber();
      var length3 = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, offset, offset + 32)).toNumber();
      return (0, bytes_1.hexDataSlice)(result, offset + 32, offset + 32 + length3);
    }
    function getIpfsLink(link) {
      if (link.match(/^ipfs:\/\/ipfs\//i)) {
        link = link.substring(12);
      } else if (link.match(/^ipfs:\/\//i)) {
        link = link.substring(7);
      } else {
        logger.throwArgumentError("unsupported IPFS format", "link", link);
      }
      return "https://gateway.ipfs.io/ipfs/" + link;
    }
    function numPad(value) {
      var result = (0, bytes_1.arrayify)(value);
      if (result.length > 32) {
        throw new Error("internal; should not happen");
      }
      var padded = new Uint8Array(32);
      padded.set(result, 32 - result.length);
      return padded;
    }
    function bytesPad(value) {
      if (value.length % 32 === 0) {
        return value;
      }
      var result = new Uint8Array(Math.ceil(value.length / 32) * 32);
      result.set(value);
      return result;
    }
    function encodeBytes(datas) {
      var result = [];
      var byteCount = 0;
      for (var i = 0; i < datas.length; i++) {
        result.push(null);
        byteCount += 32;
      }
      for (var i = 0; i < datas.length; i++) {
        var data = (0, bytes_1.arrayify)(datas[i]);
        result[i] = numPad(byteCount);
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
      }
      return (0, bytes_1.hexConcat)(result);
    }
    var Resolver = function() {
      function Resolver2(provider, address, name, resolvedAddress) {
        (0, properties_1.defineReadOnly)(this, "provider", provider);
        (0, properties_1.defineReadOnly)(this, "name", name);
        (0, properties_1.defineReadOnly)(this, "address", provider.formatter.address(address));
        (0, properties_1.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
      }
      Resolver2.prototype.supportsWildcard = function() {
        var _this = this;
        if (!this._supportsEip2544) {
          this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
          }).then(function(result) {
            return bignumber_1.BigNumber.from(result).eq(1);
          }).catch(function(error) {
            if (error.code === logger_1.Logger.errors.CALL_EXCEPTION) {
              return false;
            }
            _this._supportsEip2544 = null;
            throw error;
          });
        }
        return this._supportsEip2544;
      };
      Resolver2.prototype._fetch = function(selector, parameters) {
        return __awaiter(this, void 0, void 0, function() {
          var tx, parseBytes, result, error_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                tx = {
                  to: this.address,
                  ccipReadEnabled: true,
                  data: (0, bytes_1.hexConcat)([selector, (0, hash_1.namehash)(this.name), parameters || "0x"])
                };
                parseBytes = false;
                return [4, this.supportsWildcard()];
              case 1:
                if (_a.sent()) {
                  parseBytes = true;
                  tx.data = (0, bytes_1.hexConcat)(["0x9061b923", encodeBytes([(0, hash_1.dnsEncode)(this.name), tx.data])]);
                }
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.provider.call(tx)];
              case 3:
                result = _a.sent();
                if ((0, bytes_1.arrayify)(result).length % 32 === 4) {
                  logger.throwError("resolver threw error", logger_1.Logger.errors.CALL_EXCEPTION, {
                    transaction: tx,
                    data: result
                  });
                }
                if (parseBytes) {
                  result = _parseBytes(result, 0);
                }
                return [2, result];
              case 4:
                error_1 = _a.sent();
                if (error_1.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                  return [2, null];
                }
                throw error_1;
              case 5:
                return [2];
            }
          });
        });
      };
      Resolver2.prototype._fetchBytes = function(selector, parameters) {
        return __awaiter(this, void 0, void 0, function() {
          var result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._fetch(selector, parameters)];
              case 1:
                result = _a.sent();
                if (result != null) {
                  return [2, _parseBytes(result, 0)];
                }
                return [2, null];
            }
          });
        });
      };
      Resolver2.prototype._getAddress = function(coinType, hexBytes) {
        var coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) {
          logger.throwError("unsupported coin type: " + coinType, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress(" + coinType + ")"
          });
        }
        if (coinInfo.ilk === "eth") {
          return this.provider.formatter.address(hexBytes);
        }
        var bytes = (0, bytes_1.arrayify)(hexBytes);
        if (coinInfo.p2pkh != null) {
          var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
          if (p2pkh) {
            var length_1 = parseInt(p2pkh[1], 16);
            if (p2pkh[2].length === length_1 * 2 && length_1 >= 1 && length_1 <= 75) {
              return base58Encode((0, bytes_1.concat)([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
            }
          }
        }
        if (coinInfo.p2sh != null) {
          var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
          if (p2sh) {
            var length_2 = parseInt(p2sh[1], 16);
            if (p2sh[2].length === length_2 * 2 && length_2 >= 1 && length_2 <= 75) {
              return base58Encode((0, bytes_1.concat)([[coinInfo.p2sh], "0x" + p2sh[2]]));
            }
          }
        }
        if (coinInfo.prefix != null) {
          var length_3 = bytes[1];
          var version_1 = bytes[0];
          if (version_1 === 0) {
            if (length_3 !== 20 && length_3 !== 32) {
              version_1 = -1;
            }
          } else {
            version_1 = -1;
          }
          if (version_1 >= 0 && bytes.length === 2 + length_3 && length_3 >= 1 && length_3 <= 75) {
            var words = bech32_1.default.toWords(bytes.slice(2));
            words.unshift(version_1);
            return bech32_1.default.encode(coinInfo.prefix, words);
          }
        }
        return null;
      };
      Resolver2.prototype.getAddress = function(coinType) {
        return __awaiter(this, void 0, void 0, function() {
          var result, error_2, hexBytes, address;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (coinType == null) {
                  coinType = 60;
                }
                if (!(coinType === 60))
                  return [3, 4];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this._fetch("0x3b3b57de")];
              case 2:
                result = _a.sent();
                if (result === "0x" || result === constants_1.HashZero) {
                  return [2, null];
                }
                return [2, this.provider.formatter.callAddress(result)];
              case 3:
                error_2 = _a.sent();
                if (error_2.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                  return [2, null];
                }
                throw error_2;
              case 4:
                return [4, this._fetchBytes("0xf1cb7e06", bytes32ify(coinType))];
              case 5:
                hexBytes = _a.sent();
                if (hexBytes == null || hexBytes === "0x") {
                  return [2, null];
                }
                address = this._getAddress(coinType, hexBytes);
                if (address == null) {
                  logger.throwError("invalid or unsupported coin data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "getAddress(" + coinType + ")",
                    coinType,
                    data: hexBytes
                  });
                }
                return [2, address];
            }
          });
        });
      };
      Resolver2.prototype.getAvatar = function() {
        return __awaiter(this, void 0, void 0, function() {
          var linkage, avatar, i, match, scheme, _a, selector, owner, _b, comps, addr, tokenId, tokenOwner, _c, _d, balance, _e, _f, tx, metadataUrl, _g, metadata, imageUrl, ipfs, error_3;
          return __generator(this, function(_h) {
            switch (_h.label) {
              case 0:
                linkage = [{ type: "name", content: this.name }];
                _h.label = 1;
              case 1:
                _h.trys.push([1, 19, , 20]);
                return [4, this.getText("avatar")];
              case 2:
                avatar = _h.sent();
                if (avatar == null) {
                  return [2, null];
                }
                i = 0;
                _h.label = 3;
              case 3:
                if (!(i < matchers.length))
                  return [3, 18];
                match = avatar.match(matchers[i]);
                if (match == null) {
                  return [3, 17];
                }
                scheme = match[1].toLowerCase();
                _a = scheme;
                switch (_a) {
                  case "https":
                    return [3, 4];
                  case "data":
                    return [3, 5];
                  case "ipfs":
                    return [3, 6];
                  case "erc721":
                    return [3, 7];
                  case "erc1155":
                    return [3, 7];
                }
                return [3, 17];
              case 4:
                linkage.push({ type: "url", content: avatar });
                return [2, { linkage, url: avatar }];
              case 5:
                linkage.push({ type: "data", content: avatar });
                return [2, { linkage, url: avatar }];
              case 6:
                linkage.push({ type: "ipfs", content: avatar });
                return [2, { linkage, url: getIpfsLink(avatar) }];
              case 7:
                selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                linkage.push({ type: scheme, content: avatar });
                _b = this._resolvedAddress;
                if (_b)
                  return [3, 9];
                return [4, this.getAddress()];
              case 8:
                _b = _h.sent();
                _h.label = 9;
              case 9:
                owner = _b;
                comps = (match[2] || "").split("/");
                if (comps.length !== 2) {
                  return [2, null];
                }
                return [4, this.provider.formatter.address(comps[0])];
              case 10:
                addr = _h.sent();
                tokenId = (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(comps[1]).toHexString(), 32);
                if (!(scheme === "erc721"))
                  return [3, 12];
                _d = (_c = this.provider.formatter).callAddress;
                return [4, this.provider.call({
                  to: addr,
                  data: (0, bytes_1.hexConcat)(["0x6352211e", tokenId])
                })];
              case 11:
                tokenOwner = _d.apply(_c, [_h.sent()]);
                if (owner !== tokenOwner) {
                  return [2, null];
                }
                linkage.push({ type: "owner", content: tokenOwner });
                return [3, 14];
              case 12:
                if (!(scheme === "erc1155"))
                  return [3, 14];
                _f = (_e = bignumber_1.BigNumber).from;
                return [4, this.provider.call({
                  to: addr,
                  data: (0, bytes_1.hexConcat)(["0x00fdd58e", (0, bytes_1.hexZeroPad)(owner, 32), tokenId])
                })];
              case 13:
                balance = _f.apply(_e, [_h.sent()]);
                if (balance.isZero()) {
                  return [2, null];
                }
                linkage.push({ type: "balance", content: balance.toString() });
                _h.label = 14;
              case 14:
                tx = {
                  to: this.provider.formatter.address(comps[0]),
                  data: (0, bytes_1.hexConcat)([selector, tokenId])
                };
                _g = _parseString;
                return [4, this.provider.call(tx)];
              case 15:
                metadataUrl = _g.apply(void 0, [_h.sent(), 0]);
                if (metadataUrl == null) {
                  return [2, null];
                }
                linkage.push({ type: "metadata-url-base", content: metadataUrl });
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                  linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                }
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }
                linkage.push({ type: "metadata-url", content: metadataUrl });
                return [4, (0, web_1.fetchJson)(metadataUrl)];
              case 16:
                metadata = _h.sent();
                if (!metadata) {
                  return [2, null];
                }
                linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                imageUrl = metadata.image;
                if (typeof imageUrl !== "string") {
                  return [2, null];
                }
                if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                } else {
                  ipfs = imageUrl.match(matcherIpfs);
                  if (ipfs == null) {
                    return [2, null];
                  }
                  linkage.push({ type: "url-ipfs", content: imageUrl });
                  imageUrl = getIpfsLink(imageUrl);
                }
                linkage.push({ type: "url", content: imageUrl });
                return [2, { linkage, url: imageUrl }];
              case 17:
                i++;
                return [3, 3];
              case 18:
                return [3, 20];
              case 19:
                error_3 = _h.sent();
                return [3, 20];
              case 20:
                return [2, null];
            }
          });
        });
      };
      Resolver2.prototype.getContentHash = function() {
        return __awaiter(this, void 0, void 0, function() {
          var hexBytes, ipfs, length_4, ipns, length_5, swarm, skynet, urlSafe_1, hash;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._fetchBytes("0xbc1c58d1")];
              case 1:
                hexBytes = _a.sent();
                if (hexBytes == null || hexBytes === "0x") {
                  return [2, null];
                }
                ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                if (ipfs) {
                  length_4 = parseInt(ipfs[3], 16);
                  if (ipfs[4].length === length_4 * 2) {
                    return [2, "ipfs://" + basex_1.Base58.encode("0x" + ipfs[1])];
                  }
                }
                ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                if (ipns) {
                  length_5 = parseInt(ipns[3], 16);
                  if (ipns[4].length === length_5 * 2) {
                    return [2, "ipns://" + basex_1.Base58.encode("0x" + ipns[1])];
                  }
                }
                swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
                if (swarm) {
                  if (swarm[1].length === 32 * 2) {
                    return [2, "bzz://" + swarm[1]];
                  }
                }
                skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
                if (skynet) {
                  if (skynet[1].length === 34 * 2) {
                    urlSafe_1 = { "=": "", "+": "-", "/": "_" };
                    hash = (0, base64_1.encode)("0x" + skynet[1]).replace(/[=+\/]/g, function(a) {
                      return urlSafe_1[a];
                    });
                    return [2, "sia://" + hash];
                  }
                }
                return [2, logger.throwError("invalid or unsupported content hash data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "getContentHash()",
                  data: hexBytes
                })];
            }
          });
        });
      };
      Resolver2.prototype.getText = function(key) {
        return __awaiter(this, void 0, void 0, function() {
          var keyBytes, hexBytes;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                keyBytes = (0, strings_1.toUtf8Bytes)(key);
                keyBytes = (0, bytes_1.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
                if (keyBytes.length % 32 !== 0) {
                  keyBytes = (0, bytes_1.concat)([keyBytes, (0, bytes_1.hexZeroPad)("0x", 32 - key.length % 32)]);
                }
                return [4, this._fetchBytes("0x59d1d43c", (0, bytes_1.hexlify)(keyBytes))];
              case 1:
                hexBytes = _a.sent();
                if (hexBytes == null || hexBytes === "0x") {
                  return [2, null];
                }
                return [2, (0, strings_1.toUtf8String)(hexBytes)];
            }
          });
        });
      };
      return Resolver2;
    }();
    exports.Resolver = Resolver;
    var defaultFormatter = null;
    var nextPollId = 1;
    var BaseProvider = function(_super) {
      __extends(BaseProvider2, _super);
      function BaseProvider2(network) {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        _this._events = [];
        _this._emitted = { block: -2 };
        _this.disableCcipRead = false;
        _this.formatter = _newTarget.getFormatter();
        (0, properties_1.defineReadOnly)(_this, "anyNetwork", network === "any");
        if (_this.anyNetwork) {
          network = _this.detectNetwork();
        }
        if (network instanceof Promise) {
          _this._networkPromise = network;
          network.catch(function(error) {
          });
          _this._ready().catch(function(error) {
          });
        } else {
          var knownNetwork = (0, properties_1.getStatic)(_newTarget, "getNetwork")(network);
          if (knownNetwork) {
            (0, properties_1.defineReadOnly)(_this, "_network", knownNetwork);
            _this.emit("network", knownNetwork, null);
          } else {
            logger.throwArgumentError("invalid network", "network", network);
          }
        }
        _this._maxInternalBlockNumber = -1024;
        _this._lastBlockNumber = -2;
        _this._maxFilterBlockRange = 10;
        _this._pollingInterval = 4e3;
        _this._fastQueryDate = 0;
        return _this;
      }
      BaseProvider2.prototype._ready = function() {
        return __awaiter(this, void 0, void 0, function() {
          var network, error_4;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(this._network == null))
                  return [3, 7];
                network = null;
                if (!this._networkPromise)
                  return [3, 4];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this._networkPromise];
              case 2:
                network = _a.sent();
                return [3, 4];
              case 3:
                error_4 = _a.sent();
                return [3, 4];
              case 4:
                if (!(network == null))
                  return [3, 6];
                return [4, this.detectNetwork()];
              case 5:
                network = _a.sent();
                _a.label = 6;
              case 6:
                if (!network) {
                  logger.throwError("no network detected", logger_1.Logger.errors.UNKNOWN_ERROR, {});
                }
                if (this._network == null) {
                  if (this.anyNetwork) {
                    this._network = network;
                  } else {
                    (0, properties_1.defineReadOnly)(this, "_network", network);
                  }
                  this.emit("network", network, null);
                }
                _a.label = 7;
              case 7:
                return [2, this._network];
            }
          });
        });
      };
      Object.defineProperty(BaseProvider2.prototype, "ready", {
        get: function() {
          var _this = this;
          return (0, web_1.poll)(function() {
            return _this._ready().then(function(network) {
              return network;
            }, function(error) {
              if (error.code === logger_1.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
                return void 0;
              }
              throw error;
            });
          });
        },
        enumerable: false,
        configurable: true
      });
      BaseProvider2.getFormatter = function() {
        if (defaultFormatter == null) {
          defaultFormatter = new formatter_1.Formatter();
        }
        return defaultFormatter;
      };
      BaseProvider2.getNetwork = function(network) {
        return (0, networks_1.getNetwork)(network == null ? "homestead" : network);
      };
      BaseProvider2.prototype.ccipReadFetch = function(tx, calldata, urls) {
        return __awaiter(this, void 0, void 0, function() {
          var sender, data, errorMessages, i, url2, href, json, result, errorMessage;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (this.disableCcipRead || urls.length === 0) {
                  return [2, null];
                }
                sender = tx.to.toLowerCase();
                data = calldata.toLowerCase();
                errorMessages = [];
                i = 0;
                _a.label = 1;
              case 1:
                if (!(i < urls.length))
                  return [3, 4];
                url2 = urls[i];
                href = url2.replace("{sender}", sender).replace("{data}", data);
                json = url2.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
                return [4, (0, web_1.fetchJson)({ url: href, errorPassThrough: true }, json, function(value, response) {
                  value.status = response.statusCode;
                  return value;
                })];
              case 2:
                result = _a.sent();
                if (result.data) {
                  return [2, result.data];
                }
                errorMessage = result.message || "unknown error";
                if (result.status >= 400 && result.status < 500) {
                  return [2, logger.throwError("response not found during CCIP fetch: " + errorMessage, logger_1.Logger.errors.SERVER_ERROR, { url: url2, errorMessage })];
                }
                errorMessages.push(errorMessage);
                _a.label = 3;
              case 3:
                i++;
                return [3, 1];
              case 4:
                return [2, logger.throwError("error encountered during CCIP fetch: " + errorMessages.map(function(m) {
                  return JSON.stringify(m);
                }).join(", "), logger_1.Logger.errors.SERVER_ERROR, {
                  urls,
                  errorMessages
                })];
            }
          });
        });
      };
      BaseProvider2.prototype._getInternalBlockNumber = function(maxAge) {
        return __awaiter(this, void 0, void 0, function() {
          var internalBlockNumber, result, error_5, reqTime, checkInternalBlockNumber;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._ready()];
              case 1:
                _a.sent();
                if (!(maxAge > 0))
                  return [3, 7];
                _a.label = 2;
              case 2:
                if (!this._internalBlockNumber)
                  return [3, 7];
                internalBlockNumber = this._internalBlockNumber;
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, internalBlockNumber];
              case 4:
                result = _a.sent();
                if (getTime() - result.respTime <= maxAge) {
                  return [2, result.blockNumber];
                }
                return [3, 7];
              case 5:
                error_5 = _a.sent();
                if (this._internalBlockNumber === internalBlockNumber) {
                  return [3, 7];
                }
                return [3, 6];
              case 6:
                return [3, 2];
              case 7:
                reqTime = getTime();
                checkInternalBlockNumber = (0, properties_1.resolveProperties)({
                  blockNumber: this.perform("getBlockNumber", {}),
                  networkError: this.getNetwork().then(function(network) {
                    return null;
                  }, function(error) {
                    return error;
                  })
                }).then(function(_a2) {
                  var blockNumber = _a2.blockNumber, networkError = _a2.networkError;
                  if (networkError) {
                    if (_this._internalBlockNumber === checkInternalBlockNumber) {
                      _this._internalBlockNumber = null;
                    }
                    throw networkError;
                  }
                  var respTime = getTime();
                  blockNumber = bignumber_1.BigNumber.from(blockNumber).toNumber();
                  if (blockNumber < _this._maxInternalBlockNumber) {
                    blockNumber = _this._maxInternalBlockNumber;
                  }
                  _this._maxInternalBlockNumber = blockNumber;
                  _this._setFastBlockNumber(blockNumber);
                  return { blockNumber, reqTime, respTime };
                });
                this._internalBlockNumber = checkInternalBlockNumber;
                checkInternalBlockNumber.catch(function(error) {
                  if (_this._internalBlockNumber === checkInternalBlockNumber) {
                    _this._internalBlockNumber = null;
                  }
                });
                return [4, checkInternalBlockNumber];
              case 8:
                return [2, _a.sent().blockNumber];
            }
          });
        });
      };
      BaseProvider2.prototype.poll = function() {
        return __awaiter(this, void 0, void 0, function() {
          var pollId, runners, blockNumber, error_6, i;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                pollId = nextPollId++;
                runners = [];
                blockNumber = null;
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];
              case 2:
                blockNumber = _a.sent();
                return [3, 4];
              case 3:
                error_6 = _a.sent();
                this.emit("error", error_6);
                return [2];
              case 4:
                this._setFastBlockNumber(blockNumber);
                this.emit("poll", pollId, blockNumber);
                if (blockNumber === this._lastBlockNumber) {
                  this.emit("didPoll", pollId);
                  return [2];
                }
                if (this._emitted.block === -2) {
                  this._emitted.block = blockNumber - 1;
                }
                if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
                  logger.warn("network block skew detected; skipping block events (emitted=" + this._emitted.block + " blockNumber" + blockNumber + ")");
                  this.emit("error", logger.makeError("network block skew detected", logger_1.Logger.errors.NETWORK_ERROR, {
                    blockNumber,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                  }));
                  this.emit("block", blockNumber);
                } else {
                  for (i = this._emitted.block + 1; i <= blockNumber; i++) {
                    this.emit("block", i);
                  }
                }
                if (this._emitted.block !== blockNumber) {
                  this._emitted.block = blockNumber;
                  Object.keys(this._emitted).forEach(function(key) {
                    if (key === "block") {
                      return;
                    }
                    var eventBlockNumber = _this._emitted[key];
                    if (eventBlockNumber === "pending") {
                      return;
                    }
                    if (blockNumber - eventBlockNumber > 12) {
                      delete _this._emitted[key];
                    }
                  });
                }
                if (this._lastBlockNumber === -2) {
                  this._lastBlockNumber = blockNumber - 1;
                }
                this._events.forEach(function(event) {
                  switch (event.type) {
                    case "tx": {
                      var hash_2 = event.hash;
                      var runner = _this.getTransactionReceipt(hash_2).then(function(receipt) {
                        if (!receipt || receipt.blockNumber == null) {
                          return null;
                        }
                        _this._emitted["t:" + hash_2] = receipt.blockNumber;
                        _this.emit(hash_2, receipt);
                        return null;
                      }).catch(function(error) {
                        _this.emit("error", error);
                      });
                      runners.push(runner);
                      break;
                    }
                    case "filter": {
                      if (!event._inflight) {
                        event._inflight = true;
                        if (event._lastBlockNumber === -2) {
                          event._lastBlockNumber = blockNumber - 1;
                        }
                        var filter_1 = event.filter;
                        filter_1.fromBlock = event._lastBlockNumber + 1;
                        filter_1.toBlock = blockNumber;
                        var minFromBlock = filter_1.toBlock - _this._maxFilterBlockRange;
                        if (minFromBlock > filter_1.fromBlock) {
                          filter_1.fromBlock = minFromBlock;
                        }
                        if (filter_1.fromBlock < 0) {
                          filter_1.fromBlock = 0;
                        }
                        var runner = _this.getLogs(filter_1).then(function(logs) {
                          event._inflight = false;
                          if (logs.length === 0) {
                            return;
                          }
                          logs.forEach(function(log) {
                            if (log.blockNumber > event._lastBlockNumber) {
                              event._lastBlockNumber = log.blockNumber;
                            }
                            _this._emitted["b:" + log.blockHash] = log.blockNumber;
                            _this._emitted["t:" + log.transactionHash] = log.blockNumber;
                            _this.emit(filter_1, log);
                          });
                        }).catch(function(error) {
                          _this.emit("error", error);
                          event._inflight = false;
                        });
                        runners.push(runner);
                      }
                      break;
                    }
                  }
                });
                this._lastBlockNumber = blockNumber;
                Promise.all(runners).then(function() {
                  _this.emit("didPoll", pollId);
                }).catch(function(error) {
                  _this.emit("error", error);
                });
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.resetEventsBlock = function(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) {
          this.poll();
        }
      };
      Object.defineProperty(BaseProvider2.prototype, "network", {
        get: function() {
          return this._network;
        },
        enumerable: false,
        configurable: true
      });
      BaseProvider2.prototype.detectNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, logger.throwError("provider does not support network detection", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "provider.detectNetwork"
            })];
          });
        });
      };
      BaseProvider2.prototype.getNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var network, currentNetwork, error;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._ready()];
              case 1:
                network = _a.sent();
                return [4, this.detectNetwork()];
              case 2:
                currentNetwork = _a.sent();
                if (!(network.chainId !== currentNetwork.chainId))
                  return [3, 5];
                if (!this.anyNetwork)
                  return [3, 4];
                this._network = currentNetwork;
                this._lastBlockNumber = -2;
                this._fastBlockNumber = null;
                this._fastBlockNumberPromise = null;
                this._fastQueryDate = 0;
                this._emitted.block = -2;
                this._maxInternalBlockNumber = -1024;
                this._internalBlockNumber = null;
                this.emit("network", currentNetwork, network);
                return [4, stall(0)];
              case 3:
                _a.sent();
                return [2, this._network];
              case 4:
                error = logger.makeError("underlying network changed", logger_1.Logger.errors.NETWORK_ERROR, {
                  event: "changed",
                  network,
                  detectedNetwork: currentNetwork
                });
                this.emit("error", error);
                throw error;
              case 5:
                return [2, network];
            }
          });
        });
      };
      Object.defineProperty(BaseProvider2.prototype, "blockNumber", {
        get: function() {
          var _this = this;
          this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function(blockNumber) {
            _this._setFastBlockNumber(blockNumber);
          }, function(error) {
          });
          return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseProvider2.prototype, "polling", {
        get: function() {
          return this._poller != null;
        },
        set: function(value) {
          var _this = this;
          if (value && !this._poller) {
            this._poller = setInterval(function() {
              _this.poll();
            }, this.pollingInterval);
            if (!this._bootstrapPoll) {
              this._bootstrapPoll = setTimeout(function() {
                _this.poll();
                _this._bootstrapPoll = setTimeout(function() {
                  if (!_this._poller) {
                    _this.poll();
                  }
                  _this._bootstrapPoll = null;
                }, _this.pollingInterval);
              }, 0);
            }
          } else if (!value && this._poller) {
            clearInterval(this._poller);
            this._poller = null;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseProvider2.prototype, "pollingInterval", {
        get: function() {
          return this._pollingInterval;
        },
        set: function(value) {
          var _this = this;
          if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
            throw new Error("invalid polling interval");
          }
          this._pollingInterval = value;
          if (this._poller) {
            clearInterval(this._poller);
            this._poller = setInterval(function() {
              _this.poll();
            }, this._pollingInterval);
          }
        },
        enumerable: false,
        configurable: true
      });
      BaseProvider2.prototype._getFastBlockNumber = function() {
        var _this = this;
        var now = getTime();
        if (now - this._fastQueryDate > 2 * this._pollingInterval) {
          this._fastQueryDate = now;
          this._fastBlockNumberPromise = this.getBlockNumber().then(function(blockNumber) {
            if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {
              _this._fastBlockNumber = blockNumber;
            }
            return _this._fastBlockNumber;
          });
        }
        return this._fastBlockNumberPromise;
      };
      BaseProvider2.prototype._setFastBlockNumber = function(blockNumber) {
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
          return;
        }
        this._fastQueryDate = getTime();
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
          this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
      };
      BaseProvider2.prototype.waitForTransaction = function(transactionHash, confirmations, timeout) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null)];
          });
        });
      };
      BaseProvider2.prototype._waitForTransaction = function(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter(this, void 0, void 0, function() {
          var receipt;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getTransactionReceipt(transactionHash)];
              case 1:
                receipt = _a.sent();
                if ((receipt ? receipt.confirmations : 0) >= confirmations) {
                  return [2, receipt];
                }
                return [2, new Promise(function(resolve, reject) {
                  var cancelFuncs = [];
                  var done = false;
                  var alreadyDone = function() {
                    if (done) {
                      return true;
                    }
                    done = true;
                    cancelFuncs.forEach(function(func) {
                      func();
                    });
                    return false;
                  };
                  var minedHandler = function(receipt2) {
                    if (receipt2.confirmations < confirmations) {
                      return;
                    }
                    if (alreadyDone()) {
                      return;
                    }
                    resolve(receipt2);
                  };
                  _this.on(transactionHash, minedHandler);
                  cancelFuncs.push(function() {
                    _this.removeListener(transactionHash, minedHandler);
                  });
                  if (replaceable) {
                    var lastBlockNumber_1 = replaceable.startBlock;
                    var scannedBlock_1 = null;
                    var replaceHandler_1 = function(blockNumber) {
                      return __awaiter(_this, void 0, void 0, function() {
                        var _this2 = this;
                        return __generator(this, function(_a2) {
                          switch (_a2.label) {
                            case 0:
                              if (done) {
                                return [2];
                              }
                              return [4, stall(1e3)];
                            case 1:
                              _a2.sent();
                              this.getTransactionCount(replaceable.from).then(function(nonce) {
                                return __awaiter(_this2, void 0, void 0, function() {
                                  var mined, block, ti, tx, receipt_1, reason;
                                  return __generator(this, function(_a3) {
                                    switch (_a3.label) {
                                      case 0:
                                        if (done) {
                                          return [2];
                                        }
                                        if (!(nonce <= replaceable.nonce))
                                          return [3, 1];
                                        lastBlockNumber_1 = blockNumber;
                                        return [3, 9];
                                      case 1:
                                        return [4, this.getTransaction(transactionHash)];
                                      case 2:
                                        mined = _a3.sent();
                                        if (mined && mined.blockNumber != null) {
                                          return [2];
                                        }
                                        if (scannedBlock_1 == null) {
                                          scannedBlock_1 = lastBlockNumber_1 - 3;
                                          if (scannedBlock_1 < replaceable.startBlock) {
                                            scannedBlock_1 = replaceable.startBlock;
                                          }
                                        }
                                        _a3.label = 3;
                                      case 3:
                                        if (!(scannedBlock_1 <= blockNumber))
                                          return [3, 9];
                                        if (done) {
                                          return [2];
                                        }
                                        return [4, this.getBlockWithTransactions(scannedBlock_1)];
                                      case 4:
                                        block = _a3.sent();
                                        ti = 0;
                                        _a3.label = 5;
                                      case 5:
                                        if (!(ti < block.transactions.length))
                                          return [3, 8];
                                        tx = block.transactions[ti];
                                        if (tx.hash === transactionHash) {
                                          return [2];
                                        }
                                        if (!(tx.from === replaceable.from && tx.nonce === replaceable.nonce))
                                          return [3, 7];
                                        if (done) {
                                          return [2];
                                        }
                                        return [4, this.waitForTransaction(tx.hash, confirmations)];
                                      case 6:
                                        receipt_1 = _a3.sent();
                                        if (alreadyDone()) {
                                          return [2];
                                        }
                                        reason = "replaced";
                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                                          reason = "repriced";
                                        } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                                          reason = "cancelled";
                                        }
                                        reject(logger.makeError("transaction was replaced", logger_1.Logger.errors.TRANSACTION_REPLACED, {
                                          cancelled: reason === "replaced" || reason === "cancelled",
                                          reason,
                                          replacement: this._wrapTransaction(tx),
                                          hash: transactionHash,
                                          receipt: receipt_1
                                        }));
                                        return [2];
                                      case 7:
                                        ti++;
                                        return [3, 5];
                                      case 8:
                                        scannedBlock_1++;
                                        return [3, 3];
                                      case 9:
                                        if (done) {
                                          return [2];
                                        }
                                        this.once("block", replaceHandler_1);
                                        return [2];
                                    }
                                  });
                                });
                              }, function(error) {
                                if (done) {
                                  return;
                                }
                                _this2.once("block", replaceHandler_1);
                              });
                              return [2];
                          }
                        });
                      });
                    };
                    if (done) {
                      return;
                    }
                    _this.once("block", replaceHandler_1);
                    cancelFuncs.push(function() {
                      _this.removeListener("block", replaceHandler_1);
                    });
                  }
                  if (typeof timeout === "number" && timeout > 0) {
                    var timer_1 = setTimeout(function() {
                      if (alreadyDone()) {
                        return;
                      }
                      reject(logger.makeError("timeout exceeded", logger_1.Logger.errors.TIMEOUT, { timeout }));
                    }, timeout);
                    if (timer_1.unref) {
                      timer_1.unref();
                    }
                    cancelFuncs.push(function() {
                      clearTimeout(timer_1);
                    });
                  }
                })];
            }
          });
        });
      };
      BaseProvider2.prototype.getBlockNumber = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this._getInternalBlockNumber(0)];
          });
        });
      };
      BaseProvider2.prototype.getGasPrice = function() {
        return __awaiter(this, void 0, void 0, function() {
          var result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, this.perform("getGasPrice", {})];
              case 2:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result)];
                } catch (error) {
                  return [2, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getBalance = function(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getBalance", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result)];
                } catch (error) {
                  return [2, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getBalance",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getTransactionCount = function(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getTransactionCount", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result).toNumber()];
                } catch (error) {
                  return [2, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getCode = function(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getCode", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, (0, bytes_1.hexlify)(result)];
                } catch (error) {
                  return [2, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getCode",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getStorageAt = function(addressOrName, position, blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag),
                  position: Promise.resolve(position).then(function(p) {
                    return (0, bytes_1.hexValue)(p);
                  })
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getStorageAt", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, (0, bytes_1.hexlify)(result)];
                } catch (error) {
                  return [2, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._wrapTransaction = function(tx, hash, startBlock) {
        var _this = this;
        if (hash != null && (0, bytes_1.hexDataLength)(hash) !== 32) {
          throw new Error("invalid response - sendTransaction");
        }
        var result = tx;
        if (hash != null && tx.hash !== hash) {
          logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", logger_1.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });
        }
        result.wait = function(confirms, timeout) {
          return __awaiter(_this, void 0, void 0, function() {
            var replacement, receipt;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (confirms == null) {
                    confirms = 1;
                  }
                  if (timeout == null) {
                    timeout = 0;
                  }
                  replacement = void 0;
                  if (confirms !== 0 && startBlock != null) {
                    replacement = {
                      data: tx.data,
                      from: tx.from,
                      nonce: tx.nonce,
                      to: tx.to,
                      value: tx.value,
                      startBlock
                    };
                  }
                  return [4, this._waitForTransaction(tx.hash, confirms, timeout, replacement)];
                case 1:
                  receipt = _a.sent();
                  if (receipt == null && confirms === 0) {
                    return [2, null];
                  }
                  this._emitted["t:" + tx.hash] = receipt.blockNumber;
                  if (receipt.status === 0) {
                    logger.throwError("transaction failed", logger_1.Logger.errors.CALL_EXCEPTION, {
                      transactionHash: tx.hash,
                      transaction: tx,
                      receipt
                    });
                  }
                  return [2, receipt];
              }
            });
          });
        };
        return result;
      };
      BaseProvider2.prototype.sendTransaction = function(signedTransaction) {
        return __awaiter(this, void 0, void 0, function() {
          var hexTx, tx, blockNumber, hash, error_7;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, Promise.resolve(signedTransaction).then(function(t) {
                  return (0, bytes_1.hexlify)(t);
                })];
              case 2:
                hexTx = _a.sent();
                tx = this.formatter.transaction(signedTransaction);
                if (tx.confirmations == null) {
                  tx.confirmations = 0;
                }
                return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
              case 3:
                blockNumber = _a.sent();
                _a.label = 4;
              case 4:
                _a.trys.push([4, 6, , 7]);
                return [4, this.perform("sendTransaction", { signedTransaction: hexTx })];
              case 5:
                hash = _a.sent();
                return [2, this._wrapTransaction(tx, hash, blockNumber)];
              case 6:
                error_7 = _a.sent();
                error_7.transaction = tx;
                error_7.transactionHash = tx.hash;
                throw error_7;
              case 7:
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._getTransactionRequest = function(transaction) {
        return __awaiter(this, void 0, void 0, function() {
          var values, tx, _a, _b;
          var _this = this;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, transaction];
              case 1:
                values = _c.sent();
                tx = {};
                ["from", "to"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v ? _this._getAddress(v) : null;
                  });
                });
                ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v ? bignumber_1.BigNumber.from(v) : null;
                  });
                });
                ["type"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v != null ? v : null;
                  });
                });
                if (values.accessList) {
                  tx.accessList = this.formatter.accessList(values.accessList);
                }
                ["data"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v ? (0, bytes_1.hexlify)(v) : null;
                  });
                });
                _b = (_a = this.formatter).transactionRequest;
                return [4, (0, properties_1.resolveProperties)(tx)];
              case 2:
                return [2, _b.apply(_a, [_c.sent()])];
            }
          });
        });
      };
      BaseProvider2.prototype._getFilter = function(filter2) {
        return __awaiter(this, void 0, void 0, function() {
          var result, _a, _b;
          var _this = this;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, filter2];
              case 1:
                filter2 = _c.sent();
                result = {};
                if (filter2.address != null) {
                  result.address = this._getAddress(filter2.address);
                }
                ["blockHash", "topics"].forEach(function(key) {
                  if (filter2[key] == null) {
                    return;
                  }
                  result[key] = filter2[key];
                });
                ["fromBlock", "toBlock"].forEach(function(key) {
                  if (filter2[key] == null) {
                    return;
                  }
                  result[key] = _this._getBlockTag(filter2[key]);
                });
                _b = (_a = this.formatter).filter;
                return [4, (0, properties_1.resolveProperties)(result)];
              case 2:
                return [2, _b.apply(_a, [_c.sent()])];
            }
          });
        });
      };
      BaseProvider2.prototype._call = function(transaction, blockTag, attempt) {
        return __awaiter(this, void 0, void 0, function() {
          var txSender, result, data, sender, urls, urlsOffset, urlsLength, urlsData, u, url2, calldata, callbackSelector, extraData, ccipResult, tx, error_8;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (attempt >= MAX_CCIP_REDIRECTS) {
                  logger.throwError("CCIP read exceeded maximum redirections", logger_1.Logger.errors.SERVER_ERROR, {
                    redirects: attempt,
                    transaction
                  });
                }
                txSender = transaction.to;
                return [4, this.perform("call", { transaction, blockTag })];
              case 1:
                result = _a.sent();
                if (!(attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (0, bytes_1.hexDataLength)(result) % 32 === 4))
                  return [3, 5];
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                data = (0, bytes_1.hexDataSlice)(result, 4);
                sender = (0, bytes_1.hexDataSlice)(data, 0, 32);
                if (!bignumber_1.BigNumber.from(sender).eq(txSender)) {
                  logger.throwError("CCIP Read sender did not match", logger_1.Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                urls = [];
                urlsOffset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 32, 64)).toNumber();
                urlsLength = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();
                urlsData = (0, bytes_1.hexDataSlice)(data, urlsOffset + 32);
                for (u = 0; u < urlsLength; u++) {
                  url2 = _parseString(urlsData, u * 32);
                  if (url2 == null) {
                    logger.throwError("CCIP Read contained corrupt URL string", logger_1.Logger.errors.CALL_EXCEPTION, {
                      name: "OffchainLookup",
                      signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      transaction,
                      data: result
                    });
                  }
                  urls.push(url2);
                }
                calldata = _parseBytes(data, 64);
                if (!bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 100, 128)).isZero()) {
                  logger.throwError("CCIP Read callback selector included junk", logger_1.Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                callbackSelector = (0, bytes_1.hexDataSlice)(data, 96, 100);
                extraData = _parseBytes(data, 128);
                return [4, this.ccipReadFetch(transaction, calldata, urls)];
              case 3:
                ccipResult = _a.sent();
                if (ccipResult == null) {
                  logger.throwError("CCIP Read disabled or provided no URLs", logger_1.Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                tx = {
                  to: txSender,
                  data: (0, bytes_1.hexConcat)([callbackSelector, encodeBytes([ccipResult, extraData])])
                };
                return [2, this._call(tx, blockTag, attempt + 1)];
              case 4:
                error_8 = _a.sent();
                if (error_8.code === logger_1.Logger.errors.SERVER_ERROR) {
                  throw error_8;
                }
                return [3, 5];
              case 5:
                try {
                  return [2, (0, bytes_1.hexlify)(result)];
                } catch (error) {
                  return [2, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "call",
                    params: { transaction, blockTag },
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.call = function(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          var resolved;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  transaction: this._getTransactionRequest(transaction),
                  blockTag: this._getBlockTag(blockTag),
                  ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
                })];
              case 2:
                resolved = _a.sent();
                return [2, this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1)];
            }
          });
        });
      };
      BaseProvider2.prototype.estimateGas = function(transaction) {
        return __awaiter(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  transaction: this._getTransactionRequest(transaction)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("estimateGas", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result)];
                } catch (error) {
                  return [2, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._getAddress = function(addressOrName) {
        return __awaiter(this, void 0, void 0, function() {
          var address;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, addressOrName];
              case 1:
                addressOrName = _a.sent();
                if (typeof addressOrName !== "string") {
                  logger.throwArgumentError("invalid address or ENS name", "name", addressOrName);
                }
                return [4, this.resolveName(addressOrName)];
              case 2:
                address = _a.sent();
                if (address == null) {
                  logger.throwError("ENS name not configured", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "resolveName(" + JSON.stringify(addressOrName) + ")"
                  });
                }
                return [2, address];
            }
          });
        });
      };
      BaseProvider2.prototype._getBlock = function(blockHashOrBlockTag, includeTransactions) {
        return __awaiter(this, void 0, void 0, function() {
          var blockNumber, params, _a, error_9;
          var _this = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _b.sent();
                return [4, blockHashOrBlockTag];
              case 2:
                blockHashOrBlockTag = _b.sent();
                blockNumber = -128;
                params = {
                  includeTransactions: !!includeTransactions
                };
                if (!(0, bytes_1.isHexString)(blockHashOrBlockTag, 32))
                  return [3, 3];
                params.blockHash = blockHashOrBlockTag;
                return [3, 6];
              case 3:
                _b.trys.push([3, 5, , 6]);
                _a = params;
                return [4, this._getBlockTag(blockHashOrBlockTag)];
              case 4:
                _a.blockTag = _b.sent();
                if ((0, bytes_1.isHexString)(params.blockTag)) {
                  blockNumber = parseInt(params.blockTag.substring(2), 16);
                }
                return [3, 6];
              case 5:
                error_9 = _b.sent();
                logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
                return [3, 6];
              case 6:
                return [2, (0, web_1.poll)(function() {
                  return __awaiter(_this, void 0, void 0, function() {
                    var block, blockNumber_1, i, tx, confirmations, blockWithTxs;
                    var _this2 = this;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.perform("getBlock", params)];
                        case 1:
                          block = _a2.sent();
                          if (block == null) {
                            if (params.blockHash != null) {
                              if (this._emitted["b:" + params.blockHash] == null) {
                                return [2, null];
                              }
                            }
                            if (params.blockTag != null) {
                              if (blockNumber > this._emitted.block) {
                                return [2, null];
                              }
                            }
                            return [2, void 0];
                          }
                          if (!includeTransactions)
                            return [3, 8];
                          blockNumber_1 = null;
                          i = 0;
                          _a2.label = 2;
                        case 2:
                          if (!(i < block.transactions.length))
                            return [3, 7];
                          tx = block.transactions[i];
                          if (!(tx.blockNumber == null))
                            return [3, 3];
                          tx.confirmations = 0;
                          return [3, 6];
                        case 3:
                          if (!(tx.confirmations == null))
                            return [3, 6];
                          if (!(blockNumber_1 == null))
                            return [3, 5];
                          return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                        case 4:
                          blockNumber_1 = _a2.sent();
                          _a2.label = 5;
                        case 5:
                          confirmations = blockNumber_1 - tx.blockNumber + 1;
                          if (confirmations <= 0) {
                            confirmations = 1;
                          }
                          tx.confirmations = confirmations;
                          _a2.label = 6;
                        case 6:
                          i++;
                          return [3, 2];
                        case 7:
                          blockWithTxs = this.formatter.blockWithTransactions(block);
                          blockWithTxs.transactions = blockWithTxs.transactions.map(function(tx2) {
                            return _this2._wrapTransaction(tx2);
                          });
                          return [2, blockWithTxs];
                        case 8:
                          return [2, this.formatter.block(block)];
                      }
                    });
                  });
                }, { oncePoll: this })];
            }
          });
        });
      };
      BaseProvider2.prototype.getBlock = function(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
      };
      BaseProvider2.prototype.getBlockWithTransactions = function(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
      };
      BaseProvider2.prototype.getTransaction = function(transactionHash) {
        return __awaiter(this, void 0, void 0, function() {
          var params;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, transactionHash];
              case 2:
                transactionHash = _a.sent();
                params = { transactionHash: this.formatter.hash(transactionHash, true) };
                return [2, (0, web_1.poll)(function() {
                  return __awaiter(_this, void 0, void 0, function() {
                    var result, tx, blockNumber, confirmations;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.perform("getTransaction", params)];
                        case 1:
                          result = _a2.sent();
                          if (result == null) {
                            if (this._emitted["t:" + transactionHash] == null) {
                              return [2, null];
                            }
                            return [2, void 0];
                          }
                          tx = this.formatter.transactionResponse(result);
                          if (!(tx.blockNumber == null))
                            return [3, 2];
                          tx.confirmations = 0;
                          return [3, 4];
                        case 2:
                          if (!(tx.confirmations == null))
                            return [3, 4];
                          return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                        case 3:
                          blockNumber = _a2.sent();
                          confirmations = blockNumber - tx.blockNumber + 1;
                          if (confirmations <= 0) {
                            confirmations = 1;
                          }
                          tx.confirmations = confirmations;
                          _a2.label = 4;
                        case 4:
                          return [2, this._wrapTransaction(tx)];
                      }
                    });
                  });
                }, { oncePoll: this })];
            }
          });
        });
      };
      BaseProvider2.prototype.getTransactionReceipt = function(transactionHash) {
        return __awaiter(this, void 0, void 0, function() {
          var params;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, transactionHash];
              case 2:
                transactionHash = _a.sent();
                params = { transactionHash: this.formatter.hash(transactionHash, true) };
                return [2, (0, web_1.poll)(function() {
                  return __awaiter(_this, void 0, void 0, function() {
                    var result, receipt, blockNumber, confirmations;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.perform("getTransactionReceipt", params)];
                        case 1:
                          result = _a2.sent();
                          if (result == null) {
                            if (this._emitted["t:" + transactionHash] == null) {
                              return [2, null];
                            }
                            return [2, void 0];
                          }
                          if (result.blockHash == null) {
                            return [2, void 0];
                          }
                          receipt = this.formatter.receipt(result);
                          if (!(receipt.blockNumber == null))
                            return [3, 2];
                          receipt.confirmations = 0;
                          return [3, 4];
                        case 2:
                          if (!(receipt.confirmations == null))
                            return [3, 4];
                          return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                        case 3:
                          blockNumber = _a2.sent();
                          confirmations = blockNumber - receipt.blockNumber + 1;
                          if (confirmations <= 0) {
                            confirmations = 1;
                          }
                          receipt.confirmations = confirmations;
                          _a2.label = 4;
                        case 4:
                          return [2, receipt];
                      }
                    });
                  });
                }, { oncePoll: this })];
            }
          });
        });
      };
      BaseProvider2.prototype.getLogs = function(filter2) {
        return __awaiter(this, void 0, void 0, function() {
          var params, logs;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({ filter: this._getFilter(filter2) })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getLogs", params)];
              case 3:
                logs = _a.sent();
                logs.forEach(function(log) {
                  if (log.removed == null) {
                    log.removed = false;
                  }
                });
                return [2, formatter_1.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];
            }
          });
        });
      };
      BaseProvider2.prototype.getEtherPrice = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [2, this.perform("getEtherPrice", {})];
            }
          });
        });
      };
      BaseProvider2.prototype._getBlockTag = function(blockTag) {
        return __awaiter(this, void 0, void 0, function() {
          var blockNumber;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, blockTag];
              case 1:
                blockTag = _a.sent();
                if (!(typeof blockTag === "number" && blockTag < 0))
                  return [3, 3];
                if (blockTag % 1) {
                  logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                }
                return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
              case 2:
                blockNumber = _a.sent();
                blockNumber += blockTag;
                if (blockNumber < 0) {
                  blockNumber = 0;
                }
                return [2, this.formatter.blockTag(blockNumber)];
              case 3:
                return [2, this.formatter.blockTag(blockTag)];
            }
          });
        });
      };
      BaseProvider2.prototype.getResolver = function(name) {
        return __awaiter(this, void 0, void 0, function() {
          var currentName, addr, resolver, _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                currentName = name;
                _b.label = 1;
              case 1:
                if (false)
                  return [3, 6];
                if (currentName === "" || currentName === ".") {
                  return [2, null];
                }
                if (name !== "eth" && currentName === "eth") {
                  return [2, null];
                }
                return [4, this._getResolver(currentName, "getResolver")];
              case 2:
                addr = _b.sent();
                if (!(addr != null))
                  return [3, 5];
                resolver = new Resolver(this, addr, name);
                _a = currentName !== name;
                if (!_a)
                  return [3, 4];
                return [4, resolver.supportsWildcard()];
              case 3:
                _a = !_b.sent();
                _b.label = 4;
              case 4:
                if (_a) {
                  return [2, null];
                }
                return [2, resolver];
              case 5:
                currentName = currentName.split(".").slice(1).join(".");
                return [3, 1];
              case 6:
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._getResolver = function(name, operation) {
        return __awaiter(this, void 0, void 0, function() {
          var network, addrData, error_10;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (operation == null) {
                  operation = "ENS";
                }
                return [4, this.getNetwork()];
              case 1:
                network = _a.sent();
                if (!network.ensAddress) {
                  logger.throwError("network does not support ENS", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
                }
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.call({
                  to: network.ensAddress,
                  data: "0x0178b8bf" + (0, hash_1.namehash)(name).substring(2)
                })];
              case 3:
                addrData = _a.sent();
                return [2, this.formatter.callAddress(addrData)];
              case 4:
                error_10 = _a.sent();
                return [3, 5];
              case 5:
                return [2, null];
            }
          });
        });
      };
      BaseProvider2.prototype.resolveName = function(name) {
        return __awaiter(this, void 0, void 0, function() {
          var resolver;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, name];
              case 1:
                name = _a.sent();
                try {
                  return [2, Promise.resolve(this.formatter.address(name))];
                } catch (error) {
                  if ((0, bytes_1.isHexString)(name)) {
                    throw error;
                  }
                }
                if (typeof name !== "string") {
                  logger.throwArgumentError("invalid ENS name", "name", name);
                }
                return [4, this.getResolver(name)];
              case 2:
                resolver = _a.sent();
                if (!resolver) {
                  return [2, null];
                }
                return [4, resolver.getAddress()];
              case 3:
                return [2, _a.sent()];
            }
          });
        });
      };
      BaseProvider2.prototype.lookupAddress = function(address) {
        return __awaiter(this, void 0, void 0, function() {
          var node, resolverAddr, name, _a, addr;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, address];
              case 1:
                address = _b.sent();
                address = this.formatter.address(address);
                node = address.substring(2).toLowerCase() + ".addr.reverse";
                return [4, this._getResolver(node, "lookupAddress")];
              case 2:
                resolverAddr = _b.sent();
                if (resolverAddr == null) {
                  return [2, null];
                }
                _a = _parseString;
                return [4, this.call({
                  to: resolverAddr,
                  data: "0x691f3431" + (0, hash_1.namehash)(node).substring(2)
                })];
              case 3:
                name = _a.apply(void 0, [_b.sent(), 0]);
                return [4, this.resolveName(name)];
              case 4:
                addr = _b.sent();
                if (addr != address) {
                  return [2, null];
                }
                return [2, name];
            }
          });
        });
      };
      BaseProvider2.prototype.getAvatar = function(nameOrAddress) {
        return __awaiter(this, void 0, void 0, function() {
          var resolver, address, node, resolverAddress, avatar_1, error_11, name_1, _a, error_12, avatar;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                resolver = null;
                if (!(0, bytes_1.isHexString)(nameOrAddress))
                  return [3, 10];
                address = this.formatter.address(nameOrAddress);
                node = address.substring(2).toLowerCase() + ".addr.reverse";
                return [4, this._getResolver(node, "getAvatar")];
              case 1:
                resolverAddress = _b.sent();
                if (!resolverAddress) {
                  return [2, null];
                }
                resolver = new Resolver(this, resolverAddress, node);
                _b.label = 2;
              case 2:
                _b.trys.push([2, 4, , 5]);
                return [4, resolver.getAvatar()];
              case 3:
                avatar_1 = _b.sent();
                if (avatar_1) {
                  return [2, avatar_1.url];
                }
                return [3, 5];
              case 4:
                error_11 = _b.sent();
                if (error_11.code !== logger_1.Logger.errors.CALL_EXCEPTION) {
                  throw error_11;
                }
                return [3, 5];
              case 5:
                _b.trys.push([5, 8, , 9]);
                _a = _parseString;
                return [4, this.call({
                  to: resolverAddress,
                  data: "0x691f3431" + (0, hash_1.namehash)(node).substring(2)
                })];
              case 6:
                name_1 = _a.apply(void 0, [_b.sent(), 0]);
                return [4, this.getResolver(name_1)];
              case 7:
                resolver = _b.sent();
                return [3, 9];
              case 8:
                error_12 = _b.sent();
                if (error_12.code !== logger_1.Logger.errors.CALL_EXCEPTION) {
                  throw error_12;
                }
                return [2, null];
              case 9:
                return [3, 12];
              case 10:
                return [4, this.getResolver(nameOrAddress)];
              case 11:
                resolver = _b.sent();
                if (!resolver) {
                  return [2, null];
                }
                _b.label = 12;
              case 12:
                return [4, resolver.getAvatar()];
              case 13:
                avatar = _b.sent();
                if (avatar == null) {
                  return [2, null];
                }
                return [2, avatar.url];
            }
          });
        });
      };
      BaseProvider2.prototype.perform = function(method, params) {
        return logger.throwError(method + " not implemented", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });
      };
      BaseProvider2.prototype._startEvent = function(event) {
        this.polling = this._events.filter(function(e) {
          return e.pollable();
        }).length > 0;
      };
      BaseProvider2.prototype._stopEvent = function(event) {
        this.polling = this._events.filter(function(e) {
          return e.pollable();
        }).length > 0;
      };
      BaseProvider2.prototype._addEventListener = function(eventName, listener, once) {
        var event = new Event(getEventTag(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
      };
      BaseProvider2.prototype.on = function(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
      };
      BaseProvider2.prototype.once = function(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
      };
      BaseProvider2.prototype.emit = function(eventName) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var result = false;
        var stopped = [];
        var eventTag = getEventTag(eventName);
        this._events = this._events.filter(function(event) {
          if (event.tag !== eventTag) {
            return true;
          }
          setTimeout(function() {
            event.listener.apply(_this, args);
          }, 0);
          result = true;
          if (event.once) {
            stopped.push(event);
            return false;
          }
          return true;
        });
        stopped.forEach(function(event) {
          _this._stopEvent(event);
        });
        return result;
      };
      BaseProvider2.prototype.listenerCount = function(eventName) {
        if (!eventName) {
          return this._events.length;
        }
        var eventTag = getEventTag(eventName);
        return this._events.filter(function(event) {
          return event.tag === eventTag;
        }).length;
      };
      BaseProvider2.prototype.listeners = function(eventName) {
        if (eventName == null) {
          return this._events.map(function(event) {
            return event.listener;
          });
        }
        var eventTag = getEventTag(eventName);
        return this._events.filter(function(event) {
          return event.tag === eventTag;
        }).map(function(event) {
          return event.listener;
        });
      };
      BaseProvider2.prototype.off = function(eventName, listener) {
        var _this = this;
        if (listener == null) {
          return this.removeAllListeners(eventName);
        }
        var stopped = [];
        var found = false;
        var eventTag = getEventTag(eventName);
        this._events = this._events.filter(function(event) {
          if (event.tag !== eventTag || event.listener != listener) {
            return true;
          }
          if (found) {
            return true;
          }
          found = true;
          stopped.push(event);
          return false;
        });
        stopped.forEach(function(event) {
          _this._stopEvent(event);
        });
        return this;
      };
      BaseProvider2.prototype.removeAllListeners = function(eventName) {
        var _this = this;
        var stopped = [];
        if (eventName == null) {
          stopped = this._events;
          this._events = [];
        } else {
          var eventTag_1 = getEventTag(eventName);
          this._events = this._events.filter(function(event) {
            if (event.tag !== eventTag_1) {
              return true;
            }
            stopped.push(event);
            return false;
          });
        }
        stopped.forEach(function(event) {
          _this._stopEvent(event);
        });
        return this;
      };
      return BaseProvider2;
    }(abstract_provider_1.Provider);
    exports.BaseProvider = BaseProvider;
  }
});

// node_modules/@ethersproject/providers/lib/json-rpc-provider.js
var require_json_rpc_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/json-rpc-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcProvider = exports.JsonRpcSigner = void 0;
    var abstract_signer_1 = require_lib15();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var hash_1 = require_lib12();
    var properties_1 = require_lib4();
    var strings_1 = require_lib9();
    var transactions_1 = require_lib17();
    var web_1 = require_lib28();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var base_provider_1 = require_base_provider();
    var errorGas = ["call", "estimateGas"];
    function spelunk(value, requireData) {
      if (value == null) {
        return null;
      }
      if (typeof value.message === "string" && value.message.match("reverted")) {
        var data = (0, bytes_1.isHexString)(value.data) ? value.data : null;
        if (!requireData || data) {
          return { message: value.message, data };
        }
      }
      if (typeof value === "object") {
        for (var key in value) {
          var result = spelunk(value[key], requireData);
          if (result) {
            return result;
          }
        }
        return null;
      }
      if (typeof value === "string") {
        try {
          return spelunk(JSON.parse(value), requireData);
        } catch (error) {
        }
      }
      return null;
    }
    function checkError(method, error, params) {
      var transaction = params.transaction || params.signedTransaction;
      if (method === "call") {
        var result = spelunk(error, true);
        if (result) {
          return result.data;
        }
        logger.throwError("missing revert data in call exception; Transaction reverted without a reason string", logger_1.Logger.errors.CALL_EXCEPTION, {
          data: "0x",
          transaction,
          error
        });
      }
      if (method === "estimateGas") {
        var result = spelunk(error.body, false);
        if (result == null) {
          result = spelunk(error, false);
        }
        if (result) {
          logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            reason: result.message,
            method,
            transaction,
            error
          });
        }
      }
      var message = error.message;
      if (error.code === logger_1.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
        message = error.error.message;
      } else if (typeof error.body === "string") {
        message = error.body;
      } else if (typeof error.responseText === "string") {
        message = error.responseText;
      }
      message = (message || "").toLowerCase();
      if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
        logger.throwError("insufficient funds for intrinsic transaction cost", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/nonce (is )?too low/i)) {
        logger.throwError("nonce has already been used", logger_1.Logger.errors.NONCE_EXPIRED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
        logger.throwError("replacement fee too low", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/only replay-protected/i)) {
        logger.throwError("legacy pre-eip-155 transactions not supported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          error,
          method,
          transaction
        });
      }
      if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error,
          method,
          transaction
        });
      }
      throw error;
    }
    function timer(timeout) {
      return new Promise(function(resolve) {
        setTimeout(resolve, timeout);
      });
    }
    function getResult(payload) {
      if (payload.error) {
        var error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
      }
      return payload.result;
    }
    function getLowerCase(value) {
      if (value) {
        return value.toLowerCase();
      }
      return value;
    }
    var _constructorGuard = {};
    var JsonRpcSigner = function(_super) {
      __extends(JsonRpcSigner2, _super);
      function JsonRpcSigner2(constructorGuard, provider, addressOrIndex) {
        var _this = _super.call(this) || this;
        if (constructorGuard !== _constructorGuard) {
          throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        }
        (0, properties_1.defineReadOnly)(_this, "provider", provider);
        if (addressOrIndex == null) {
          addressOrIndex = 0;
        }
        if (typeof addressOrIndex === "string") {
          (0, properties_1.defineReadOnly)(_this, "_address", _this.provider.formatter.address(addressOrIndex));
          (0, properties_1.defineReadOnly)(_this, "_index", null);
        } else if (typeof addressOrIndex === "number") {
          (0, properties_1.defineReadOnly)(_this, "_index", addressOrIndex);
          (0, properties_1.defineReadOnly)(_this, "_address", null);
        } else {
          logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
        }
        return _this;
      }
      JsonRpcSigner2.prototype.connect = function(provider) {
        return logger.throwError("cannot alter JSON-RPC Signer connection", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "connect"
        });
      };
      JsonRpcSigner2.prototype.connectUnchecked = function() {
        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
      };
      JsonRpcSigner2.prototype.getAddress = function() {
        var _this = this;
        if (this._address) {
          return Promise.resolve(this._address);
        }
        return this.provider.send("eth_accounts", []).then(function(accounts) {
          if (accounts.length <= _this._index) {
            logger.throwError("unknown account #" + _this._index, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "getAddress"
            });
          }
          return _this.provider.formatter.address(accounts[_this._index]);
        });
      };
      JsonRpcSigner2.prototype.sendUncheckedTransaction = function(transaction) {
        var _this = this;
        transaction = (0, properties_1.shallowCopy)(transaction);
        var fromAddress = this.getAddress().then(function(address) {
          if (address) {
            address = address.toLowerCase();
          }
          return address;
        });
        if (transaction.gasLimit == null) {
          var estimate = (0, properties_1.shallowCopy)(transaction);
          estimate.from = fromAddress;
          transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) {
          transaction.to = Promise.resolve(transaction.to).then(function(to) {
            return __awaiter(_this, void 0, void 0, function() {
              var address;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (to == null) {
                      return [2, null];
                    }
                    return [4, this.provider.resolveName(to)];
                  case 1:
                    address = _a.sent();
                    if (address == null) {
                      logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }
                    return [2, address];
                }
              });
            });
          });
        }
        return (0, properties_1.resolveProperties)({
          tx: (0, properties_1.resolveProperties)(transaction),
          sender: fromAddress
        }).then(function(_a) {
          var tx = _a.tx, sender = _a.sender;
          if (tx.from != null) {
            if (tx.from.toLowerCase() !== sender) {
              logger.throwArgumentError("from address mismatch", "transaction", transaction);
            }
          } else {
            tx.from = sender;
          }
          var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });
          return _this.provider.send("eth_sendTransaction", [hexTx]).then(function(hash) {
            return hash;
          }, function(error) {
            if (typeof error.message === "string" && error.message.match(/user denied/i)) {
              logger.throwError("user rejected transaction", logger_1.Logger.errors.ACTION_REJECTED, {
                action: "sendTransaction",
                transaction: tx
              });
            }
            return checkError("sendTransaction", error, hexTx);
          });
        });
      };
      JsonRpcSigner2.prototype.signTransaction = function(transaction) {
        return logger.throwError("signing transactions is unsupported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "signTransaction"
        });
      };
      JsonRpcSigner2.prototype.sendTransaction = function(transaction) {
        return __awaiter(this, void 0, void 0, function() {
          var blockNumber, hash, error_1;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval)];
              case 1:
                blockNumber = _a.sent();
                return [4, this.sendUncheckedTransaction(transaction)];
              case 2:
                hash = _a.sent();
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, (0, web_1.poll)(function() {
                  return __awaiter(_this, void 0, void 0, function() {
                    var tx;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.provider.getTransaction(hash)];
                        case 1:
                          tx = _a2.sent();
                          if (tx === null) {
                            return [2, void 0];
                          }
                          return [2, this.provider._wrapTransaction(tx, hash, blockNumber)];
                      }
                    });
                  });
                }, { oncePoll: this.provider })];
              case 4:
                return [2, _a.sent()];
              case 5:
                error_1 = _a.sent();
                error_1.transactionHash = hash;
                throw error_1;
              case 6:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype.signMessage = function(message) {
        return __awaiter(this, void 0, void 0, function() {
          var data, address, error_2;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                data = typeof message === "string" ? (0, strings_1.toUtf8Bytes)(message) : message;
                return [4, this.getAddress()];
              case 1:
                address = _a.sent();
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.provider.send("personal_sign", [(0, bytes_1.hexlify)(data), address.toLowerCase()])];
              case 3:
                return [2, _a.sent()];
              case 4:
                error_2 = _a.sent();
                if (typeof error_2.message === "string" && error_2.message.match(/user denied/i)) {
                  logger.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                    action: "signMessage",
                    from: address,
                    messageData: message
                  });
                }
                throw error_2;
              case 5:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype._legacySignMessage = function(message) {
        return __awaiter(this, void 0, void 0, function() {
          var data, address, error_3;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                data = typeof message === "string" ? (0, strings_1.toUtf8Bytes)(message) : message;
                return [4, this.getAddress()];
              case 1:
                address = _a.sent();
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.provider.send("eth_sign", [address.toLowerCase(), (0, bytes_1.hexlify)(data)])];
              case 3:
                return [2, _a.sent()];
              case 4:
                error_3 = _a.sent();
                if (typeof error_3.message === "string" && error_3.message.match(/user denied/i)) {
                  logger.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                    action: "_legacySignMessage",
                    from: address,
                    messageData: message
                  });
                }
                throw error_3;
              case 5:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype._signTypedData = function(domain, types, value) {
        return __awaiter(this, void 0, void 0, function() {
          var populated, address, error_4;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function(name) {
                  return _this.provider.resolveName(name);
                })];
              case 1:
                populated = _a.sent();
                return [4, this.getAddress()];
              case 2:
                address = _a.sent();
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, this.provider.send("eth_signTypedData_v4", [
                  address.toLowerCase(),
                  JSON.stringify(hash_1._TypedDataEncoder.getPayload(populated.domain, types, populated.value))
                ])];
              case 4:
                return [2, _a.sent()];
              case 5:
                error_4 = _a.sent();
                if (typeof error_4.message === "string" && error_4.message.match(/user denied/i)) {
                  logger.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                    action: "_signTypedData",
                    from: address,
                    messageData: { domain: populated.domain, types, value: populated.value }
                  });
                }
                throw error_4;
              case 6:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype.unlock = function(password) {
        return __awaiter(this, void 0, void 0, function() {
          var provider, address;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                provider = this.provider;
                return [4, this.getAddress()];
              case 1:
                address = _a.sent();
                return [2, provider.send("personal_unlockAccount", [address.toLowerCase(), password, null])];
            }
          });
        });
      };
      return JsonRpcSigner2;
    }(abstract_signer_1.Signer);
    exports.JsonRpcSigner = JsonRpcSigner;
    var UncheckedJsonRpcSigner = function(_super) {
      __extends(UncheckedJsonRpcSigner2, _super);
      function UncheckedJsonRpcSigner2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      UncheckedJsonRpcSigner2.prototype.sendTransaction = function(transaction) {
        var _this = this;
        return this.sendUncheckedTransaction(transaction).then(function(hash) {
          return {
            hash,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: function(confirmations) {
              return _this.provider.waitForTransaction(hash, confirmations);
            }
          };
        });
      };
      return UncheckedJsonRpcSigner2;
    }(JsonRpcSigner);
    var allowedTransactionKeys = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true
    };
    var JsonRpcProvider = function(_super) {
      __extends(JsonRpcProvider2, _super);
      function JsonRpcProvider2(url2, network) {
        var _this = this;
        var networkOrReady = network;
        if (networkOrReady == null) {
          networkOrReady = new Promise(function(resolve, reject) {
            setTimeout(function() {
              _this.detectNetwork().then(function(network2) {
                resolve(network2);
              }, function(error) {
                reject(error);
              });
            }, 0);
          });
        }
        _this = _super.call(this, networkOrReady) || this;
        if (!url2) {
          url2 = (0, properties_1.getStatic)(_this.constructor, "defaultUrl")();
        }
        if (typeof url2 === "string") {
          (0, properties_1.defineReadOnly)(_this, "connection", Object.freeze({
            url: url2
          }));
        } else {
          (0, properties_1.defineReadOnly)(_this, "connection", Object.freeze((0, properties_1.shallowCopy)(url2)));
        }
        _this._nextId = 42;
        return _this;
      }
      Object.defineProperty(JsonRpcProvider2.prototype, "_cache", {
        get: function() {
          if (this._eventLoopCache == null) {
            this._eventLoopCache = {};
          }
          return this._eventLoopCache;
        },
        enumerable: false,
        configurable: true
      });
      JsonRpcProvider2.defaultUrl = function() {
        return "http://localhost:8545";
      };
      JsonRpcProvider2.prototype.detectNetwork = function() {
        var _this = this;
        if (!this._cache["detectNetwork"]) {
          this._cache["detectNetwork"] = this._uncachedDetectNetwork();
          setTimeout(function() {
            _this._cache["detectNetwork"] = null;
          }, 0);
        }
        return this._cache["detectNetwork"];
      };
      JsonRpcProvider2.prototype._uncachedDetectNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var chainId, error_5, error_6, getNetwork;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, timer(0)];
              case 1:
                _a.sent();
                chainId = null;
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 9]);
                return [4, this.send("eth_chainId", [])];
              case 3:
                chainId = _a.sent();
                return [3, 9];
              case 4:
                error_5 = _a.sent();
                _a.label = 5;
              case 5:
                _a.trys.push([5, 7, , 8]);
                return [4, this.send("net_version", [])];
              case 6:
                chainId = _a.sent();
                return [3, 8];
              case 7:
                error_6 = _a.sent();
                return [3, 8];
              case 8:
                return [3, 9];
              case 9:
                if (chainId != null) {
                  getNetwork = (0, properties_1.getStatic)(this.constructor, "getNetwork");
                  try {
                    return [2, getNetwork(bignumber_1.BigNumber.from(chainId).toNumber())];
                  } catch (error) {
                    return [2, logger.throwError("could not detect network", logger_1.Logger.errors.NETWORK_ERROR, {
                      chainId,
                      event: "invalidNetwork",
                      serverError: error
                    })];
                  }
                }
                return [2, logger.throwError("could not detect network", logger_1.Logger.errors.NETWORK_ERROR, {
                  event: "noNetwork"
                })];
            }
          });
        });
      };
      JsonRpcProvider2.prototype.getSigner = function(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
      };
      JsonRpcProvider2.prototype.getUncheckedSigner = function(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
      };
      JsonRpcProvider2.prototype.listAccounts = function() {
        var _this = this;
        return this.send("eth_accounts", []).then(function(accounts) {
          return accounts.map(function(a) {
            return _this.formatter.address(a);
          });
        });
      };
      JsonRpcProvider2.prototype.send = function(method, params) {
        var _this = this;
        var request2 = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        this.emit("debug", {
          action: "request",
          request: (0, properties_1.deepCopy)(request2),
          provider: this
        });
        var cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
        if (cache && this._cache[method]) {
          return this._cache[method];
        }
        var result = (0, web_1.fetchJson)(this.connection, JSON.stringify(request2), getResult).then(function(result2) {
          _this.emit("debug", {
            action: "response",
            request: request2,
            response: result2,
            provider: _this
          });
          return result2;
        }, function(error) {
          _this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: _this
          });
          throw error;
        });
        if (cache) {
          this._cache[method] = result;
          setTimeout(function() {
            _this._cache[method] = null;
          }, 0);
        }
        return result;
      };
      JsonRpcProvider2.prototype.prepareRequest = function(method, params) {
        switch (method) {
          case "getBlockNumber":
            return ["eth_blockNumber", []];
          case "getGasPrice":
            return ["eth_gasPrice", []];
          case "getBalance":
            return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
          case "getTransactionCount":
            return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
          case "getCode":
            return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
          case "getStorageAt":
            return ["eth_getStorageAt", [getLowerCase(params.address), (0, bytes_1.hexZeroPad)(params.position, 32), params.blockTag]];
          case "sendTransaction":
            return ["eth_sendRawTransaction", [params.signedTransaction]];
          case "getBlock":
            if (params.blockTag) {
              return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
            } else if (params.blockHash) {
              return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
            }
            return null;
          case "getTransaction":
            return ["eth_getTransactionByHash", [params.transactionHash]];
          case "getTransactionReceipt":
            return ["eth_getTransactionReceipt", [params.transactionHash]];
          case "call": {
            var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, "hexlifyTransaction");
            return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
          }
          case "estimateGas": {
            var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, "hexlifyTransaction");
            return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
          }
          case "getLogs":
            if (params.filter && params.filter.address != null) {
              params.filter.address = getLowerCase(params.filter.address);
            }
            return ["eth_getLogs", [params.filter]];
          default:
            break;
        }
        return null;
      };
      JsonRpcProvider2.prototype.perform = function(method, params) {
        return __awaiter(this, void 0, void 0, function() {
          var tx, feeData, args, error_7;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(method === "call" || method === "estimateGas"))
                  return [3, 2];
                tx = params.transaction;
                if (!(tx && tx.type != null && bignumber_1.BigNumber.from(tx.type).isZero()))
                  return [3, 2];
                if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null))
                  return [3, 2];
                return [4, this.getFeeData()];
              case 1:
                feeData = _a.sent();
                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  params = (0, properties_1.shallowCopy)(params);
                  params.transaction = (0, properties_1.shallowCopy)(tx);
                  delete params.transaction.type;
                }
                _a.label = 2;
              case 2:
                args = this.prepareRequest(method, params);
                if (args == null) {
                  logger.throwError(method + " not implemented", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });
                }
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, this.send(args[0], args[1])];
              case 4:
                return [2, _a.sent()];
              case 5:
                error_7 = _a.sent();
                return [2, checkError(method, error_7, params)];
              case 6:
                return [2];
            }
          });
        });
      };
      JsonRpcProvider2.prototype._startEvent = function(event) {
        if (event.tag === "pending") {
          this._startPending();
        }
        _super.prototype._startEvent.call(this, event);
      };
      JsonRpcProvider2.prototype._startPending = function() {
        if (this._pendingFilter != null) {
          return;
        }
        var self2 = this;
        var pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function(filterId) {
          function poll() {
            self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
              if (self2._pendingFilter != pendingFilter) {
                return null;
              }
              var seq = Promise.resolve();
              hashes.forEach(function(hash) {
                self2._emitted["t:" + hash.toLowerCase()] = "pending";
                seq = seq.then(function() {
                  return self2.getTransaction(hash).then(function(tx) {
                    self2.emit("pending", tx);
                    return null;
                  });
                });
              });
              return seq.then(function() {
                return timer(1e3);
              });
            }).then(function() {
              if (self2._pendingFilter != pendingFilter) {
                self2.send("eth_uninstallFilter", [filterId]);
                return;
              }
              setTimeout(function() {
                poll();
              }, 0);
              return null;
            }).catch(function(error) {
            });
          }
          poll();
          return filterId;
        }).catch(function(error) {
        });
      };
      JsonRpcProvider2.prototype._stopEvent = function(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) {
          this._pendingFilter = null;
        }
        _super.prototype._stopEvent.call(this, event);
      };
      JsonRpcProvider2.hexlifyTransaction = function(transaction, allowExtra) {
        var allowed = (0, properties_1.shallowCopy)(allowedTransactionKeys);
        if (allowExtra) {
          for (var key in allowExtra) {
            if (allowExtra[key]) {
              allowed[key] = true;
            }
          }
        }
        (0, properties_1.checkProperties)(transaction, allowed);
        var result = {};
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          var value = (0, bytes_1.hexValue)(bignumber_1.BigNumber.from(transaction[key2]));
          if (key2 === "gasLimit") {
            key2 = "gas";
          }
          result[key2] = value;
        });
        ["from", "to", "data"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          result[key2] = (0, bytes_1.hexlify)(transaction[key2]);
        });
        if (transaction.accessList) {
          result["accessList"] = (0, transactions_1.accessListify)(transaction.accessList);
        }
        return result;
      };
      return JsonRpcProvider2;
    }(base_provider_1.BaseProvider);
    exports.JsonRpcProvider = JsonRpcProvider;
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/buffer-util.js
var require_buffer_util2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants2();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length3) {
      for (let i = 0; i < length3; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length3 = buffer.length;
      for (let i = 0; i < length3; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length3) {
          if (length3 < 48)
            _mask(source, mask, output, offset, length3);
          else
            bu.mask(source, mask, output, offset, length3);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/limiter.js
var require_limiter2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util2();
    var Limiter = require_limiter2();
    var { kStatusCode, NOOP: NOOP2 } = require_constants2();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP2);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/validation.js
var require_validation2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require("utf-8-validate");
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate2();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants2();
    var { concat, toArrayBuffer, unmask } = require_buffer_util2();
    var { isValidStatusCode, isValidUTF8 } = require_validation2();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002);
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002);
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002);
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002
            );
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(RangeError, "MASK must be set", true, 1002);
          }
        } else if (this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be clear", true, 1002);
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009);
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(RangeError, "Max payload size exceeded", false, 1009)
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002);
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002);
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/sender.js
var require_sender2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate2();
    var { EMPTY_BUFFER } = require_constants2();
    var { isValidStatusCode } = require_validation2();
    var { mask: applyMask, toBuffer } = require_buffer_util2();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge2 = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge2 ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge2) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length3 = Buffer.byteLength(data);
          if (length3 > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length3);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 8,
            mask: mask2,
            readOnly: false
          }),
          cb
        );
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 9,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(
          Sender.frame(data, {
            fin: true,
            rsv1: false,
            opcode: 10,
            mask: mask2,
            readOnly
          }),
          cb
        );
      }
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(buf, {
              fin: options.fin,
              rsv1: false,
              opcode,
              mask: options.mask,
              readOnly: toBuffer.readOnly
            }),
            cb
          );
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/event-target.js
var require_event_target2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/extension.js
var require_extension2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse2(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse2 };
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var https2 = require("https");
    var http3 = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash: createHash2 } = require("crypto");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate2();
    var Receiver = require_receiver2();
    var Sender = require_sender2();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP: NOOP2
    } = require_constants2();
    var { addEventListener, removeEventListener } = require_event_target2();
    var { format, parse: parse2 } = require_extension2();
    var { toBuffer } = require_buffer_util2();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter2 {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this.binaryType,
          this._extensions,
          this._isServer,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && this._closeFrameReceived)
            this._socket.end();
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived)
            this._socket.end();
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    readyStates.forEach((readyState, i) => {
      const descriptor = { enumerable: true, value: i };
      Object.defineProperty(WebSocket.prototype, readyState, descriptor);
      Object.defineProperty(WebSocket, readyState, descriptor);
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        configurable: true,
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        throw new Error(`Invalid URL: ${websocket.url}`);
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get2 = isSecure ? https2.get : http3.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket",
        ...opts.headers
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req = websocket._req = get2(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        websocket._readyState = WebSocket.CLOSING;
        websocket.emit("error", err);
        websocket.emitClose();
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          const addr = new URL2(location, address);
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        if (perMessageDeflate) {
          try {
            const extensions = parse2(res.headers["sec-websocket-extensions"]);
            if (extensions[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
              websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            abortHandshake(
              websocket,
              socket,
              "Invalid Sec-WebSocket-Extensions header"
            );
            return;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream4, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream4.setHeader) {
        stream4.abort();
        if (stream4.socket && !stream4.socket.destroyed) {
          stream4.socket.destroy();
        }
        stream4.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream4.destroy(err);
        stream4.once("error", websocket.emit.bind(websocket, "error"));
        stream4.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length3 = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length3;
        else
          websocket._bufferedAmount += length3;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._socket.resume();
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._readyState = WebSocket.CLOSING;
      websocket._closeCode = err[kStatusCode];
      websocket.emit("error", err);
      websocket._socket.destroy();
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP2);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      websocket._socket.read();
      websocket._receiver.end();
      this.removeListener("data", socketOnData);
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP2);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/stream.js
var require_stream3 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream4) {
      stream4.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open2() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        duplex.destroy(err);
      });
      ws.once("close", function close2() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close2() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/lib/websocket-server.js
var require_websocket_server2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var { createHash: createHash2 } = require("crypto");
    var { createServer, STATUS_CODES } = require("http");
    var PerMessageDeflate = require_permessage_deflate2();
    var WebSocket = require_websocket2();
    var { format, parse: parse2 } = require_extension2();
    var { GUID, kWebSocket } = require_constants2();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var WebSocketServer = class extends EventEmitter2 {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer) {
          throw new TypeError(
            'One of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = createServer((req, res) => {
            const body = STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = /* @__PURE__ */ new Set();
        this.options = options;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(() => this.emit("close"));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = parse2(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        const digest = createHash2("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim2);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map2) {
      for (const event of Object.keys(map2))
        server.on(event, map2[event]);
      return function removeListeners() {
        for (const event of Object.keys(map2)) {
          server.removeListener(event, map2[event]);
        }
      };
    }
    function emitClose(server) {
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.write(
          `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim2(str) {
      return str.trim();
    }
  }
});

// node_modules/@ethersproject/providers/node_modules/ws/index.js
var require_ws2 = __commonJS({
  "node_modules/@ethersproject/providers/node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket = require_websocket2();
    WebSocket.createWebSocketStream = require_stream3();
    WebSocket.Server = require_websocket_server2();
    WebSocket.Receiver = require_receiver2();
    WebSocket.Sender = require_sender2();
    module2.exports = WebSocket;
  }
});

// node_modules/@ethersproject/providers/lib/ws.js
var require_ws3 = __commonJS({
  "node_modules/@ethersproject/providers/lib/ws.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocket = void 0;
    var ws_1 = __importDefault(require_ws2());
    exports.WebSocket = ws_1.default;
  }
});

// node_modules/@ethersproject/providers/lib/websocket-provider.js
var require_websocket_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/websocket-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketProvider = void 0;
    var bignumber_1 = require_lib3();
    var properties_1 = require_lib4();
    var json_rpc_provider_1 = require_json_rpc_provider();
    var ws_1 = require_ws3();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var NextId = 1;
    var WebSocketProvider = function(_super) {
      __extends(WebSocketProvider2, _super);
      function WebSocketProvider2(url2, network) {
        var _this = this;
        if (network === "any") {
          logger.throwError("WebSocketProvider does not support 'any' network yet", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "network:any"
          });
        }
        if (typeof url2 === "string") {
          _this = _super.call(this, url2, network) || this;
        } else {
          _this = _super.call(this, "_websocket", network) || this;
        }
        _this._pollingInterval = -1;
        _this._wsReady = false;
        if (typeof url2 === "string") {
          (0, properties_1.defineReadOnly)(_this, "_websocket", new ws_1.WebSocket(_this.connection.url));
        } else {
          (0, properties_1.defineReadOnly)(_this, "_websocket", url2);
        }
        (0, properties_1.defineReadOnly)(_this, "_requests", {});
        (0, properties_1.defineReadOnly)(_this, "_subs", {});
        (0, properties_1.defineReadOnly)(_this, "_subIds", {});
        (0, properties_1.defineReadOnly)(_this, "_detectNetwork", _super.prototype.detectNetwork.call(_this));
        _this.websocket.onopen = function() {
          _this._wsReady = true;
          Object.keys(_this._requests).forEach(function(id) {
            _this.websocket.send(_this._requests[id].payload);
          });
        };
        _this.websocket.onmessage = function(messageEvent) {
          var data = messageEvent.data;
          var result = JSON.parse(data);
          if (result.id != null) {
            var id = String(result.id);
            var request2 = _this._requests[id];
            delete _this._requests[id];
            if (result.result !== void 0) {
              request2.callback(null, result.result);
              _this.emit("debug", {
                action: "response",
                request: JSON.parse(request2.payload),
                response: result.result,
                provider: _this
              });
            } else {
              var error = null;
              if (result.error) {
                error = new Error(result.error.message || "unknown error");
                (0, properties_1.defineReadOnly)(error, "code", result.error.code || null);
                (0, properties_1.defineReadOnly)(error, "response", data);
              } else {
                error = new Error("unknown error");
              }
              request2.callback(error, void 0);
              _this.emit("debug", {
                action: "response",
                error,
                request: JSON.parse(request2.payload),
                provider: _this
              });
            }
          } else if (result.method === "eth_subscription") {
            var sub = _this._subs[result.params.subscription];
            if (sub) {
              sub.processFunc(result.params.result);
            }
          } else {
            console.warn("this should not happen");
          }
        };
        var fauxPoll = setInterval(function() {
          _this.emit("poll");
        }, 1e3);
        if (fauxPoll.unref) {
          fauxPoll.unref();
        }
        return _this;
      }
      Object.defineProperty(WebSocketProvider2.prototype, "websocket", {
        get: function() {
          return this._websocket;
        },
        enumerable: false,
        configurable: true
      });
      WebSocketProvider2.prototype.detectNetwork = function() {
        return this._detectNetwork;
      };
      Object.defineProperty(WebSocketProvider2.prototype, "pollingInterval", {
        get: function() {
          return 0;
        },
        set: function(value) {
          logger.throwError("cannot set polling interval on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
          });
        },
        enumerable: false,
        configurable: true
      });
      WebSocketProvider2.prototype.resetEventsBlock = function(blockNumber) {
        logger.throwError("cannot reset events block on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resetEventBlock"
        });
      };
      WebSocketProvider2.prototype.poll = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, null];
          });
        });
      };
      Object.defineProperty(WebSocketProvider2.prototype, "polling", {
        set: function(value) {
          if (!value) {
            return;
          }
          logger.throwError("cannot set polling on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
          });
        },
        enumerable: false,
        configurable: true
      });
      WebSocketProvider2.prototype.send = function(method, params) {
        var _this = this;
        var rid = NextId++;
        return new Promise(function(resolve, reject) {
          function callback(error, result) {
            if (error) {
              return reject(error);
            }
            return resolve(result);
          }
          var payload = JSON.stringify({
            method,
            params,
            id: rid,
            jsonrpc: "2.0"
          });
          _this.emit("debug", {
            action: "request",
            request: JSON.parse(payload),
            provider: _this
          });
          _this._requests[String(rid)] = { callback, payload };
          if (_this._wsReady) {
            _this.websocket.send(payload);
          }
        });
      };
      WebSocketProvider2.defaultUrl = function() {
        return "ws://localhost:8546";
      };
      WebSocketProvider2.prototype._subscribe = function(tag, param, processFunc) {
        return __awaiter(this, void 0, void 0, function() {
          var subIdPromise, subId;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                subIdPromise = this._subIds[tag];
                if (subIdPromise == null) {
                  subIdPromise = Promise.all(param).then(function(param2) {
                    return _this.send("eth_subscribe", param2);
                  });
                  this._subIds[tag] = subIdPromise;
                }
                return [4, subIdPromise];
              case 1:
                subId = _a.sent();
                this._subs[subId] = { tag, processFunc };
                return [2];
            }
          });
        });
      };
      WebSocketProvider2.prototype._startEvent = function(event) {
        var _this = this;
        switch (event.type) {
          case "block":
            this._subscribe("block", ["newHeads"], function(result) {
              var blockNumber = bignumber_1.BigNumber.from(result.number).toNumber();
              _this._emitted.block = blockNumber;
              _this.emit("block", blockNumber);
            });
            break;
          case "pending":
            this._subscribe("pending", ["newPendingTransactions"], function(result) {
              _this.emit("pending", result);
            });
            break;
          case "filter":
            this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], function(result) {
              if (result.removed == null) {
                result.removed = false;
              }
              _this.emit(event.filter, _this.formatter.filterLog(result));
            });
            break;
          case "tx": {
            var emitReceipt_1 = function(event2) {
              var hash = event2.hash;
              _this.getTransactionReceipt(hash).then(function(receipt) {
                if (!receipt) {
                  return;
                }
                _this.emit(hash, receipt);
              });
            };
            emitReceipt_1(event);
            this._subscribe("tx", ["newHeads"], function(result) {
              _this._events.filter(function(e) {
                return e.type === "tx";
              }).forEach(emitReceipt_1);
            });
            break;
          }
          case "debug":
          case "poll":
          case "willPoll":
          case "didPoll":
          case "error":
            break;
          default:
            console.log("unhandled:", event);
            break;
        }
      };
      WebSocketProvider2.prototype._stopEvent = function(event) {
        var _this = this;
        var tag = event.tag;
        if (event.type === "tx") {
          if (this._events.filter(function(e) {
            return e.type === "tx";
          }).length) {
            return;
          }
          tag = "tx";
        } else if (this.listenerCount(event.event)) {
          return;
        }
        var subId = this._subIds[tag];
        if (!subId) {
          return;
        }
        delete this._subIds[tag];
        subId.then(function(subId2) {
          if (!_this._subs[subId2]) {
            return;
          }
          delete _this._subs[subId2];
          _this.send("eth_unsubscribe", [subId2]);
        });
      };
      WebSocketProvider2.prototype.destroy = function() {
        return __awaiter(this, void 0, void 0, function() {
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(this.websocket.readyState === ws_1.WebSocket.CONNECTING))
                  return [3, 2];
                return [4, new Promise(function(resolve) {
                  _this.websocket.onopen = function() {
                    resolve(true);
                  };
                  _this.websocket.onerror = function() {
                    resolve(false);
                  };
                })];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                this.websocket.close(1e3);
                return [2];
            }
          });
        });
      };
      return WebSocketProvider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.WebSocketProvider = WebSocketProvider;
  }
});

// node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js
var require_url_json_rpc_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlJsonRpcProvider = exports.StaticJsonRpcProvider = void 0;
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var json_rpc_provider_1 = require_json_rpc_provider();
    var StaticJsonRpcProvider = function(_super) {
      __extends(StaticJsonRpcProvider2, _super);
      function StaticJsonRpcProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      StaticJsonRpcProvider2.prototype.detectNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var network;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                network = this.network;
                if (!(network == null))
                  return [3, 2];
                return [4, _super.prototype.detectNetwork.call(this)];
              case 1:
                network = _a.sent();
                if (!network) {
                  logger.throwError("no network detected", logger_1.Logger.errors.UNKNOWN_ERROR, {});
                }
                if (this._network == null) {
                  (0, properties_1.defineReadOnly)(this, "_network", network);
                  this.emit("network", network, null);
                }
                _a.label = 2;
              case 2:
                return [2, network];
            }
          });
        });
      };
      return StaticJsonRpcProvider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.StaticJsonRpcProvider = StaticJsonRpcProvider;
    var UrlJsonRpcProvider = function(_super) {
      __extends(UrlJsonRpcProvider2, _super);
      function UrlJsonRpcProvider2(network, apiKey) {
        var _newTarget = this.constructor;
        var _this = this;
        logger.checkAbstract(_newTarget, UrlJsonRpcProvider2);
        network = (0, properties_1.getStatic)(_newTarget, "getNetwork")(network);
        apiKey = (0, properties_1.getStatic)(_newTarget, "getApiKey")(apiKey);
        var connection = (0, properties_1.getStatic)(_newTarget, "getUrl")(network, apiKey);
        _this = _super.call(this, connection, network) || this;
        if (typeof apiKey === "string") {
          (0, properties_1.defineReadOnly)(_this, "apiKey", apiKey);
        } else if (apiKey != null) {
          Object.keys(apiKey).forEach(function(key) {
            (0, properties_1.defineReadOnly)(_this, key, apiKey[key]);
          });
        }
        return _this;
      }
      UrlJsonRpcProvider2.prototype._startPending = function() {
        logger.warn("WARNING: API provider does not support pending filters");
      };
      UrlJsonRpcProvider2.prototype.isCommunityResource = function() {
        return false;
      };
      UrlJsonRpcProvider2.prototype.getSigner = function(address) {
        return logger.throwError("API provider does not support signing", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
      };
      UrlJsonRpcProvider2.prototype.listAccounts = function() {
        return Promise.resolve([]);
      };
      UrlJsonRpcProvider2.getApiKey = function(apiKey) {
        return apiKey;
      };
      UrlJsonRpcProvider2.getUrl = function(network, apiKey) {
        return logger.throwError("not implemented; sub-classes must override getUrl", logger_1.Logger.errors.NOT_IMPLEMENTED, {
          operation: "getUrl"
        });
      };
      return UrlJsonRpcProvider2;
    }(StaticJsonRpcProvider);
    exports.UrlJsonRpcProvider = UrlJsonRpcProvider;
  }
});

// node_modules/@ethersproject/providers/lib/alchemy-provider.js
var require_alchemy_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/alchemy-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlchemyProvider = exports.AlchemyWebSocketProvider = void 0;
    var properties_1 = require_lib4();
    var formatter_1 = require_formatter();
    var websocket_provider_1 = require_websocket_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
    var AlchemyWebSocketProvider = function(_super) {
      __extends(AlchemyWebSocketProvider2, _super);
      function AlchemyWebSocketProvider2(network, apiKey) {
        var _this = this;
        var provider = new AlchemyProvider(network, apiKey);
        var url2 = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
        _this = _super.call(this, url2, provider.network) || this;
        (0, properties_1.defineReadOnly)(_this, "apiKey", provider.apiKey);
        return _this;
      }
      AlchemyWebSocketProvider2.prototype.isCommunityResource = function() {
        return this.apiKey === defaultApiKey;
      };
      return AlchemyWebSocketProvider2;
    }(websocket_provider_1.WebSocketProvider);
    exports.AlchemyWebSocketProvider = AlchemyWebSocketProvider;
    var AlchemyProvider = function(_super) {
      __extends(AlchemyProvider2, _super);
      function AlchemyProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AlchemyProvider2.getWebSocketProvider = function(network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
      };
      AlchemyProvider2.getApiKey = function(apiKey) {
        if (apiKey == null) {
          return defaultApiKey;
        }
        if (apiKey && typeof apiKey !== "string") {
          logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey;
      };
      AlchemyProvider2.getUrl = function(network, apiKey) {
        var host = null;
        switch (network.name) {
          case "homestead":
            host = "eth-mainnet.alchemyapi.io/v2/";
            break;
          case "goerli":
            host = "eth-goerli.g.alchemy.com/v2/";
            break;
          case "matic":
            host = "polygon-mainnet.g.alchemy.com/v2/";
            break;
          case "maticmum":
            host = "polygon-mumbai.g.alchemy.com/v2/";
            break;
          case "arbitrum":
            host = "arb-mainnet.g.alchemy.com/v2/";
            break;
          case "arbitrum-goerli":
            host = "arb-goerli.g.alchemy.com/v2/";
            break;
          case "optimism":
            host = "opt-mainnet.g.alchemy.com/v2/";
            break;
          case "optimism-goerli":
            host = "opt-goerli.g.alchemy.com/v2/";
            break;
          default:
            logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
          allowGzip: true,
          url: "https://" + host + apiKey,
          throttleCallback: function(attempt, url2) {
            if (apiKey === defaultApiKey) {
              (0, formatter_1.showThrottleMessage)();
            }
            return Promise.resolve(true);
          }
        };
      };
      AlchemyProvider2.prototype.isCommunityResource = function() {
        return this.apiKey === defaultApiKey;
      };
      return AlchemyProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.AlchemyProvider = AlchemyProvider;
  }
});

// node_modules/@ethersproject/providers/lib/ankr-provider.js
var require_ankr_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/ankr-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnkrProvider = void 0;
    var formatter_1 = require_formatter();
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
    function getHost(name) {
      switch (name) {
        case "homestead":
          return "rpc.ankr.com/eth/";
        case "ropsten":
          return "rpc.ankr.com/eth_ropsten/";
        case "rinkeby":
          return "rpc.ankr.com/eth_rinkeby/";
        case "goerli":
          return "rpc.ankr.com/eth_goerli/";
        case "matic":
          return "rpc.ankr.com/polygon/";
        case "arbitrum":
          return "rpc.ankr.com/arbitrum/";
      }
      return logger.throwArgumentError("unsupported network", "name", name);
    }
    var AnkrProvider = function(_super) {
      __extends(AnkrProvider2, _super);
      function AnkrProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnkrProvider2.prototype.isCommunityResource = function() {
        return this.apiKey === defaultApiKey;
      };
      AnkrProvider2.getApiKey = function(apiKey) {
        if (apiKey == null) {
          return defaultApiKey;
        }
        return apiKey;
      };
      AnkrProvider2.getUrl = function(network, apiKey) {
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        var connection = {
          allowGzip: true,
          url: "https://" + getHost(network.name) + apiKey,
          throttleCallback: function(attempt, url2) {
            if (apiKey.apiKey === defaultApiKey) {
              (0, formatter_1.showThrottleMessage)();
            }
            return Promise.resolve(true);
          }
        };
        if (apiKey.projectSecret != null) {
          connection.user = "";
          connection.password = apiKey.projectSecret;
        }
        return connection;
      };
      return AnkrProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.AnkrProvider = AnkrProvider;
  }
});

// node_modules/@ethersproject/providers/lib/cloudflare-provider.js
var require_cloudflare_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/cloudflare-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloudflareProvider = void 0;
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var CloudflareProvider = function(_super) {
      __extends(CloudflareProvider2, _super);
      function CloudflareProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CloudflareProvider2.getApiKey = function(apiKey) {
        if (apiKey != null) {
          logger.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        }
        return null;
      };
      CloudflareProvider2.getUrl = function(network, apiKey) {
        var host = null;
        switch (network.name) {
          case "homestead":
            host = "https://cloudflare-eth.com/";
            break;
          default:
            logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
      };
      CloudflareProvider2.prototype.perform = function(method, params) {
        return __awaiter(this, void 0, void 0, function() {
          var block;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(method === "getBlockNumber"))
                  return [3, 2];
                return [4, _super.prototype.perform.call(this, "getBlock", { blockTag: "latest" })];
              case 1:
                block = _a.sent();
                return [2, block.number];
              case 2:
                return [2, _super.prototype.perform.call(this, method, params)];
            }
          });
        });
      };
      return CloudflareProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.CloudflareProvider = CloudflareProvider;
  }
});

// node_modules/@ethersproject/providers/lib/etherscan-provider.js
var require_etherscan_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/etherscan-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherscanProvider = void 0;
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var transactions_1 = require_lib17();
    var web_1 = require_lib28();
    var formatter_1 = require_formatter();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var base_provider_1 = require_base_provider();
    function getTransactionPostData(transaction) {
      var result = {};
      for (var key in transaction) {
        if (transaction[key] == null) {
          continue;
        }
        var value = transaction[key];
        if (key === "type" && value === 0) {
          continue;
        }
        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
          value = (0, bytes_1.hexValue)((0, bytes_1.hexlify)(value));
        } else if (key === "accessList") {
          value = "[" + (0, transactions_1.accessListify)(value).map(function(set) {
            return '{address:"' + set.address + '",storageKeys:["' + set.storageKeys.join('","') + '"]}';
          }).join(",") + "]";
        } else {
          value = (0, bytes_1.hexlify)(value);
        }
        result[key] = value;
      }
      return result;
    }
    function getResult(result) {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        return result.result;
      }
      if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
        var error = new Error("invalid response");
        error.result = JSON.stringify(result);
        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
          error.throttleRetry = true;
        }
        throw error;
      }
      return result.result;
    }
    function getJsonResult(result) {
      if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        var error = new Error("throttled response");
        error.result = JSON.stringify(result);
        error.throttleRetry = true;
        throw error;
      }
      if (result.jsonrpc != "2.0") {
        var error = new Error("invalid response");
        error.result = JSON.stringify(result);
        throw error;
      }
      if (result.error) {
        var error = new Error(result.error.message || "unknown error");
        if (result.error.code) {
          error.code = result.error.code;
        }
        if (result.error.data) {
          error.data = result.error.data;
        }
        throw error;
      }
      return result.result;
    }
    function checkLogTag(blockTag) {
      if (blockTag === "pending") {
        throw new Error("pending not supported");
      }
      if (blockTag === "latest") {
        return blockTag;
      }
      return parseInt(blockTag.substring(2), 16);
    }
    function checkError(method, error, transaction) {
      if (method === "call" && error.code === logger_1.Logger.errors.SERVER_ERROR) {
        var e = error.error;
        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
          var data = e.data;
          if (data) {
            data = "0x" + data.replace(/^.*0x/i, "");
          }
          if ((0, bytes_1.isHexString)(data)) {
            return data;
          }
          logger.throwError("missing revert data in call exception", logger_1.Logger.errors.CALL_EXCEPTION, {
            error,
            data: "0x"
          });
        }
      }
      var message = error.message;
      if (error.code === logger_1.Logger.errors.SERVER_ERROR) {
        if (error.error && typeof error.error.message === "string") {
          message = error.error.message;
        } else if (typeof error.body === "string") {
          message = error.body;
        } else if (typeof error.responseText === "string") {
          message = error.responseText;
        }
      }
      message = (message || "").toLowerCase();
      if (message.match(/insufficient funds/)) {
        logger.throwError("insufficient funds for intrinsic transaction cost", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
        logger.throwError("nonce has already been used", logger_1.Logger.errors.NONCE_EXPIRED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/another transaction with same nonce/)) {
        logger.throwError("replacement fee too low", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/execution failed due to an exception|execution reverted/)) {
        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error,
          method,
          transaction
        });
      }
      throw error;
    }
    var EtherscanProvider = function(_super) {
      __extends(EtherscanProvider2, _super);
      function EtherscanProvider2(network, apiKey) {
        var _this = _super.call(this, network) || this;
        (0, properties_1.defineReadOnly)(_this, "baseUrl", _this.getBaseUrl());
        (0, properties_1.defineReadOnly)(_this, "apiKey", apiKey || null);
        return _this;
      }
      EtherscanProvider2.prototype.getBaseUrl = function() {
        switch (this.network ? this.network.name : "invalid") {
          case "homestead":
            return "https://api.etherscan.io";
          case "goerli":
            return "https://api-goerli.etherscan.io";
          case "sepolia":
            return "https://api-sepolia.etherscan.io";
          case "matic":
            return "https://api.polygonscan.com";
          case "maticmum":
            return "https://api-testnet.polygonscan.com";
          case "arbitrum":
            return "https://api.arbiscan.io";
          case "arbitrum-goerli":
            return "https://api-goerli.arbiscan.io";
          case "optimism":
            return "https://api-optimistic.etherscan.io";
          case "optimism-goerli":
            return "https://api-goerli-optimistic.etherscan.io";
          default:
        }
        return logger.throwArgumentError("unsupported network", "network", this.network.name);
      };
      EtherscanProvider2.prototype.getUrl = function(module3, params) {
        var query = Object.keys(params).reduce(function(accum, key) {
          var value = params[key];
          if (value != null) {
            accum += "&" + key + "=" + value;
          }
          return accum;
        }, "");
        var apiKey = this.apiKey ? "&apikey=" + this.apiKey : "";
        return this.baseUrl + "/api?module=" + module3 + query + apiKey;
      };
      EtherscanProvider2.prototype.getPostUrl = function() {
        return this.baseUrl + "/api";
      };
      EtherscanProvider2.prototype.getPostData = function(module3, params) {
        params.module = module3;
        params.apikey = this.apiKey;
        return params;
      };
      EtherscanProvider2.prototype.fetch = function(module3, params, post) {
        return __awaiter(this, void 0, void 0, function() {
          var url2, payload, procFunc, connection, payloadStr, result;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                url2 = post ? this.getPostUrl() : this.getUrl(module3, params);
                payload = post ? this.getPostData(module3, params) : null;
                procFunc = module3 === "proxy" ? getJsonResult : getResult;
                this.emit("debug", {
                  action: "request",
                  request: url2,
                  provider: this
                });
                connection = {
                  url: url2,
                  throttleSlotInterval: 1e3,
                  throttleCallback: function(attempt, url3) {
                    if (_this.isCommunityResource()) {
                      (0, formatter_1.showThrottleMessage)();
                    }
                    return Promise.resolve(true);
                  }
                };
                payloadStr = null;
                if (payload) {
                  connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
                  payloadStr = Object.keys(payload).map(function(key) {
                    return key + "=" + payload[key];
                  }).join("&");
                }
                return [4, (0, web_1.fetchJson)(connection, payloadStr, procFunc || getJsonResult)];
              case 1:
                result = _a.sent();
                this.emit("debug", {
                  action: "response",
                  request: url2,
                  response: (0, properties_1.deepCopy)(result),
                  provider: this
                });
                return [2, result];
            }
          });
        });
      };
      EtherscanProvider2.prototype.detectNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.network];
          });
        });
      };
      EtherscanProvider2.prototype.perform = function(method, params) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, postData, error_1, postData, error_2, args, topic0, logs, blocks, i, log, block, _b;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                _a = method;
                switch (_a) {
                  case "getBlockNumber":
                    return [3, 1];
                  case "getGasPrice":
                    return [3, 2];
                  case "getBalance":
                    return [3, 3];
                  case "getTransactionCount":
                    return [3, 4];
                  case "getCode":
                    return [3, 5];
                  case "getStorageAt":
                    return [3, 6];
                  case "sendTransaction":
                    return [3, 7];
                  case "getBlock":
                    return [3, 8];
                  case "getTransaction":
                    return [3, 9];
                  case "getTransactionReceipt":
                    return [3, 10];
                  case "call":
                    return [3, 11];
                  case "estimateGas":
                    return [3, 15];
                  case "getLogs":
                    return [3, 19];
                  case "getEtherPrice":
                    return [3, 26];
                }
                return [3, 28];
              case 1:
                return [2, this.fetch("proxy", { action: "eth_blockNumber" })];
              case 2:
                return [2, this.fetch("proxy", { action: "eth_gasPrice" })];
              case 3:
                return [2, this.fetch("account", {
                  action: "balance",
                  address: params.address,
                  tag: params.blockTag
                })];
              case 4:
                return [2, this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: params.address,
                  tag: params.blockTag
                })];
              case 5:
                return [2, this.fetch("proxy", {
                  action: "eth_getCode",
                  address: params.address,
                  tag: params.blockTag
                })];
              case 6:
                return [2, this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: params.address,
                  position: params.position,
                  tag: params.blockTag
                })];
              case 7:
                return [2, this.fetch("proxy", {
                  action: "eth_sendRawTransaction",
                  hex: params.signedTransaction
                }, true).catch(function(error) {
                  return checkError("sendTransaction", error, params.signedTransaction);
                })];
              case 8:
                if (params.blockTag) {
                  return [2, this.fetch("proxy", {
                    action: "eth_getBlockByNumber",
                    tag: params.blockTag,
                    boolean: params.includeTransactions ? "true" : "false"
                  })];
                }
                throw new Error("getBlock by blockHash not implemented");
              case 9:
                return [2, this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: params.transactionHash
                })];
              case 10:
                return [2, this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: params.transactionHash
                })];
              case 11:
                if (params.blockTag !== "latest") {
                  throw new Error("EtherscanProvider does not support blockTag for call");
                }
                postData = getTransactionPostData(params.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                _c.label = 12;
              case 12:
                _c.trys.push([12, 14, , 15]);
                return [4, this.fetch("proxy", postData, true)];
              case 13:
                return [2, _c.sent()];
              case 14:
                error_1 = _c.sent();
                return [2, checkError("call", error_1, params.transaction)];
              case 15:
                postData = getTransactionPostData(params.transaction);
                postData.module = "proxy";
                postData.action = "eth_estimateGas";
                _c.label = 16;
              case 16:
                _c.trys.push([16, 18, , 19]);
                return [4, this.fetch("proxy", postData, true)];
              case 17:
                return [2, _c.sent()];
              case 18:
                error_2 = _c.sent();
                return [2, checkError("estimateGas", error_2, params.transaction)];
              case 19:
                args = { action: "getLogs" };
                if (params.filter.fromBlock) {
                  args.fromBlock = checkLogTag(params.filter.fromBlock);
                }
                if (params.filter.toBlock) {
                  args.toBlock = checkLogTag(params.filter.toBlock);
                }
                if (params.filter.address) {
                  args.address = params.filter.address;
                }
                if (params.filter.topics && params.filter.topics.length > 0) {
                  if (params.filter.topics.length > 1) {
                    logger.throwError("unsupported topic count", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                  }
                  if (params.filter.topics.length === 1) {
                    topic0 = params.filter.topics[0];
                    if (typeof topic0 !== "string" || topic0.length !== 66) {
                      logger.throwError("unsupported topic format", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
                    }
                    args.topic0 = topic0;
                  }
                }
                return [4, this.fetch("logs", args)];
              case 20:
                logs = _c.sent();
                blocks = {};
                i = 0;
                _c.label = 21;
              case 21:
                if (!(i < logs.length))
                  return [3, 25];
                log = logs[i];
                if (log.blockHash != null) {
                  return [3, 24];
                }
                if (!(blocks[log.blockNumber] == null))
                  return [3, 23];
                return [4, this.getBlock(log.blockNumber)];
              case 22:
                block = _c.sent();
                if (block) {
                  blocks[log.blockNumber] = block.hash;
                }
                _c.label = 23;
              case 23:
                log.blockHash = blocks[log.blockNumber];
                _c.label = 24;
              case 24:
                i++;
                return [3, 21];
              case 25:
                return [2, logs];
              case 26:
                if (this.network.name !== "homestead") {
                  return [2, 0];
                }
                _b = parseFloat;
                return [4, this.fetch("stats", { action: "ethprice" })];
              case 27:
                return [2, _b.apply(void 0, [_c.sent().ethusd])];
              case 28:
                return [3, 29];
              case 29:
                return [2, _super.prototype.perform.call(this, method, params)];
            }
          });
        });
      };
      EtherscanProvider2.prototype.getHistory = function(addressOrName, startBlock, endBlock) {
        return __awaiter(this, void 0, void 0, function() {
          var params, result;
          var _a;
          var _this = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a = {
                  action: "txlist"
                };
                return [4, this.resolveName(addressOrName)];
              case 1:
                params = (_a.address = _b.sent(), _a.startblock = startBlock == null ? 0 : startBlock, _a.endblock = endBlock == null ? 99999999 : endBlock, _a.sort = "asc", _a);
                return [4, this.fetch("account", params)];
              case 2:
                result = _b.sent();
                return [2, result.map(function(tx) {
                  ["contractAddress", "to"].forEach(function(key) {
                    if (tx[key] == "") {
                      delete tx[key];
                    }
                  });
                  if (tx.creates == null && tx.contractAddress != null) {
                    tx.creates = tx.contractAddress;
                  }
                  var item = _this.formatter.transactionResponse(tx);
                  if (tx.timeStamp) {
                    item.timestamp = parseInt(tx.timeStamp);
                  }
                  return item;
                })];
            }
          });
        });
      };
      EtherscanProvider2.prototype.isCommunityResource = function() {
        return this.apiKey == null;
      };
      return EtherscanProvider2;
    }(base_provider_1.BaseProvider);
    exports.EtherscanProvider = EtherscanProvider;
  }
});

// node_modules/@ethersproject/providers/lib/fallback-provider.js
var require_fallback_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/fallback-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FallbackProvider = void 0;
    var abstract_provider_1 = require_lib14();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var random_1 = require_lib24();
    var web_1 = require_lib28();
    var base_provider_1 = require_base_provider();
    var formatter_1 = require_formatter();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    function now() {
      return new Date().getTime();
    }
    function checkNetworks(networks) {
      var result = null;
      for (var i = 0; i < networks.length; i++) {
        var network = networks[i];
        if (network == null) {
          return null;
        }
        if (result) {
          if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
            logger.throwArgumentError("provider mismatch", "networks", networks);
          }
        } else {
          result = network;
        }
      }
      return result;
    }
    function median(values, maxDelta) {
      values = values.slice().sort();
      var middle = Math.floor(values.length / 2);
      if (values.length % 2) {
        return values[middle];
      }
      var a = values[middle - 1], b = values[middle];
      if (maxDelta != null && Math.abs(a - b) > maxDelta) {
        return null;
      }
      return (a + b) / 2;
    }
    function serialize3(value) {
      if (value === null) {
        return "null";
      } else if (typeof value === "number" || typeof value === "boolean") {
        return JSON.stringify(value);
      } else if (typeof value === "string") {
        return value;
      } else if (bignumber_1.BigNumber.isBigNumber(value)) {
        return value.toString();
      } else if (Array.isArray(value)) {
        return JSON.stringify(value.map(function(i) {
          return serialize3(i);
        }));
      } else if (typeof value === "object") {
        var keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map(function(key) {
          var v = value[key];
          if (typeof v === "function") {
            v = "[function]";
          } else {
            v = serialize3(v);
          }
          return JSON.stringify(key) + ":" + v;
        }).join(",") + "}";
      }
      throw new Error("unknown value type: " + typeof value);
    }
    var nextRid = 1;
    function stall(duration) {
      var cancel = null;
      var timer = null;
      var promise = new Promise(function(resolve) {
        cancel = function() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          resolve();
        };
        timer = setTimeout(cancel, duration);
      });
      var wait = function(func) {
        promise = promise.then(func);
        return promise;
      };
      function getPromise() {
        return promise;
      }
      return { cancel, getPromise, wait };
    }
    var ForwardErrors = [
      logger_1.Logger.errors.CALL_EXCEPTION,
      logger_1.Logger.errors.INSUFFICIENT_FUNDS,
      logger_1.Logger.errors.NONCE_EXPIRED,
      logger_1.Logger.errors.REPLACEMENT_UNDERPRICED,
      logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT
    ];
    var ForwardProperties = [
      "address",
      "args",
      "errorArgs",
      "errorSignature",
      "method",
      "transaction"
    ];
    function exposeDebugConfig(config, now2) {
      var result = {
        weight: config.weight
      };
      Object.defineProperty(result, "provider", { get: function() {
        return config.provider;
      } });
      if (config.start) {
        result.start = config.start;
      }
      if (now2) {
        result.duration = now2 - config.start;
      }
      if (config.done) {
        if (config.error) {
          result.error = config.error;
        } else {
          result.result = config.result || null;
        }
      }
      return result;
    }
    function normalizedTally(normalize, quorum) {
      return function(configs) {
        var tally = {};
        configs.forEach(function(c3) {
          var value = normalize(c3.result);
          if (!tally[value]) {
            tally[value] = { count: 0, result: c3.result };
          }
          tally[value].count++;
        });
        var keys = Object.keys(tally);
        for (var i = 0; i < keys.length; i++) {
          var check = tally[keys[i]];
          if (check.count >= quorum) {
            return check.result;
          }
        }
        return void 0;
      };
    }
    function getProcessFunc(provider, method, params) {
      var normalize = serialize3;
      switch (method) {
        case "getBlockNumber":
          return function(configs) {
            var values = configs.map(function(c3) {
              return c3.result;
            });
            var blockNumber = median(configs.map(function(c3) {
              return c3.result;
            }), 2);
            if (blockNumber == null) {
              return void 0;
            }
            blockNumber = Math.ceil(blockNumber);
            if (values.indexOf(blockNumber + 1) >= 0) {
              blockNumber++;
            }
            if (blockNumber >= provider._highestBlockNumber) {
              provider._highestBlockNumber = blockNumber;
            }
            return provider._highestBlockNumber;
          };
        case "getGasPrice":
          return function(configs) {
            var values = configs.map(function(c3) {
              return c3.result;
            });
            values.sort();
            return values[Math.floor(values.length / 2)];
          };
        case "getEtherPrice":
          return function(configs) {
            return median(configs.map(function(c3) {
              return c3.result;
            }));
          };
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
          break;
        case "getTransaction":
        case "getTransactionReceipt":
          normalize = function(tx) {
            if (tx == null) {
              return null;
            }
            tx = (0, properties_1.shallowCopy)(tx);
            tx.confirmations = -1;
            return serialize3(tx);
          };
          break;
        case "getBlock":
          if (params.includeTransactions) {
            normalize = function(block) {
              if (block == null) {
                return null;
              }
              block = (0, properties_1.shallowCopy)(block);
              block.transactions = block.transactions.map(function(tx) {
                tx = (0, properties_1.shallowCopy)(tx);
                tx.confirmations = -1;
                return tx;
              });
              return serialize3(block);
            };
          } else {
            normalize = function(block) {
              if (block == null) {
                return null;
              }
              return serialize3(block);
            };
          }
          break;
        default:
          throw new Error("unknown method: " + method);
      }
      return normalizedTally(normalize, provider.quorum);
    }
    function waitForSync(config, blockNumber) {
      return __awaiter(this, void 0, void 0, function() {
        var provider;
        return __generator(this, function(_a) {
          provider = config.provider;
          if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
            return [2, provider];
          }
          return [2, (0, web_1.poll)(function() {
            return new Promise(function(resolve, reject) {
              setTimeout(function() {
                if (provider.blockNumber >= blockNumber) {
                  return resolve(provider);
                }
                if (config.cancelled) {
                  return resolve(null);
                }
                return resolve(void 0);
              }, 0);
            });
          }, { oncePoll: provider })];
        });
      });
    }
    function getRunner(config, currentBlockNumber, method, params) {
      return __awaiter(this, void 0, void 0, function() {
        var provider, _a, filter2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              provider = config.provider;
              _a = method;
              switch (_a) {
                case "getBlockNumber":
                  return [3, 1];
                case "getGasPrice":
                  return [3, 1];
                case "getEtherPrice":
                  return [3, 2];
                case "getBalance":
                  return [3, 3];
                case "getTransactionCount":
                  return [3, 3];
                case "getCode":
                  return [3, 3];
                case "getStorageAt":
                  return [3, 6];
                case "getBlock":
                  return [3, 9];
                case "call":
                  return [3, 12];
                case "estimateGas":
                  return [3, 12];
                case "getTransaction":
                  return [3, 15];
                case "getTransactionReceipt":
                  return [3, 15];
                case "getLogs":
                  return [3, 16];
              }
              return [3, 19];
            case 1:
              return [2, provider[method]()];
            case 2:
              if (provider.getEtherPrice) {
                return [2, provider.getEtherPrice()];
              }
              return [3, 19];
            case 3:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 5];
              return [4, waitForSync(config, currentBlockNumber)];
            case 4:
              provider = _b.sent();
              _b.label = 5;
            case 5:
              return [2, provider[method](params.address, params.blockTag || "latest")];
            case 6:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 8];
              return [4, waitForSync(config, currentBlockNumber)];
            case 7:
              provider = _b.sent();
              _b.label = 8;
            case 8:
              return [2, provider.getStorageAt(params.address, params.position, params.blockTag || "latest")];
            case 9:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 11];
              return [4, waitForSync(config, currentBlockNumber)];
            case 10:
              provider = _b.sent();
              _b.label = 11;
            case 11:
              return [2, provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash)];
            case 12:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 14];
              return [4, waitForSync(config, currentBlockNumber)];
            case 13:
              provider = _b.sent();
              _b.label = 14;
            case 14:
              if (method === "call" && params.blockTag) {
                return [2, provider[method](params.transaction, params.blockTag)];
              }
              return [2, provider[method](params.transaction)];
            case 15:
              return [2, provider[method](params.transactionHash)];
            case 16:
              filter2 = params.filter;
              if (!(filter2.fromBlock && (0, bytes_1.isHexString)(filter2.fromBlock) || filter2.toBlock && (0, bytes_1.isHexString)(filter2.toBlock)))
                return [3, 18];
              return [4, waitForSync(config, currentBlockNumber)];
            case 17:
              provider = _b.sent();
              _b.label = 18;
            case 18:
              return [2, provider.getLogs(filter2)];
            case 19:
              return [2, logger.throwError("unknown method error", logger_1.Logger.errors.UNKNOWN_ERROR, {
                method,
                params
              })];
          }
        });
      });
    }
    var FallbackProvider = function(_super) {
      __extends(FallbackProvider2, _super);
      function FallbackProvider2(providers2, quorum) {
        var _this = this;
        if (providers2.length === 0) {
          logger.throwArgumentError("missing providers", "providers", providers2);
        }
        var providerConfigs = providers2.map(function(configOrProvider, index) {
          if (abstract_provider_1.Provider.isProvider(configOrProvider)) {
            var stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2e3 : 750;
            var priority = 1;
            return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
          }
          var config = (0, properties_1.shallowCopy)(configOrProvider);
          if (config.priority == null) {
            config.priority = 1;
          }
          if (config.stallTimeout == null) {
            config.stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2e3 : 750;
          }
          if (config.weight == null) {
            config.weight = 1;
          }
          var weight = config.weight;
          if (weight % 1 || weight > 512 || weight < 1) {
            logger.throwArgumentError("invalid weight; must be integer in [1, 512]", "providers[" + index + "].weight", weight);
          }
          return Object.freeze(config);
        });
        var total = providerConfigs.reduce(function(accum, c3) {
          return accum + c3.weight;
        }, 0);
        if (quorum == null) {
          quorum = total / 2;
        } else if (quorum > total) {
          logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        }
        var networkOrReady = checkNetworks(providerConfigs.map(function(c3) {
          return c3.provider.network;
        }));
        if (networkOrReady == null) {
          networkOrReady = new Promise(function(resolve, reject) {
            setTimeout(function() {
              _this.detectNetwork().then(resolve, reject);
            }, 0);
          });
        }
        _this = _super.call(this, networkOrReady) || this;
        (0, properties_1.defineReadOnly)(_this, "providerConfigs", Object.freeze(providerConfigs));
        (0, properties_1.defineReadOnly)(_this, "quorum", quorum);
        _this._highestBlockNumber = -1;
        return _this;
      }
      FallbackProvider2.prototype.detectNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var networks;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, Promise.all(this.providerConfigs.map(function(c3) {
                  return c3.provider.getNetwork();
                }))];
              case 1:
                networks = _a.sent();
                return [2, checkNetworks(networks)];
            }
          });
        });
      };
      FallbackProvider2.prototype.perform = function(method, params) {
        return __awaiter(this, void 0, void 0, function() {
          var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(method === "sendTransaction"))
                  return [3, 2];
                return [4, Promise.all(this.providerConfigs.map(function(c3) {
                  return c3.provider.sendTransaction(params.signedTransaction).then(function(result2) {
                    return result2.hash;
                  }, function(error) {
                    return error;
                  });
                }))];
              case 1:
                results = _a.sent();
                for (i_1 = 0; i_1 < results.length; i_1++) {
                  result = results[i_1];
                  if (typeof result === "string") {
                    return [2, result];
                  }
                }
                throw results[0];
              case 2:
                if (!(this._highestBlockNumber === -1 && method !== "getBlockNumber"))
                  return [3, 4];
                return [4, this.getBlockNumber()];
              case 3:
                _a.sent();
                _a.label = 4;
              case 4:
                processFunc = getProcessFunc(this, method, params);
                configs = (0, random_1.shuffled)(this.providerConfigs.map(properties_1.shallowCopy));
                configs.sort(function(a, b) {
                  return a.priority - b.priority;
                });
                currentBlockNumber = this._highestBlockNumber;
                i = 0;
                first = true;
                _loop_1 = function() {
                  var t0, inflightWeight, _loop_2, waiting, results2, result2, errors;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        t0 = now();
                        inflightWeight = configs.filter(function(c3) {
                          return c3.runner && t0 - c3.start < c3.stallTimeout;
                        }).reduce(function(accum, c3) {
                          return accum + c3.weight;
                        }, 0);
                        _loop_2 = function() {
                          var config = configs[i++];
                          var rid = nextRid++;
                          config.start = now();
                          config.staller = stall(config.stallTimeout);
                          config.staller.wait(function() {
                            config.staller = null;
                          });
                          config.runner = getRunner(config, currentBlockNumber, method, params).then(function(result3) {
                            config.done = true;
                            config.result = result3;
                            if (_this.listenerCount("debug")) {
                              _this.emit("debug", {
                                action: "request",
                                rid,
                                backend: exposeDebugConfig(config, now()),
                                request: { method, params: (0, properties_1.deepCopy)(params) },
                                provider: _this
                              });
                            }
                          }, function(error) {
                            config.done = true;
                            config.error = error;
                            if (_this.listenerCount("debug")) {
                              _this.emit("debug", {
                                action: "request",
                                rid,
                                backend: exposeDebugConfig(config, now()),
                                request: { method, params: (0, properties_1.deepCopy)(params) },
                                provider: _this
                              });
                            }
                          });
                          if (this_1.listenerCount("debug")) {
                            this_1.emit("debug", {
                              action: "request",
                              rid,
                              backend: exposeDebugConfig(config, null),
                              request: { method, params: (0, properties_1.deepCopy)(params) },
                              provider: this_1
                            });
                          }
                          inflightWeight += config.weight;
                        };
                        while (inflightWeight < this_1.quorum && i < configs.length) {
                          _loop_2();
                        }
                        waiting = [];
                        configs.forEach(function(c3) {
                          if (c3.done || !c3.runner) {
                            return;
                          }
                          waiting.push(c3.runner);
                          if (c3.staller) {
                            waiting.push(c3.staller.getPromise());
                          }
                        });
                        if (!waiting.length)
                          return [3, 2];
                        return [4, Promise.race(waiting)];
                      case 1:
                        _b.sent();
                        _b.label = 2;
                      case 2:
                        results2 = configs.filter(function(c3) {
                          return c3.done && c3.error == null;
                        });
                        if (!(results2.length >= this_1.quorum))
                          return [3, 5];
                        result2 = processFunc(results2);
                        if (result2 !== void 0) {
                          configs.forEach(function(c3) {
                            if (c3.staller) {
                              c3.staller.cancel();
                            }
                            c3.cancelled = true;
                          });
                          return [2, { value: result2 }];
                        }
                        if (!!first)
                          return [3, 4];
                        return [4, stall(100).getPromise()];
                      case 3:
                        _b.sent();
                        _b.label = 4;
                      case 4:
                        first = false;
                        _b.label = 5;
                      case 5:
                        errors = configs.reduce(function(accum, c3) {
                          if (!c3.done || c3.error == null) {
                            return accum;
                          }
                          var code = c3.error.code;
                          if (ForwardErrors.indexOf(code) >= 0) {
                            if (!accum[code]) {
                              accum[code] = { error: c3.error, weight: 0 };
                            }
                            accum[code].weight += c3.weight;
                          }
                          return accum;
                        }, {});
                        Object.keys(errors).forEach(function(errorCode) {
                          var tally = errors[errorCode];
                          if (tally.weight < _this.quorum) {
                            return;
                          }
                          configs.forEach(function(c3) {
                            if (c3.staller) {
                              c3.staller.cancel();
                            }
                            c3.cancelled = true;
                          });
                          var e = tally.error;
                          var props = {};
                          ForwardProperties.forEach(function(name) {
                            if (e[name] == null) {
                              return;
                            }
                            props[name] = e[name];
                          });
                          logger.throwError(e.reason || e.message, errorCode, props);
                        });
                        if (configs.filter(function(c3) {
                          return !c3.done;
                        }).length === 0) {
                          return [2, "break"];
                        }
                        return [2];
                    }
                  });
                };
                this_1 = this;
                _a.label = 5;
              case 5:
                if (false)
                  return [3, 7];
                return [5, _loop_1()];
              case 6:
                state_1 = _a.sent();
                if (typeof state_1 === "object")
                  return [2, state_1.value];
                if (state_1 === "break")
                  return [3, 7];
                return [3, 5];
              case 7:
                configs.forEach(function(c3) {
                  if (c3.staller) {
                    c3.staller.cancel();
                  }
                  c3.cancelled = true;
                });
                return [2, logger.throwError("failed to meet quorum", logger_1.Logger.errors.SERVER_ERROR, {
                  method,
                  params,
                  results: configs.map(function(c3) {
                    return exposeDebugConfig(c3);
                  }),
                  provider: this
                })];
            }
          });
        });
      };
      return FallbackProvider2;
    }(base_provider_1.BaseProvider);
    exports.FallbackProvider = FallbackProvider;
  }
});

// node_modules/@ethersproject/providers/lib/ipc-provider.js
var require_ipc_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/ipc-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IpcProvider = void 0;
    var net_1 = require("net");
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var json_rpc_provider_1 = require_json_rpc_provider();
    var IpcProvider = function(_super) {
      __extends(IpcProvider2, _super);
      function IpcProvider2(path3, network) {
        var _this = this;
        if (path3 == null) {
          logger.throwError("missing path", logger_1.Logger.errors.MISSING_ARGUMENT, { arg: "path" });
        }
        _this = _super.call(this, "ipc://" + path3, network) || this;
        (0, properties_1.defineReadOnly)(_this, "path", path3);
        return _this;
      }
      IpcProvider2.prototype.send = function(method, params) {
        var _this = this;
        var payload = JSON.stringify({
          method,
          params,
          id: 42,
          jsonrpc: "2.0"
        });
        return new Promise(function(resolve, reject) {
          var response = Buffer.alloc(0);
          var stream4 = (0, net_1.connect)(_this.path);
          stream4.on("data", function(data) {
            response = Buffer.concat([response, data]);
          });
          stream4.on("end", function() {
            try {
              resolve(JSON.parse(response.toString()).result);
              stream4.destroy();
            } catch (error) {
              reject(error);
              stream4.destroy();
            }
          });
          stream4.on("error", function(error) {
            reject(error);
            stream4.destroy();
          });
          stream4.write(payload);
          stream4.end();
        });
      };
      return IpcProvider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.IpcProvider = IpcProvider;
  }
});

// node_modules/@ethersproject/providers/lib/infura-provider.js
var require_infura_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/infura-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;
    var properties_1 = require_lib4();
    var websocket_provider_1 = require_websocket_provider();
    var formatter_1 = require_formatter();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var defaultProjectId = "84842078b09946638c03157f83405213";
    var InfuraWebSocketProvider = function(_super) {
      __extends(InfuraWebSocketProvider2, _super);
      function InfuraWebSocketProvider2(network, apiKey) {
        var _this = this;
        var provider = new InfuraProvider(network, apiKey);
        var connection = provider.connection;
        if (connection.password) {
          logger.throwError("INFURA WebSocket project secrets unsupported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "InfuraProvider.getWebSocketProvider()"
          });
        }
        var url2 = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        _this = _super.call(this, url2, network) || this;
        (0, properties_1.defineReadOnly)(_this, "apiKey", provider.projectId);
        (0, properties_1.defineReadOnly)(_this, "projectId", provider.projectId);
        (0, properties_1.defineReadOnly)(_this, "projectSecret", provider.projectSecret);
        return _this;
      }
      InfuraWebSocketProvider2.prototype.isCommunityResource = function() {
        return this.projectId === defaultProjectId;
      };
      return InfuraWebSocketProvider2;
    }(websocket_provider_1.WebSocketProvider);
    exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
    var InfuraProvider = function(_super) {
      __extends(InfuraProvider2, _super);
      function InfuraProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      InfuraProvider2.getWebSocketProvider = function(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
      };
      InfuraProvider2.getApiKey = function(apiKey) {
        var apiKeyObj = {
          apiKey: defaultProjectId,
          projectId: defaultProjectId,
          projectSecret: null
        };
        if (apiKey == null) {
          return apiKeyObj;
        }
        if (typeof apiKey === "string") {
          apiKeyObj.projectId = apiKey;
        } else if (apiKey.projectSecret != null) {
          logger.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
          logger.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
          apiKeyObj.projectId = apiKey.projectId;
          apiKeyObj.projectSecret = apiKey.projectSecret;
        } else if (apiKey.projectId) {
          apiKeyObj.projectId = apiKey.projectId;
        }
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
      };
      InfuraProvider2.getUrl = function(network, apiKey) {
        var host = null;
        switch (network ? network.name : "unknown") {
          case "homestead":
            host = "mainnet.infura.io";
            break;
          case "goerli":
            host = "goerli.infura.io";
            break;
          case "sepolia":
            host = "sepolia.infura.io";
            break;
          case "matic":
            host = "polygon-mainnet.infura.io";
            break;
          case "maticmum":
            host = "polygon-mumbai.infura.io";
            break;
          case "optimism":
            host = "optimism-mainnet.infura.io";
            break;
          case "optimism-goerli":
            host = "optimism-goerli.infura.io";
            break;
          case "arbitrum":
            host = "arbitrum-mainnet.infura.io";
            break;
          case "arbitrum-goerli":
            host = "arbitrum-goerli.infura.io";
            break;
          default:
            logger.throwError("unsupported network", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        var connection = {
          allowGzip: true,
          url: "https://" + host + "/v3/" + apiKey.projectId,
          throttleCallback: function(attempt, url2) {
            if (apiKey.projectId === defaultProjectId) {
              (0, formatter_1.showThrottleMessage)();
            }
            return Promise.resolve(true);
          }
        };
        if (apiKey.projectSecret != null) {
          connection.user = "";
          connection.password = apiKey.projectSecret;
        }
        return connection;
      };
      InfuraProvider2.prototype.isCommunityResource = function() {
        return this.projectId === defaultProjectId;
      };
      return InfuraProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.InfuraProvider = InfuraProvider;
  }
});

// node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js
var require_json_rpc_batch_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcBatchProvider = void 0;
    var properties_1 = require_lib4();
    var web_1 = require_lib28();
    var json_rpc_provider_1 = require_json_rpc_provider();
    var JsonRpcBatchProvider = function(_super) {
      __extends(JsonRpcBatchProvider2, _super);
      function JsonRpcBatchProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      JsonRpcBatchProvider2.prototype.send = function(method, params) {
        var _this = this;
        var request2 = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) {
          this._pendingBatch = [];
        }
        var inflightRequest = { request: request2, resolve: null, reject: null };
        var promise = new Promise(function(resolve, reject) {
          inflightRequest.resolve = resolve;
          inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) {
          this._pendingBatchAggregator = setTimeout(function() {
            var batch = _this._pendingBatch;
            _this._pendingBatch = null;
            _this._pendingBatchAggregator = null;
            var request3 = batch.map(function(inflight) {
              return inflight.request;
            });
            _this.emit("debug", {
              action: "requestBatch",
              request: (0, properties_1.deepCopy)(request3),
              provider: _this
            });
            return (0, web_1.fetchJson)(_this.connection, JSON.stringify(request3)).then(function(result) {
              _this.emit("debug", {
                action: "response",
                request: request3,
                response: result,
                provider: _this
              });
              batch.forEach(function(inflightRequest2, index) {
                var payload = result[index];
                if (payload.error) {
                  var error = new Error(payload.error.message);
                  error.code = payload.error.code;
                  error.data = payload.error.data;
                  inflightRequest2.reject(error);
                } else {
                  inflightRequest2.resolve(payload.result);
                }
              });
            }, function(error) {
              _this.emit("debug", {
                action: "response",
                error,
                request: request3,
                provider: _this
              });
              batch.forEach(function(inflightRequest2) {
                inflightRequest2.reject(error);
              });
            });
          }, 10);
        }
        return promise;
      };
      return JsonRpcBatchProvider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.JsonRpcBatchProvider = JsonRpcBatchProvider;
  }
});

// node_modules/@ethersproject/providers/lib/nodesmith-provider.js
var require_nodesmith_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/nodesmith-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodesmithProvider = void 0;
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var defaultApiKey = "ETHERS_JS_SHARED";
    var NodesmithProvider = function(_super) {
      __extends(NodesmithProvider2, _super);
      function NodesmithProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NodesmithProvider2.getApiKey = function(apiKey) {
        if (apiKey && typeof apiKey !== "string") {
          logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey || defaultApiKey;
      };
      NodesmithProvider2.getUrl = function(network, apiKey) {
        logger.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        var host = null;
        switch (network.name) {
          case "homestead":
            host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
            break;
          case "ropsten":
            host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
            break;
          case "rinkeby":
            host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
            break;
          case "goerli":
            host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
            break;
          case "kovan":
            host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
            break;
          default:
            logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host + "?apiKey=" + apiKey;
      };
      return NodesmithProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.NodesmithProvider = NodesmithProvider;
  }
});

// node_modules/@ethersproject/providers/lib/pocket-provider.js
var require_pocket_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/pocket-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PocketProvider = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
    var PocketProvider = function(_super) {
      __extends(PocketProvider2, _super);
      function PocketProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PocketProvider2.getApiKey = function(apiKey) {
        var apiKeyObj = {
          applicationId: null,
          loadBalancer: true,
          applicationSecretKey: null
        };
        if (apiKey == null) {
          apiKeyObj.applicationId = defaultApplicationId;
        } else if (typeof apiKey === "string") {
          apiKeyObj.applicationId = apiKey;
        } else if (apiKey.applicationSecretKey != null) {
          apiKeyObj.applicationId = apiKey.applicationId;
          apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
        } else if (apiKey.applicationId) {
          apiKeyObj.applicationId = apiKey.applicationId;
        } else {
          logger.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        }
        return apiKeyObj;
      };
      PocketProvider2.getUrl = function(network, apiKey) {
        var host = null;
        switch (network ? network.name : "unknown") {
          case "goerli":
            host = "eth-goerli.gateway.pokt.network";
            break;
          case "homestead":
            host = "eth-mainnet.gateway.pokt.network";
            break;
          case "kovan":
            host = "poa-kovan.gateway.pokt.network";
            break;
          case "matic":
            host = "poly-mainnet.gateway.pokt.network";
            break;
          case "maticmum":
            host = "polygon-mumbai-rpc.gateway.pokt.network";
            break;
          case "rinkeby":
            host = "eth-rinkeby.gateway.pokt.network";
            break;
          case "ropsten":
            host = "eth-ropsten.gateway.pokt.network";
            break;
          default:
            logger.throwError("unsupported network", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        var url2 = "https://" + host + "/v1/lb/" + apiKey.applicationId;
        var connection = { headers: {}, url: url2 };
        if (apiKey.applicationSecretKey != null) {
          connection.user = "";
          connection.password = apiKey.applicationSecretKey;
        }
        return connection;
      };
      PocketProvider2.prototype.isCommunityResource = function() {
        return this.applicationId === defaultApplicationId;
      };
      return PocketProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.PocketProvider = PocketProvider;
  }
});

// node_modules/@ethersproject/providers/lib/web3-provider.js
var require_web3_provider = __commonJS({
  "node_modules/@ethersproject/providers/lib/web3-provider.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Provider = void 0;
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    var json_rpc_provider_1 = require_json_rpc_provider();
    var _nextId = 1;
    function buildWeb3LegacyFetcher(provider, sendFunc) {
      var fetcher = "Web3LegacyFetcher";
      return function(method, params) {
        var _this = this;
        var request2 = {
          method,
          params,
          id: _nextId++,
          jsonrpc: "2.0"
        };
        return new Promise(function(resolve, reject) {
          _this.emit("debug", {
            action: "request",
            fetcher,
            request: (0, properties_1.deepCopy)(request2),
            provider: _this
          });
          sendFunc(request2, function(error, response) {
            if (error) {
              _this.emit("debug", {
                action: "response",
                fetcher,
                error,
                request: request2,
                provider: _this
              });
              return reject(error);
            }
            _this.emit("debug", {
              action: "response",
              fetcher,
              request: request2,
              response,
              provider: _this
            });
            if (response.error) {
              var error_1 = new Error(response.error.message);
              error_1.code = response.error.code;
              error_1.data = response.error.data;
              return reject(error_1);
            }
            resolve(response.result);
          });
        });
      };
    }
    function buildEip1193Fetcher(provider) {
      return function(method, params) {
        var _this = this;
        if (params == null) {
          params = [];
        }
        var request2 = { method, params };
        this.emit("debug", {
          action: "request",
          fetcher: "Eip1193Fetcher",
          request: (0, properties_1.deepCopy)(request2),
          provider: this
        });
        return provider.request(request2).then(function(response) {
          _this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request: request2,
            response,
            provider: _this
          });
          return response;
        }, function(error) {
          _this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request: request2,
            error,
            provider: _this
          });
          throw error;
        });
      };
    }
    var Web3Provider = function(_super) {
      __extends(Web3Provider2, _super);
      function Web3Provider2(provider, network) {
        var _this = this;
        if (provider == null) {
          logger.throwArgumentError("missing provider", "provider", provider);
        }
        var path3 = null;
        var jsonRpcFetchFunc = null;
        var subprovider = null;
        if (typeof provider === "function") {
          path3 = "unknown:";
          jsonRpcFetchFunc = provider;
        } else {
          path3 = provider.host || provider.path || "";
          if (!path3 && provider.isMetaMask) {
            path3 = "metamask";
          }
          subprovider = provider;
          if (provider.request) {
            if (path3 === "") {
              path3 = "eip-1193:";
            }
            jsonRpcFetchFunc = buildEip1193Fetcher(provider);
          } else if (provider.sendAsync) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
          } else if (provider.send) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
          } else {
            logger.throwArgumentError("unsupported provider", "provider", provider);
          }
          if (!path3) {
            path3 = "unknown:";
          }
        }
        _this = _super.call(this, path3, network) || this;
        (0, properties_1.defineReadOnly)(_this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        (0, properties_1.defineReadOnly)(_this, "provider", subprovider);
        return _this;
      }
      Web3Provider2.prototype.send = function(method, params) {
        return this.jsonRpcFetchFunc(method, params);
      };
      return Web3Provider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.Web3Provider = Web3Provider;
  }
});

// node_modules/@ethersproject/providers/lib/index.js
var require_lib29 = __commonJS({
  "node_modules/@ethersproject/providers/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Formatter = exports.showThrottleMessage = exports.isCommunityResourcable = exports.isCommunityResource = exports.getNetwork = exports.getDefaultProvider = exports.JsonRpcSigner = exports.IpcProvider = exports.WebSocketProvider = exports.Web3Provider = exports.StaticJsonRpcProvider = exports.PocketProvider = exports.NodesmithProvider = exports.JsonRpcBatchProvider = exports.JsonRpcProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyWebSocketProvider = exports.AlchemyProvider = exports.FallbackProvider = exports.UrlJsonRpcProvider = exports.Resolver = exports.BaseProvider = exports.Provider = void 0;
    var abstract_provider_1 = require_lib14();
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return abstract_provider_1.Provider;
    } });
    var networks_1 = require_lib27();
    Object.defineProperty(exports, "getNetwork", { enumerable: true, get: function() {
      return networks_1.getNetwork;
    } });
    var base_provider_1 = require_base_provider();
    Object.defineProperty(exports, "BaseProvider", { enumerable: true, get: function() {
      return base_provider_1.BaseProvider;
    } });
    Object.defineProperty(exports, "Resolver", { enumerable: true, get: function() {
      return base_provider_1.Resolver;
    } });
    var alchemy_provider_1 = require_alchemy_provider();
    Object.defineProperty(exports, "AlchemyProvider", { enumerable: true, get: function() {
      return alchemy_provider_1.AlchemyProvider;
    } });
    Object.defineProperty(exports, "AlchemyWebSocketProvider", { enumerable: true, get: function() {
      return alchemy_provider_1.AlchemyWebSocketProvider;
    } });
    var ankr_provider_1 = require_ankr_provider();
    Object.defineProperty(exports, "AnkrProvider", { enumerable: true, get: function() {
      return ankr_provider_1.AnkrProvider;
    } });
    var cloudflare_provider_1 = require_cloudflare_provider();
    Object.defineProperty(exports, "CloudflareProvider", { enumerable: true, get: function() {
      return cloudflare_provider_1.CloudflareProvider;
    } });
    var etherscan_provider_1 = require_etherscan_provider();
    Object.defineProperty(exports, "EtherscanProvider", { enumerable: true, get: function() {
      return etherscan_provider_1.EtherscanProvider;
    } });
    var fallback_provider_1 = require_fallback_provider();
    Object.defineProperty(exports, "FallbackProvider", { enumerable: true, get: function() {
      return fallback_provider_1.FallbackProvider;
    } });
    var ipc_provider_1 = require_ipc_provider();
    Object.defineProperty(exports, "IpcProvider", { enumerable: true, get: function() {
      return ipc_provider_1.IpcProvider;
    } });
    var infura_provider_1 = require_infura_provider();
    Object.defineProperty(exports, "InfuraProvider", { enumerable: true, get: function() {
      return infura_provider_1.InfuraProvider;
    } });
    Object.defineProperty(exports, "InfuraWebSocketProvider", { enumerable: true, get: function() {
      return infura_provider_1.InfuraWebSocketProvider;
    } });
    var json_rpc_provider_1 = require_json_rpc_provider();
    Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
      return json_rpc_provider_1.JsonRpcProvider;
    } });
    Object.defineProperty(exports, "JsonRpcSigner", { enumerable: true, get: function() {
      return json_rpc_provider_1.JsonRpcSigner;
    } });
    var json_rpc_batch_provider_1 = require_json_rpc_batch_provider();
    Object.defineProperty(exports, "JsonRpcBatchProvider", { enumerable: true, get: function() {
      return json_rpc_batch_provider_1.JsonRpcBatchProvider;
    } });
    var nodesmith_provider_1 = require_nodesmith_provider();
    Object.defineProperty(exports, "NodesmithProvider", { enumerable: true, get: function() {
      return nodesmith_provider_1.NodesmithProvider;
    } });
    var pocket_provider_1 = require_pocket_provider();
    Object.defineProperty(exports, "PocketProvider", { enumerable: true, get: function() {
      return pocket_provider_1.PocketProvider;
    } });
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    Object.defineProperty(exports, "StaticJsonRpcProvider", { enumerable: true, get: function() {
      return url_json_rpc_provider_1.StaticJsonRpcProvider;
    } });
    Object.defineProperty(exports, "UrlJsonRpcProvider", { enumerable: true, get: function() {
      return url_json_rpc_provider_1.UrlJsonRpcProvider;
    } });
    var web3_provider_1 = require_web3_provider();
    Object.defineProperty(exports, "Web3Provider", { enumerable: true, get: function() {
      return web3_provider_1.Web3Provider;
    } });
    var websocket_provider_1 = require_websocket_provider();
    Object.defineProperty(exports, "WebSocketProvider", { enumerable: true, get: function() {
      return websocket_provider_1.WebSocketProvider;
    } });
    var formatter_1 = require_formatter();
    Object.defineProperty(exports, "Formatter", { enumerable: true, get: function() {
      return formatter_1.Formatter;
    } });
    Object.defineProperty(exports, "isCommunityResourcable", { enumerable: true, get: function() {
      return formatter_1.isCommunityResourcable;
    } });
    Object.defineProperty(exports, "isCommunityResource", { enumerable: true, get: function() {
      return formatter_1.isCommunityResource;
    } });
    Object.defineProperty(exports, "showThrottleMessage", { enumerable: true, get: function() {
      return formatter_1.showThrottleMessage;
    } });
    var logger_1 = require_lib();
    var _version_1 = require_version22();
    var logger = new logger_1.Logger(_version_1.version);
    function getDefaultProvider(network, options) {
      if (network == null) {
        network = "homestead";
      }
      if (typeof network === "string") {
        var match = network.match(/^(ws|http)s?:/i);
        if (match) {
          switch (match[1].toLowerCase()) {
            case "http":
            case "https":
              return new json_rpc_provider_1.JsonRpcProvider(network);
            case "ws":
            case "wss":
              return new websocket_provider_1.WebSocketProvider(network);
            default:
              logger.throwArgumentError("unsupported URL scheme", "network", network);
          }
        }
      }
      var n = (0, networks_1.getNetwork)(network);
      if (!n || !n._defaultProvider) {
        logger.throwError("unsupported getDefaultProvider network", logger_1.Logger.errors.NETWORK_ERROR, {
          operation: "getDefaultProvider",
          network
        });
      }
      return n._defaultProvider({
        FallbackProvider: fallback_provider_1.FallbackProvider,
        AlchemyProvider: alchemy_provider_1.AlchemyProvider,
        AnkrProvider: ankr_provider_1.AnkrProvider,
        CloudflareProvider: cloudflare_provider_1.CloudflareProvider,
        EtherscanProvider: etherscan_provider_1.EtherscanProvider,
        InfuraProvider: infura_provider_1.InfuraProvider,
        JsonRpcProvider: json_rpc_provider_1.JsonRpcProvider,
        NodesmithProvider: nodesmith_provider_1.NodesmithProvider,
        PocketProvider: pocket_provider_1.PocketProvider,
        Web3Provider: web3_provider_1.Web3Provider,
        IpcProvider: ipc_provider_1.IpcProvider
      }, options);
    }
    exports.getDefaultProvider = getDefaultProvider;
  }
});

// node_modules/@ethersproject/solidity/lib/_version.js
var require_version23 = __commonJS({
  "node_modules/@ethersproject/solidity/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "solidity/5.7.0";
  }
});

// node_modules/@ethersproject/solidity/lib/index.js
var require_lib30 = __commonJS({
  "node_modules/@ethersproject/solidity/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = exports.keccak256 = exports.pack = void 0;
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib5();
    var sha2_1 = require_lib21();
    var strings_1 = require_lib9();
    var regexBytes = new RegExp("^bytes([0-9]+)$");
    var regexNumber = new RegExp("^(u?int)([0-9]*)$");
    var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    var Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
    var logger_1 = require_lib();
    var _version_1 = require_version23();
    var logger = new logger_1.Logger(_version_1.version);
    function _pack(type, value, isArray2) {
      switch (type) {
        case "address":
          if (isArray2) {
            return (0, bytes_1.zeroPad)(value, 32);
          }
          return (0, bytes_1.arrayify)(value);
        case "string":
          return (0, strings_1.toUtf8Bytes)(value);
        case "bytes":
          return (0, bytes_1.arrayify)(value);
        case "bool":
          value = value ? "0x01" : "0x00";
          if (isArray2) {
            return (0, bytes_1.zeroPad)(value, 32);
          }
          return (0, bytes_1.arrayify)(value);
      }
      var match = type.match(regexNumber);
      if (match) {
        var size = parseInt(match[2] || "256");
        if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
          logger.throwArgumentError("invalid number type", "type", type);
        }
        if (isArray2) {
          size = 256;
        }
        value = bignumber_1.BigNumber.from(value).toTwos(size);
        return (0, bytes_1.zeroPad)(value, size / 8);
      }
      match = type.match(regexBytes);
      if (match) {
        var size = parseInt(match[1]);
        if (String(size) !== match[1] || size === 0 || size > 32) {
          logger.throwArgumentError("invalid bytes type", "type", type);
        }
        if ((0, bytes_1.arrayify)(value).byteLength !== size) {
          logger.throwArgumentError("invalid value for " + type, "value", value);
        }
        if (isArray2) {
          return (0, bytes_1.arrayify)((value + Zeros).substring(0, 66));
        }
        return value;
      }
      match = type.match(regexArray);
      if (match && Array.isArray(value)) {
        var baseType_1 = match[1];
        var count = parseInt(match[2] || String(value.length));
        if (count != value.length) {
          logger.throwArgumentError("invalid array length for " + type, "value", value);
        }
        var result_1 = [];
        value.forEach(function(value2) {
          result_1.push(_pack(baseType_1, value2, true));
        });
        return (0, bytes_1.concat)(result_1);
      }
      return logger.throwArgumentError("invalid type", "type", type);
    }
    function pack(types, values) {
      if (types.length != values.length) {
        logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
      }
      var tight = [];
      types.forEach(function(type, index) {
        tight.push(_pack(type, values[index]));
      });
      return (0, bytes_1.hexlify)((0, bytes_1.concat)(tight));
    }
    exports.pack = pack;
    function keccak256(types, values) {
      return (0, keccak256_1.keccak256)(pack(types, values));
    }
    exports.keccak256 = keccak256;
    function sha256(types, values) {
      return (0, sha2_1.sha256)(pack(types, values));
    }
    exports.sha256 = sha256;
  }
});

// node_modules/@ethersproject/units/lib/_version.js
var require_version24 = __commonJS({
  "node_modules/@ethersproject/units/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "units/5.7.0";
  }
});

// node_modules/@ethersproject/units/lib/index.js
var require_lib31 = __commonJS({
  "node_modules/@ethersproject/units/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = exports.commify = void 0;
    var bignumber_1 = require_lib3();
    var logger_1 = require_lib();
    var _version_1 = require_version24();
    var logger = new logger_1.Logger(_version_1.version);
    var names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
    function commify(value) {
      var comps = String(value).split(".");
      if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
        logger.throwArgumentError("invalid value", "value", value);
      }
      var whole = comps[0];
      var negative = "";
      if (whole.substring(0, 1) === "-") {
        negative = "-";
        whole = whole.substring(1);
      }
      while (whole.substring(0, 1) === "0") {
        whole = whole.substring(1);
      }
      if (whole === "") {
        whole = "0";
      }
      var suffix = "";
      if (comps.length === 2) {
        suffix = "." + (comps[1] || "0");
      }
      while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
        suffix = suffix.substring(0, suffix.length - 1);
      }
      var formatted = [];
      while (whole.length) {
        if (whole.length <= 3) {
          formatted.unshift(whole);
          break;
        } else {
          var index = whole.length - 3;
          formatted.unshift(whole.substring(index));
          whole = whole.substring(0, index);
        }
      }
      return negative + formatted.join(",") + suffix;
    }
    exports.commify = commify;
    function formatUnits(value, unitName) {
      if (typeof unitName === "string") {
        var index = names.indexOf(unitName);
        if (index !== -1) {
          unitName = 3 * index;
        }
      }
      return (0, bignumber_1.formatFixed)(value, unitName != null ? unitName : 18);
    }
    exports.formatUnits = formatUnits;
    function parseUnits(value, unitName) {
      if (typeof value !== "string") {
        logger.throwArgumentError("value must be a string", "value", value);
      }
      if (typeof unitName === "string") {
        var index = names.indexOf(unitName);
        if (index !== -1) {
          unitName = 3 * index;
        }
      }
      return (0, bignumber_1.parseFixed)(value, unitName != null ? unitName : 18);
    }
    exports.parseUnits = parseUnits;
    function formatEther(wei) {
      return formatUnits(wei, 18);
    }
    exports.formatEther = formatEther;
    function parseEther(ether) {
      return parseUnits(ether, 18);
    }
    exports.parseEther = parseEther;
  }
});

// node_modules/ethers/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
    var abi_1 = require_lib13();
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = require_lib7();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar(require_lib10());
    exports.base64 = base64;
    var basex_1 = require_lib19();
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = require_lib2();
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = require_lib12();
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = require_lib23();
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = require_lib25();
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = require_lib5();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = require_lib();
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = require_lib21();
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = require_lib30();
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = require_lib24();
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = require_lib4();
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar(require_lib6());
    exports.RLP = RLP;
    var signing_key_1 = require_lib16();
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = require_lib9();
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = require_lib17();
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = require_lib31();
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = require_lib26();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = require_lib28();
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = require_lib21();
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = require_lib9();
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/ethers/lib/_version.js
var require_version25 = __commonJS({
  "node_modules/ethers/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "ethers/5.7.2";
  }
});

// node_modules/ethers/lib/ethers.js
var require_ethers = __commonJS({
  "node_modules/ethers/lib/ethers.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = void 0;
    var contracts_1 = require_lib18();
    Object.defineProperty(exports, "BaseContract", { enumerable: true, get: function() {
      return contracts_1.BaseContract;
    } });
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return contracts_1.Contract;
    } });
    Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function() {
      return contracts_1.ContractFactory;
    } });
    var bignumber_1 = require_lib3();
    Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function() {
      return bignumber_1.BigNumber;
    } });
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return bignumber_1.FixedNumber;
    } });
    var abstract_signer_1 = require_lib15();
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return abstract_signer_1.Signer;
    } });
    Object.defineProperty(exports, "VoidSigner", { enumerable: true, get: function() {
      return abstract_signer_1.VoidSigner;
    } });
    var wallet_1 = require_lib26();
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return wallet_1.Wallet;
    } });
    var constants = __importStar(require_lib8());
    exports.constants = constants;
    var providers2 = __importStar(require_lib29());
    exports.providers = providers2;
    var providers_1 = require_lib29();
    Object.defineProperty(exports, "getDefaultProvider", { enumerable: true, get: function() {
      return providers_1.getDefaultProvider;
    } });
    var wordlists_1 = require_lib22();
    Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
      return wordlists_1.Wordlist;
    } });
    Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
      return wordlists_1.wordlists;
    } });
    var utils = __importStar(require_utils5());
    exports.utils = utils;
    var logger_1 = require_lib();
    Object.defineProperty(exports, "errors", { enumerable: true, get: function() {
      return logger_1.ErrorCode;
    } });
    var _version_1 = require_version25();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return _version_1.version;
    } });
    var logger = new logger_1.Logger(_version_1.version);
    exports.logger = logger;
  }
});

// node_modules/ethers/lib/index.js
var require_lib32 = __commonJS({
  "node_modules/ethers/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wordlist = exports.version = exports.wordlists = exports.utils = exports.logger = exports.errors = exports.constants = exports.FixedNumber = exports.BigNumber = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.providers = exports.getDefaultProvider = exports.VoidSigner = exports.Wallet = exports.Signer = exports.ethers = void 0;
    var ethers8 = __importStar(require_ethers());
    exports.ethers = ethers8;
    try {
      anyGlobal = window;
      if (anyGlobal._ethers == null) {
        anyGlobal._ethers = ethers8;
      }
    } catch (error) {
    }
    var anyGlobal;
    var ethers_1 = require_ethers();
    Object.defineProperty(exports, "Signer", { enumerable: true, get: function() {
      return ethers_1.Signer;
    } });
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return ethers_1.Wallet;
    } });
    Object.defineProperty(exports, "VoidSigner", { enumerable: true, get: function() {
      return ethers_1.VoidSigner;
    } });
    Object.defineProperty(exports, "getDefaultProvider", { enumerable: true, get: function() {
      return ethers_1.getDefaultProvider;
    } });
    Object.defineProperty(exports, "providers", { enumerable: true, get: function() {
      return ethers_1.providers;
    } });
    Object.defineProperty(exports, "BaseContract", { enumerable: true, get: function() {
      return ethers_1.BaseContract;
    } });
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return ethers_1.Contract;
    } });
    Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function() {
      return ethers_1.ContractFactory;
    } });
    Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function() {
      return ethers_1.BigNumber;
    } });
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return ethers_1.FixedNumber;
    } });
    Object.defineProperty(exports, "constants", { enumerable: true, get: function() {
      return ethers_1.constants;
    } });
    Object.defineProperty(exports, "errors", { enumerable: true, get: function() {
      return ethers_1.errors;
    } });
    Object.defineProperty(exports, "logger", { enumerable: true, get: function() {
      return ethers_1.logger;
    } });
    Object.defineProperty(exports, "utils", { enumerable: true, get: function() {
      return ethers_1.utils;
    } });
    Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
      return ethers_1.wordlists;
    } });
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return ethers_1.version;
    } });
    Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
      return ethers_1.Wordlist;
    } });
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    var Stream = require("stream").Stream;
    var util2 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    var util2 = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util2.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path3) {
      if (!path3 || typeof path3 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path3).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer2 = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module2) {
    module2.exports = defer3;
    function defer3(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async2 = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module2) {
    var defer3 = require_defer2();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer3(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer3(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module2) {
    var async = require_async2();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state2 = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module2) {
    var abort = require_abort();
    var async = require_async2();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state2();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module2) {
    var iterate = require_iterate();
    var initState = require_state2();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/axios/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/axios/node_modules/form-data/lib/populate.js"(exports, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/axios/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/axios/node_modules/form-data/lib/form_data.js"(exports, module2) {
    var CombinedStream = require_combined_stream();
    var util2 = require("util");
    var path3 = require("path");
    var http3 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs4 = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData3;
    util2.inherits(FormData3, CombinedStream);
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs4.stat(value.path, function(err, stat2) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat2.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path3.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path3.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path3.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length3) {
          knownLength += length3;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request2, options, defaults2 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request2 = https2.request(options);
      } else {
        request2 = http3.request(options);
      }
      this.getLength(function(err, length3) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length3) {
          request2.setHeader("Content-Length", length3);
        }
        this.pipe(request2);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request2.removeListener("error", callback);
            request2.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request2.on("error", callback);
          request2.on("response", onResponse);
        }
      }.bind(this));
      return request2;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl2(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto2 = parsedUrl.protocol;
      var hostname3 = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname3 !== "string" || !hostname3 || typeof proto2 !== "string") {
        return "";
      }
      proto2 = proto2.split(":", 1)[0];
      hostname3 = hostname3.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto2] || 0;
      if (!shouldProxy(hostname3, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto2 + "_proxy") || getEnv(proto2 + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto2 + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname3, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname3 !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname3, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty2 = require("tty");
    var util2 = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor2 = require("supports-color");
      if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c3 = this.color;
        const colorCode = "\x1B[3" + (c3 < 8 ? c3 : "8;5;" + c3);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports, module2) {
    var url2 = require("url");
    var URL2 = url2.URL;
    var http3 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert2 = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction2(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request2._redirectable = this;
      for (var event of events) {
        request2.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : this._options.path;
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request2 === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url2.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url2.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url2.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction2(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request2(input, options, callback) {
          if (isString2(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL2(input));
            } catch (err) {
              parsed = url2.parse(input);
            }
            if (!isString2(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction2(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert2.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get2(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get2, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop5() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex2, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex2.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request2) {
      for (var event of events) {
        request2.removeListener(event, eventHandlers[event]);
      }
      request2.on("error", noop5);
      request2.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert2(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    module2.exports = wrap({ http: http3, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/commander/esm.mjs
var import_index = __toESM(require_commander(), 1);
var {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError,
  Command,
  Argument,
  Option,
  Help
} = import_index.default;

// package.json
var package_default = {
  name: "w3-cli-ts",
  version: "0.0.3",
  main: "./dist/index.js",
  scripts: {
    build: "tsc -p ./tsconfig.json && esbuild ./src/index.ts --bundle --platform=node --format=cjs --outdir=dist",
    dev: "tsc -p ./tsconfig.json && esbuild ./src/index.ts --bundle --platform=node --format=cjs --outdir=dist --watch"
  },
  bin: {
    w3: "./dist/index.js"
  },
  license: "MIT",
  devDependencies: {
    "@types/express": "^4.17.14",
    "@types/express-serve-static-core": "^4.17.31",
    "@types/node": "^18.11.9",
    "@types/readline-sync": "^1.4.4",
    commander: "^9.4.1",
    cuid: "^2.1.8",
    ethers: "^5.7.2",
    ora: "^6.1.2",
    typescript: "^4.9.3"
  },
  dependencies: {
    acebase: "^1.26.2",
    axios: "^1.1.3",
    "binance-api-node": "^0.12.0",
    esbuild: "^0.15.15",
    global: "^4.4.0",
    graphql: "^16.6.0",
    "graphql-request": "^5.1.0",
    "readline-sync": "^1.4.10"
  }
};

// node_modules/ora/index.js
var import_node_process6 = __toESM(require("node:process"), 1);

// node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require("node:process"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_node_tty = __toESM(require("node:tty"), 1);
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process.default;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_node_process.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream4, options = {}) {
  const level = _supportsColor(stream4, {
    streamIsTTY: stream4 && stream4.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open2, close2, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open2;
    closeAll = close2;
  } else {
    openAll = parent.openAll + open2;
    closeAll = close2 + parent.closeAll;
  }
  return {
    open: open2,
    close: close2,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/cli-cursor/index.js
var import_node_process3 = __toESM(require("node:process"), 1);

// node_modules/restore-cursor/index.js
var import_node_process2 = __toESM(require("node:process"), 1);
var import_onetime = __toESM(require_onetime(), 1);
var import_signal_exit = __toESM(require_signal_exit(), 1);
var restoreCursor = (0, import_onetime.default)(() => {
  (0, import_signal_exit.default)(() => {
    import_node_process2.default.stderr.write("\x1B[?25h");
  }, { alwaysLast: true });
});
var restore_cursor_default = restoreCursor;

// node_modules/cli-cursor/index.js
var isHidden = false;
var cliCursor = {};
cliCursor.show = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  isHidden = false;
  writableStream.write("\x1B[?25h");
};
cliCursor.hide = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  restore_cursor_default();
  isHidden = true;
  writableStream.write("\x1B[?25l");
};
cliCursor.toggle = (force, writableStream) => {
  if (force !== void 0) {
    isHidden = force;
  }
  if (isHidden) {
    cliCursor.show(writableStream);
  } else {
    cliCursor.hide(writableStream);
  }
};
var cli_cursor_default = cliCursor;

// node_modules/ora/index.js
var import_cli_spinners = __toESM(require_cli_spinners(), 1);

// node_modules/is-unicode-supported/index.js
var import_node_process4 = __toESM(require("node:process"), 1);
function isUnicodeSupported() {
  if (import_node_process4.default.platform !== "win32") {
    return import_node_process4.default.env.TERM !== "linux";
  }
  return Boolean(import_node_process4.default.env.CI) || Boolean(import_node_process4.default.env.WT_SESSION) || Boolean(import_node_process4.default.env.TERMINUS_SUBLIME) || import_node_process4.default.env.ConEmuTask === "{cmd::Cmder}" || import_node_process4.default.env.TERM_PROGRAM === "Terminus-Sublime" || import_node_process4.default.env.TERM_PROGRAM === "vscode" || import_node_process4.default.env.TERM === "xterm-256color" || import_node_process4.default.env.TERM === "alacritty" || import_node_process4.default.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/log-symbols/index.js
var main = {
  info: source_default.blue("\u2139"),
  success: source_default.green("\u2714"),
  warning: source_default.yellow("\u26A0"),
  error: source_default.red("\u2716")
};
var fallback = {
  info: source_default.blue("i"),
  success: source_default.green("\u221A"),
  warning: source_default.yellow("\u203C"),
  error: source_default.red("\xD7")
};
var logSymbols = isUnicodeSupported() ? main : fallback;
var log_symbols_default = logSymbols;

// node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}

// node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  }
  return string.replace(regex, "");
}

// node_modules/ora/index.js
var import_wcwidth = __toESM(require_wcwidth(), 1);

// node_modules/is-interactive/index.js
function isInteractive({ stream: stream4 = process.stdout } = {}) {
  return Boolean(
    stream4 && stream4.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env)
  );
}

// node_modules/stdin-discarder/index.js
var import_node_process5 = __toESM(require("node:process"), 1);
var import_node_readline = __toESM(require("node:readline"), 1);
var import_bl = __toESM(require_bl(), 1);
var ASCII_ETX_CODE = 3;
var StdinDiscarder = class {
  #requests = 0;
  #mutedStream = new import_bl.BufferListStream();
  #ourEmit;
  #rl;
  constructor() {
    this.#mutedStream.pipe(import_node_process5.default.stdout);
    const self2 = this;
    this.#ourEmit = function(event, data, ...arguments_) {
      const { stdin } = import_node_process5.default;
      if (self2.#requests > 0 || stdin.emit === self2.#ourEmit) {
        if (event === "keypress") {
          return;
        }
        if (event === "data" && data.includes(ASCII_ETX_CODE)) {
          import_node_process5.default.emit("SIGINT");
        }
        Reflect.apply(self2.#ourEmit, this, [event, data, ...arguments_]);
      } else {
        Reflect.apply(import_node_process5.default.stdin.emit, this, [event, data, ...arguments_]);
      }
    };
  }
  start() {
    this.#requests++;
    if (this.#requests === 1) {
      this._realStart();
    }
  }
  stop() {
    if (this.#requests <= 0) {
      throw new Error("`stop` called more times than `start`");
    }
    this.#requests--;
    if (this.#requests === 0) {
      this._realStop();
    }
  }
  _realStart() {
    if (import_node_process5.default.platform === "win32") {
      return;
    }
    this.#rl = import_node_readline.default.createInterface({
      input: import_node_process5.default.stdin,
      output: this.#mutedStream
    });
    this.#rl.on("SIGINT", () => {
      if (import_node_process5.default.listenerCount("SIGINT") === 0) {
        import_node_process5.default.emit("SIGINT");
      } else {
        this.#rl.close();
        import_node_process5.default.kill(import_node_process5.default.pid, "SIGINT");
      }
    });
  }
  _realStop() {
    if (import_node_process5.default.platform === "win32") {
      return;
    }
    this.#rl.close();
    this.#rl = void 0;
  }
};
var stdinDiscarder = new StdinDiscarder();
var stdin_discarder_default = stdinDiscarder;

// node_modules/ora/index.js
var import_cli_spinners2 = __toESM(require_cli_spinners(), 1);
var Ora = class {
  #linesToClear = 0;
  #isDiscardingStdin = false;
  #lineCount = 0;
  #frameIndex = 0;
  #options;
  #spinner;
  #stream;
  #id;
  #initialInterval;
  #isEnabled;
  #isSilent;
  #indent;
  #text;
  #prefixText;
  #suffixText;
  color;
  constructor(options) {
    if (typeof options === "string") {
      options = {
        text: options
      };
    }
    this.#options = {
      color: "cyan",
      stream: import_node_process6.default.stderr,
      discardStdin: true,
      hideCursor: true,
      ...options
    };
    this.color = this.#options.color;
    this.spinner = this.#options.spinner;
    this.#initialInterval = this.#options.interval;
    this.#stream = this.#options.stream;
    this.#isEnabled = typeof this.#options.isEnabled === "boolean" ? this.#options.isEnabled : isInteractive({ stream: this.#stream });
    this.#isSilent = typeof this.#options.isSilent === "boolean" ? this.#options.isSilent : false;
    this.text = this.#options.text;
    this.prefixText = this.#options.prefixText;
    this.suffixText = this.#options.suffixText;
    this.indent = this.#options.indent;
    if (import_node_process6.default.env.NODE_ENV === "test") {
      this._stream = this.#stream;
      this._isEnabled = this.#isEnabled;
      Object.defineProperty(this, "_linesToClear", {
        get() {
          return this.#linesToClear;
        },
        set(newValue) {
          this.#linesToClear = newValue;
        }
      });
      Object.defineProperty(this, "_frameIndex", {
        get() {
          return this.#frameIndex;
        }
      });
      Object.defineProperty(this, "_lineCount", {
        get() {
          return this.#lineCount;
        }
      });
    }
  }
  get indent() {
    return this.#indent;
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent))) {
      throw new Error("The `indent` option must be an integer from 0 and up");
    }
    this.#indent = indent;
    this.updateLineCount();
  }
  get interval() {
    return this.#initialInterval || this.#spinner.interval || 100;
  }
  get spinner() {
    return this.#spinner;
  }
  set spinner(spinner2) {
    this.#frameIndex = 0;
    this.#initialInterval = void 0;
    if (typeof spinner2 === "object") {
      if (spinner2.frames === void 0) {
        throw new Error("The given spinner must have a `frames` property");
      }
      this.#spinner = spinner2;
    } else if (!isUnicodeSupported()) {
      this.#spinner = import_cli_spinners.default.line;
    } else if (spinner2 === void 0) {
      this.#spinner = import_cli_spinners.default.dots;
    } else if (spinner2 !== "default" && import_cli_spinners.default[spinner2]) {
      this.#spinner = import_cli_spinners.default[spinner2];
    } else {
      throw new Error(`There is no built-in spinner named '${spinner2}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
    }
  }
  get text() {
    return this.#text;
  }
  set text(value) {
    this.#text = value || "";
    this.updateLineCount();
  }
  get prefixText() {
    return this.#prefixText;
  }
  set prefixText(value) {
    this.#prefixText = value || "";
    this.updateLineCount();
  }
  get suffixText() {
    return this.#suffixText;
  }
  set suffixText(value) {
    this.#suffixText = value || "";
    this.updateLineCount();
  }
  get isSpinning() {
    return this.#id !== void 0;
  }
  getFullPrefixText(prefixText = this.#prefixText, postfix = " ") {
    if (typeof prefixText === "string" && prefixText !== "") {
      return prefixText + postfix;
    }
    if (typeof prefixText === "function") {
      return prefixText() + postfix;
    }
    return "";
  }
  getFullSuffixText(suffixText = this.#suffixText, prefix = " ") {
    if (typeof suffixText === "string" && suffixText !== "") {
      return prefix + suffixText;
    }
    if (typeof suffixText === "function") {
      return prefix + suffixText();
    }
    return "";
  }
  updateLineCount() {
    const columns = this.#stream.columns || 80;
    const fullPrefixText = this.getFullPrefixText(this.#prefixText, "-");
    const fullSuffixText = this.getFullSuffixText(this.#suffixText, "-");
    const fullText = " ".repeat(this.#indent) + fullPrefixText + "--" + this.#text + "--" + fullSuffixText;
    this.#lineCount = 0;
    for (const line of stripAnsi(fullText).split("\n")) {
      this.#lineCount += Math.max(1, Math.ceil((0, import_wcwidth.default)(line) / columns));
    }
  }
  get isEnabled() {
    return this.#isEnabled && !this.#isSilent;
  }
  set isEnabled(value) {
    if (typeof value !== "boolean") {
      throw new TypeError("The `isEnabled` option must be a boolean");
    }
    this.#isEnabled = value;
  }
  get isSilent() {
    return this.#isSilent;
  }
  set isSilent(value) {
    if (typeof value !== "boolean") {
      throw new TypeError("The `isSilent` option must be a boolean");
    }
    this.#isSilent = value;
  }
  frame() {
    const { frames } = this.#spinner;
    let frame = frames[this.#frameIndex];
    if (this.color) {
      frame = source_default[this.color](frame);
    }
    this.#frameIndex = ++this.#frameIndex % frames.length;
    const fullPrefixText = typeof this.#prefixText === "string" && this.#prefixText !== "" ? this.#prefixText + " " : "";
    const fullText = typeof this.text === "string" ? " " + this.text : "";
    const fullSuffixText = typeof this.#suffixText === "string" && this.#suffixText !== "" ? " " + this.#suffixText : "";
    return fullPrefixText + frame + fullText + fullSuffixText;
  }
  clear() {
    if (!this.#isEnabled || !this.#stream.isTTY) {
      return this;
    }
    this.#stream.cursorTo(0);
    for (let index = 0; index < this.#linesToClear; index++) {
      if (index > 0) {
        this.#stream.moveCursor(0, -1);
      }
      this.#stream.clearLine(1);
    }
    if (this.#indent || this.lastIndent !== this.#indent) {
      this.#stream.cursorTo(this.#indent);
    }
    this.lastIndent = this.#indent;
    this.#linesToClear = 0;
    return this;
  }
  render() {
    if (this.#isSilent) {
      return this;
    }
    this.clear();
    this.#stream.write(this.frame());
    this.#linesToClear = this.#lineCount;
    return this;
  }
  start(text) {
    if (text) {
      this.text = text;
    }
    if (this.#isSilent) {
      return this;
    }
    if (!this.#isEnabled) {
      if (this.text) {
        this.#stream.write(`- ${this.text}
`);
      }
      return this;
    }
    if (this.isSpinning) {
      return this;
    }
    if (this.#options.hideCursor) {
      cli_cursor_default.hide(this.#stream);
    }
    if (this.#options.discardStdin && import_node_process6.default.stdin.isTTY) {
      this.#isDiscardingStdin = true;
      stdin_discarder_default.start();
    }
    this.render();
    this.#id = setInterval(this.render.bind(this), this.interval);
    return this;
  }
  stop() {
    if (!this.#isEnabled) {
      return this;
    }
    clearInterval(this.#id);
    this.#id = void 0;
    this.#frameIndex = 0;
    this.clear();
    if (this.#options.hideCursor) {
      cli_cursor_default.show(this.#stream);
    }
    if (this.#options.discardStdin && import_node_process6.default.stdin.isTTY && this.#isDiscardingStdin) {
      stdin_discarder_default.stop();
      this.#isDiscardingStdin = false;
    }
    return this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: log_symbols_default.info, text });
  }
  stopAndPersist(options = {}) {
    if (this.#isSilent) {
      return this;
    }
    const prefixText = options.prefixText || this.#prefixText;
    const fullPrefixText = this.getFullPrefixText(prefixText, " ");
    const symbolText = options.symbol || " ";
    const text = options.text || this.text;
    const fullText = typeof text === "string" ? " " + text : "";
    const suffixText = options.suffixText !== void 0 ? options.suffixText : this.#suffixText;
    const fullSuffixText = this.getFullSuffixText(suffixText, " ");
    const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + "\n";
    this.stop();
    this.#stream.write(textToWrite);
    return this;
  }
};
function ora(options) {
  return new Ora(options);
}

// src/uis/spinner.ts
var Spinner = class {
  constructor(_spinner) {
    this.spinner = _spinner || ora({ spinner: "dots" });
  }
  start(message) {
    if (this.spinner.isSpinning) {
      this.spinner.text = message || "";
      return;
    }
    this.spinner.start(message);
  }
  updateMessage(message) {
    if (this.spinner.isSpinning) {
      this.spinner.text = message;
      return;
    }
    this.spinner.start(message);
  }
  stop() {
    if (this.spinner.isSpinning) {
      this.spinner.stop();
    }
  }
  fail(message) {
    if (this.spinner.isSpinning) {
      this.spinner.fail(message);
    }
  }
  succeed(message) {
    if (this.spinner.isSpinning) {
      this.spinner.succeed(message);
    }
  }
  info(message) {
    this.spinner.info(message);
  }
  logInfo(message) {
    this.spinner.clear();
    this.spinner.frame();
    console.log(message);
  }
};

// node_modules/acebase-core/dist/esm/simple-event-emitter.js
function runCallback(callback, data) {
  try {
    callback(data);
  } catch (err) {
    console.error("Error in subscription callback", err);
  }
}
var _subscriptions = Symbol("subscriptions");
var _oneTimeEvents = Symbol("oneTimeEvents");
var SimpleEventEmitter = class {
  constructor() {
    this[_subscriptions] = [];
    this[_oneTimeEvents] = /* @__PURE__ */ new Map();
  }
  on(event, callback) {
    if (this[_oneTimeEvents].has(event)) {
      return runCallback(callback, this[_oneTimeEvents].get(event));
    }
    this[_subscriptions].push({ event, callback, once: false });
    return this;
  }
  off(event, callback) {
    this[_subscriptions] = this[_subscriptions].filter((s) => s.event !== event || callback && s.callback !== callback);
    return this;
  }
  once(event, callback) {
    return new Promise((resolve) => {
      const ourCallback = (data) => {
        resolve(data);
        callback?.(data);
      };
      if (this[_oneTimeEvents].has(event)) {
        runCallback(ourCallback, this[_oneTimeEvents].get(event));
      } else {
        this[_subscriptions].push({ event, callback: ourCallback, once: true });
      }
    });
  }
  emit(event, data) {
    if (this[_oneTimeEvents].has(event)) {
      throw new Error(`Event "${event}" was supposed to be emitted only once`);
    }
    for (let i = 0; i < this[_subscriptions].length; i++) {
      const s = this[_subscriptions][i];
      if (s.event !== event) {
        continue;
      }
      runCallback(s.callback, data);
      if (s.once) {
        this[_subscriptions].splice(i, 1);
        i--;
      }
    }
    return this;
  }
  emitOnce(event, data) {
    if (this[_oneTimeEvents].has(event)) {
      throw new Error(`Event "${event}" was supposed to be emitted only once`);
    }
    this.emit(event, data);
    this[_oneTimeEvents].set(event, data);
    this.off(event);
    return this;
  }
  pipe(event, eventEmitter) {
    this.on(event, (data) => {
      eventEmitter.emit(event, data);
    });
  }
  pipeOnce(event, eventEmitter) {
    this.once(event, (data) => {
      eventEmitter.emitOnce(event, data);
    });
  }
};

// node_modules/acebase-core/dist/esm/path-info.js
function getPathKeys(path3) {
  path3 = path3.replace(/\[/g, "/[").replace(/^\/+/, "").replace(/\/+$/, "");
  if (path3.length === 0) {
    return [];
  }
  const keys = path3.split("/");
  return keys.map((key) => {
    return key.startsWith("[") ? parseInt(key.slice(1, -1)) : key;
  });
}
var PathInfo = class {
  static get(path3) {
    return new PathInfo(path3);
  }
  static getChildPath(path3, childKey) {
    return PathInfo.get(path3).child(childKey).path;
  }
  static getPathKeys(path3) {
    return getPathKeys(path3);
  }
  constructor(path3) {
    if (typeof path3 === "string") {
      this.keys = getPathKeys(path3);
    } else if (path3 instanceof Array) {
      this.keys = path3;
    }
    this.path = this.keys.reduce((path4, key, i) => i === 0 ? `${key}` : typeof key === "string" ? `${path4}/${key}` : `${path4}[${key}]`, "");
  }
  get key() {
    return this.keys.length === 0 ? null : this.keys.slice(-1)[0];
  }
  get parent() {
    if (this.keys.length == 0) {
      return null;
    }
    const parentKeys = this.keys.slice(0, -1);
    return new PathInfo(parentKeys);
  }
  get parentPath() {
    return this.keys.length === 0 ? null : this.parent.path;
  }
  child(childKey) {
    if (typeof childKey === "string") {
      if (childKey.length === 0) {
        throw new Error(`child key for path "${this.path}" cannot be empty`);
      }
      const keys = getPathKeys(childKey);
      keys.forEach((key) => {
        if (typeof key !== "string") {
          return;
        }
        if (/[\x00-\x08\x0b\x0c\x0e-\x1f/[\]\\]/.test(key)) {
          throw new Error(`Invalid child key "${key}" for path "${this.path}". Keys cannot contain control characters or any of the following characters: \\ / [ ]`);
        }
        if (key.length > 128) {
          throw new Error(`child key "${key}" for path "${this.path}" is too long. Max key length is 128`);
        }
        if (key.length === 0) {
          throw new Error(`child key for path "${this.path}" cannot be empty`);
        }
      });
      childKey = keys;
    }
    return new PathInfo(this.keys.concat(childKey));
  }
  childPath(childKey) {
    return this.child(childKey).path;
  }
  get pathKeys() {
    return this.keys;
  }
  static extractVariables(varPath, fullPath) {
    if (!varPath.includes("*") && !varPath.includes("$")) {
      return [];
    }
    const keys = getPathKeys(varPath);
    const pathKeys = getPathKeys(fullPath);
    let count = 0;
    const variables = {
      get length() {
        return count;
      }
    };
    keys.forEach((key, index) => {
      const pathKey = pathKeys[index];
      if (key === "*") {
        variables[count++] = pathKey;
      } else if (typeof key === "string" && key[0] === "$") {
        variables[count++] = pathKey;
        variables[key] = pathKey;
        const varName = key.slice(1);
        if (typeof variables[varName] === "undefined") {
          variables[varName] = pathKey;
        }
      }
    });
    return variables;
  }
  static fillVariables(varPath, fullPath) {
    if (varPath.indexOf("*") < 0 && varPath.indexOf("$") < 0) {
      return varPath;
    }
    const keys = getPathKeys(varPath);
    const pathKeys = getPathKeys(fullPath);
    const merged = keys.map((key, index) => {
      if (key === pathKeys[index] || index >= pathKeys.length) {
        return key;
      } else if (typeof key === "string" && (key === "*" || key[0] === "$")) {
        return pathKeys[index];
      } else {
        throw new Error(`Path "${fullPath}" cannot be used to fill variables of path "${varPath}" because they do not match`);
      }
    });
    let mergedPath = "";
    merged.forEach((key) => {
      if (typeof key === "number") {
        mergedPath += `[${key}]`;
      } else {
        if (mergedPath.length > 0) {
          mergedPath += "/";
        }
        mergedPath += key;
      }
    });
    return mergedPath;
  }
  static fillVariables2(varPath, vars) {
    if (typeof vars !== "object" || Object.keys(vars).length === 0) {
      return varPath;
    }
    const pathKeys = getPathKeys(varPath);
    let n = 0;
    const targetPath = pathKeys.reduce((path3, key) => {
      if (typeof key === "string" && (key === "*" || key.startsWith("$"))) {
        return PathInfo.getChildPath(path3, vars[n++]);
      } else {
        return PathInfo.getChildPath(path3, key);
      }
    }, "");
    return targetPath;
  }
  equals(otherPath) {
    const other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
    if (this.path === other.path) {
      return true;
    }
    if (this.keys.length !== other.keys.length) {
      return false;
    }
    return this.keys.every((key, index) => {
      const otherKey = other.keys[index];
      return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
    });
  }
  isAncestorOf(descendantPath) {
    const descendant = descendantPath instanceof PathInfo ? descendantPath : new PathInfo(descendantPath);
    if (descendant.path === "" || this.path === descendant.path) {
      return false;
    }
    if (this.path === "") {
      return true;
    }
    if (this.keys.length >= descendant.keys.length) {
      return false;
    }
    return this.keys.every((key, index) => {
      const otherKey = descendant.keys[index];
      return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
    });
  }
  isDescendantOf(ancestorPath) {
    const ancestor = ancestorPath instanceof PathInfo ? ancestorPath : new PathInfo(ancestorPath);
    if (this.path === "" || this.path === ancestor.path) {
      return false;
    }
    if (ancestorPath === "") {
      return true;
    }
    if (ancestor.keys.length >= this.keys.length) {
      return false;
    }
    return ancestor.keys.every((key, index) => {
      const otherKey = this.keys[index];
      return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
    });
  }
  isOnTrailOf(otherPath) {
    const other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
    if (this.path.length === 0 || other.path.length === 0) {
      return true;
    }
    if (this.path === other.path) {
      return true;
    }
    return this.pathKeys.every((key, index) => {
      if (index >= other.keys.length) {
        return true;
      }
      const otherKey = other.keys[index];
      return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
    });
  }
  isChildOf(otherPath) {
    const other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
    if (this.path === "") {
      return false;
    }
    return this.parent.equals(other);
  }
  isParentOf(otherPath) {
    const other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
    if (other.path === "") {
      return false;
    }
    return this.equals(other.parent);
  }
};

// node_modules/acebase-core/dist/esm/data-snapshot.js
function getChild(snapshot, path3, previous = false) {
  if (!snapshot.exists()) {
    return null;
  }
  let child = previous ? snapshot.previous() : snapshot.val();
  if (typeof path3 === "number") {
    return child[path3];
  }
  PathInfo.getPathKeys(path3).every((key) => {
    child = child[key];
    return typeof child !== "undefined";
  });
  return child || null;
}
function getChildren(snapshot) {
  if (!snapshot.exists()) {
    return [];
  }
  const value = snapshot.val();
  if (value instanceof Array) {
    return new Array(value.length).map((v, i) => i);
  }
  if (typeof value === "object") {
    return Object.keys(value);
  }
  return [];
}
var DataSnapshot = class {
  exists() {
    return false;
  }
  constructor(ref, value, isRemoved = false, prevValue, context) {
    this.ref = ref;
    this.val = () => {
      return value;
    };
    this.previous = () => {
      return prevValue;
    };
    this.exists = () => {
      if (isRemoved) {
        return false;
      }
      return value !== null && typeof value !== "undefined";
    };
    this.context = () => {
      return context || {};
    };
  }
  static for(ref, value) {
    return new DataSnapshot(ref, value);
  }
  child(path3) {
    const val = getChild(this, path3, false);
    const prev = getChild(this, path3, true);
    return new DataSnapshot(this.ref.child(path3), val, false, prev);
  }
  hasChild(path3) {
    return getChild(this, path3) !== null;
  }
  hasChildren() {
    return getChildren(this).length > 0;
  }
  numChildren() {
    return getChildren(this).length;
  }
  forEach(callback) {
    const value = this.val();
    const prev = this.previous();
    return getChildren(this).every((key) => {
      const snap = new DataSnapshot(this.ref.child(key), value[key], false, prev[key]);
      return callback(snap);
    });
  }
  get key() {
    return this.ref.key;
  }
};
var MutationsDataSnapshot = class extends DataSnapshot {
  constructor(ref, mutations, context) {
    super(ref, mutations, false, void 0, context);
    this.previous = () => {
      throw new Error("Iterate values to get previous values for each mutation");
    };
    this.val = (warn = true) => {
      if (warn) {
        console.warn("Unless you know what you are doing, it is best not to use the value of a mutations snapshot directly. Use child methods and forEach to iterate the mutations instead");
      }
      return mutations;
    };
  }
  forEach(callback) {
    const mutations = this.val(false);
    return mutations.every((mutation) => {
      const ref = mutation.target.reduce((ref2, key) => ref2.child(key), this.ref);
      const snap = new DataSnapshot(ref, mutation.val, false, mutation.prev);
      return callback(snap);
    });
  }
  child(index) {
    if (typeof index !== "number") {
      throw new Error("child index must be a number");
    }
    const mutation = this.val(false)[index];
    const ref = mutation.target.reduce((ref2, key) => ref2.child(key), this.ref);
    return new DataSnapshot(ref, mutation.val, false, mutation.prev);
  }
};

// node_modules/acebase-core/dist/esm/subscription.js
var EventSubscription = class {
  constructor(stop) {
    this.stop = stop;
    this._internal = {
      state: "init",
      activatePromises: []
    };
  }
  activated(callback) {
    if (callback) {
      this._internal.activatePromises.push({ callback });
      if (this._internal.state === "active") {
        callback(true);
      } else if (this._internal.state === "canceled") {
        callback(false, this._internal.cancelReason);
      }
    }
    return new Promise((resolve, reject) => {
      if (this._internal.state === "active") {
        return resolve();
      } else if (this._internal.state === "canceled" && !callback) {
        return reject(new Error(this._internal.cancelReason));
      }
      const noop5 = () => {
      };
      this._internal.activatePromises.push({
        resolve,
        reject: callback ? noop5 : reject
      });
    });
  }
  _setActivationState(activated, cancelReason) {
    this._internal.cancelReason = cancelReason;
    this._internal.state = activated ? "active" : "canceled";
    while (this._internal.activatePromises.length > 0) {
      const p = this._internal.activatePromises.shift();
      if (activated) {
        p.callback && p.callback(true);
        p.resolve && p.resolve();
      } else {
        p.callback && p.callback(false, cancelReason);
        p.reject && p.reject(cancelReason);
      }
    }
  }
};
var EventPublisher = class {
  constructor(publish, start, cancel) {
    this.publish = publish;
    this.start = start;
    this.cancel = cancel;
  }
};
var EventStream = class {
  constructor(eventPublisherCallback) {
    const subscribers = [];
    let noMoreSubscribersCallback;
    let activationState;
    const STATE_STOPPED = "stopped (no more subscribers)";
    this.subscribe = (callback, activationCallback) => {
      if (typeof callback !== "function") {
        throw new TypeError("callback must be a function");
      } else if (activationState === STATE_STOPPED) {
        throw new Error("stream can't be used anymore because all subscribers were stopped");
      }
      const sub = {
        callback,
        activationCallback: function(activated, cancelReason) {
          activationCallback?.(activated, cancelReason);
          this.subscription._setActivationState(activated, cancelReason);
        },
        subscription: new EventSubscription(function stop() {
          subscribers.splice(subscribers.indexOf(this), 1);
          return checkActiveSubscribers();
        })
      };
      subscribers.push(sub);
      if (typeof activationState !== "undefined") {
        if (activationState === true) {
          activationCallback?.(true);
          sub.subscription._setActivationState(true);
        } else if (typeof activationState === "string") {
          activationCallback?.(false, activationState);
          sub.subscription._setActivationState(false, activationState);
        }
      }
      return sub.subscription;
    };
    const checkActiveSubscribers = () => {
      let ret;
      if (subscribers.length === 0) {
        ret = noMoreSubscribersCallback?.();
        activationState = STATE_STOPPED;
      }
      return Promise.resolve(ret);
    };
    this.unsubscribe = (callback) => {
      const remove = callback ? subscribers.filter((sub) => sub.callback === callback) : subscribers;
      remove.forEach((sub) => {
        const i = subscribers.indexOf(sub);
        subscribers.splice(i, 1);
      });
      checkActiveSubscribers();
    };
    this.stop = () => {
      subscribers.splice(0);
      checkActiveSubscribers();
    };
    const publish = (val) => {
      subscribers.forEach((sub) => {
        try {
          sub.callback(val);
        } catch (err) {
          console.error(`Error running subscriber callback: ${err.message}`);
        }
      });
      if (subscribers.length === 0) {
        checkActiveSubscribers();
      }
      return subscribers.length > 0;
    };
    const start = (allSubscriptionsStoppedCallback) => {
      activationState = true;
      noMoreSubscribersCallback = allSubscriptionsStoppedCallback;
      subscribers.forEach((sub) => {
        sub.activationCallback?.(true);
      });
    };
    const cancel = (reason) => {
      activationState = reason;
      subscribers.forEach((sub) => {
        sub.activationCallback?.(false, reason || new Error("unknown reason"));
      });
      subscribers.splice(0);
    };
    const publisher = new EventPublisher(publish, start, cancel);
    eventPublisherCallback(publisher);
  }
};

// node_modules/acebase-core/dist/esm/cuid/pad.js
function pad(num, size) {
  const s = "000000000" + num;
  return s.substr(s.length - size);
}

// node_modules/acebase-core/dist/esm/cuid/fingerprint/index.js
var os2 = __toESM(require("os"), 1);
var padding = 2;
var pid = pad(process.pid.toString(36), padding);
var hostname2 = os2.hostname();
var length2 = hostname2.length;
var hostId = pad(hostname2.split("").reduce(function(prev, char) {
  return +prev + char.charCodeAt(0);
}, +length2 + 36).toString(36), padding);
function fingerprint() {
  return pid + hostId;
}

// node_modules/acebase-core/dist/esm/cuid/index.js
var c = 0;
var blockSize = 4;
var base = 36;
var discreteValues = Math.pow(base, blockSize);
function randomBlock() {
  return pad((Math.random() * discreteValues << 0).toString(base), blockSize);
}
function safeCounter() {
  c = c < discreteValues ? c : 0;
  c++;
  return c - 1;
}
function cuid(timebias = 0) {
  const letter = "c", timestamp = (new Date().getTime() + timebias).toString(base), counter = pad(safeCounter().toString(base), blockSize), print = fingerprint(), random = randomBlock() + randomBlock();
  return letter + timestamp + counter + print + random;
}

// node_modules/acebase-core/dist/esm/id.js
var timeBias = 0;
var ID = class {
  static set timeBias(bias) {
    if (typeof bias !== "number") {
      return;
    }
    timeBias = bias;
  }
  static generate() {
    return cuid(timeBias).slice(1);
  }
};

// node_modules/acebase-core/dist/esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  ObjectDifferences: () => ObjectDifferences,
  bigintToBytes: () => bigintToBytes,
  bytesToBigint: () => bytesToBigint,
  bytesToNumber: () => bytesToNumber,
  cloneObject: () => cloneObject,
  compareValues: () => compareValues,
  concatTypedArrays: () => concatTypedArrays,
  decodeString: () => decodeString,
  defer: () => defer,
  encodeString: () => encodeString,
  getChildValues: () => getChildValues,
  getGlobalObject: () => getGlobalObject,
  getMutations: () => getMutations,
  numberToBytes: () => numberToBytes,
  valuesAreEqual: () => valuesAreEqual
});

// node_modules/acebase-core/dist/esm/path-reference.js
var PathReference = class {
  constructor(path3) {
    this.path = path3;
  }
};

// node_modules/acebase-core/dist/esm/process/index.js
var process_default = process;

// node_modules/acebase-core/dist/esm/partial-array.js
var PartialArray = class {
  constructor(sparseArray) {
    if (sparseArray instanceof Array) {
      for (let i = 0; i < sparseArray.length; i++) {
        if (typeof sparseArray[i] !== "undefined") {
          this[i] = sparseArray[i];
        }
      }
    } else if (sparseArray) {
      Object.assign(this, sparseArray);
    }
  }
};

// node_modules/acebase-core/dist/esm/utils.js
function numberToBytes(number) {
  const bytes = new Uint8Array(8);
  const view = new DataView(bytes.buffer);
  view.setFloat64(0, number);
  return new Array(...bytes);
}
function bytesToNumber(bytes) {
  const length3 = Array.isArray(bytes) ? bytes.length : bytes.byteLength;
  if (length3 !== 8) {
    throw new TypeError("must be 8 bytes");
  }
  const bin = new Uint8Array(bytes);
  const view = new DataView(bin.buffer);
  const nr = view.getFloat64(0);
  return nr;
}
var hasBigIntSupport = (() => {
  try {
    return typeof BigInt(0) === "bigint";
  } catch (err) {
    return false;
  }
})();
var noBigIntError = "BigInt is not supported on this platform";
var bigIntFunctions = {
  bigintToBytes(number) {
    throw new Error(noBigIntError);
  },
  bytesToBigint(bytes) {
    throw new Error(noBigIntError);
  }
};
if (hasBigIntSupport) {
  const big = {
    zero: BigInt(0),
    one: BigInt(1),
    two: BigInt(2),
    eight: BigInt(8),
    ff: BigInt(255)
  };
  bigIntFunctions.bigintToBytes = function bigintToBytes6(number) {
    if (typeof number !== "bigint") {
      throw new Error("number must be a bigint");
    }
    const bytes = [];
    const negative = number < big.zero;
    do {
      const byte = Number(number & big.ff);
      bytes.push(byte);
      number = number >> big.eight;
    } while (number !== (negative ? -big.one : big.zero));
    bytes.reverse();
    if (negative ? bytes[0] < 128 : bytes[0] >= 128) {
      bytes.unshift(negative ? 255 : 0);
    }
    return bytes;
  };
  bigIntFunctions.bytesToBigint = function bytesToBigint4(bytes) {
    const negative = bytes[0] >= 128;
    let number = big.zero;
    for (let b of bytes) {
      if (negative) {
        b = ~b & 255;
      }
      number = (number << big.eight) + BigInt(b);
    }
    if (negative) {
      number = -(number + big.one);
    }
    return number;
  };
}
var bigintToBytes = bigIntFunctions.bigintToBytes;
var bytesToBigint = bigIntFunctions.bytesToBigint;
function encodeString(str) {
  if (typeof TextEncoder !== "undefined") {
    const encoder = new TextEncoder();
    return encoder.encode(str);
  } else if (typeof Buffer === "function") {
    const buf = Buffer.from(str, "utf-8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  } else {
    const arr = [];
    for (let i = 0; i < str.length; i++) {
      let code = str.charCodeAt(i);
      if (code > 128) {
        if ((code & 55296) === 55296) {
          const nextCode = str.charCodeAt(i + 1);
          if ((nextCode & 56320) !== 56320) {
            throw new Error("follow-up utf-16 character does not start with 0xDC00");
          }
          i++;
          const p1 = code & 1023;
          const p2 = nextCode & 1023;
          code = 65536 | p1 << 10 | p2;
        }
        if (code < 2048) {
          const b1 = 192 | code >> 6 & 31;
          const b2 = 128 | code & 63;
          arr.push(b1, b2);
        } else if (code < 65536) {
          const b1 = 224 | code >> 12 & 15;
          const b2 = 128 | code >> 6 & 63;
          const b3 = 128 | code & 63;
          arr.push(b1, b2, b3);
        } else if (code < 2097152) {
          const b1 = 240 | code >> 18 & 7;
          const b2 = 128 | code >> 12 & 63;
          const b3 = 128 | code >> 6 & 63;
          const b4 = 128 | code & 63;
          arr.push(b1, b2, b3, b4);
        } else {
          throw new Error(`Cannot convert character ${str.charAt(i)} (code ${code}) to utf-8`);
        }
      } else {
        arr.push(code < 128 ? code : 63);
      }
    }
    return new Uint8Array(arr);
  }
}
function decodeString(buffer) {
  if (typeof TextDecoder !== "undefined") {
    const decoder = new TextDecoder();
    if (buffer instanceof Uint8Array) {
      return decoder.decode(buffer);
    }
    const buf = Uint8Array.from(buffer);
    return decoder.decode(buf);
  } else if (typeof Buffer === "function") {
    if (buffer instanceof Array) {
      buffer = Uint8Array.from(buffer);
    }
    if (!(buffer instanceof Buffer) && "buffer" in buffer && buffer.buffer instanceof ArrayBuffer) {
      const typedArray = buffer;
      buffer = Buffer.from(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
    }
    if (!(buffer instanceof Buffer)) {
      throw new Error("Unsupported buffer argument");
    }
    return buffer.toString("utf-8");
  } else {
    if (!(buffer instanceof Uint8Array) && "buffer" in buffer && buffer["buffer"] instanceof ArrayBuffer) {
      const typedArray = buffer;
      buffer = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
    }
    if (buffer instanceof Buffer || buffer instanceof Array || buffer instanceof Uint8Array) {
      let str = "";
      for (let i = 0; i < buffer.length; i++) {
        let code = buffer[i];
        if (code > 128) {
          if ((code & 240) === 240) {
            const b1 = code, b2 = buffer[i + 1], b3 = buffer[i + 2], b4 = buffer[i + 3];
            code = (b1 & 7) << 18 | (b2 & 63) << 12 | (b3 & 63) << 6 | b4 & 63;
            i += 3;
          } else if ((code & 224) === 224) {
            const b1 = code, b2 = buffer[i + 1], b3 = buffer[i + 2];
            code = (b1 & 15) << 12 | (b2 & 63) << 6 | b3 & 63;
            i += 2;
          } else if ((code & 192) === 192) {
            const b1 = code, b2 = buffer[i + 1];
            code = (b1 & 31) << 6 | b2 & 63;
            i++;
          } else {
            throw new Error("invalid utf-8 data");
          }
        }
        if (code >= 65536) {
          code ^= 65536;
          const p1 = 55296 | code >> 10;
          const p2 = 56320 | code & 1023;
          str += String.fromCharCode(p1);
          str += String.fromCharCode(p2);
        } else {
          str += String.fromCharCode(code);
        }
      }
      return str;
    } else {
      throw new Error("Unsupported buffer argument");
    }
  }
}
function concatTypedArrays(a, b) {
  const c3 = new a.constructor(a.length + b.length);
  c3.set(a);
  c3.set(b, a.length);
  return c3;
}
function cloneObject(original, stack) {
  if (original?.constructor?.name === "DataSnapshot") {
    throw new TypeError(`Object to clone is a DataSnapshot (path "${original.ref.path}")`);
  }
  const checkAndFixTypedArray = (obj) => {
    if (obj !== null && typeof obj === "object" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && ["Buffer", "Uint8Array", "Int8Array", "Uint16Array", "Int16Array", "Uint32Array", "Int32Array", "BigUint64Array", "BigInt64Array"].includes(obj.constructor.name)) {
      obj = obj.buffer.slice(obj.byteOffset, obj.byteOffset + obj.byteLength);
    }
    return obj;
  };
  original = checkAndFixTypedArray(original);
  if (typeof original !== "object" || original === null || original instanceof Date || original instanceof ArrayBuffer || original instanceof PathReference || original instanceof RegExp) {
    return original;
  }
  const cloneValue = (val) => {
    if (stack.indexOf(val) >= 0) {
      throw new ReferenceError("object contains a circular reference");
    }
    val = checkAndFixTypedArray(val);
    if (val === null || val instanceof Date || val instanceof ArrayBuffer || val instanceof PathReference || val instanceof RegExp) {
      return val;
    } else if (typeof val === "object") {
      stack.push(val);
      val = cloneObject(val, stack);
      stack.pop();
      return val;
    } else {
      return val;
    }
  };
  if (typeof stack === "undefined") {
    stack = [original];
  }
  const clone = original instanceof Array ? [] : original instanceof PartialArray ? new PartialArray() : {};
  Object.keys(original).forEach((key) => {
    const val = original[key];
    if (typeof val === "function") {
      return;
    }
    clone[key] = cloneValue(val);
  });
  return clone;
}
var isTypedArray = (val) => typeof val === "object" && ["ArrayBuffer", "Buffer", "Uint8Array", "Uint16Array", "Uint32Array", "Int8Array", "Int16Array", "Int32Array"].includes(val.constructor.name);
function valuesAreEqual(val1, val2) {
  if (val1 === val2) {
    return true;
  }
  if (typeof val1 !== typeof val2) {
    return false;
  }
  if (typeof val1 === "object" || typeof val2 === "object") {
    if (val1 === null || val2 === null) {
      return false;
    }
    if (val1 instanceof PathReference || val2 instanceof PathReference) {
      return val1 instanceof PathReference && val2 instanceof PathReference && val1.path === val2.path;
    }
    if (val1 instanceof Date || val2 instanceof Date) {
      return val1 instanceof Date && val2 instanceof Date && val1.getTime() === val2.getTime();
    }
    if (val1 instanceof Array || val2 instanceof Array) {
      return val1 instanceof Array && val2 instanceof Array && val1.length === val2.length && val1.every((item, i) => valuesAreEqual(val1[i], val2[i]));
    }
    if (isTypedArray(val1) || isTypedArray(val2)) {
      if (!isTypedArray(val1) || !isTypedArray(val2) || val1.byteLength === val2.byteLength) {
        return false;
      }
      const typed1 = val1 instanceof ArrayBuffer ? new Uint8Array(val1) : new Uint8Array(val1.buffer, val1.byteOffset, val1.byteLength), typed2 = val2 instanceof ArrayBuffer ? new Uint8Array(val2) : new Uint8Array(val2.buffer, val2.byteOffset, val2.byteLength);
      return typed1.every((val, i) => typed2[i] === val);
    }
    const keys1 = Object.keys(val1), keys2 = Object.keys(val2);
    return keys1.length === keys2.length && keys1.every((key) => keys2.includes(key)) && keys1.every((key) => valuesAreEqual(val1[key], val2[key]));
  }
  return false;
}
var ObjectDifferences = class {
  constructor(added, removed, changed) {
    this.added = added;
    this.removed = removed;
    this.changed = changed;
  }
  forChild(key) {
    if (this.added.includes(key)) {
      return "added";
    }
    if (this.removed.includes(key)) {
      return "removed";
    }
    const changed = this.changed.find((ch) => ch.key === key);
    return changed ? changed.change : "identical";
  }
};
function compareValues(oldVal, newVal, sortedResults = false) {
  const voids = [void 0, null];
  if (oldVal === newVal) {
    return "identical";
  } else if (voids.indexOf(oldVal) >= 0 && voids.indexOf(newVal) < 0) {
    return "added";
  } else if (voids.indexOf(oldVal) < 0 && voids.indexOf(newVal) >= 0) {
    return "removed";
  } else if (typeof oldVal !== typeof newVal) {
    return "changed";
  } else if (isTypedArray(oldVal) || isTypedArray(newVal)) {
    if (!isTypedArray(oldVal) || !isTypedArray(newVal)) {
      return "changed";
    }
    const typed1 = oldVal instanceof Uint8Array ? oldVal : oldVal instanceof ArrayBuffer ? new Uint8Array(oldVal) : new Uint8Array(oldVal.buffer, oldVal.byteOffset, oldVal.byteLength);
    const typed2 = newVal instanceof Uint8Array ? newVal : newVal instanceof ArrayBuffer ? new Uint8Array(newVal) : new Uint8Array(newVal.buffer, newVal.byteOffset, newVal.byteLength);
    return typed1.byteLength === typed2.byteLength && typed1.every((val, i) => typed2[i] === val) ? "identical" : "changed";
  } else if (oldVal instanceof Date || newVal instanceof Date) {
    return oldVal instanceof Date && newVal instanceof Date && oldVal.getTime() === newVal.getTime() ? "identical" : "changed";
  } else if (oldVal instanceof PathReference || newVal instanceof PathReference) {
    return oldVal instanceof PathReference && newVal instanceof PathReference && oldVal.path === newVal.path ? "identical" : "changed";
  } else if (typeof oldVal === "object") {
    const isArray2 = oldVal instanceof Array;
    const getKeys = (obj) => {
      let keys = Object.keys(obj).filter((key) => !voids.includes(obj[key]));
      if (isArray2) {
        keys = keys.map((v) => parseInt(v));
      }
      return keys;
    };
    const oldKeys = getKeys(oldVal);
    const newKeys = getKeys(newVal);
    const removedKeys = oldKeys.filter((key) => !newKeys.includes(key));
    const addedKeys = newKeys.filter((key) => !oldKeys.includes(key));
    const changedKeys = newKeys.reduce((changed, key) => {
      if (oldKeys.includes(key)) {
        const val1 = oldVal[key];
        const val2 = newVal[key];
        const c3 = compareValues(val1, val2);
        if (c3 !== "identical") {
          changed.push({ key, change: c3 });
        }
      }
      return changed;
    }, []);
    if (addedKeys.length === 0 && removedKeys.length === 0 && changedKeys.length === 0) {
      return "identical";
    } else {
      return new ObjectDifferences(addedKeys, removedKeys, sortedResults ? changedKeys.sort((a, b) => a.key < b.key ? -1 : 1) : changedKeys);
    }
  }
  return "changed";
}
function getMutations(oldVal, newVal, sortedResults = false) {
  const process9 = (target, compareResult2, prev, val) => {
    switch (compareResult2) {
      case "identical":
        return [];
      case "changed":
        return [{ target, prev, val }];
      case "added":
        return [{ target, prev: null, val }];
      case "removed":
        return [{ target, prev, val: null }];
      default: {
        let changes = [];
        compareResult2.added.forEach((key) => changes.push({ target: target.concat(key), prev: null, val: val[key] }));
        compareResult2.removed.forEach((key) => changes.push({ target: target.concat(key), prev: prev[key], val: null }));
        compareResult2.changed.forEach((item) => {
          const childChanges = process9(target.concat(item.key), item.change, prev[item.key], val[item.key]);
          changes = changes.concat(childChanges);
        });
        return changes;
      }
    }
  };
  const compareResult = compareValues(oldVal, newVal, sortedResults);
  return process9([], compareResult, oldVal, newVal);
}
function getChildValues(childKey, oldValue, newValue) {
  oldValue = oldValue === null ? null : oldValue[childKey];
  if (typeof oldValue === "undefined") {
    oldValue = null;
  }
  newValue = newValue === null ? null : newValue[childKey];
  if (typeof newValue === "undefined") {
    newValue = null;
  }
  return { oldValue, newValue };
}
function defer(fn) {
  process_default.nextTick(fn);
}
function getGlobalObject() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return function() {
    return this;
  }() ?? Function("return this")();
}

// node_modules/acebase-core/dist/esm/simple-observable.js
var SimpleObservable = class {
  constructor(create) {
    this._active = false;
    this._subscribers = [];
    this._create = create;
  }
  subscribe(subscriber) {
    if (!this._active) {
      const next = (value) => {
        this._subscribers.forEach((s) => {
          try {
            s(value);
          } catch (err) {
            console.error("Error in subscriber callback:", err);
          }
        });
      };
      const observer = { next };
      this._cleanup = this._create(observer);
      this._active = true;
    }
    this._subscribers.push(subscriber);
    const unsubscribe = () => {
      this._subscribers.splice(this._subscribers.indexOf(subscriber), 1);
      if (this._subscribers.length === 0) {
        this._active = false;
        this._cleanup();
      }
    };
    const subscription = {
      unsubscribe
    };
    return subscription;
  }
};

// node_modules/acebase-core/dist/esm/optional-observable.js
var _shimRequested = false;
var _observable;
(async () => {
  const global2 = getGlobalObject();
  if (typeof global2.Observable !== "undefined") {
    _observable = global2.Observable;
    return;
  }
  try {
    const { Observable } = await Promise.resolve().then(() => __toESM(require_cjs(), 1));
    _observable = Observable;
  } catch {
    _observable = SimpleObservable;
  }
})();
function getObservable() {
  if (_observable === SimpleObservable && !_shimRequested) {
    console.warn(`Using AceBase's simple Observable implementation because rxjs is not available. Add it to your project with "npm install rxjs", add it to AceBase using db.setObservable(Observable), or call db.setObservable("shim") to suppress this warning`);
  }
  if (_observable) {
    return _observable;
  }
  throw new Error("RxJS Observable could not be loaded. ");
}
function setObservable(Observable) {
  if (Observable === "shim") {
    _observable = SimpleObservable;
    _shimRequested = true;
  } else {
    _observable = Observable;
  }
}

// node_modules/acebase-core/dist/esm/data-proxy.js
var RelativeNodeTarget = class extends Array {
  static areEqual(t1, t2) {
    return t1.length === t2.length && t1.every((key, i) => t2[i] === key);
  }
  static isAncestor(ancestor, other) {
    return ancestor.length < other.length && ancestor.every((key, i) => other[i] === key);
  }
  static isDescendant(descendant, other) {
    return descendant.length > other.length && other.every((key, i) => descendant[i] === key);
  }
};
var isProxy = Symbol("isProxy");
var LiveDataProxy = class {
  static async create(ref, options) {
    ref = new DataReference(ref.db, ref.path);
    let cache, loaded = false;
    let latestCursor = options?.cursor;
    let proxy;
    const proxyId = ID.generate();
    const clientSubscriptions = [];
    const clientEventEmitter = new SimpleEventEmitter();
    clientEventEmitter.on("cursor", (cursor) => latestCursor = cursor);
    clientEventEmitter.on("error", (err) => {
      console.error(err.message, err.details);
    });
    const applyChange = (keys, newValue) => {
      if (keys.length === 0) {
        cache = newValue;
        return true;
      }
      const allowCreation = false;
      if (allowCreation) {
        cache = typeof keys[0] === "number" ? [] : {};
      }
      let target = cache;
      const trailKeys = keys.slice();
      while (trailKeys.length > 1) {
        const key = trailKeys.shift();
        if (!(key in target)) {
          if (allowCreation) {
            target[key] = typeof key === "number" ? [] : {};
          } else {
            return false;
          }
        }
        target = target[key];
      }
      const prop = trailKeys.shift();
      if (newValue === null) {
        target instanceof Array ? target.splice(prop, 1) : delete target[prop];
      } else {
        target[prop] = newValue;
      }
      return true;
    };
    const syncFallback = async () => {
      if (!loaded) {
        return;
      }
      await reload();
    };
    const subscription = ref.on("mutations", { syncFallback }).subscribe(async (snap2) => {
      if (!loaded) {
        return;
      }
      const context = snap2.context();
      const isRemote = context.acebase_proxy?.id !== proxyId;
      if (!isRemote) {
        return;
      }
      const mutations = snap2.val(false);
      const proceed = mutations.every((mutation) => {
        if (!applyChange(mutation.target, mutation.val)) {
          return false;
        }
        const changeRef = mutation.target.reduce((ref2, key) => ref2.child(key), ref);
        const changeSnap = new DataSnapshot(changeRef, mutation.val, false, mutation.prev, snap2.context());
        clientEventEmitter.emit("mutation", { snapshot: changeSnap, isRemote });
        return true;
      });
      if (proceed) {
        clientEventEmitter.emit("cursor", context.acebase_cursor);
        localMutationsEmitter.emit("mutations", { origin: "remote", snap: snap2 });
      } else {
        console.warn(`Cached value of live data proxy on "${ref.path}" appears outdated, will be reloaded`);
        await reload();
      }
    });
    let processPromise = Promise.resolve();
    const mutationQueue = [];
    const transactions = [];
    const pushLocalMutations = async () => {
      const mutations = [];
      for (let i = 0, m = mutationQueue[0]; i < mutationQueue.length; i++, m = mutationQueue[i]) {
        if (!transactions.find((t) => RelativeNodeTarget.areEqual(t.target, m.target) || RelativeNodeTarget.isAncestor(t.target, m.target))) {
          mutationQueue.splice(i, 1);
          i--;
          mutations.push(m);
        }
      }
      if (mutations.length === 0) {
        return;
      }
      mutations.forEach((mutation) => {
        mutation.value = cloneObject(getTargetValue(cache, mutation.target));
      });
      process_default.nextTick(() => {
        const context = { acebase_proxy: { id: proxyId, source: "update" } };
        mutations.forEach((mutation) => {
          const mutationRef = mutation.target.reduce((ref2, key) => ref2.child(key), ref);
          const mutationSnap = new DataSnapshot(mutationRef, mutation.value, false, mutation.previous, context);
          clientEventEmitter.emit("mutation", { snapshot: mutationSnap, isRemote: false });
        });
        const snap2 = new MutationsDataSnapshot(ref, mutations.map((m) => ({ target: m.target, val: m.value, prev: m.previous })), context);
        localMutationsEmitter.emit("mutations", { origin: "local", snap: snap2 });
      });
      processPromise = mutations.reduce((mutations2, m, i, arr) => {
        if (!arr.some((other) => RelativeNodeTarget.isAncestor(other.target, m.target))) {
          mutations2.push(m);
        }
        return mutations2;
      }, []).reduce((updates, m) => {
        const target = m.target;
        if (target.length === 0) {
          updates.push({ ref, target, value: cache, type: "set", previous: m.previous });
        } else {
          const parentTarget = target.slice(0, -1);
          const key = target.slice(-1)[0];
          const parentRef = parentTarget.reduce((ref2, key2) => ref2.child(key2), ref);
          const parentUpdate = updates.find((update) => update.ref.path === parentRef.path);
          const cacheValue = getTargetValue(cache, target);
          const prevValue = m.previous;
          if (parentUpdate) {
            parentUpdate.value[key] = cacheValue;
            parentUpdate.previous[key] = prevValue;
          } else {
            updates.push({ ref: parentRef, target: parentTarget, value: { [key]: cacheValue }, type: "update", previous: { [key]: prevValue } });
          }
        }
        return updates;
      }, []).reduce(async (promise, update) => {
        const context = {
          acebase_proxy: {
            id: proxyId,
            source: update.type
          }
        };
        await promise;
        await update.ref.context(context)[update.type](update.value).catch((err) => {
          clientEventEmitter.emit("error", { source: "update", message: `Error processing update of "/${ref.path}"`, details: err });
          const context2 = { acebase_proxy: { id: proxyId, source: "update-rollback" } };
          const mutations2 = [];
          if (update.type === "set") {
            setTargetValue(cache, update.target, update.previous);
            const mutationSnap = new DataSnapshot(update.ref, update.previous, false, update.value, context2);
            clientEventEmitter.emit("mutation", { snapshot: mutationSnap, isRemote: false });
            mutations2.push({ target: update.target, val: update.previous, prev: update.value });
          } else {
            Object.keys(update.previous).forEach((key) => {
              setTargetValue(cache, update.target.concat(key), update.previous[key]);
              const mutationSnap = new DataSnapshot(update.ref.child(key), update.previous[key], false, update.value[key], context2);
              clientEventEmitter.emit("mutation", { snapshot: mutationSnap, isRemote: false });
              mutations2.push({ target: update.target.concat(key), val: update.previous[key], prev: update.value[key] });
            });
          }
          mutations2.forEach((m) => {
            const mutationRef = m.target.reduce((ref2, key) => ref2.child(key), ref);
            const mutationSnap = new DataSnapshot(mutationRef, m.val, false, m.prev, context2);
            clientEventEmitter.emit("mutation", { snapshot: mutationSnap, isRemote: false });
          });
          const snap2 = new MutationsDataSnapshot(update.ref, mutations2, context2);
          localMutationsEmitter.emit("mutations", { origin: "local", snap: snap2 });
        });
        if (update.ref.cursor) {
          clientEventEmitter.emit("cursor", update.ref.cursor);
        }
      }, processPromise);
      await processPromise;
    };
    let syncInProgress = false;
    const syncPromises = [];
    const syncCompleted = () => {
      let resolve;
      const promise = new Promise((rs) => resolve = rs);
      syncPromises.push({ resolve });
      return promise;
    };
    let processQueueTimeout = null;
    const scheduleSync = () => {
      if (!processQueueTimeout) {
        processQueueTimeout = setTimeout(async () => {
          syncInProgress = true;
          processQueueTimeout = null;
          await pushLocalMutations();
          syncInProgress = false;
          syncPromises.splice(0).forEach((p) => p.resolve());
        }, 0);
      }
    };
    const flagOverwritten = (target) => {
      if (!mutationQueue.find((m) => RelativeNodeTarget.areEqual(m.target, target))) {
        mutationQueue.push({ target, previous: cloneObject(getTargetValue(cache, target)) });
      }
      scheduleSync();
    };
    const localMutationsEmitter = new SimpleEventEmitter();
    const addOnChangeHandler = (target, callback) => {
      const isObject2 = (val) => val !== null && typeof val === "object";
      const mutationsHandler = async (details) => {
        const { snap: snap2, origin } = details;
        const context = snap2.context();
        const causedByOurProxy = context.acebase_proxy?.id === proxyId;
        if (details.origin === "remote" && causedByOurProxy) {
          console.error("DEV ISSUE: mutationsHandler was called from remote event originating from our own proxy");
          return;
        }
        const mutations = snap2.val(false).filter((mutation) => {
          return mutation.target.slice(0, target.length).every((key, i) => target[i] === key);
        });
        if (mutations.length === 0) {
          return;
        }
        let newValue, previousValue;
        const singleMutation = mutations.find((m) => m.target.length <= target.length);
        if (singleMutation) {
          const trailKeys = target.slice(singleMutation.target.length);
          newValue = trailKeys.reduce((val, key) => !isObject2(val) || !(key in val) ? null : val[key], singleMutation.val);
          previousValue = trailKeys.reduce((val, key) => !isObject2(val) || !(key in val) ? null : val[key], singleMutation.prev);
        } else {
          const currentValue = getTargetValue(cache, target);
          newValue = cloneObject(currentValue);
          previousValue = cloneObject(newValue);
          mutations.forEach((mutation) => {
            const trailKeys = mutation.target.slice(target.length);
            for (let i = 0, val = newValue, prev = previousValue; i < trailKeys.length; i++) {
              const last = i + 1 === trailKeys.length, key = trailKeys[i];
              if (last) {
                val[key] = mutation.val;
                if (val[key] === null) {
                  delete val[key];
                }
                prev[key] = mutation.prev;
                if (prev[key] === null) {
                  delete prev[key];
                }
              } else {
                val = val[key] = key in val ? val[key] : {};
                prev = prev[key] = key in prev ? prev[key] : {};
              }
            }
          });
        }
        process_default.nextTick(() => {
          let keepSubscription = true;
          try {
            keepSubscription = false !== callback(Object.freeze(newValue), Object.freeze(previousValue), !causedByOurProxy, context);
          } catch (err) {
            clientEventEmitter.emit("error", { source: origin === "remote" ? "remote_update" : "local_update", message: "Error running subscription callback", details: err });
          }
          if (keepSubscription === false) {
            stop();
          }
        });
      };
      localMutationsEmitter.on("mutations", mutationsHandler);
      const stop = () => {
        localMutationsEmitter.off("mutations", mutationsHandler);
        clientSubscriptions.splice(clientSubscriptions.findIndex((cs) => cs.stop === stop), 1);
      };
      clientSubscriptions.push({ target, stop });
      return { stop };
    };
    const handleFlag = (flag, target, args) => {
      if (flag === "write") {
        return flagOverwritten(target);
      } else if (flag === "onChange") {
        return addOnChangeHandler(target, args.callback);
      } else if (flag === "subscribe" || flag === "observe") {
        const subscribe = (subscriber) => {
          const currentValue = getTargetValue(cache, target);
          subscriber.next(currentValue);
          const subscription2 = addOnChangeHandler(target, (value) => {
            subscriber.next(value);
          });
          return function unsubscribe() {
            subscription2.stop();
          };
        };
        if (flag === "subscribe") {
          return subscribe;
        }
        const Observable = getObservable();
        return new Observable(subscribe);
      } else if (flag === "transaction") {
        const hasConflictingTransaction = transactions.some((t) => RelativeNodeTarget.areEqual(target, t.target) || RelativeNodeTarget.isAncestor(target, t.target) || RelativeNodeTarget.isDescendant(target, t.target));
        if (hasConflictingTransaction) {
          return Promise.reject(new Error("Cannot start transaction because it conflicts with another transaction"));
        }
        return new Promise(async (resolve) => {
          const hasPendingMutations = mutationQueue.some((m) => RelativeNodeTarget.areEqual(target, m.target) || RelativeNodeTarget.isAncestor(target, m.target));
          if (hasPendingMutations) {
            if (!syncInProgress) {
              scheduleSync();
            }
            await syncCompleted();
          }
          const tx = { target, status: "started", transaction: null };
          transactions.push(tx);
          tx.transaction = {
            get status() {
              return tx.status;
            },
            get completed() {
              return tx.status !== "started";
            },
            get mutations() {
              return mutationQueue.filter((m) => RelativeNodeTarget.areEqual(tx.target, m.target) || RelativeNodeTarget.isAncestor(tx.target, m.target));
            },
            get hasMutations() {
              return this.mutations.length > 0;
            },
            async commit() {
              if (this.completed) {
                throw new Error(`Transaction has completed already (status '${tx.status}')`);
              }
              tx.status = "finished";
              transactions.splice(transactions.indexOf(tx), 1);
              if (syncInProgress) {
                await syncCompleted();
              }
              scheduleSync();
              await syncCompleted();
            },
            rollback() {
              if (this.completed) {
                throw new Error(`Transaction has completed already (status '${tx.status}')`);
              }
              tx.status = "canceled";
              const mutations = [];
              for (let i = 0; i < mutationQueue.length; i++) {
                const m = mutationQueue[i];
                if (RelativeNodeTarget.areEqual(tx.target, m.target) || RelativeNodeTarget.isAncestor(tx.target, m.target)) {
                  mutationQueue.splice(i, 1);
                  i--;
                  mutations.push(m);
                }
              }
              mutations.reverse().forEach((m) => {
                if (m.target.length === 0) {
                  cache = m.previous;
                } else {
                  setTargetValue(cache, m.target, m.previous);
                }
              });
              transactions.splice(transactions.indexOf(tx), 1);
            }
          };
          resolve(tx.transaction);
        });
      }
    };
    const snap = await ref.get({ cache_mode: "allow", cache_cursor: options?.cursor });
    if (snap.context().acebase_origin !== "cache") {
      clientEventEmitter.emit("cursor", ref.cursor ?? null);
    }
    loaded = true;
    cache = snap.val();
    if (cache === null && typeof options?.defaultValue !== "undefined") {
      cache = options.defaultValue;
      const context = {
        acebase_proxy: {
          id: proxyId,
          source: "default"
        }
      };
      await ref.context(context).set(cache);
    }
    proxy = createProxy({ root: { ref, get cache() {
      return cache;
    } }, target: [], id: proxyId, flag: handleFlag });
    const assertProxyAvailable = () => {
      if (proxy === null) {
        throw new Error("Proxy was destroyed");
      }
    };
    const reload = async () => {
      assertProxyAvailable();
      mutationQueue.splice(0);
      const snap2 = await ref.get({ allow_cache: false });
      const oldVal = cache, newVal = snap2.val();
      cache = newVal;
      const mutations = getMutations(oldVal, newVal);
      if (mutations.length === 0) {
        return;
      }
      const context = snap2.context();
      context.acebase_proxy = { id: proxyId, source: "reload" };
      mutations.forEach((m) => {
        const targetRef = getTargetRef(ref, m.target);
        const newSnap = new DataSnapshot(targetRef, m.val, m.val === null, m.prev, context);
        clientEventEmitter.emit("mutation", { snapshot: newSnap, isRemote: true });
      });
      const mutationsSnap = new MutationsDataSnapshot(ref, mutations, context);
      localMutationsEmitter.emit("mutations", { origin: "local", snap: mutationsSnap });
    };
    return {
      async destroy() {
        await processPromise;
        const promises = [
          subscription.stop(),
          ...clientSubscriptions.map((cs) => cs.stop())
        ];
        await Promise.all(promises);
        ["cursor", "mutation", "error"].forEach((event) => clientEventEmitter.off(event));
        cache = null;
        proxy = null;
      },
      stop() {
        this.destroy();
      },
      get value() {
        assertProxyAvailable();
        return proxy;
      },
      get hasValue() {
        assertProxyAvailable();
        return cache !== null;
      },
      set value(val) {
        assertProxyAvailable();
        if (val !== null && typeof val === "object" && val[isProxy]) {
          val = val.valueOf();
        }
        flagOverwritten([]);
        cache = val;
      },
      get ref() {
        return ref;
      },
      get cursor() {
        return latestCursor;
      },
      reload,
      onMutation(callback) {
        assertProxyAvailable();
        clientEventEmitter.off("mutation");
        clientEventEmitter.on("mutation", ({ snapshot, isRemote }) => {
          try {
            callback(snapshot, isRemote);
          } catch (err) {
            clientEventEmitter.emit("error", { source: "mutation_callback", message: "Error in dataproxy onMutation callback", details: err });
          }
        });
      },
      onError(callback) {
        assertProxyAvailable();
        clientEventEmitter.off("error");
        clientEventEmitter.on("error", (err) => {
          try {
            callback(err);
          } catch (err2) {
            console.error(`Error in dataproxy onError callback: ${err2.message}`);
          }
        });
      },
      on(event, callback) {
        clientEventEmitter.on(event, callback);
      },
      off(event, callback) {
        clientEventEmitter.off(event, callback);
      }
    };
  }
};
function getTargetValue(obj, target) {
  let val = obj;
  for (const key of target) {
    val = typeof val === "object" && val !== null && key in val ? val[key] : null;
  }
  return val;
}
function setTargetValue(obj, target, value) {
  if (target.length === 0) {
    throw new Error("Cannot update root target, caller must do that itself!");
  }
  const targetObject = target.slice(0, -1).reduce((obj2, key) => obj2[key], obj);
  const prop = target.slice(-1)[0];
  if (value === null || typeof value === "undefined") {
    targetObject instanceof Array ? targetObject.splice(prop, 1) : delete targetObject[prop];
  } else {
    targetObject[prop] = value;
  }
}
function getTargetRef(ref, target) {
  const path3 = PathInfo.get(ref.path).childPath(target);
  return new DataReference(ref.db, path3);
}
function createProxy(context) {
  const targetRef = getTargetRef(context.root.ref, context.target);
  const childProxies = [];
  const handler = {
    get(target, prop, receiver) {
      target = getTargetValue(context.root.cache, context.target);
      if (typeof prop === "symbol") {
        if (prop.toString() === Symbol.iterator.toString()) {
          prop = "values";
        } else if (prop.toString() === isProxy.toString()) {
          return true;
        } else {
          return Reflect.get(target, prop, receiver);
        }
      }
      if (prop === "valueOf") {
        return function valueOf() {
          return target;
        };
      }
      if (target === null || typeof target !== "object") {
        throw new Error(`Cannot read property "${prop}" of ${target}. Value of path "/${targetRef.path}" is not an object (anymore)`);
      }
      if (target instanceof Array && typeof prop === "string" && /^[0-9]+$/.test(prop)) {
        prop = parseInt(prop);
      }
      const value = target[prop];
      if (value === null) {
        delete target[prop];
        return;
      }
      const childProxy = childProxies.find((proxy2) => proxy2.prop === prop);
      if (childProxy) {
        if (childProxy.typeof === typeof value) {
          return childProxy.value;
        }
        childProxies.splice(childProxies.indexOf(childProxy), 1);
      }
      const proxifyChildValue = (prop2) => {
        const value2 = target[prop2];
        const childProxy2 = childProxies.find((child) => child.prop === prop2);
        if (childProxy2) {
          if (childProxy2.typeof === typeof value2) {
            return childProxy2.value;
          }
          childProxies.splice(childProxies.indexOf(childProxy2), 1);
        }
        if (typeof value2 !== "object") {
          return value2;
        }
        const newChildProxy = createProxy({ root: context.root, target: context.target.concat(prop2), id: context.id, flag: context.flag });
        childProxies.push({ typeof: typeof value2, prop: prop2, value: newChildProxy });
        return newChildProxy;
      };
      const unproxyValue = (value2) => {
        return value2 !== null && typeof value2 === "object" && value2[isProxy] ? value2.getTarget() : value2;
      };
      if (["string", "number", "boolean"].includes(typeof value) || value instanceof Date || value instanceof PathReference || value instanceof ArrayBuffer || typeof value === "object" && "buffer" in value) {
        return value;
      }
      const isArray2 = target instanceof Array;
      if (prop === "toString") {
        return function toString3() {
          return `[LiveDataProxy for "${targetRef.path}"]`;
        };
      }
      if (typeof value === "undefined") {
        if (prop === "push") {
          return function push(item) {
            const childRef = targetRef.push();
            context.flag("write", context.target.concat(childRef.key));
            target[childRef.key] = item;
            return childRef.key;
          };
        }
        if (prop === "getTarget") {
          return function(warn = true) {
            warn && console.warn("Use getTarget with caution - any changes will not be synchronized!");
            return target;
          };
        }
        if (prop === "getRef") {
          return function getRef() {
            const ref = getTargetRef(context.root.ref, context.target);
            return ref;
          };
        }
        if (prop === "forEach") {
          return function forEach2(callback) {
            const keys = Object.keys(target);
            let stop = false;
            for (let i = 0; !stop && i < keys.length; i++) {
              const key = keys[i];
              const value2 = proxifyChildValue(key);
              stop = callback(value2, key, i) === false;
            }
          };
        }
        if (["values", "entries", "keys"].includes(prop)) {
          return function* generator() {
            const keys = Object.keys(target);
            for (const key of keys) {
              if (prop === "keys") {
                yield key;
              } else {
                const value2 = proxifyChildValue(key);
                if (prop === "entries") {
                  yield [key, value2];
                } else {
                  yield value2;
                }
              }
            }
          };
        }
        if (prop === "toArray") {
          return function toArray2(sortFn) {
            const arr = Object.keys(target).map((key) => proxifyChildValue(key));
            if (sortFn) {
              arr.sort(sortFn);
            }
            return arr;
          };
        }
        if (prop === "onChanged") {
          return function onChanged(callback) {
            return context.flag("onChange", context.target, { callback });
          };
        }
        if (prop === "subscribe") {
          return function subscribe() {
            return context.flag("subscribe", context.target);
          };
        }
        if (prop === "getObservable") {
          return function getObservable2() {
            return context.flag("observe", context.target);
          };
        }
        if (prop === "getOrderedCollection") {
          return function getOrderedCollection(orderProperty, orderIncrement) {
            return new OrderedCollectionProxy(this, orderProperty, orderIncrement);
          };
        }
        if (prop === "startTransaction") {
          return function startTransaction() {
            return context.flag("transaction", context.target);
          };
        }
        if (prop === "remove" && !isArray2) {
          return function remove() {
            if (context.target.length === 0) {
              throw new Error("Can't remove proxy root value");
            }
            const parent = getTargetValue(context.root.cache, context.target.slice(0, -1));
            const key = context.target.slice(-1)[0];
            context.flag("write", context.target);
            delete parent[key];
          };
        }
        return;
      } else if (typeof value === "function") {
        if (isArray2) {
          const writeArray = (action) => {
            context.flag("write", context.target);
            return action();
          };
          const cleanArrayValues = (values) => values.map((value2) => {
            value2 = unproxyValue(value2);
            removeVoidProperties(value2);
            return value2;
          });
          if (prop === "push") {
            return function push(...items) {
              items = cleanArrayValues(items);
              return writeArray(() => target.push(...items));
            };
          }
          if (prop === "pop") {
            return function pop() {
              return writeArray(() => target.pop());
            };
          }
          if (prop === "splice") {
            return function splice(start, deleteCount, ...items) {
              items = cleanArrayValues(items);
              return writeArray(() => target.splice(start, deleteCount, ...items));
            };
          }
          if (prop === "shift") {
            return function shift() {
              return writeArray(() => target.shift());
            };
          }
          if (prop === "unshift") {
            return function unshift(...items) {
              items = cleanArrayValues(items);
              return writeArray(() => target.unshift(...items));
            };
          }
          if (prop === "sort") {
            return function sort(compareFn) {
              return writeArray(() => target.sort(compareFn));
            };
          }
          if (prop === "reverse") {
            return function reverse() {
              return writeArray(() => target.reverse());
            };
          }
          if (["indexOf", "lastIndexOf"].includes(prop)) {
            return function indexOf(item, start) {
              if (item !== null && typeof item === "object" && item[isProxy]) {
                item = item.getTarget(false);
              }
              return target[prop](item, start);
            };
          }
          if (["forEach", "every", "some", "filter", "map"].includes(prop)) {
            return function iterate(callback) {
              return target[prop]((value2, i) => {
                return callback(proxifyChildValue(i), i, proxy);
              });
            };
          }
          if (["reduce", "reduceRight"].includes(prop)) {
            return function reduce(callback, initialValue) {
              return target[prop]((prev, value2, i) => {
                return callback(prev, proxifyChildValue(i), i, proxy);
              }, initialValue);
            };
          }
          if (["find", "findIndex"].includes(prop)) {
            return function find(callback) {
              let value2 = target[prop]((value3, i) => {
                return callback(proxifyChildValue(i), i, proxy);
              });
              if (prop === "find" && value2) {
                const index = target.indexOf(value2);
                value2 = proxifyChildValue(index);
              }
              return value2;
            };
          }
          if (["values", "entries", "keys"].includes(prop)) {
            return function* generator() {
              for (let i = 0; i < target.length; i++) {
                if (prop === "keys") {
                  yield i;
                } else {
                  const value2 = proxifyChildValue(i);
                  if (prop === "entries") {
                    yield [i, value2];
                  } else {
                    yield value2;
                  }
                }
              }
            };
          }
        }
        return value;
      }
      return proxifyChildValue(prop);
    },
    set(target, prop, value, receiver) {
      target = getTargetValue(context.root.cache, context.target);
      if (typeof prop === "symbol") {
        return Reflect.set(target, prop, value, receiver);
      }
      if (target === null || typeof target !== "object") {
        throw new Error(`Cannot set property "${prop}" of ${target}. Value of path "/${targetRef.path}" is not an object`);
      }
      if (target instanceof Array && typeof prop === "string") {
        if (!/^[0-9]+$/.test(prop)) {
          throw new Error(`Cannot set property "${prop}" on array value of path "/${targetRef.path}"`);
        }
        prop = parseInt(prop);
      }
      if (value !== null) {
        if (typeof value === "object") {
          if (value[isProxy]) {
            value = value.valueOf();
          }
          value = cloneObject(value);
        }
        if (valuesAreEqual(value, target[prop])) {
          return true;
        }
      }
      if (context.target.some((key) => typeof key === "number")) {
        context.flag("write", context.target.slice(0, context.target.findIndex((key) => typeof key === "number")));
      } else if (target instanceof Array) {
        context.flag("write", context.target);
      } else {
        context.flag("write", context.target.concat(prop));
      }
      if (value === null) {
        delete target[prop];
      } else {
        removeVoidProperties(value);
        target[prop] = value;
      }
      return true;
    },
    deleteProperty(target, prop) {
      target = getTargetValue(context.root.cache, context.target);
      if (target === null) {
        throw new Error(`Cannot delete property ${prop.toString()} of null`);
      }
      if (typeof prop === "symbol") {
        return Reflect.deleteProperty(target, prop);
      }
      if (!(prop in target)) {
        return true;
      }
      context.flag("write", context.target.concat(prop));
      delete target[prop];
      return true;
    },
    ownKeys(target) {
      target = getTargetValue(context.root.cache, context.target);
      return Reflect.ownKeys(target);
    },
    has(target, prop) {
      target = getTargetValue(context.root.cache, context.target);
      return Reflect.has(target, prop);
    },
    getOwnPropertyDescriptor(target, prop) {
      target = getTargetValue(context.root.cache, context.target);
      const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
      if (descriptor) {
        descriptor.configurable = true;
      }
      return descriptor;
    },
    getPrototypeOf(target) {
      target = getTargetValue(context.root.cache, context.target);
      return Reflect.getPrototypeOf(target);
    }
  };
  const proxy = new Proxy({}, handler);
  return proxy;
}
function removeVoidProperties(obj) {
  if (typeof obj !== "object") {
    return;
  }
  Object.keys(obj).forEach((key) => {
    const val = obj[key];
    if (val === null || typeof val === "undefined") {
      delete obj[key];
    } else if (typeof val === "object") {
      removeVoidProperties(val);
    }
  });
}
function proxyAccess(proxiedValue) {
  if (typeof proxiedValue !== "object" || !proxiedValue[isProxy]) {
    throw new Error("Given value is not proxied. Make sure you are referencing the value through the live data proxy.");
  }
  return proxiedValue;
}
var OrderedCollectionProxy = class {
  constructor(collection, orderProperty = "order", orderIncrement = 10) {
    this.collection = collection;
    this.orderProperty = orderProperty;
    this.orderIncrement = orderIncrement;
    if (typeof collection !== "object" || !collection[isProxy]) {
      throw new Error("Collection is not proxied");
    }
    if (collection.valueOf() instanceof Array) {
      throw new Error("Collection is an array, not an object collection");
    }
    if (!Object.keys(collection).every((key) => typeof collection[key] === "object")) {
      throw new Error("Collection has non-object children");
    }
    const ok = Object.keys(collection).every((key) => typeof collection[key][orderProperty] === "number");
    if (!ok) {
      const keys = Object.keys(collection);
      for (let i = 0; i < keys.length; i++) {
        const item = collection[keys[i]];
        item[orderProperty] = i * orderIncrement;
      }
    }
  }
  getObservable() {
    return proxyAccess(this.collection).getObservable();
  }
  getArrayObservable() {
    const Observable = getObservable();
    return new Observable((subscriber) => {
      const subscription = this.getObservable().subscribe(() => {
        const newArray = this.getArray();
        subscriber.next(newArray);
      });
      return function unsubscribe() {
        subscription.unsubscribe();
      };
    });
  }
  getArray() {
    const arr = proxyAccess(this.collection).toArray((a, b) => a[this.orderProperty] - b[this.orderProperty]);
    return arr;
  }
  add(item, index, from) {
    const arr = this.getArray();
    let minOrder = Number.POSITIVE_INFINITY, maxOrder = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < arr.length; i++) {
      const order = arr[i][this.orderProperty];
      minOrder = Math.min(order, minOrder);
      maxOrder = Math.max(order, maxOrder);
    }
    let fromKey;
    if (typeof from === "number") {
      fromKey = Object.keys(this.collection).find((key2) => this.collection[key2] === item);
      if (!fromKey) {
        throw new Error("item not found in collection");
      }
      if (from === index) {
        return { key: fromKey, index };
      }
      if (Math.abs(from - index) === 1) {
        const otherItem = arr[index];
        const otherOrder = otherItem[this.orderProperty];
        otherItem[this.orderProperty] = item[this.orderProperty];
        item[this.orderProperty] = otherOrder;
        return { key: fromKey, index };
      } else {
        arr.splice(from, 1);
      }
    }
    if (typeof index !== "number" || index >= arr.length) {
      index = arr.length;
      item[this.orderProperty] = arr.length == 0 ? 0 : maxOrder + this.orderIncrement;
    } else if (index === 0) {
      item[this.orderProperty] = arr.length == 0 ? 0 : minOrder - this.orderIncrement;
    } else {
      const orders = arr.map((item2) => item2[this.orderProperty]);
      const gap = orders[index] - orders[index - 1];
      if (gap > 1) {
        item[this.orderProperty] = orders[index] - Math.floor(gap / 2);
      } else {
        arr.splice(index, 0, item);
        for (let i = 0; i < arr.length; i++) {
          arr[i][this.orderProperty] = i * this.orderIncrement;
        }
      }
    }
    const key = typeof fromKey === "string" ? fromKey : proxyAccess(this.collection).push(item);
    return { key, index };
  }
  delete(index) {
    const arr = this.getArray();
    const item = arr[index];
    if (!item) {
      throw new Error(`Item at index ${index} not found`);
    }
    const key = Object.keys(this.collection).find((key2) => this.collection[key2] === item);
    if (!key) {
      throw new Error("Cannot find target object to delete");
    }
    this.collection[key] = null;
    return { key, index };
  }
  move(fromIndex, toIndex) {
    const arr = this.getArray();
    return this.add(arr[fromIndex], toIndex, fromIndex);
  }
  sort(sortFn) {
    const arr = this.getArray();
    arr.sort(sortFn);
    for (let i = 0; i < arr.length; i++) {
      arr[i][this.orderProperty] = i * this.orderIncrement;
    }
  }
};

// node_modules/acebase-core/dist/esm/data-reference.js
var DataRetrievalOptions = class {
  constructor(options) {
    if (!options) {
      options = {};
    }
    if (typeof options.include !== "undefined" && !(options.include instanceof Array)) {
      throw new TypeError("options.include must be an array");
    }
    if (typeof options.exclude !== "undefined" && !(options.exclude instanceof Array)) {
      throw new TypeError("options.exclude must be an array");
    }
    if (typeof options.child_objects !== "undefined" && typeof options.child_objects !== "boolean") {
      throw new TypeError("options.child_objects must be a boolean");
    }
    if (typeof options.cache_mode === "string" && !["allow", "bypass", "force"].includes(options.cache_mode)) {
      throw new TypeError("invalid value for options.cache_mode");
    }
    this.include = options.include || void 0;
    this.exclude = options.exclude || void 0;
    this.child_objects = typeof options.child_objects === "boolean" ? options.child_objects : void 0;
    this.cache_mode = typeof options.cache_mode === "string" ? options.cache_mode : typeof options.allow_cache === "boolean" ? options.allow_cache ? "allow" : "bypass" : "allow";
    this.cache_cursor = typeof options.cache_cursor === "string" ? options.cache_cursor : void 0;
  }
};
var QueryDataRetrievalOptions = class extends DataRetrievalOptions {
  constructor(options) {
    super(options);
    if (!["undefined", "boolean"].includes(typeof options.snapshots)) {
      throw new TypeError("options.snapshots must be a boolean");
    }
    this.snapshots = typeof options.snapshots === "boolean" ? options.snapshots : true;
  }
};
var _private = Symbol("private");
var DataReference = class {
  constructor(db, path3, vars) {
    this.db = db;
    if (!path3) {
      path3 = "";
    }
    path3 = path3.replace(/^\/|\/$/g, "");
    const pathInfo = PathInfo.get(path3);
    const key = pathInfo.key;
    const callbacks = [];
    this[_private] = {
      get path() {
        return path3;
      },
      get key() {
        return key;
      },
      get callbacks() {
        return callbacks;
      },
      vars: vars || {},
      context: {},
      pushed: false,
      cursor: null
    };
  }
  context(context, merge2 = false) {
    const currentContext = this[_private].context;
    if (typeof context === "object") {
      const newContext = context ? merge2 ? currentContext || {} : context : {};
      if (context) {
        Object.keys(context).forEach((key) => {
          newContext[key] = context[key];
        });
      }
      this[_private].context = newContext;
      return this;
    } else if (typeof context === "undefined") {
      console.warn("Use snap.context() instead of snap.ref.context() to get updating context in event callbacks");
      return currentContext;
    } else {
      throw new Error("Invalid context argument");
    }
  }
  get cursor() {
    return this[_private].cursor;
  }
  set cursor(value) {
    this[_private].cursor = value;
    this.onCursor?.(value);
  }
  get path() {
    return this[_private].path;
  }
  get key() {
    const key = this[_private].key;
    return typeof key === "number" ? `[${key}]` : key;
  }
  get index() {
    const key = this[_private].key;
    if (typeof key !== "number") {
      throw new Error(`"${key}" is not a number`);
    }
    return key;
  }
  get parent() {
    const currentPath = PathInfo.fillVariables2(this.path, this.vars);
    const info = PathInfo.get(currentPath);
    if (info.parentPath === null) {
      return null;
    }
    return new DataReference(this.db, info.parentPath).context(this[_private].context);
  }
  get vars() {
    return this[_private].vars;
  }
  child(childPath) {
    childPath = typeof childPath === "number" ? childPath : childPath.replace(/^\/|\/$/g, "");
    const currentPath = PathInfo.fillVariables2(this.path, this.vars);
    const targetPath = PathInfo.getChildPath(currentPath, childPath);
    return new DataReference(this.db, targetPath).context(this[_private].context);
  }
  async set(value, onComplete) {
    try {
      if (this.isWildcardPath) {
        throw new Error(`Cannot set the value of wildcard path "/${this.path}"`);
      }
      if (this.parent === null) {
        throw new Error("Cannot set the root object. Use update, or set individual child properties");
      }
      if (typeof value === "undefined") {
        throw new TypeError(`Cannot store undefined value in "/${this.path}"`);
      }
      if (!this.db.isReady) {
        await this.db.ready();
      }
      value = this.db.types.serialize(this.path, value);
      const { cursor } = await this.db.api.set(this.path, value, { context: this[_private].context });
      this.cursor = cursor;
      if (typeof onComplete === "function") {
        try {
          onComplete(null, this);
        } catch (err) {
          console.error("Error in onComplete callback:", err);
        }
      }
    } catch (err) {
      if (typeof onComplete === "function") {
        try {
          onComplete(err, this);
        } catch (err2) {
          console.error("Error in onComplete callback:", err2);
        }
      } else {
        throw err;
      }
    }
    return this;
  }
  async update(updates, onComplete) {
    try {
      if (this.isWildcardPath) {
        throw new Error(`Cannot update the value of wildcard path "/${this.path}"`);
      }
      if (!this.db.isReady) {
        await this.db.ready();
      }
      if (typeof updates !== "object" || updates instanceof Array || updates instanceof ArrayBuffer || updates instanceof Date) {
        await this.set(updates);
      } else if (Object.keys(updates).length === 0) {
        console.warn(`update called on path "/${this.path}", but there is nothing to update`);
      } else {
        updates = this.db.types.serialize(this.path, updates);
        const { cursor } = await this.db.api.update(this.path, updates, { context: this[_private].context });
        this.cursor = cursor;
      }
      if (typeof onComplete === "function") {
        try {
          onComplete(null, this);
        } catch (err) {
          console.error("Error in onComplete callback:", err);
        }
      }
    } catch (err) {
      if (typeof onComplete === "function") {
        try {
          onComplete(err, this);
        } catch (err2) {
          console.error("Error in onComplete callback:", err2);
        }
      } else {
        throw err;
      }
    }
    return this;
  }
  async transaction(callback) {
    if (this.isWildcardPath) {
      throw new Error(`Cannot start a transaction on wildcard path "/${this.path}"`);
    }
    if (!this.db.isReady) {
      await this.db.ready();
    }
    let throwError;
    const cb = (currentValue) => {
      currentValue = this.db.types.deserialize(this.path, currentValue);
      const snap = new DataSnapshot(this, currentValue);
      let newValue;
      try {
        newValue = callback(snap);
      } catch (err) {
        throwError = err;
        return;
      }
      if (newValue instanceof Promise) {
        return newValue.then((val) => {
          return this.db.types.serialize(this.path, val);
        }).catch((err) => {
          throwError = err;
          return;
        });
      } else {
        return this.db.types.serialize(this.path, newValue);
      }
    };
    const { cursor } = await this.db.api.transaction(this.path, cb, { context: this[_private].context });
    this.cursor = cursor;
    if (throwError) {
      throw throwError;
    }
    return this;
  }
  on(event, callback, cancelCallback) {
    if (this.path === "" && ["value", "child_changed"].includes(event)) {
      console.warn("WARNING: Listening for value and child_changed events on the root node is a bad practice. These events require loading of all data (value event), or potentially lots of data (child_changed event) each time they are fired");
    }
    let eventPublisher = null;
    const eventStream = new EventStream((publisher) => {
      eventPublisher = publisher;
    });
    const cb = {
      event,
      stream: eventStream,
      userCallback: typeof callback === "function" && callback,
      ourCallback: (err, path3, newValue, oldValue, eventContext) => {
        if (err) {
          this.db.debug.error(`Error getting data for event ${event} on path "${path3}"`, err);
          return;
        }
        const ref = this.db.ref(path3);
        ref[_private].vars = PathInfo.extractVariables(this.path, path3);
        let callbackObject;
        if (event.startsWith("notify_")) {
          callbackObject = ref.context(eventContext || {});
        } else {
          const values = {
            previous: this.db.types.deserialize(path3, oldValue),
            current: this.db.types.deserialize(path3, newValue)
          };
          if (event === "child_removed") {
            callbackObject = new DataSnapshot(ref, values.previous, true, values.previous, eventContext);
          } else if (event === "mutations") {
            callbackObject = new MutationsDataSnapshot(ref, values.current, eventContext);
          } else {
            const isRemoved = event === "mutated" && values.current === null;
            callbackObject = new DataSnapshot(ref, values.current, isRemoved, values.previous, eventContext);
          }
        }
        eventPublisher.publish(callbackObject);
        if (eventContext?.acebase_cursor) {
          this.cursor = eventContext.acebase_cursor;
        }
      }
    };
    this[_private].callbacks.push(cb);
    const subscribe = () => {
      if (typeof callback === "function") {
        eventStream.subscribe(callback, (activated, cancelReason) => {
          if (!activated) {
            cancelCallback && cancelCallback(cancelReason);
          }
        });
      }
      const advancedOptions = typeof callback === "object" ? callback : { newOnly: !callback };
      if (typeof advancedOptions.newOnly !== "boolean") {
        advancedOptions.newOnly = false;
      }
      if (this.isWildcardPath) {
        advancedOptions.newOnly = true;
      }
      const cancelSubscription = (err) => {
        const callbacks = this[_private].callbacks;
        callbacks.splice(callbacks.indexOf(cb), 1);
        this.db.api.unsubscribe(this.path, event, cb.ourCallback);
        this.db.debug.error(`Subscription "${event}" on path "/${this.path}" canceled because of an error: ${err.message}`);
        eventPublisher.cancel(err.message);
      };
      const authorized = this.db.api.subscribe(this.path, event, cb.ourCallback, { newOnly: advancedOptions.newOnly, cancelCallback: cancelSubscription, syncFallback: advancedOptions.syncFallback });
      const allSubscriptionsStoppedCallback = () => {
        const callbacks = this[_private].callbacks;
        callbacks.splice(callbacks.indexOf(cb), 1);
        return this.db.api.unsubscribe(this.path, event, cb.ourCallback);
      };
      if (authorized instanceof Promise) {
        authorized.then(() => {
          eventPublisher.start(allSubscriptionsStoppedCallback);
        }).catch(cancelSubscription);
      } else {
        eventPublisher.start(allSubscriptionsStoppedCallback);
      }
      if (!advancedOptions.newOnly) {
        if (event === "value") {
          this.get((snap) => {
            eventPublisher.publish(snap);
          });
        } else if (event === "child_added") {
          this.get((snap) => {
            const val = snap.val();
            if (val === null || typeof val !== "object") {
              return;
            }
            Object.keys(val).forEach((key) => {
              const childSnap = new DataSnapshot(this.child(key), val[key]);
              eventPublisher.publish(childSnap);
            });
          });
        } else if (event === "notify_child_added") {
          const step = 100, limit = step;
          let skip = 0;
          const more = async () => {
            const children = await this.db.api.reflect(this.path, "children", { limit, skip });
            children.list.forEach((child) => {
              const childRef = this.child(child.key);
              eventPublisher.publish(childRef);
            });
            if (children.more) {
              skip += step;
              more();
            }
          };
          more();
        }
      }
    };
    if (this.db.isReady) {
      subscribe();
    } else {
      this.db.ready(subscribe);
    }
    return eventStream;
  }
  off(event, callback) {
    const subscriptions = this[_private].callbacks;
    const stopSubs = subscriptions.filter((sub) => (!event || sub.event === event) && (!callback || sub.userCallback === callback));
    if (stopSubs.length === 0) {
      this.db.debug.warn(`Can't find event subscriptions to stop (path: "${this.path}", event: ${event || "(any)"}, callback: ${callback})`);
    }
    stopSubs.forEach((sub) => {
      sub.stream.stop();
    });
    return this;
  }
  get(optionsOrCallback, callback) {
    if (!this.db.isReady) {
      const promise2 = this.db.ready().then(() => this.get(optionsOrCallback, callback));
      return typeof optionsOrCallback !== "function" && typeof callback !== "function" ? promise2 : void 0;
    }
    callback = typeof optionsOrCallback === "function" ? optionsOrCallback : typeof callback === "function" ? callback : void 0;
    if (this.isWildcardPath) {
      const error = new Error(`Cannot get value of wildcard path "/${this.path}". Use .query() instead`);
      if (typeof callback === "function") {
        throw error;
      }
      return Promise.reject(error);
    }
    const options = new DataRetrievalOptions(typeof optionsOrCallback === "object" ? optionsOrCallback : { cache_mode: "allow" });
    const promise = this.db.api.get(this.path, options).then((result) => {
      const isNewApiResult = "context" in result && "value" in result;
      if (!isNewApiResult) {
        console.warn("AceBase api.get method returned an old response value. Update your acebase or acebase-client package");
        result = { value: result, context: {} };
      }
      const value = this.db.types.deserialize(this.path, result.value);
      const snapshot = new DataSnapshot(this, value, void 0, void 0, result.context);
      if (result.context?.acebase_cursor) {
        this.cursor = result.context.acebase_cursor;
      }
      return snapshot;
    });
    if (callback) {
      promise.then(callback).catch((err) => {
        console.error("Uncaught error:", err);
      });
      return;
    } else {
      return promise;
    }
  }
  once(event, options) {
    if (event === "value" && !this.isWildcardPath) {
      return this.get(options);
    }
    return new Promise((resolve) => {
      const callback = (snap) => {
        this.off(event, callback);
        resolve(snap);
      };
      this.on(event, callback);
    });
  }
  push(value, onComplete) {
    if (this.isWildcardPath) {
      const error = new Error(`Cannot push to wildcard path "/${this.path}"`);
      if (typeof value === "undefined" || typeof onComplete === "function") {
        throw error;
      }
      return Promise.reject(error);
    }
    const id = ID.generate();
    const ref = this.child(id);
    ref[_private].pushed = true;
    if (typeof value !== "undefined") {
      return ref.set(value, onComplete).then(() => ref);
    } else {
      return ref;
    }
  }
  async remove() {
    if (this.isWildcardPath) {
      throw new Error(`Cannot remove wildcard path "/${this.path}". Use query().remove instead`);
    }
    if (this.parent === null) {
      throw new Error("Cannot remove the root node");
    }
    return this.set(null);
  }
  async exists() {
    if (this.isWildcardPath) {
      throw new Error(`Cannot check wildcard path "/${this.path}" existence`);
    }
    if (!this.db.isReady) {
      await this.db.ready();
    }
    return this.db.api.exists(this.path);
  }
  get isWildcardPath() {
    return this.path.indexOf("*") >= 0 || this.path.indexOf("$") >= 0;
  }
  query() {
    return new DataReferenceQuery(this);
  }
  async count() {
    const info = await this.reflect("info", { child_count: true });
    return info.children.count;
  }
  async reflect(type, args) {
    if (this.isWildcardPath) {
      throw new Error(`Cannot reflect on wildcard path "/${this.path}"`);
    }
    if (!this.db.isReady) {
      await this.db.ready();
    }
    return this.db.api.reflect(this.path, type, args);
  }
  async export(write2, options = { format: "json", type_safe: true }) {
    if (this.isWildcardPath) {
      throw new Error(`Cannot export wildcard path "/${this.path}"`);
    }
    if (!this.db.isReady) {
      await this.db.ready();
    }
    const writeFn = typeof write2 === "function" ? write2 : write2.write.bind(write2);
    return this.db.api.export(this.path, writeFn, options);
  }
  async import(read2, options = { format: "json", suppress_events: false }) {
    if (this.isWildcardPath) {
      throw new Error(`Cannot import to wildcard path "/${this.path}"`);
    }
    if (!this.db.isReady) {
      await this.db.ready();
    }
    return this.db.api.import(this.path, read2, options);
  }
  proxy(options) {
    const isOptionsArg = typeof options === "object" && (typeof options.cursor !== "undefined" || typeof options.defaultValue !== "undefined");
    if (typeof options !== "undefined" && !isOptionsArg) {
      this.db.debug.warn("Warning: live data proxy is being initialized with a deprecated method signature. Use ref.proxy(options) instead of ref.proxy(defaultValue)");
      options = { defaultValue: options };
    }
    return LiveDataProxy.create(this, options);
  }
  observe(options) {
    if (options) {
      throw new Error("observe does not support data retrieval options yet");
    }
    if (this.isWildcardPath) {
      throw new Error(`Cannot observe wildcard path "/${this.path}"`);
    }
    const Observable = getObservable();
    return new Observable((observer) => {
      let cache, resolved = false;
      let promise = this.get(options).then((snap) => {
        resolved = true;
        cache = snap.val();
        observer.next(cache);
      });
      const updateCache = (snap) => {
        if (!resolved) {
          promise = promise.then(() => updateCache(snap));
          return;
        }
        const mutatedPath = snap.ref.path;
        if (mutatedPath === this.path) {
          cache = snap.val();
          return observer.next(cache);
        }
        const trailKeys = PathInfo.getPathKeys(mutatedPath).slice(PathInfo.getPathKeys(this.path).length);
        let target = cache;
        while (trailKeys.length > 1) {
          const key = trailKeys.shift();
          if (!(key in target)) {
            target[key] = typeof trailKeys[0] === "number" ? [] : {};
          }
          target = target[key];
        }
        const prop = trailKeys.shift();
        const newValue = snap.val();
        if (newValue === null) {
          target instanceof Array && typeof prop === "number" ? target.splice(prop, 1) : delete target[prop];
        } else {
          target[prop] = newValue;
        }
        observer.next(cache);
      };
      this.on("mutated", updateCache);
      return () => {
        this.off("mutated", updateCache);
      };
    });
  }
  async forEach(callbackOrOptions, callback) {
    let options;
    if (typeof callbackOrOptions === "function") {
      callback = callbackOrOptions;
    } else {
      options = callbackOrOptions;
    }
    if (typeof callback !== "function") {
      throw new TypeError("No callback function given");
    }
    const info = await this.reflect("children", { limit: 0, skip: 0 });
    const summary = {
      canceled: false,
      total: info.list.length,
      processed: 0
    };
    for (let i = 0; i < info.list.length; i++) {
      const key = info.list[i].key;
      const snapshot = await this.child(key).get(options);
      summary.processed++;
      if (!snapshot.exists()) {
        continue;
      }
      const result = await callback(snapshot);
      if (result === false) {
        summary.canceled = true;
        break;
      }
    }
    return summary;
  }
  async getMutations(cursorOrDate) {
    const cursor = typeof cursorOrDate === "string" ? cursorOrDate : void 0;
    const timestamp = cursorOrDate === null || typeof cursorOrDate === "undefined" ? 0 : cursorOrDate instanceof Date ? cursorOrDate.getTime() : void 0;
    return this.db.api.getMutations({ path: this.path, cursor, timestamp });
  }
  async getChanges(cursorOrDate) {
    const cursor = typeof cursorOrDate === "string" ? cursorOrDate : void 0;
    const timestamp = cursorOrDate === null || typeof cursorOrDate === "undefined" ? 0 : cursorOrDate instanceof Date ? cursorOrDate.getTime() : void 0;
    return this.db.api.getChanges({ path: this.path, cursor, timestamp });
  }
};
var DataReferenceQuery = class {
  constructor(ref) {
    this.ref = ref;
    this[_private] = {
      filters: [],
      skip: 0,
      take: 0,
      order: [],
      events: {}
    };
  }
  filter(key, op, compare) {
    if ((op === "in" || op === "!in") && (!(compare instanceof Array) || compare.length === 0)) {
      throw new Error(`${op} filter for ${key} must supply an Array compare argument containing at least 1 value`);
    }
    if ((op === "between" || op === "!between") && (!(compare instanceof Array) || compare.length !== 2)) {
      throw new Error(`${op} filter for ${key} must supply an Array compare argument containing 2 values`);
    }
    if ((op === "matches" || op === "!matches") && !(compare instanceof RegExp)) {
      throw new Error(`${op} filter for ${key} must supply a RegExp compare argument`);
    }
    this[_private].filters.push({ key, op, compare });
    return this;
  }
  where(key, op, compare) {
    return this.filter(key, op, compare);
  }
  take(n) {
    this[_private].take = n;
    return this;
  }
  skip(n) {
    this[_private].skip = n;
    return this;
  }
  sort(key, ascending = true) {
    if (!["string", "number"].includes(typeof key)) {
      throw "key must be a string or number";
    }
    this[_private].order.push({ key, ascending });
    return this;
  }
  order(key, ascending = true) {
    return this.sort(key, ascending);
  }
  get(optionsOrCallback, callback) {
    if (!this.ref.db.isReady) {
      const promise = this.ref.db.ready().then(() => this.get(optionsOrCallback, callback));
      return typeof optionsOrCallback !== "function" && typeof callback !== "function" ? promise : void 0;
    }
    callback = typeof optionsOrCallback === "function" ? optionsOrCallback : typeof callback === "function" ? callback : void 0;
    const options = new QueryDataRetrievalOptions(typeof optionsOrCallback === "object" ? optionsOrCallback : { snapshots: true, cache_mode: "allow" });
    options.allow_cache = options.cache_mode !== "bypass";
    options.eventHandler = (ev) => {
      if (!this[_private].events[ev.name]) {
        return false;
      }
      const listeners = this[_private].events[ev.name];
      if (typeof listeners !== "object" || listeners.length === 0) {
        return false;
      }
      if (["add", "change", "remove"].includes(ev.name)) {
        const eventData = {
          name: ev.name,
          ref: new DataReference(this.ref.db, ev.path)
        };
        if (options.snapshots && ev.name !== "remove") {
          const val = db.types.deserialize(ev.path, ev.value);
          eventData.snapshot = new DataSnapshot(eventData.ref, val, false);
        }
        ev = eventData;
      }
      listeners.forEach((callback2) => {
        try {
          callback2(ev);
        } catch (err) {
          this.ref.db.debug.error(`Error executing "${ev.name}" event handler of realtime query on path "${this.ref.path}": ${err?.stack ?? err?.message ?? err}`);
        }
      });
    };
    options.monitor = { add: false, change: false, remove: false };
    if (this[_private].events) {
      if (this[_private].events["add"] && this[_private].events["add"].length > 0) {
        options.monitor.add = true;
      }
      if (this[_private].events["change"] && this[_private].events["change"].length > 0) {
        options.monitor.change = true;
      }
      if (this[_private].events["remove"] && this[_private].events["remove"].length > 0) {
        options.monitor.remove = true;
      }
    }
    this.stop();
    const db = this.ref.db;
    return db.api.query(this.ref.path, this[_private], options).catch((err) => {
      throw new Error(err);
    }).then((res) => {
      const { stop } = res;
      let { results, context } = res;
      this.stop = async () => {
        await stop();
      };
      if (!("results" in res && "context" in res)) {
        console.warn("Query results missing context. Update your acebase and/or acebase-client packages");
        results = res, context = {};
      }
      if (options.snapshots) {
        const snaps = results.map((result) => {
          const val = db.types.deserialize(result.path, result.val);
          return new DataSnapshot(db.ref(result.path), val, false, void 0, context);
        });
        return DataSnapshotsArray.from(snaps);
      } else {
        const refs = results.map((path3) => db.ref(path3));
        return DataReferencesArray.from(refs);
      }
    }).then((results) => {
      callback && callback(results);
      return results;
    });
  }
  async stop() {
  }
  getRefs(callback) {
    return this.get({ snapshots: false }, callback);
  }
  find() {
    return this.get({ snapshots: false });
  }
  async count() {
    const refs = await this.find();
    return refs.length;
  }
  async exists() {
    const originalTake = this[_private].take;
    const p = this.take(1).find();
    this.take(originalTake);
    const refs = await p;
    return refs.length !== 0;
  }
  async remove(callback) {
    const refs = await this.find();
    const parentUpdates = refs.reduce((parents, ref) => {
      const parent = parents[ref.parent.path];
      if (!parent) {
        parents[ref.parent.path] = [ref];
      } else {
        parent.push(ref);
      }
      return parents;
    }, {});
    const db = this.ref.db;
    const promises = Object.keys(parentUpdates).map(async (parentPath) => {
      const updates = refs.reduce((updates2, ref2) => {
        updates2[ref2.key] = null;
        return updates2;
      }, {});
      const ref = db.ref(parentPath);
      try {
        await ref.update(updates);
        return { ref, success: true };
      } catch (error) {
        return { ref, success: false, error };
      }
    });
    const results = await Promise.all(promises);
    callback && callback(results);
    return results;
  }
  on(event, callback) {
    if (!this[_private].events[event]) {
      this[_private].events[event] = [];
    }
    this[_private].events[event].push(callback);
    return this;
  }
  off(event, callback) {
    if (typeof event === "undefined") {
      this[_private].events = {};
      return this;
    }
    if (!this[_private].events[event]) {
      return this;
    }
    if (typeof callback === "undefined") {
      delete this[_private].events[event];
      return this;
    }
    const index = this[_private].events[event].indexOf(callback);
    if (!~index) {
      return this;
    }
    this[_private].events[event].splice(index, 1);
    return this;
  }
  async forEach(callbackOrOptions, callback) {
    let options;
    if (typeof callbackOrOptions === "function") {
      callback = callbackOrOptions;
    } else {
      options = callbackOrOptions;
    }
    if (typeof callback !== "function") {
      throw new TypeError("No callback function given");
    }
    const refs = await this.find();
    const summary = {
      canceled: false,
      total: refs.length,
      processed: 0
    };
    for (let i = 0; i < refs.length; i++) {
      const ref = refs[i];
      const snapshot = await ref.get(options);
      summary.processed++;
      if (!snapshot.exists()) {
        continue;
      }
      const result = await callback(snapshot);
      if (result === false) {
        summary.canceled = true;
        break;
      }
    }
    return summary;
  }
};
var DataSnapshotsArray = class extends Array {
  static from(snaps) {
    const arr = new DataSnapshotsArray(snaps.length);
    snaps.forEach((snap, i) => arr[i] = snap);
    return arr;
  }
  getValues() {
    return this.map((snap) => snap.val());
  }
};
var DataReferencesArray = class extends Array {
  static from(refs) {
    const arr = new DataReferencesArray(refs.length);
    refs.forEach((ref, i) => arr[i] = ref);
    return arr;
  }
  getPaths() {
    return this.map((ref) => ref.path);
  }
};

// node_modules/acebase-core/dist/esm/type-mappings.js
function get(mappings, path3) {
  path3 = path3.replace(/^\/|\/$/g, "");
  const keys = PathInfo.getPathKeys(path3);
  const mappedPath = Object.keys(mappings).find((mpath) => {
    const mkeys = PathInfo.getPathKeys(mpath);
    if (mkeys.length !== keys.length) {
      return false;
    }
    return mkeys.every((mkey, index) => {
      if (mkey === "*" || typeof mkey === "string" && mkey[0] === "$") {
        return true;
      }
      return mkey === keys[index];
    });
  });
  const mapping = mappings[mappedPath];
  return mapping;
}
function map(mappings, path3) {
  const targetPath = PathInfo.get(path3).parentPath;
  if (targetPath === null) {
    return;
  }
  return get(mappings, targetPath);
}
function mapDeep(mappings, entryPath) {
  entryPath = entryPath.replace(/^\/|\/$/g, "");
  const pathInfo = PathInfo.get(entryPath);
  const startPath = pathInfo.parentPath;
  const keys = startPath ? PathInfo.getPathKeys(startPath) : [];
  const matches = Object.keys(mappings).reduce((m, mpath) => {
    const mkeys = PathInfo.getPathKeys(mpath);
    if (mkeys.length < keys.length) {
      return m;
    }
    let isMatch = true;
    if (keys.length === 0 && startPath !== null) {
      isMatch = mkeys.length === 1 && (mkeys[0] === "*" || typeof mkeys[0] === "string" && mkeys[0][0] === "$");
    } else {
      mkeys.every((mkey, index) => {
        if (index >= keys.length) {
          return false;
        } else if (mkey === "*" || typeof mkey === "string" && mkey[0] === "$" || mkey === keys[index]) {
          return true;
        } else {
          isMatch = false;
          return false;
        }
      });
    }
    if (isMatch) {
      const mapping = mappings[mpath];
      m.push({ path: mpath, type: mapping });
    }
    return m;
  }, []);
  return matches;
}
function process8(db, mappings, path3, obj, action) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  const keys = PathInfo.getPathKeys(path3);
  const m = mapDeep(mappings, path3);
  const changes = [];
  m.sort((a, b) => PathInfo.getPathKeys(a.path).length > PathInfo.getPathKeys(b.path).length ? -1 : 1);
  m.forEach((mapping) => {
    const mkeys = PathInfo.getPathKeys(mapping.path);
    mkeys.push("*");
    const mTrailKeys = mkeys.slice(keys.length);
    if (mTrailKeys.length === 0) {
      const vars = PathInfo.extractVariables(mapping.path, path3);
      const ref = new DataReference(db, path3, vars);
      if (action === "serialize") {
        obj = mapping.type.serialize(obj, ref);
      } else if (action === "deserialize") {
        const snap = new DataSnapshot(ref, obj);
        obj = mapping.type.deserialize(snap);
      }
      return;
    }
    const process9 = (parentPath, parent, keys2) => {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const key = keys2[0];
      let children = [];
      if (key === "*" || typeof key === "string" && key[0] === "$") {
        if (parent instanceof Array) {
          children = parent.map((val, index) => ({ key: index, val }));
        } else {
          children = Object.keys(parent).map((k) => ({ key: k, val: parent[k] }));
        }
      } else {
        const child = parent[key];
        if (typeof child === "object") {
          children.push({ key, val: child });
        }
      }
      children.forEach((child) => {
        const childPath = PathInfo.getChildPath(parentPath, child.key);
        const vars = PathInfo.extractVariables(mapping.path, childPath);
        const ref = new DataReference(db, childPath, vars);
        if (keys2.length === 1) {
          if (action === "serialize") {
            changes.push({ parent, key: child.key, original: parent[child.key] });
            parent[child.key] = mapping.type.serialize(child.val, ref);
          } else if (action === "deserialize") {
            const snap = new DataSnapshot(ref, child.val);
            parent[child.key] = mapping.type.deserialize(snap);
          }
        } else {
          process9(childPath, child.val, keys2.slice(1));
        }
      });
    };
    process9(path3, obj, mTrailKeys);
  });
  if (action === "serialize") {
    obj = cloneObject(obj);
    if (changes.length > 0) {
      changes.forEach((change) => {
        change.parent[change.key] = change.original;
      });
    }
  }
  return obj;
}
var _mappings = Symbol("mappings");
var TypeMappings = class {
  constructor(db) {
    this.db = db;
    this[_mappings] = {};
  }
  get mappings() {
    return this[_mappings];
  }
  map(path3) {
    return map(this[_mappings], path3);
  }
  bind(path3, type, options = {}) {
    if (typeof path3 !== "string") {
      throw new TypeError("path must be a string");
    }
    if (typeof type !== "function") {
      throw new TypeError("constructor must be a function");
    }
    if (typeof options.serializer === "undefined") {
    } else if (typeof options.serializer === "string") {
      if (typeof type.prototype[options.serializer] === "function") {
        options.serializer = type.prototype[options.serializer];
      } else {
        throw new TypeError(`${type.name}.prototype.${options.serializer} is not a function, cannot use it as serializer`);
      }
    } else if (typeof options.serializer !== "function") {
      throw new TypeError(`serializer for class ${type.name} must be a function, or the name of a prototype method`);
    }
    if (typeof options.creator === "undefined") {
      if (typeof type.create === "function") {
        options.creator = type.create;
      }
    } else if (typeof options.creator === "string") {
      if (typeof type[options.creator] === "function") {
        options.creator = type[options.creator];
      } else {
        throw new TypeError(`${type.name}.${options.creator} is not a function, cannot use it as creator`);
      }
    } else if (typeof options.creator !== "function") {
      throw new TypeError(`creator for class ${type.name} must be a function, or the name of a static method`);
    }
    path3 = path3.replace(/^\/|\/$/g, "");
    this[_mappings][path3] = {
      db: this.db,
      type,
      creator: options.creator,
      serializer: options.serializer,
      deserialize(snap) {
        let obj;
        if (this.creator) {
          obj = this.creator.call(this.type, snap);
        } else {
          obj = new this.type(snap);
        }
        return obj;
      },
      serialize(obj, ref) {
        if (this.serializer) {
          obj = this.serializer.call(obj, ref, obj);
        } else if (obj && typeof obj.serialize === "function") {
          obj = obj.serialize(ref, obj);
        }
        return obj;
      }
    };
  }
  serialize(path3, obj) {
    return process8(this.db, this[_mappings], path3, obj, "serialize");
  }
  deserialize(path3, obj) {
    return process8(this.db, this[_mappings], path3, obj, "deserialize");
  }
};

// node_modules/acebase-core/dist/esm/debug.js
var noop = () => {
};
var DebugLogger = class {
  constructor(level = "log", prefix = "") {
    this.level = level;
    this.prefix = prefix;
    this.setLevel(level);
  }
  setLevel(level) {
    const prefix = this.prefix ? this.prefix + " %s" : "";
    this.verbose = ["verbose"].includes(level) ? prefix ? console.log.bind(console, prefix) : console.log.bind(console) : noop;
    this.log = ["verbose", "log"].includes(level) ? prefix ? console.log.bind(console, prefix) : console.log.bind(console) : noop;
    this.warn = ["verbose", "log", "warn"].includes(level) ? prefix ? console.warn.bind(console, prefix) : console.warn.bind(console) : noop;
    this.error = ["verbose", "log", "warn", "error"].includes(level) ? prefix ? console.error.bind(console, prefix) : console.error.bind(console) : noop;
    this.write = (text) => {
      const isRunKit = typeof process_default !== "undefined" && process_default.env && typeof process_default.env.RUNKIT_ENDPOINT_PATH === "string";
      if (text && isRunKit) {
        text.split("\n").forEach((line) => console.log(line));
      } else {
        console.log(text);
      }
    };
  }
};

// node_modules/acebase-core/dist/esm/simple-colors.js
var FontCode = {
  bold: 1,
  dim: 2,
  italic: 3,
  underline: 4,
  inverse: 7,
  hidden: 8,
  strikethrough: 94
};
var ColorCode = {
  black: 30,
  red: 31,
  green: 32,
  yellow: 33,
  blue: 34,
  magenta: 35,
  cyan: 36,
  white: 37,
  grey: 90,
  brightRed: 91
};
var BgColorCode = {
  bgBlack: 40,
  bgRed: 41,
  bgGreen: 42,
  bgYellow: 43,
  bgBlue: 44,
  bgMagenta: 45,
  bgCyan: 46,
  bgWhite: 47,
  bgGrey: 100,
  bgBrightRed: 101
};
var ResetCode = {
  all: 0,
  color: 39,
  background: 49,
  bold: 22,
  dim: 22,
  italic: 23,
  underline: 24,
  inverse: 27,
  hidden: 28,
  strikethrough: 29
};
var ColorStyle;
(function(ColorStyle2) {
  ColorStyle2["reset"] = "reset";
  ColorStyle2["bold"] = "bold";
  ColorStyle2["dim"] = "dim";
  ColorStyle2["italic"] = "italic";
  ColorStyle2["underline"] = "underline";
  ColorStyle2["inverse"] = "inverse";
  ColorStyle2["hidden"] = "hidden";
  ColorStyle2["strikethrough"] = "strikethrough";
  ColorStyle2["black"] = "black";
  ColorStyle2["red"] = "red";
  ColorStyle2["green"] = "green";
  ColorStyle2["yellow"] = "yellow";
  ColorStyle2["blue"] = "blue";
  ColorStyle2["magenta"] = "magenta";
  ColorStyle2["cyan"] = "cyan";
  ColorStyle2["grey"] = "grey";
  ColorStyle2["bgBlack"] = "bgBlack";
  ColorStyle2["bgRed"] = "bgRed";
  ColorStyle2["bgGreen"] = "bgGreen";
  ColorStyle2["bgYellow"] = "bgYellow";
  ColorStyle2["bgBlue"] = "bgBlue";
  ColorStyle2["bgMagenta"] = "bgMagenta";
  ColorStyle2["bgCyan"] = "bgCyan";
  ColorStyle2["bgWhite"] = "bgWhite";
  ColorStyle2["bgGrey"] = "bgGrey";
})(ColorStyle || (ColorStyle = {}));
function ColorsSupported() {
  if (typeof process_default === "undefined" || !process_default.stdout || !process_default.env || !process_default.platform || process_default.platform === "browser") {
    return false;
  }
  if (process_default.platform === "win32") {
    return true;
  }
  const env2 = process_default.env;
  if (env2.COLORTERM) {
    return true;
  }
  if (env2.TERM === "dumb") {
    return false;
  }
  if (env2.CI || env2.TEAMCITY_VERSION) {
    return !!env2.TRAVIS;
  }
  if (["iTerm.app", "HyperTerm", "Hyper", "MacTerm", "Apple_Terminal", "vscode"].includes(env2.TERM_PROGRAM)) {
    return true;
  }
  if (/^xterm-256|^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(env2.TERM)) {
    return true;
  }
  return false;
}
var _enabled = ColorsSupported();
function SetColorsEnabled(enabled) {
  _enabled = ColorsSupported() && enabled;
}
function Colorize(str, style) {
  if (!_enabled) {
    return str;
  }
  const openCodes = [], closeCodes = [];
  const addStyle = (style2) => {
    if (style2 === ColorStyle.reset) {
      openCodes.push(ResetCode.all);
    } else if (style2 in FontCode) {
      openCodes.push(FontCode[style2]);
      closeCodes.push(ResetCode[style2]);
    } else if (style2 in ColorCode) {
      openCodes.push(ColorCode[style2]);
      closeCodes.push(ResetCode.color);
    } else if (style2 in BgColorCode) {
      openCodes.push(BgColorCode[style2]);
      closeCodes.push(ResetCode.background);
    }
  };
  if (style instanceof Array) {
    style.forEach(addStyle);
  } else {
    addStyle(style);
  }
  const open2 = openCodes.map((code) => "\x1B[" + code + "m").join("");
  const close2 = closeCodes.map((code) => "\x1B[" + code + "m").join("");
  return str.split("\n").map((line) => open2 + line + close2).join("\n");
}
String.prototype.colorize = function(style) {
  return Colorize(this, style);
};

// node_modules/acebase-core/dist/esm/acebase-base.js
var AceBaseBaseSettings = class {
  constructor(options) {
    this.logLevel = "log";
    this.logColors = true;
    this.info = "realtime database";
    this.sponsor = false;
    if (typeof options !== "object") {
      options = {};
    }
    if (typeof options.logLevel === "string") {
      this.logLevel = options.logLevel;
    }
    if (typeof options.logColors === "boolean") {
      this.logColors = options.logColors;
    }
    if (typeof options.info === "string") {
      this.info = options.info;
    }
    if (typeof options.sponsor === "boolean") {
      this.sponsor = options.sponsor;
    }
  }
};
var AceBaseBase = class extends SimpleEventEmitter {
  constructor(dbname, options = {}) {
    super();
    this._ready = false;
    options = new AceBaseBaseSettings(options);
    this.name = dbname;
    this.debug = new DebugLogger(options.logLevel, `[${dbname}]`);
    SetColorsEnabled(options.logColors);
    const logoStyle = [ColorStyle.magenta, ColorStyle.bold];
    const logo = "     ___          ______                \n    / _ \\         | ___ \\               \n   / /_\\ \\ ___ ___| |_/ / __ _ ___  ___ \n   |  _  |/ __/ _ \\ ___ \\/ _` / __|/ _ \\\n   | | | | (_|  __/ |_/ / (_| \\__ \\  __/\n   \\_| |_/\\___\\___\\____/ \\__,_|___/\\___|";
    const info = options.info ? "".padStart(40 - options.info.length, " ") + options.info + "\n" : "";
    if (!options.sponsor) {
      this.debug.write(logo.colorize(logoStyle));
      info && this.debug.write(info.colorize(ColorStyle.magenta));
    }
    this.types = new TypeMappings(this);
    this.once("ready", () => {
      this._ready = true;
    });
  }
  async ready(callback) {
    if (!this._ready) {
      await new Promise((resolve) => this.on("ready", resolve));
    }
    callback?.();
  }
  get isReady() {
    return this._ready;
  }
  setObservable(ObservableImpl) {
    setObservable(ObservableImpl);
  }
  ref(path3) {
    return new DataReference(this, path3);
  }
  get root() {
    return this.ref("");
  }
  query(path3) {
    const ref = new DataReference(this, path3);
    return new DataReferenceQuery(ref);
  }
  get indexes() {
    return {
      get: () => {
        return this.api.getIndexes();
      },
      create: (path3, key, options) => {
        return this.api.createIndex(path3, key, options);
      },
      delete: async (filePath) => {
        return this.api.deleteIndex(filePath);
      }
    };
  }
  get schema() {
    return {
      get: (path3) => {
        return this.api.getSchema(path3);
      },
      set: (path3, schema, warnOnly = false) => {
        return this.api.setSchema(path3, schema, warnOnly);
      },
      all: () => {
        return this.api.getSchemas();
      },
      check: (path3, value, isUpdate) => {
        return this.api.validateSchema(path3, value, isUpdate);
      }
    };
  }
};

// node_modules/acebase-core/dist/esm/api.js
var NotImplementedError = class extends Error {
  constructor(name) {
    super(`${name} is not implemented`);
  }
};
var Api = class extends SimpleEventEmitter {
  constructor() {
    super();
  }
  stats(options) {
    throw new NotImplementedError("stats");
  }
  subscribe(path3, event, callback, settings) {
    throw new NotImplementedError("subscribe");
  }
  unsubscribe(path3, event, callback) {
    throw new NotImplementedError("unsubscribe");
  }
  update(path3, updates, options) {
    throw new NotImplementedError("update");
  }
  set(path3, value, options) {
    throw new NotImplementedError("set");
  }
  get(path3, options) {
    throw new NotImplementedError("get");
  }
  transaction(path3, callback, options) {
    throw new NotImplementedError("transaction");
  }
  exists(path3) {
    throw new NotImplementedError("exists");
  }
  query(path3, query, options) {
    throw new NotImplementedError("query");
  }
  reflect(path3, type, args) {
    throw new NotImplementedError("reflect");
  }
  export(path3, write2, options) {
    throw new NotImplementedError("export");
  }
  import(path3, read2, options) {
    throw new NotImplementedError("import");
  }
  createIndex(path3, key, options) {
    throw new NotImplementedError("createIndex");
  }
  getIndexes() {
    throw new NotImplementedError("getIndexes");
  }
  deleteIndex(filePath) {
    throw new NotImplementedError("deleteIndex");
  }
  setSchema(path3, schema, warnOnly) {
    throw new NotImplementedError("setSchema");
  }
  getSchema(path3) {
    throw new NotImplementedError("getSchema");
  }
  getSchemas() {
    throw new NotImplementedError("getSchemas");
  }
  validateSchema(path3, value, isUpdate) {
    throw new NotImplementedError("validateSchema");
  }
  getMutations(filter2) {
    throw new NotImplementedError("getMutations");
  }
  getChanges(filter2) {
    throw new NotImplementedError("getChanges");
  }
};

// node_modules/acebase-core/dist/esm/transport.js
var transport_exports = {};
__export(transport_exports, {
  deserialize: () => deserialize,
  deserialize2: () => deserialize2,
  detectSerializeVersion: () => detectSerializeVersion,
  serialize: () => serialize,
  serialize2: () => serialize2
});

// node_modules/acebase-core/dist/esm/ascii85.js
function c2(input, length3, result) {
  const b = [0, 0, 0, 0, 0];
  for (let i = 0; i < length3; i += 4) {
    let n = ((input[i] * 256 + input[i + 1]) * 256 + input[i + 2]) * 256 + input[i + 3];
    if (!n) {
      result.push("z");
    } else {
      for (let j = 0; j < 5; b[j++] = n % 85 + 33, n = Math.floor(n / 85)) {
      }
      result.push(String.fromCharCode(b[4], b[3], b[2], b[1], b[0]));
    }
  }
}
function encode(arr) {
  const input = arr, result = [], remainder = input.length % 4, length3 = input.length - remainder;
  c2(input, length3, result);
  if (remainder) {
    const t = new Uint8Array(4);
    t.set(input.slice(length3), 0);
    c2(t, 4, result);
    let x = result.pop();
    if (x == "z") {
      x = "!!!!!";
    }
    result.push(x.substr(0, remainder + 1));
  }
  let ret = result.join("");
  ret = "<~" + ret + "~>";
  return ret;
}
var ascii85 = {
  encode: function(arr) {
    if (arr instanceof ArrayBuffer) {
      arr = new Uint8Array(arr, 0, arr.byteLength);
    }
    return encode(arr);
  },
  decode: function(input) {
    if (!input.startsWith("<~") || !input.endsWith("~>")) {
      throw new Error("Invalid input string");
    }
    input = input.substr(2, input.length - 4);
    const n = input.length, r = [], b = [0, 0, 0, 0, 0];
    let t, x, y, d;
    for (let i = 0; i < n; ++i) {
      if (input.charAt(i) == "z") {
        r.push(0, 0, 0, 0);
        continue;
      }
      for (let j = 0; j < 5; ++j) {
        b[j] = input.charCodeAt(i + j) - 33;
      }
      d = n - i;
      if (d < 5) {
        for (let j = d; j < 4; b[++j] = 0) {
        }
        b[d] = 85;
      }
      t = (((b[0] * 85 + b[1]) * 85 + b[2]) * 85 + b[3]) * 85 + b[4];
      x = t & 255;
      t >>>= 8;
      y = t & 255;
      t >>>= 8;
      r.push(t >>> 8, t & 255, y, x);
      for (let j = d; j < 5; ++j, r.pop()) {
      }
      i += 4;
    }
    const data = new Uint8Array(r);
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
};

// node_modules/acebase-core/dist/esm/transport.js
var deserialize = (data) => {
  if (data.map === null || typeof data.map === "undefined") {
    if (typeof data.val === "undefined") {
      throw new Error("serialized value must have a val property");
    }
    return data.val;
  }
  const deserializeValue = (type, val) => {
    if (type === "date") {
      return new Date(val);
    } else if (type === "binary") {
      return ascii85.decode(val);
    } else if (type === "reference") {
      return new PathReference(val);
    } else if (type === "regexp") {
      return new RegExp(val.pattern, val.flags);
    } else if (type === "array") {
      return new PartialArray(val);
    } else if (type === "bigint") {
      return BigInt(val);
    }
    return val;
  };
  if (typeof data.map === "string") {
    return deserializeValue(data.map, data.val);
  }
  Object.keys(data.map).forEach((path3) => {
    const type = data.map[path3];
    const keys = PathInfo.getPathKeys(path3);
    let parent = data;
    let key = "val";
    let val = data.val;
    keys.forEach((k) => {
      key = k;
      parent = val;
      val = val[key];
    });
    parent[key] = deserializeValue(type, val);
  });
  return data.val;
};
var detectSerializeVersion = (data) => {
  if (typeof data !== "object" || data === null) {
    return 2;
  }
  if ("map" in data && "val" in data) {
    return 1;
  } else if ("val" in data) {
    if (Object.keys(data).length > 1) {
      return 2;
    }
    return 1;
  }
  return 2;
};
var serialize = (obj) => {
  if (obj === null || typeof obj !== "object" || obj instanceof Date || obj instanceof ArrayBuffer || obj instanceof PathReference || obj instanceof RegExp) {
    const ser = serialize({ value: obj });
    return {
      map: ser.map?.value,
      val: ser.val.value
    };
  }
  obj = cloneObject(obj);
  const process9 = (obj2, mappings2, prefix) => {
    if (obj2 instanceof PartialArray) {
      mappings2[prefix] = "array";
    }
    Object.keys(obj2).forEach((key) => {
      const val = obj2[key];
      const path3 = prefix.length === 0 ? key : `${prefix}/${key}`;
      if (typeof val === "bigint") {
        obj2[key] = val.toString();
        mappings2[path3] = "bigint";
      } else if (val instanceof Date) {
        obj2[key] = val.toISOString();
        mappings2[path3] = "date";
      } else if (val instanceof ArrayBuffer) {
        obj2[key] = ascii85.encode(val);
        mappings2[path3] = "binary";
      } else if (val instanceof PathReference) {
        obj2[key] = val.path;
        mappings2[path3] = "reference";
      } else if (val instanceof RegExp) {
        obj2[key] = { pattern: val.source, flags: val.flags };
        mappings2[path3] = "regexp";
      } else if (typeof val === "object" && val !== null) {
        process9(val, mappings2, path3);
      }
    });
  };
  const mappings = {};
  process9(obj, mappings, "");
  const serialized = { val: obj };
  if (Object.keys(mappings).length > 0) {
    serialized.map = mappings;
  }
  return serialized;
};
var serialize2 = (obj) => {
  const getSerializedValue = (val) => {
    if (typeof val === "bigint") {
      return {
        ".type": "bigint",
        ".val": val.toString()
      };
    } else if (val instanceof Date) {
      return {
        ".type": "date",
        ".val": val.toISOString()
      };
    } else if (val instanceof ArrayBuffer) {
      return {
        ".type": "binary",
        ".val": ascii85.encode(val)
      };
    } else if (val instanceof PathReference) {
      return {
        ".type": "reference",
        ".val": val.path
      };
    } else if (val instanceof RegExp) {
      return {
        ".type": "regexp",
        ".val": `/${val.source}/${val.flags}`
      };
    } else if (typeof val === "object" && val !== null) {
      if (val instanceof Array) {
        const copy = [];
        for (let i = 0; i < val.length; i++) {
          copy[i] = getSerializedValue(val[i]);
        }
        return copy;
      } else {
        const copy = {};
        if (val instanceof PartialArray) {
          copy[".type"] = "array";
        }
        for (const prop in val) {
          copy[prop] = getSerializedValue(val[prop]);
        }
        return copy;
      }
    } else {
      return val;
    }
  };
  const serialized = getSerializedValue(obj);
  if (serialized !== null && typeof serialized === "object" && "val" in serialized && Object.keys(serialized).length === 1) {
    serialized[".version"] = 2;
  }
  return serialized;
};
var deserialize2 = (data) => {
  if (typeof data !== "object" || data === null) {
    return data;
  }
  if (typeof data[".type"] === "undefined") {
    if (data instanceof Array) {
      const copy = [];
      const arr = data;
      for (let i = 0; i < arr.length; i++) {
        copy.push(deserialize2(arr[i]));
      }
      return copy;
    } else {
      const copy = {};
      const obj = data;
      for (const prop in obj) {
        copy[prop] = deserialize2(obj[prop]);
      }
      return copy;
    }
  } else if (typeof data[".type"] === "string") {
    const dataType = data[".type"].toLowerCase();
    if (dataType === "bigint") {
      const val = data[".val"];
      return BigInt(val);
    } else if (dataType === "array") {
      const arr = data;
      const copy = {};
      for (const index in arr) {
        copy[index] = deserialize2(arr[index]);
      }
      delete copy[".type"];
      return new PartialArray(copy);
    } else if (dataType === "date") {
      const val = data[".val"];
      return new Date(val);
    } else if (dataType === "binary") {
      const val = data[".val"];
      return ascii85.decode(val);
    } else if (dataType === "reference") {
      const val = data[".val"];
      return new PathReference(val);
    } else if (dataType === "regexp") {
      const val = data[".val"];
      if (typeof val === "string") {
        const match = /^\/(.*)\/([a-z]+)$/.exec(val);
        return new RegExp(match[1], match[2]);
      }
      return new RegExp(val.pattern, val.flags);
    }
  }
  throw new Error(`Unknown data type "${data[".type"]}" in serialized value`);
};

// node_modules/acebase-core/dist/esm/schema.js
function parse(definition) {
  let pos = 0;
  function consumeSpaces() {
    let c3;
    while (c3 = definition[pos], [" ", "\r", "\n", "	"].includes(c3)) {
      pos++;
    }
  }
  function consumeCharacter(c3) {
    if (definition[pos] !== c3) {
      throw new Error(`Unexpected character at position ${pos}. Expected: '${c3}', found '${definition[pos]}'`);
    }
    pos++;
  }
  function readProperty() {
    consumeSpaces();
    const prop = { name: "", optional: false, wildcard: false };
    let c3;
    while (c3 = definition[pos], c3 === "_" || c3 === "$" || c3 >= "a" && c3 <= "z" || c3 >= "A" && c3 <= "Z" || prop.name.length > 0 && c3 >= "0" && c3 <= "9" || prop.name.length === 0 && c3 === "*") {
      prop.name += c3;
      pos++;
    }
    if (prop.name.length === 0) {
      throw new Error(`Property name expected at position ${pos}, found: ${definition.slice(pos, pos + 10)}..`);
    }
    if (definition[pos] === "?") {
      prop.optional = true;
      pos++;
    }
    if (prop.name === "*" || prop.name[0] === "$") {
      prop.optional = true;
      prop.wildcard = true;
    }
    consumeSpaces();
    consumeCharacter(":");
    return prop;
  }
  function readType() {
    consumeSpaces();
    let type = { typeOf: "any" }, c3;
    let name = "";
    while (c3 = definition[pos], c3 >= "a" && c3 <= "z" || c3 >= "A" && c3 <= "Z") {
      name += c3;
      pos++;
    }
    if (name.length === 0) {
      if (definition[pos] === "*") {
        consumeCharacter("*");
        type.typeOf = "any";
      } else if (["'", '"', "`"].includes(definition[pos])) {
        type.typeOf = "string";
        type.value = "";
        const quote = definition[pos];
        consumeCharacter(quote);
        while (c3 = definition[pos], c3 && c3 !== quote) {
          type.value += c3;
          pos++;
        }
        consumeCharacter(quote);
      } else if (definition[pos] >= "0" && definition[pos] <= "9") {
        type.typeOf = "number";
        let nr = "";
        while (c3 = definition[pos], c3 === "." || c3 === "n" || c3 >= "0" && c3 <= "9") {
          nr += c3;
          pos++;
        }
        if (nr.endsWith("n")) {
          type.value = BigInt(nr);
        } else if (nr.includes(".")) {
          type.value = parseFloat(nr);
        } else {
          type.value = parseInt(nr);
        }
      } else if (definition[pos] === "{") {
        consumeCharacter("{");
        type.typeOf = "object";
        type.instanceOf = Object;
        type.children = [];
        while (true) {
          const prop = readProperty();
          const types = readTypes();
          type.children.push({ name: prop.name, optional: prop.optional, wildcard: prop.wildcard, types });
          consumeSpaces();
          if (definition[pos] === ";" || definition[pos] === ",") {
            consumeCharacter(definition[pos]);
            consumeSpaces();
          }
          if (definition[pos] === "}") {
            break;
          }
        }
        consumeCharacter("}");
      } else if (definition[pos] === "/") {
        consumeCharacter("/");
        let pattern = "", flags = "";
        while (c3 = definition[pos], c3 !== "/" || pattern.endsWith("\\")) {
          pattern += c3;
          pos++;
        }
        consumeCharacter("/");
        while (c3 = definition[pos], ["g", "i", "m", "s", "u", "y", "d"].includes(c3)) {
          flags += c3;
          pos++;
        }
        type.typeOf = "string";
        type.matches = new RegExp(pattern, flags);
      } else {
        throw new Error(`Expected a type definition at position ${pos}, found character '${definition[pos]}'`);
      }
    } else if (["string", "number", "boolean", "bigint", "undefined", "String", "Number", "Boolean", "BigInt"].includes(name)) {
      type.typeOf = name.toLowerCase();
    } else if (name === "Object" || name === "object") {
      type.typeOf = "object";
      type.instanceOf = Object;
    } else if (name === "Date") {
      type.typeOf = "object";
      type.instanceOf = Date;
    } else if (name === "Binary" || name === "binary") {
      type.typeOf = "object";
      type.instanceOf = ArrayBuffer;
    } else if (name === "any") {
      type.typeOf = "any";
    } else if (name === "null") {
      type.typeOf = "object";
      type.value = null;
    } else if (name === "Array") {
      consumeCharacter("<");
      type.typeOf = "object";
      type.instanceOf = Array;
      type.genericTypes = readTypes();
      consumeCharacter(">");
    } else if (["true", "false"].includes(name)) {
      type.typeOf = "boolean";
      type.value = name === "true";
    } else {
      throw new Error(`Unknown type at position ${pos}: "${type}"`);
    }
    consumeSpaces();
    while (definition[pos] === "[") {
      consumeCharacter("[");
      consumeCharacter("]");
      type = { typeOf: "object", instanceOf: Array, genericTypes: [type] };
    }
    return type;
  }
  function readTypes() {
    consumeSpaces();
    const types = [readType()];
    while (definition[pos] === "|") {
      consumeCharacter("|");
      types.push(readType());
      consumeSpaces();
    }
    return types;
  }
  return readType();
}
function checkObject(path3, properties, obj, partial) {
  const invalidProperties = properties.find((prop) => prop.name === "*" || prop.name[0] === "$") ? [] : Object.keys(obj).filter((key) => ![null, void 0].includes(obj[key]) && !properties.find((prop) => prop.name === key));
  if (invalidProperties.length > 0) {
    return { ok: false, reason: `Object at path "${path3}" cannot have propert${invalidProperties.length === 1 ? "y" : "ies"} ${invalidProperties.map((p) => `"${p}"`).join(", ")}` };
  }
  function checkProperty(property) {
    const hasValue = ![null, void 0].includes(obj[property.name]);
    if (!property.optional && (partial ? obj[property.name] === null : !hasValue)) {
      return { ok: false, reason: `Property at path "${path3}/${property.name}" is not optional` };
    }
    if (hasValue && property.types.length === 1) {
      return checkType(`${path3}/${property.name}`, property.types[0], obj[property.name], false);
    }
    if (hasValue && !property.types.some((type) => checkType(`${path3}/${property.name}`, type, obj[property.name], false).ok)) {
      return { ok: false, reason: `Property at path "${path3}/${property.name}" does not match any of ${property.types.length} allowed types` };
    }
    return { ok: true };
  }
  const namedProperties = properties.filter((prop) => !prop.wildcard);
  const failedProperty = namedProperties.find((prop) => !checkProperty(prop).ok);
  if (failedProperty) {
    const reason = checkProperty(failedProperty).reason;
    return { ok: false, reason };
  }
  const wildcardProperty = properties.find((prop) => prop.wildcard);
  if (!wildcardProperty) {
    return { ok: true };
  }
  const wildcardChildKeys = Object.keys(obj).filter((key) => !namedProperties.find((prop) => prop.name === key));
  let result = { ok: true };
  for (let i = 0; i < wildcardChildKeys.length && result.ok; i++) {
    const childKey = wildcardChildKeys[i];
    result = checkProperty({ name: childKey, types: wildcardProperty.types, optional: true, wildcard: true });
  }
  return result;
}
function checkType(path3, type, value, partial, trailKeys) {
  const ok = { ok: true };
  if (type.typeOf === "any") {
    return ok;
  }
  if (trailKeys instanceof Array && trailKeys.length > 0) {
    if (type.typeOf !== "object") {
      return { ok: false, reason: `path "${path3}" must be typeof ${type.typeOf}` };
    }
    if (!type.children) {
      return ok;
    }
    const childKey = trailKeys[0];
    let property = type.children.find((prop) => prop.name === childKey);
    if (!property) {
      property = type.children.find((prop) => prop.name === "*" || prop.name[0] === "$");
    }
    if (!property) {
      return { ok: false, reason: `Object at path "${path3}" cannot have property "${childKey}"` };
    }
    if (property.optional && value === null && trailKeys.length === 1) {
      return ok;
    }
    let result;
    property.types.some((type2) => {
      const childPath = typeof childKey === "number" ? `${path3}[${childKey}]` : `${path3}/${childKey}`;
      result = checkType(childPath, type2, value, partial, trailKeys.slice(1));
      return result.ok;
    });
    return result;
  }
  if (value === null) {
    return ok;
  }
  if (type.instanceOf === Object && (typeof value !== "object" || value instanceof Array || value instanceof Date)) {
    return { ok: false, reason: `path "${path3}" must be an object collection` };
  }
  if (type.instanceOf && (typeof value !== "object" || value.constructor !== type.instanceOf)) {
    return { ok: false, reason: `path "${path3}" must be an instance of ${type.instanceOf.name}` };
  }
  if ("value" in type && value !== type.value) {
    return { ok: false, reason: `path "${path3}" must be value: ${type.value}` };
  }
  if (typeof value !== type.typeOf) {
    return { ok: false, reason: `path "${path3}" must be typeof ${type.typeOf}` };
  }
  if (type.instanceOf === Array && type.genericTypes && !value.every((v) => type.genericTypes.some((t) => checkType(path3, t, v, false).ok))) {
    return { ok: false, reason: `every array value of path "${path3}" must match one of the specified types` };
  }
  if (type.typeOf === "object" && type.children) {
    return checkObject(path3, type.children, value, partial);
  }
  if (type.matches && !type.matches.test(value)) {
    return { ok: false, reason: `path "${path3}" must match regular expression /${type.matches.source}/${type.matches.flags}` };
  }
  return ok;
}
function getConstructorType(val) {
  switch (val) {
    case String:
      return "string";
    case Number:
      return "number";
    case Boolean:
      return "boolean";
    case Date:
      return "Date";
    case BigInt:
      return "bigint";
    case Array:
      throw new Error("Schema error: Array cannot be used without a type. Use string[] or Array<string> instead");
    default:
      throw new Error(`Schema error: unknown type used: ${val.name}`);
  }
}
var SchemaDefinition = class {
  constructor(definition, handling = { warnOnly: false }) {
    this.handling = handling;
    this.source = definition;
    if (typeof definition === "object") {
      const toTS = (obj) => {
        return "{" + Object.keys(obj).map((key) => {
          let val = obj[key];
          if (val === void 0) {
            val = "undefined";
          } else if (val instanceof RegExp) {
            val = `/${val.source}/${val.flags}`;
          } else if (typeof val === "object") {
            val = toTS(val);
          } else if (typeof val === "function") {
            val = getConstructorType(val);
          } else if (!["string", "number", "boolean", "bigint"].includes(typeof val)) {
            throw new Error(`Type definition for key "${key}" must be a string, number, boolean, bigint, object, regular expression, or one of these classes: String, Number, Boolean, Date, BigInt`);
          }
          return `${key}:${val}`;
        }).join(",") + "}";
      };
      this.text = toTS(definition);
    } else if (typeof definition === "string") {
      this.text = definition;
    } else {
      throw new Error("Type definiton must be a string or an object");
    }
    this.type = parse(this.text);
  }
  check(path3, value, partial, trailKeys) {
    const result = checkType(path3, this.type, value, partial, trailKeys);
    if (!result.ok && this.handling.warnOnly) {
      result.warning = `${partial ? "Partial schema" : "Schema"} check on path "${path3}"${trailKeys ? ` for child "${trailKeys.join("/")}"` : ""} failed: ${result.reason}`;
      result.ok = true;
      this.handling.warnCallback(result.warning);
    }
    return result;
  }
};

// node_modules/acebase/dist/esm/storage/binary/index.js
var fs2 = __toESM(require("fs"), 1);

// node_modules/acebase/dist/esm/promise-fs/index.js
var fs = __toESM(require("fs"), 1);
var nodeVersion = process.versions.node.split(".").reduce((v, n, i) => (v[i === 0 ? "major" : i === 1 ? "minor" : "patch"] = +n, v), { major: 0, minor: 0, patch: 0 });
var pfs = class {
  static get hasFileSystem() {
    return typeof fs === "object" && "open" in fs;
  }
  static get fs() {
    return fs;
  }
  static get flags() {
    return {
      get append() {
        return "a";
      },
      get appendAndCreate() {
        return "ax";
      },
      get readAndAppend() {
        return "a+";
      },
      get readAndAppendAndCreate() {
        return "ax+";
      },
      get appendSynchronous() {
        return "as";
      },
      get readAndAppendSynchronous() {
        return "as+";
      },
      get read() {
        return "r";
      },
      get readAndWrite() {
        return "r+";
      },
      get readAndWriteSynchronous() {
        return "rs+";
      },
      get write() {
        return "w";
      },
      get writeAndCreate() {
        return "wx";
      },
      get readAndWriteAndCreateOrOverwrite() {
        return "w+";
      },
      get readAndWriteAndCreate() {
        return "wx+";
      }
    };
  }
  static exists(path3) {
    return new Promise((resolve) => {
      fs.exists(path3, (exists2) => {
        resolve(exists2);
      });
    });
  }
  static open(path3, flags, mode) {
    return new Promise((resolve, reject) => {
      fs.open(path3, flags, mode, (err, fd) => {
        if (err) {
          reject(err);
        } else {
          resolve(fd);
        }
      });
    });
  }
  static close(fd) {
    return new Promise((resolve, reject) => {
      fs.close(fd, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static write(fd, buffer, offset, length3, position) {
    if (typeof offset === "undefined") {
      offset = 0;
    }
    if (typeof length3 === "undefined") {
      length3 = buffer.byteLength - offset;
    }
    if (typeof position === "undefined") {
      position = null;
    }
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, offset, length3, position, (err, bytesWritten, buffer2) => {
        if (err) {
          err.args = { fd, buffer: buffer2, offset, length: length3, position };
          reject(err);
        } else {
          resolve({ bytesWritten, buffer: buffer2 });
        }
      });
    });
  }
  static writeFile(path3, data, options) {
    return new Promise((resolve, reject) => {
      fs.writeFile(path3, data, options, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static read(fd, buffer, offset, length3, position) {
    if (typeof offset === "undefined") {
      offset = 0;
    }
    if (typeof length3 === "undefined") {
      length3 = buffer.byteLength;
    }
    if (typeof position === "undefined") {
      position = null;
    }
    return new Promise((resolve, reject) => {
      fs.read(fd, buffer, offset, length3, position, (err, bytesRead, buffer2) => {
        if (err) {
          err.args = { fd, buffer: buffer2, offset, length: length3, position };
          reject(err);
        } else {
          resolve({ bytesRead, buffer: buffer2 });
        }
      });
    });
  }
  static readFile(path3, options) {
    return new Promise((resolve, reject) => {
      fs.readFile(path3, options, (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
    });
  }
  static truncate(path3, len = 0) {
    return new Promise((resolve, reject) => {
      fs.truncate(path3, len, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static ftruncate(fd, len = 0) {
    return new Promise((resolve, reject) => {
      fs.ftruncate(fd, len, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static readdir(path3, options) {
    return new Promise((resolve, reject) => {
      fs.readdir(path3, options, (err, files) => {
        if (err) {
          reject(err);
        } else {
          resolve(files);
        }
      });
    });
  }
  static mkdir(path3, options) {
    return new Promise((resolve, reject) => {
      fs.mkdir(path3, options, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static unlink(path3) {
    return new Promise((resolve, reject) => {
      fs.unlink(path3, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static rm(path3) {
    return this.unlink(path3);
  }
  static rmdir(path3, options) {
    return new Promise((resolve, reject) => {
      const callback = (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      };
      const hasRecursiveOption = options?.recursive === true;
      if (nodeVersion.major < 12) {
        if (hasRecursiveOption) {
          throw new Error(`rmdir options not supported in NodeJS ${process.version}`);
        }
        fs.rmdir(path3, callback);
      } else if (hasRecursiveOption && (nodeVersion.major > 14 || nodeVersion.major === 14 && nodeVersion.minor >= 14)) {
        fs.rm(path3, options, callback);
      } else {
        fs.rmdir(path3, options, callback);
      }
    });
  }
  static rename(oldPath, newPath) {
    return new Promise((resolve, reject) => {
      fs.rename(oldPath, newPath, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static stat(path3, options) {
    return new Promise((resolve, reject) => {
      fs.stat(path3, options, (err, stats) => {
        if (err) {
          reject(err);
        } else {
          resolve(stats);
        }
      });
    });
  }
  static fsync(fd) {
    return new Promise((resolve, reject) => {
      fs.fsync(fd, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  static fdatasync(fd) {
    return new Promise((resolve, reject) => {
      fs.fdatasync(fd, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
};

// node_modules/acebase/dist/esm/node-changes.js
var CHANGE_TYPE = Object.freeze({
  UPDATE: "update",
  DELETE: "delete",
  INSERT: "insert"
});
var NodeChange = class {
  static get CHANGE_TYPE() {
    return CHANGE_TYPE;
  }
  constructor(keyOrIndex, changeType, oldValue, newValue) {
    this.keyOrIndex = keyOrIndex;
    this.changeType = changeType;
    this.oldValue = oldValue;
    this.newValue = newValue;
  }
};
var NodeChangeTracker = class {
  constructor(path3) {
    this.path = path3;
    this._changes = [];
  }
  addDelete(keyOrIndex, oldValue) {
    const change = new NodeChange(keyOrIndex, NodeChange.CHANGE_TYPE.DELETE, oldValue, null);
    this._changes.push(change);
    return change;
  }
  addUpdate(keyOrIndex, oldValue, newValue) {
    const change = new NodeChange(keyOrIndex, NodeChange.CHANGE_TYPE.UPDATE, oldValue, newValue);
    this._changes.push(change);
    return change;
  }
  addInsert(keyOrIndex, newValue) {
    const change = new NodeChange(keyOrIndex, NodeChange.CHANGE_TYPE.INSERT, null, newValue);
    this._changes.push(change);
    return change;
  }
  add(keyOrIndex, currentValue, newValue) {
    if (currentValue === null) {
      if (newValue === null) {
        throw new Error(`Wrong logic for node change on "${this.path}/${keyOrIndex}" - both old and new values are null`);
      }
      return this.addInsert(keyOrIndex, newValue);
    } else if (newValue === null) {
      return this.addDelete(keyOrIndex, currentValue);
    } else {
      return this.addUpdate(keyOrIndex, currentValue, newValue);
    }
  }
  get updates() {
    return this._changes.filter((change) => change.changeType === NodeChange.CHANGE_TYPE.UPDATE);
  }
  get deletes() {
    return this._changes.filter((change) => change.changeType === NodeChange.CHANGE_TYPE.DELETE);
  }
  get inserts() {
    return this._changes.filter((change) => change.changeType === NodeChange.CHANGE_TYPE.INSERT);
  }
  get all() {
    return this._changes;
  }
  get totalChanges() {
    return this._changes.length;
  }
  get(keyOrIndex) {
    return this._changes.find((change) => change.keyOrIndex === keyOrIndex);
  }
  hasChanged(keyOrIndex) {
    return !!this.get(keyOrIndex);
  }
  get newValue() {
    if (typeof this._newValue === "object") {
      return this._newValue;
    }
    if (typeof this._oldValue === "undefined") {
      throw new TypeError(`oldValue is not set`);
    }
    const newValue = {};
    Object.keys(this.oldValue).forEach((key) => newValue[key] = this.oldValue[key]);
    this.deletes.forEach((change) => delete newValue[change.keyOrIndex]);
    this.updates.forEach((change) => newValue[change.keyOrIndex] = change.newValue);
    this.inserts.forEach((change) => newValue[change.keyOrIndex] = change.newValue);
    return newValue;
  }
  set newValue(value) {
    this._newValue = value;
  }
  get oldValue() {
    if (typeof this._oldValue === "object") {
      return this._oldValue;
    }
    if (typeof this._newValue === "undefined") {
      throw new TypeError(`newValue is not set`);
    }
    const oldValue = {};
    Object.keys(this.newValue).forEach((key) => oldValue[key] = this.newValue[key]);
    this.deletes.forEach((change) => oldValue[change.keyOrIndex] = change.oldValue);
    this.updates.forEach((change) => oldValue[change.keyOrIndex] = change.oldValue);
    this.inserts.forEach((change) => delete oldValue[change.keyOrIndex]);
    return oldValue;
  }
  set oldValue(value) {
    this._oldValue = value;
  }
  get typeChanged() {
    return typeof this.oldValue !== typeof this.newValue || this.oldValue instanceof Array && !(this.newValue instanceof Array) || this.newValue instanceof Array && !(this.oldValue instanceof Array);
  }
  static create(path3, oldValue, newValue) {
    const changes = new NodeChangeTracker(path3);
    changes.oldValue = oldValue;
    changes.newValue = newValue;
    oldValue && typeof oldValue === "object" && Object.keys(oldValue).forEach((key) => {
      if (typeof newValue === "object" && key in newValue && newValue !== null) {
        changes.add(key, oldValue[key], newValue[key]);
      } else {
        changes.add(key, oldValue[key], null);
      }
    });
    newValue && typeof newValue === "object" && Object.keys(newValue).forEach((key) => {
      if (typeof oldValue !== "object" || !(key in oldValue) || oldValue[key] === null) {
        changes.add(key, null, newValue[key]);
      }
    });
    return changes;
  }
};

// node_modules/acebase/dist/esm/node-address.js
var NodeAddress = class {
  constructor(path3) {
    this.path = path3;
  }
  toString() {
    return `"/${this.path}"`;
  }
  equals(address) {
    return this.path === address.path;
  }
};

// node_modules/acebase/dist/esm/storage/binary/node-address.js
var BinaryNodeAddress = class extends NodeAddress {
  constructor(path3, pageNr, recordNr) {
    super(path3);
    this.pageNr = pageNr;
    this.recordNr = recordNr;
  }
  toString() {
    return `"/${this.path}" @${this.pageNr},${this.recordNr}`;
  }
  equals(address) {
    return this.path === address.path && this.pageNr === address.pageNr && this.recordNr === address.recordNr;
  }
};

// node_modules/acebase/dist/esm/node-value-types.js
var nodeValueTypes = {
  OBJECT: 1,
  ARRAY: 2,
  NUMBER: 3,
  BOOLEAN: 4,
  STRING: 5,
  BIGINT: 7,
  DATETIME: 6,
  BINARY: 8,
  REFERENCE: 9
};
var VALUE_TYPES = nodeValueTypes;
function getValueTypeName(valueType) {
  switch (valueType) {
    case VALUE_TYPES.ARRAY:
      return "array";
    case VALUE_TYPES.BINARY:
      return "binary";
    case VALUE_TYPES.BOOLEAN:
      return "boolean";
    case VALUE_TYPES.DATETIME:
      return "date";
    case VALUE_TYPES.NUMBER:
      return "number";
    case VALUE_TYPES.OBJECT:
      return "object";
    case VALUE_TYPES.REFERENCE:
      return "reference";
    case VALUE_TYPES.STRING:
      return "string";
    case VALUE_TYPES.BIGINT:
      return "bigint";
    default:
      "unknown";
  }
}
function getValueType(value) {
  if (value instanceof Array) {
    return VALUE_TYPES.ARRAY;
  } else if (value instanceof PathReference) {
    return VALUE_TYPES.REFERENCE;
  } else if (value instanceof ArrayBuffer) {
    return VALUE_TYPES.BINARY;
  } else if (value instanceof Date) {
    return VALUE_TYPES.DATETIME;
  } else if (typeof value === "string") {
    return VALUE_TYPES.STRING;
  } else if (typeof value === "object") {
    return VALUE_TYPES.OBJECT;
  } else if (typeof value === "number") {
    return VALUE_TYPES.NUMBER;
  } else if (typeof value === "boolean") {
    return VALUE_TYPES.BOOLEAN;
  } else if (typeof value === "bigint") {
    return VALUE_TYPES.BIGINT;
  }
  throw new Error(`Unknown value type: ${value}`);
}

// node_modules/acebase/dist/esm/node-info.js
var NodeInfo = class {
  constructor(info) {
    this.path = info.path;
    this.type = info.type;
    this.index = info.index;
    this.key = info.key;
    this.exists = info.exists;
    this.address = info.address;
    this.value = info.value;
    this.childCount = info.childCount;
    if (typeof this.path === "string" && (typeof this.key === "undefined" && typeof this.index === "undefined")) {
      const pathInfo = PathInfo.get(this.path);
      if (typeof pathInfo.key === "number") {
        this.index = pathInfo.key;
      } else {
        this.key = pathInfo.key;
      }
    }
    if (typeof this.exists === "undefined") {
      this.exists = true;
    }
  }
  get valueType() {
    return this.type;
  }
  get valueTypeName() {
    return getValueTypeName(this.valueType);
  }
  toString() {
    if (!this.exists) {
      return `"${this.path}" doesn't exist`;
    }
    if (this.address) {
      return `"${this.path}" is ${this.valueTypeName} stored at ${this.address.toString()}`;
    } else {
      return `"${this.path}" is ${this.valueTypeName} with value ${this.value}`;
    }
  }
};

// node_modules/acebase/dist/esm/node-cache.js
var MINUTE = 6e4;
var DEBUG_MODE = false;
var CACHE_TIMEOUT = DEBUG_MODE ? 5 * MINUTE : MINUTE;
var NodeCacheEntry = class {
  constructor(nodeInfo) {
    this.nodeInfo = nodeInfo;
    this.pathInfo = PathInfo.get(nodeInfo.path);
    this.created = Date.now();
    this.keepAlive();
  }
  keepAlive() {
    this.expires = (this.updated || this.created) + NodeCache.CACHE_DURATION;
  }
  update(nodeInfo) {
    this.nodeInfo = nodeInfo;
    this.updated = Date.now();
    this.keepAlive();
  }
};
var NodeCache = class {
  constructor() {
    this._cleanupTimeout = null;
    this._cache = /* @__PURE__ */ new Map();
    this._announcements = /* @__PURE__ */ new Map();
  }
  static get CACHE_DURATION() {
    return CACHE_TIMEOUT;
  }
  has(key) {
    return this._cache.has(key);
  }
  _assertCleanupTimeout() {
    if (this._cleanupTimeout === null) {
      this._cleanupTimeout = setTimeout(() => {
        this.cleanup();
        this._cleanupTimeout = null;
        if (this._cache.size > 0) {
          this._assertCleanupTimeout();
        }
      }, CACHE_TIMEOUT);
      this._cleanupTimeout.unref && this._cleanupTimeout.unref();
    }
  }
  announce(path3) {
    let announcement = this._announcements.get(path3);
    if (!announcement) {
      announcement = {
        resolve: null,
        reject: null,
        promise: null
      };
      announcement.promise = new Promise((resolve, reject) => {
        announcement.resolve = resolve;
        announcement.reject = reject;
      });
      this._announcements.set(path3, announcement);
    }
  }
  update(nodeInfo) {
    if (!(nodeInfo instanceof NodeInfo)) {
      throw new TypeError(`nodeInfo must be an instance of NodeInfo`);
    }
    if (nodeInfo.path === "") {
      return;
    }
    let entry = this._cache.get(nodeInfo.path);
    if (entry) {
      DEBUG_MODE && console.error(`CACHE UPDATE ${nodeInfo}`);
      entry.update(nodeInfo);
    } else {
      DEBUG_MODE && console.error(`CACHE INSERT ${nodeInfo}`);
      entry = new NodeCacheEntry(nodeInfo);
      this._cache.set(nodeInfo.path, entry);
    }
    const announcement = this._announcements.get(nodeInfo.path);
    if (announcement) {
      this._announcements.delete(nodeInfo.path);
      announcement.resolve(nodeInfo);
    }
    this._assertCleanupTimeout();
  }
  invalidate(path3, recursive, reason) {
    const entry = this._cache.get(path3);
    const pathInfo = PathInfo.get(path3);
    if (entry) {
      DEBUG_MODE && console.error(`CACHE INVALIDATE ${reason} => ${entry.nodeInfo}`);
      this._cache.delete(path3);
    }
    if (recursive) {
      this._cache.forEach((entry2, cachedPath) => {
        if (pathInfo.isAncestorOf(entry2.pathInfo)) {
          if (typeof recursive === "object") {
            const key = entry2.pathInfo.keys[pathInfo.keys.length];
            const action = recursive[key];
            switch (action) {
              case "delete":
                this.update(new NodeInfo({ path: cachedPath, exists: false }));
                break;
              case "invalidate":
                this._cache.delete(cachedPath);
                break;
            }
          } else {
            DEBUG_MODE && console.error(`CACHE INVALIDATE ${reason} => (child) ${entry2.nodeInfo}`);
            this._cache.delete(cachedPath);
          }
        }
      });
    }
  }
  delete(path3) {
    const entry = this._cache.get(path3);
    const pathInfo = PathInfo.get(path3);
    DEBUG_MODE && console.error(`CACHE MARK_DELETED => ${entry.nodeInfo}`);
    this.update(new NodeInfo({ path: path3, exists: false }));
    this._cache.forEach((entry2, cachedPath) => {
      if (pathInfo.isAncestorOf(cachedPath)) {
        DEBUG_MODE && console.error(`CACHE MARK_DELETED => (child) ${entry2.nodeInfo}`);
        entry2.nodeInfo.exists = false;
        entry2.nodeInfo.value = null;
        delete entry2.nodeInfo.type;
        entry2.updated = Date.now();
        entry2.keepAlive();
      }
    });
  }
  cleanup() {
    const now = Date.now();
    const entriesBefore = this._cache.size;
    this._cache.forEach((entry, path3) => {
      if (entry.expires <= now) {
        this._cache.delete(path3);
      }
    });
    const entriesAfter = this._cache.size;
    const entriesRemoved = entriesBefore - entriesAfter;
    DEBUG_MODE && console.log(`CACHE Removed ${entriesRemoved} cache entries (${entriesAfter} remain cached)`);
  }
  clear() {
    this._cache.clear();
  }
  find(path3, checkAnnounced = false) {
    if (checkAnnounced === true) {
      const announcement = this._announcements.get(path3);
      if (announcement) {
        return announcement.promise;
      }
    }
    let entry = this._cache.get(path3) || null;
    if (entry && entry.nodeInfo.path !== "") {
      if (entry.expires <= Date.now()) {
        this._cache.delete(path3);
        entry = null;
      } else {
        entry.keepAlive();
      }
    }
    this._assertCleanupTimeout();
    DEBUG_MODE && console.error(`CACHE FIND ${path3}: ${entry ? entry.nodeInfo : "null"}`);
    return entry ? entry.nodeInfo : null;
  }
};

// node_modules/acebase/dist/esm/storage/binary/node-info.js
var BinaryNodeInfo = class extends NodeInfo {
};

// node_modules/acebase/dist/esm/node-errors.js
var NodeNotFoundError = class extends Error {
};
var NodeRevisionError = class extends Error {
};

// node_modules/acebase/dist/esm/assert.js
function assert(condition, error) {
  if (!condition) {
    throw new Error(`Assertion failed: ${error ?? "check your code"}`);
  }
}

// node_modules/acebase/dist/esm/node-lock.js
var DEBUG_MODE2 = false;
var DEFAULT_LOCK_TIMEOUT = 120;
var LOCK_STATE = {
  PENDING: "pending",
  LOCKED: "locked",
  EXPIRED: "expired",
  DONE: "done"
};
var NodeLocker = class {
  constructor(debug, lockTimeout = DEFAULT_LOCK_TIMEOUT) {
    this._locks = [];
    this._lastTid = 0;
    this.debug = debug;
    this.timeout = lockTimeout * 1e3;
  }
  setTimeout(timeout) {
    this.timeout = timeout * 1e3;
  }
  createTid() {
    return DEBUG_MODE2 ? ++this._lastTid : ID.generate();
  }
  _allowLock(path3, tid, forWriting) {
    const conflict = this._locks.find((otherLock) => {
      return otherLock.tid !== tid && otherLock.state === LOCK_STATE.LOCKED && (forWriting || otherLock.forWriting);
    });
    return { allow: !conflict, conflict };
  }
  quit() {
    return new Promise((resolve) => {
      if (this._locks.length === 0) {
        return resolve();
      }
      this._quit = resolve;
    });
  }
  _rejectLock(lock, err) {
    this._locks.splice(this._locks.indexOf(lock), 1);
    clearTimeout(lock.timeout);
    try {
      lock.reject(err);
    } catch (err2) {
      console.error(`Unhandled promise rejection:`, err2);
    }
  }
  _processLockQueue() {
    if (this._quit) {
      const quitError = new Error("Quitting");
      this._locks.filter((lock) => lock.state === LOCK_STATE.PENDING).forEach((lock) => this._rejectLock(lock, quitError));
      if (this._locks.length === 0) {
        this._quit();
      }
    }
    const pending = this._locks.filter((lock) => lock.state === LOCK_STATE.PENDING).sort((a, b) => {
      if (a.priority && !b.priority) {
        return -1;
      } else if (!a.priority && b.priority) {
        return 1;
      }
      return a.requested - b.requested;
    });
    pending.forEach((lock) => {
      const check = this._allowLock(lock.path, lock.tid, lock.forWriting);
      lock.waitingFor = check.conflict || null;
      if (check.allow) {
        this.lock(lock).then(lock.resolve).catch((err) => this._rejectLock(lock, err));
      }
    });
  }
  async lock(path3, tid, forWriting = true, comment = "", options = { withPriority: false, noTimeout: false }) {
    let lock, proceed;
    if (path3 instanceof NodeLock) {
      lock = path3;
      proceed = true;
    } else if (this._locks.findIndex((l) => l.tid === tid && l.state === LOCK_STATE.EXPIRED) >= 0) {
      throw new Error(`lock on tid ${tid} has expired, not allowed to continue`);
    } else if (this._quit && !options.withPriority) {
      throw new Error(`Quitting`);
    } else {
      DEBUG_MODE2 && console.error(`${forWriting ? "write" : "read"} lock requested on "${path3}" by tid ${tid} (${comment})`);
      lock = new NodeLock(this, path3, tid, forWriting, options.withPriority === true);
      lock.comment = comment;
      this._locks.push(lock);
      const check = this._allowLock(path3, tid, forWriting);
      lock.waitingFor = check.conflict || null;
      proceed = check.allow;
    }
    if (proceed) {
      DEBUG_MODE2 && console.error(`${lock.forWriting ? "write" : "read"} lock ALLOWED on "${lock.path}" by tid ${lock.tid} (${lock.comment})`);
      lock.state = LOCK_STATE.LOCKED;
      if (typeof lock.granted === "number") {
      } else {
        lock.granted = Date.now();
        if (options.noTimeout !== true) {
          lock.expires = Date.now() + this.timeout;
          let timeoutCount = 0;
          const timeoutHandler = () => {
            if (lock.state !== LOCK_STATE.LOCKED) {
              return;
            }
            timeoutCount++;
            if (timeoutCount <= 3) {
              this.debug.warn(`${lock.forWriting ? "write" : "read"} lock on path "/${lock.path}" by tid ${lock.tid} (${lock.comment}) is taking a long time to complete [${timeoutCount}]`);
              lock.timeout = setTimeout(timeoutHandler, this.timeout / 4);
              return;
            }
            this.debug.error(`lock :: ${lock.forWriting ? "write" : "read"} lock on path "/${lock.path}" by tid ${lock.tid} (${lock.comment}) took too long`);
            lock.state = LOCK_STATE.EXPIRED;
            this._processLockQueue();
          };
          lock.timeout = setTimeout(timeoutHandler, this.timeout / 4);
        }
      }
      return lock;
    } else {
      assert(lock.state === LOCK_STATE.PENDING);
      return new Promise((resolve, reject) => {
        lock.resolve = resolve;
        lock.reject = reject;
      });
    }
  }
  unlock(lockOrId, comment, processQueue = true) {
    let lock, i;
    if (lockOrId instanceof NodeLock) {
      lock = lockOrId;
      i = this._locks.indexOf(lock);
    } else {
      const id = lockOrId;
      i = this._locks.findIndex((l) => l.id === id);
      lock = this._locks[i];
    }
    if (i < 0) {
      const msg = `lock on "/${lock.path}" for tid ${lock.tid} wasn't found; ${comment}`;
      throw new Error(msg);
    }
    lock.state = LOCK_STATE.DONE;
    clearTimeout(lock.timeout);
    this._locks.splice(i, 1);
    DEBUG_MODE2 && console.error(`${lock.forWriting ? "write" : "read"} lock RELEASED on "${lock.path}" by tid ${lock.tid}`);
    processQueue && this._processLockQueue();
    return lock;
  }
  list() {
    return this._locks || [];
  }
  isAllowed(path3, tid, forWriting) {
    return this._allowLock(path3, tid, forWriting).allow;
  }
};
var lastid = 0;
var NodeLock = class {
  static get LOCK_STATE() {
    return LOCK_STATE;
  }
  constructor(locker, path3, tid, forWriting, priority = false) {
    this.locker = locker;
    this.path = path3;
    this.tid = tid;
    this.forWriting = forWriting;
    this.priority = priority;
    this.state = LOCK_STATE.PENDING;
    this.requested = Date.now();
    this.comment = "";
    this.waitingFor = null;
    this.id = ++lastid;
    this.history = [];
  }
  async release(comment) {
    this.history.push({ action: "release", path: this.path, forWriting: this.forWriting, comment });
    return this.locker.unlock(this, comment || this.comment);
  }
  async moveToParent() {
    const parentPath = PathInfo.get(this.path).parentPath;
    const allowed = this.locker.isAllowed(parentPath, this.tid, this.forWriting);
    if (allowed) {
      DEBUG_MODE2 && console.error(`moveToParent ALLOWED for ${this.forWriting ? "write" : "read"} lock on "${this.path}" by tid ${this.tid} (${this.comment})`);
      this.history.push({ path: this.path, forWriting: this.forWriting, action: "moving to parent" });
      this.waitingFor = null;
      this.path = parentPath;
      return this;
    } else {
      DEBUG_MODE2 && console.error(`moveToParent QUEUED for ${this.forWriting ? "write" : "read"} lock on "${this.path}" by tid ${this.tid} (${this.comment})`);
      this.locker.unlock(this, `moveLockToParent: ${this.comment}`, false);
      const newLock = await this.locker.lock(parentPath, this.tid, this.forWriting, this.comment, { withPriority: true });
      DEBUG_MODE2 && console.error(`QUEUED moveToParent ALLOWED for ${this.forWriting ? "write" : "read"} lock on "${this.path}" by tid ${this.tid} (${this.comment})`);
      newLock.history = this.history;
      newLock.history.push({ path: this.path, forWriting: this.forWriting, action: "moving to parent through queue (priority)" });
      return newLock;
    }
  }
};

// node_modules/acebase/dist/esm/ipc/ipc.js
var AceBaseIPCPeerExitingError = class extends Error {
  constructor(message) {
    super(`Exiting: ${message}`);
  }
};
var AceBaseIPCPeer = class extends SimpleEventEmitter {
  get isMaster() {
    return this.masterPeerId === this.id;
  }
  constructor(storage, id, dbname = storage.name) {
    super();
    this.storage = storage;
    this.id = id;
    this.dbname = dbname;
    this.ipcType = "ipc";
    this.ourSubscriptions = [];
    this.remoteSubscriptions = [];
    this.peers = [];
    this._exiting = false;
    this._locks = [];
    this._requests = /* @__PURE__ */ new Map();
    this._eventsEnabled = true;
    this._nodeLocker = new NodeLocker(storage.debug, storage.settings.lockTimeout);
    storage.on("subscribe", (subscription) => {
      storage.debug.verbose(`database subscription being added on peer ${this.id}`);
      const remoteSubscription = this.remoteSubscriptions.find((sub) => sub.callback === subscription.callback);
      if (remoteSubscription) {
        return;
      }
      const othersAlreadyNotifying = this.ourSubscriptions.some((sub) => sub.event === subscription.event && sub.path === subscription.path);
      this.ourSubscriptions.push(subscription);
      if (othersAlreadyNotifying) {
        return;
      }
      const message = { type: "subscribe", from: this.id, data: { path: subscription.path, event: subscription.event } };
      this.sendMessage(message);
    });
    storage.on("unsubscribe", (subscription) => {
      const remoteSubscription = this.remoteSubscriptions.find((sub) => sub.callback === subscription.callback);
      if (remoteSubscription) {
        this.remoteSubscriptions.splice(this.remoteSubscriptions.indexOf(remoteSubscription), 1);
        return;
      }
      this.ourSubscriptions.filter((sub) => sub.path === subscription.path && (!subscription.event || sub.event === subscription.event) && (!subscription.callback || sub.callback === subscription.callback)).forEach((sub) => {
        this.ourSubscriptions.splice(this.ourSubscriptions.indexOf(sub), 1);
        const message = { type: "unsubscribe", from: this.id, data: { path: sub.path, event: sub.event } };
        this.sendMessage(message);
      });
    });
  }
  async exit(code = 0) {
    if (this._exiting) {
      return this.once("exit");
    }
    this._exiting = true;
    this.storage.debug.warn(`Received ${this.isMaster ? "master" : "worker " + this.id} process exit request`);
    if (this._locks.length > 0) {
      this.storage.debug.warn(`Waiting for ${this.isMaster ? "master" : "worker"} ${this.id} locks to clear`);
      await this.once("locks-cleared");
    }
    this.sayGoodbye(this.id);
    this.storage.debug.warn(`${this.isMaster ? "Master" : "Worker " + this.id} will now exit`);
    this.emitOnce("exit", code);
  }
  sayGoodbye(forPeerId) {
    const bye = { type: "bye", from: forPeerId, data: void 0 };
    this.sendMessage(bye);
  }
  addPeer(id, sendReply = true) {
    if (this._exiting) {
      return;
    }
    const peer = this.peers.find((w) => w.id === id);
    if (!peer) {
      this.peers.push({ id, lastSeen: Date.now() });
    }
    if (sendReply) {
      const helloMessage = { type: "hello", from: this.id, to: id, data: void 0 };
      this.sendMessage(helloMessage);
      this.ourSubscriptions.forEach((sub) => {
        const message = { type: "subscribe", from: this.id, to: id, data: { path: sub.path, event: sub.event } };
        this.sendMessage(message);
      });
    }
  }
  removePeer(id, ignoreUnknown = false) {
    if (this._exiting) {
      return;
    }
    const peer = this.peers.find((peer2) => peer2.id === id);
    if (!peer) {
      if (!ignoreUnknown) {
        throw new Error(`We are supposed to know this peer!`);
      }
      return;
    }
    this.peers.splice(this.peers.indexOf(peer), 1);
    const subscriptions = this.remoteSubscriptions.filter((sub) => sub.for === id);
    subscriptions.forEach((sub) => {
      this.remoteSubscriptions.splice(this.remoteSubscriptions.indexOf(sub), 1);
      this.storage.subscriptions.remove(sub.path, sub.event, sub.callback);
    });
  }
  addRemoteSubscription(peerId, details) {
    if (this._exiting) {
      return;
    }
    if (this.remoteSubscriptions.some((sub) => sub.for === peerId && sub.event === details.event && sub.path === details.path)) {
      return;
    }
    const subscribeCallback = (err, path3, val, previous, context) => {
      const eventMessage = {
        type: "event",
        from: this.id,
        to: peerId,
        path: details.path,
        event: details.event,
        data: {
          path: path3,
          val,
          previous,
          context
        }
      };
      this.sendMessage(eventMessage);
    };
    this.remoteSubscriptions.push({ for: peerId, event: details.event, path: details.path, callback: subscribeCallback });
    this.storage.subscriptions.add(details.path, details.event, subscribeCallback);
  }
  cancelRemoteSubscription(peerId, details) {
    const sub = this.remoteSubscriptions.find((sub2) => sub2.for === peerId && sub2.event === details.event && sub2.path === details.event);
    if (!sub) {
      return;
    }
    this.storage.subscriptions.remove(details.path, details.event, sub.callback);
  }
  async handleMessage(message) {
    switch (message.type) {
      case "hello":
        return this.addPeer(message.from, message.to !== this.id);
      case "bye":
        return this.removePeer(message.from, true);
      case "subscribe":
        return this.addRemoteSubscription(message.from, message.data);
      case "unsubscribe":
        return this.cancelRemoteSubscription(message.from, message.data);
      case "event": {
        if (!this._eventsEnabled) {
          break;
        }
        const eventMessage = message;
        const context = eventMessage.data.context || {};
        context.acebase_ipc = { type: this.ipcType, origin: eventMessage.from };
        const subscriptions = this.ourSubscriptions.filter((sub) => sub.event === eventMessage.event && sub.path === eventMessage.path);
        subscriptions.forEach((sub) => {
          sub.callback(null, eventMessage.data.path, eventMessage.data.val, eventMessage.data.previous, context);
        });
        break;
      }
      case "lock-request": {
        if (!this.isMaster) {
          throw new Error(`Workers are not supposed to receive lock requests!`);
        }
        const request2 = message;
        const result = { type: "lock-result", id: request2.id, from: this.id, to: request2.from, ok: true, data: void 0 };
        try {
          const lock = await this.lock(request2.data);
          result.data = {
            id: lock.id,
            path: lock.path,
            tid: lock.tid,
            write: lock.forWriting,
            expires: lock.expires,
            comment: lock.comment
          };
        } catch (err) {
          result.ok = false;
          result.reason = err.stack || err.message || err;
        }
        return this.sendMessage(result);
      }
      case "lock-result": {
        if (this.isMaster) {
          throw new Error(`Masters are not supposed to receive results for lock requests!`);
        }
        const result = message;
        const request2 = this._requests.get(result.id);
        if (typeof request2 !== "object") {
          throw new Error(`The request must be known to us!`);
        }
        if (result.ok) {
          request2.resolve(result.data);
        } else {
          request2.reject(new Error(result.reason));
        }
        return;
      }
      case "unlock-request": {
        if (!this.isMaster) {
          throw new Error(`Workers are not supposed to receive unlock requests!`);
        }
        const request2 = message;
        const result = { type: "unlock-result", id: request2.id, from: this.id, to: request2.from, ok: true, data: { id: request2.data.id } };
        try {
          const lockInfo = this._locks.find((l) => l.lock?.id === request2.data.id);
          await lockInfo.lock.release();
        } catch (err) {
          result.ok = false;
          result.reason = err.stack || err.message || err;
        }
        return this.sendMessage(result);
      }
      case "unlock-result": {
        if (this.isMaster) {
          throw new Error(`Masters are not supposed to receive results for unlock requests!`);
        }
        const result = message;
        const request2 = this._requests.get(result.id);
        if (typeof request2 !== "object") {
          throw new Error(`The request must be known to us!`);
        }
        if (result.ok) {
          request2.resolve(result.data);
        } else {
          request2.reject(new Error(result.reason));
        }
        return;
      }
      case "move-lock-request": {
        if (!this.isMaster) {
          throw new Error(`Workers are not supposed to receive move lock requests!`);
        }
        const request2 = message;
        const result = { type: "lock-result", id: request2.id, from: this.id, to: request2.from, ok: true, data: void 0 };
        try {
          let movedLock;
          const lockRequest = this._locks.find((r) => r.lock?.id === request2.data.id);
          if (request2.data.move_to === "parent") {
            movedLock = await lockRequest.lock.moveToParent();
          } else {
            throw new Error(`Unknown lock move_to "${request2.data.move_to}"`);
          }
          lockRequest.lock = movedLock;
          result.data = {
            id: movedLock.id,
            path: movedLock.path,
            tid: movedLock.tid,
            write: movedLock.forWriting,
            expires: movedLock.expires,
            comment: movedLock.comment
          };
        } catch (err) {
          result.ok = false;
          result.reason = err.stack || err.message || err;
        }
        return this.sendMessage(result);
      }
      case "notification": {
        return this.emit("notification", message);
      }
      case "request": {
        return this.emit("request", message);
      }
      case "result": {
        const result = message;
        const request2 = this._requests.get(result.id);
        if (typeof request2 !== "object") {
          throw new Error(`Result of unknown request received`);
        }
        if (result.ok) {
          request2.resolve(result.data);
        } else {
          request2.reject(new Error(result.reason));
        }
      }
    }
  }
  async lock(details) {
    if (this._exiting) {
      const tidApproved = this._locks.find((l) => l.tid === details.tid && l.granted);
      if (!tidApproved) {
        throw new AceBaseIPCPeerExitingError("new transaction lock denied because the IPC peer is exiting");
      }
    }
    const removeLock = (lockDetails) => {
      this._locks.splice(this._locks.indexOf(lockDetails), 1);
      if (this._locks.length === 0) {
        this.emit("locks-cleared");
      }
    };
    if (this.isMaster) {
      const lockInfo = { tid: details.tid, granted: false, request: details, lock: null };
      this._locks.push(lockInfo);
      const lock = await this._nodeLocker.lock(details.path, details.tid, details.write, details.comment);
      lockInfo.tid = lock.tid;
      lockInfo.granted = true;
      const createIPCLock = (lock2) => {
        return {
          get id() {
            return lock2.id;
          },
          get tid() {
            return lock2.tid;
          },
          get path() {
            return lock2.path;
          },
          get forWriting() {
            return lock2.forWriting;
          },
          get expires() {
            return lock2.expires;
          },
          get comment() {
            return lock2.comment;
          },
          get state() {
            return lock2.state;
          },
          release: async () => {
            await lock2.release();
            removeLock(lockInfo);
          },
          moveToParent: async () => {
            const parentLock = await lock2.moveToParent();
            lockInfo.lock = createIPCLock(parentLock);
            return lockInfo.lock;
          }
        };
      };
      lockInfo.lock = createIPCLock(lock);
      return lockInfo.lock;
    } else {
      const lockInfo = { tid: details.tid, granted: false, request: details, lock: null };
      this._locks.push(lockInfo);
      const createIPCLock = (result2) => {
        lockInfo.granted = true;
        lockInfo.tid = result2.tid;
        lockInfo.lock = {
          id: result2.id,
          tid: result2.tid,
          path: result2.path,
          forWriting: result2.write,
          state: LOCK_STATE.LOCKED,
          expires: result2.expires,
          comment: result2.comment,
          release: async () => {
            const req2 = { type: "unlock-request", id: ID.generate(), from: this.id, to: this.masterPeerId, data: { id: lockInfo.lock.id } };
            await this.request(req2);
            lockInfo.lock.state = LOCK_STATE.DONE;
            this.storage.debug.verbose(`Worker ${this.id} released lock ${lockInfo.lock.id} (tid ${lockInfo.lock.tid}, ${lockInfo.lock.comment}, "/${lockInfo.lock.path}", ${lockInfo.lock.forWriting ? "write" : "read"})`);
            removeLock(lockInfo);
          },
          moveToParent: async () => {
            const req2 = { type: "move-lock-request", id: ID.generate(), from: this.id, to: this.masterPeerId, data: { id: lockInfo.lock.id, move_to: "parent" } };
            let result3;
            try {
              result3 = await this.request(req2);
            } catch (err2) {
              lockInfo.lock.state = LOCK_STATE.DONE;
              removeLock(lockInfo);
              throw err2;
            }
            lockInfo.lock = createIPCLock(result3);
            return lockInfo.lock;
          }
        };
        return lockInfo.lock;
      };
      const req = { type: "lock-request", id: ID.generate(), from: this.id, to: this.masterPeerId, data: details };
      let result, err;
      try {
        result = await this.request(req);
      } catch (e) {
        err = e;
        result = null;
      }
      if (err) {
        removeLock(lockInfo);
        throw err;
      }
      return createIPCLock(result);
    }
  }
  async request(req) {
    let resolve, reject;
    const promise = new Promise((rs, rj) => {
      resolve = (result) => {
        this._requests.delete(req.id);
        rs(result);
      };
      reject = (err) => {
        this._requests.delete(req.id);
        rj(err);
      };
    });
    this._requests.set(req.id, { resolve, reject, request: req });
    this.sendMessage(req);
    return promise;
  }
  sendRequest(request2) {
    const req = { type: "request", from: this.id, to: this.masterPeerId, id: ID.generate(), data: request2 };
    return this.request(req).catch((err) => {
      this.storage.debug.error(err);
      throw err;
    });
  }
  replyRequest(requestMessage, result) {
    const reply = { type: "result", id: requestMessage.id, ok: true, from: this.id, to: requestMessage.from, data: result };
    this.sendMessage(reply);
  }
  sendNotification(notification) {
    const msg = { type: "notification", from: this.id, data: notification };
    this.sendMessage(msg);
  }
  get eventsEnabled() {
    return this._eventsEnabled;
  }
  set eventsEnabled(enabled) {
    this.storage.debug.log(`ipc events ${enabled ? "enabled" : "disabled"}`);
    this._eventsEnabled = enabled;
  }
};

// node_modules/acebase/dist/esm/ipc/index.js
var Cluster = __toESM(require("cluster"), 1);

// node_modules/acebase/dist/esm/ipc/remote.js
var http = __toESM(require("http"), 1);
var masterPeerId = "[master]";
var WS_CLOSE_PING_TIMEOUT = 1;
var WS_CLOSE_PROCESS_EXIT = 2;
var RemoteIPCPeer = class extends AceBaseIPCPeer {
  get version() {
    return "1.0.0";
  }
  constructor(storage, config) {
    super(storage, config.role === "master" ? masterPeerId : ID.generate(), config.dbname);
    this.config = config;
    this.queue = true;
    this.pending = { in: [], out: [] };
    this.maxPayload = 100;
    this.masterPeerId = masterPeerId;
    this.connect().catch((err) => {
      storage.debug.error(err.message);
      this.exit();
    });
  }
  async connect(options) {
    const ws = await (async () => {
      try {
        return Promise.resolve().then(() => __toESM(require_ws(), 1));
      } catch {
        throw new Error(`ws package is not installed. To fix this, run: npm install ws`);
      }
    })();
    return new Promise((resolve, reject) => {
      let connected = false;
      this.ws = new ws.WebSocket(`ws${this.config.ssl ? "s" : ""}://${this.config.host || "localhost"}:${this.config.port}/${this.config.dbname}/connect?v=${this.version}&id=${this.id}&t=${this.config.token}`);
      this.ws.addEventListener("open", async () => {
        connected = true;
        this.pending.out.forEach((msg) => {
          this.ws.send(msg);
        });
        this.pending.out = [];
        this.queue = false;
        resolve();
      });
      this.ws.addEventListener("error", (event) => {
        if (!connected) {
          if (event.message.includes("403")) {
            reject(new Error("Cannot connect to IPC server: unauthorized"));
          } else if (event.message.includes("409")) {
            reject(new Error("Cannot connect to IPC server: unsupported client version (too new or old)"));
          } else if (event.message.includes("500")) {
            reject(new Error("Cannot connect to IPC server: server error"));
          } else if (typeof options?.maxRetries === "undefined" || typeof options?.maxRetries === "number" && options?.maxRetries > 0) {
            const retryMs = 1e3;
            this.storage.debug.error(`Unable to connect to remote IPC server (${event.message}). Trying again in ${retryMs}ms`);
            const retryOptions = {};
            if (typeof typeof options?.maxRetries === "number") {
              retryOptions.maxRetries = options.maxRetries - 1;
            }
            const timeout = setTimeout(() => {
              this.connect(retryOptions);
            }, retryMs);
            timeout.unref?.();
          } else {
            reject(event);
          }
        }
      });
      let lastMessageReceived = Date.now();
      const pingInterval = setInterval(() => {
        if (this._exiting) {
          return;
        }
        const ms = Date.now() - lastMessageReceived;
        if (ms > 1e4) {
          this.ws.close(WS_CLOSE_PING_TIMEOUT);
        } else if (ms > 5e3) {
          this.ws.send("ping");
        }
      }, 500);
      pingInterval.unref?.();
      process.once("exit", () => {
        this.ws.close(WS_CLOSE_PROCESS_EXIT);
      });
      this.ws.addEventListener("close", () => {
        if (!connected) {
          return;
        }
        if (this._exiting) {
          return;
        }
        this.storage.debug.error(`Connection to remote IPC server was lost. Trying to reconnect`);
        clearInterval(pingInterval);
        this.storage.invalidateCache?.(true, "", true, "ipc_ws_disconnect");
        this.connect();
      });
      this.ws.addEventListener("message", async (event) => {
        lastMessageReceived = Date.now();
        let str = event.data.toString();
        console.log(str);
        if (str === "pong") {
          return;
        } else if (str.startsWith("welcome:")) {
          const config = JSON.parse(str.slice(8));
          this.maxPayload = config.maxPayload;
        } else if (str.startsWith("connect:")) {
        } else if (str.startsWith("disconnect:")) {
          const id = str.slice(11);
          if (this.peers.find((peer) => peer.id === id)) {
            this.removePeer(id);
            this.sayGoodbye(id);
          }
        } else if (str.startsWith("get:")) {
          const msgId = str.slice(4);
          try {
            str = await this.fetch("GET", `/${this.config.dbname}/receive?id=${this.id}&msg=${msgId}&t=${this.config.token}`);
            const msg = JSON.parse(str);
            super.handleMessage(msg);
          } catch (err) {
            this.storage.debug.error(`Failed to receive message ${msgId}:`, err);
          }
        } else if (str.startsWith("{")) {
          const msg = JSON.parse(str);
          super.handleMessage(msg);
        } else {
          console.warn(`Received unknown IPC message: "${str}"`);
        }
      });
    });
  }
  sendMessage(message) {
    this.storage.debug.verbose(`[RemoteIPC] sending: `, message);
    let json = JSON.stringify(message);
    if (typeof message.to === "string") {
      json = `to:${message.to};${json}`;
    }
    if (this.queue) {
      this.pending.out.push(json);
    } else if (json.length > this.maxPayload) {
      this.fetch("POST", `/${this.dbname}/send?id=${this.id}&t=${this.config.token}`, json);
    } else {
      this.ws.send(json);
    }
  }
  async fetch(method, path3, postData) {
    const options = {
      hostname: this.config.host || "localhost",
      port: this.config.port,
      path: path3,
      method,
      headers: {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(postData || "")
      }
    };
    return await new Promise((resolve, reject) => {
      const req = http.request(options, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          resolve(data);
        });
      });
      req.on("error", reject);
      req.write(postData);
      req.end();
    });
  }
};

// node_modules/acebase/dist/esm/ipc/socket.js
var import_net = require("net");
var import_path = require("path");
var import_child_process = require("child_process");

// node_modules/acebase/dist/esm/ipc/service/shared.js
var import_crypto = require("crypto");
function getSocketPath(filePath) {
  let path3 = process.platform === "win32" ? `\\\\.\\pipe\\${filePath.replace(/^\//, "").replace(/\//g, "-")}` : `${filePath}.sock`;
  const maxLength = process.platform === "win32" ? 256 : 108;
  if (path3.length > maxLength) {
    const hash = (0, import_crypto.createHash)("sha256").update(path3).digest("hex");
    path3 = process.platform === "win32" ? `\\\\.\\pipe\\${hash}` : `${hash}.sock`;
  }
  return path3;
}
var MSG_DELIMITER = "\n";

// node_modules/acebase/dist/esm/ipc/socket.js
var import_net2 = require("net");
var import_meta = {};
var masterPeerId2 = "[master]";
var IPCSocketPeer = class extends AceBaseIPCPeer {
  constructor(storage, ipcSettings) {
    const isMaster = storage.settings.ipc instanceof import_net.Server;
    const peerId = isMaster ? masterPeerId2 : ID.generate();
    super(storage, peerId, ipcSettings.ipcName);
    this.server = ipcSettings.server;
    this.masterPeerId = masterPeerId2;
    this.ipcType = "node.socket";
    const dbFile = (0, import_path.resolve)(storage.path, `${storage.settings.type}.db`);
    const socketPath = getSocketPath(dbFile);
    const bindEventHandler = (target, event, handler) => {
      (target.on ?? target.addListener).bind(target)(event, handler);
      this.on("exit", () => (target.off ?? target.removeListener).bind(target)(event, handler));
    };
    bindEventHandler(process, "SIGINT", () => {
      this.exit();
    });
    if (!isMaster) {
      const service = (0, import_child_process.spawn)("node", [`${process.platform === "win32" ? "" : "/"}${/file:\/{2,3}(.+)\/[^/]/.exec(import_meta.url)[1]}/service/start.js`, dbFile, "--loglevel", storage.debug.level, "--maxidletime", "0"], { detached: true, stdio: "ignore" });
      service.unref();
    }
    let socket = null;
    let connected = false;
    const queue = [];
    const peerSockets = isMaster ? /* @__PURE__ */ new Map() : null;
    const handleMessage = (socket2, message) => {
      if (typeof message !== "object") {
        return;
      }
      if (isMaster && message.to !== masterPeerId2) {
        this.sendMessage(message);
      }
      if (message.to && message.to !== this.id) {
        return;
      }
      if (this.isMaster) {
        if (message.type === "hello") {
          peerSockets.set(message.from, socket2);
        } else if (message.type === "bye") {
          peerSockets.delete(message.from);
        }
      }
      return super.handleMessage(message);
    };
    if (isMaster) {
      this.server.on("connection", (socket2) => {
        let buffer = Buffer.alloc(0);
        socket2.on("data", (chunk) => {
          buffer = Buffer.concat([buffer, chunk]);
          while (buffer.length > 0) {
            const delimiterIndex = buffer.indexOf(MSG_DELIMITER);
            if (delimiterIndex === -1) {
              break;
            }
            const message = buffer.subarray(0, delimiterIndex);
            buffer = buffer.subarray(delimiterIndex + MSG_DELIMITER.length);
            try {
              const json = message.toString("utf-8");
              const serialized = JSON.parse(json);
              const msg = transport_exports.deserialize2(serialized);
              handleMessage(socket2, msg);
            } catch (err) {
              storage.debug.error(`[IPC ${ipcSettings.ipcName}] Error parsing message: ${err}`);
            }
          }
        });
        socket2.on("close", (hadError) => {
          for (const [peerId2, peerSocket] of peerSockets.entries()) {
            if (peerSocket === socket2) {
              this.removePeer(peerId2);
              this.sayGoodbye(peerId2);
              break;
            }
          }
        });
      });
    } else {
      const connectSocket = async (path3) => {
        const tryConnect = async (tries) => {
          try {
            if (this._exiting) {
              return;
            }
            const s = (0, import_net.connect)({ path: path3 });
            await new Promise((resolve, reject) => {
              s.once("error", reject).unref();
              s.once("connect", resolve).unref();
            });
            storage.debug.log(`[IPC ${ipcSettings.ipcName}] peer ${this.id} successfully established connection to the service`);
            socket = s;
            connected = true;
          } catch (err) {
            if (tries < 100) {
              await new Promise((resolve) => setTimeout(resolve, 100));
              return tryConnect(tries + 1);
            }
            storage.debug.error(`[IPC ${ipcSettings.ipcName}] peer ${this.id} cannot connect to service: ${err.message}`);
            throw err;
          }
        };
        await tryConnect(1);
        this.once("exit", () => {
          socket?.destroy();
        });
        bindEventHandler(socket, "close", (hadError) => {
          storage.debug.log(`IPC peer ${this.id} lost its connection to the service${hadError ? " because of an error" : ""}`);
        });
        let buffer = Buffer.alloc(0);
        bindEventHandler(socket, "data", (chunk) => {
          buffer = Buffer.concat([buffer, chunk]);
          while (buffer.length > 0) {
            const delimiterIndex = buffer.indexOf(MSG_DELIMITER);
            if (delimiterIndex === -1) {
              break;
            }
            const message = buffer.subarray(0, delimiterIndex);
            buffer = buffer.subarray(delimiterIndex + MSG_DELIMITER.length);
            try {
              const json = message.toString("utf-8");
              const serialized = JSON.parse(json);
              const msg = transport_exports.deserialize2(serialized);
              handleMessage(socket, msg);
            } catch (err) {
              storage.debug.error(`Error parsing message: ${err}`);
            }
          }
        });
        connected = true;
        while (queue.length) {
          const message = queue.shift();
          this.sendMessage(message);
        }
      };
      connectSocket(socketPath);
    }
    this.sendMessage = (message) => {
      const serialized = transport_exports.serialize2(message);
      const buffer = Buffer.from(JSON.stringify(serialized) + MSG_DELIMITER);
      if (this.isMaster) {
        this.peers.filter((p) => p.id !== message.from && (!message.to || p.id === message.to)).forEach((peer) => {
          const socket2 = peerSockets.get(peer.id);
          socket2?.write(buffer);
        });
      } else if (connected) {
        socket.write(buffer);
      } else {
        queue.push(message);
      }
    };
    const helloMsg = { type: "hello", from: this.id, data: void 0 };
    this.sendMessage(helloMsg);
  }
  sendMessage(message) {
    throw new Error("Must be set by constructor");
  }
  async exit(code = 0) {
    await super.exit(code);
  }
};

// node_modules/acebase/dist/esm/ipc/index.js
var cluster = Cluster.default ?? Cluster;
var masterPeerId3 = "[master]";
var IPCPeer = class extends AceBaseIPCPeer {
  constructor(storage, dbname) {
    const pm2id = process.env?.NODE_APP_INSTANCE || process.env?.pm_id;
    if (typeof pm2id === "string" && pm2id !== "0") {
      throw new Error(`To use AceBase with pm2 in cluster mode, use an AceBase IPC server to enable interprocess communication.`);
    }
    const peerId = cluster.isMaster ? masterPeerId3 : cluster.worker.id.toString();
    super(storage, peerId, dbname);
    this.masterPeerId = masterPeerId3;
    this.ipcType = "node.cluster";
    const bindEventHandler = (target, event, handler) => {
      target.addListener(event, handler);
      this.on("exit", () => target.removeListener(event, handler));
    };
    bindEventHandler(process, "SIGINT", () => {
      this.exit();
    });
    if (cluster.isMaster) {
      bindEventHandler(cluster, "online", (worker) => {
        bindEventHandler(worker, "error", (err) => {
          storage.debug.error(`Caught worker error:`, err);
        });
      });
      bindEventHandler(cluster, "exit", (worker) => {
        if (this.peers.find((peer) => peer.id === worker.id.toString())) {
          this.removePeer(worker.id.toString());
          this.sayGoodbye(worker.id.toString());
        }
      });
    }
    const handleMessage = (message) => {
      if (typeof message !== "object") {
        return;
      }
      if (message.dbname !== this.dbname) {
        return;
      }
      if (cluster.isMaster && message.to !== masterPeerId3) {
        this.sendMessage(message);
      }
      if (message.to && message.to !== this.id) {
        return;
      }
      return super.handleMessage(message);
    };
    if (cluster.isMaster) {
      bindEventHandler(cluster, "message", (worker, message) => handleMessage(message));
    } else {
      bindEventHandler(cluster.worker, "message", handleMessage);
    }
    const helloMsg = { type: "hello", from: this.id, data: void 0 };
    this.sendMessage(helloMsg);
  }
  sendMessage(msg) {
    const message = msg;
    message.dbname = this.dbname;
    if (cluster.isMaster) {
      this.peers.filter((p) => p.id !== message.from && (!message.to || p.id === message.to)).forEach((peer) => {
        const worker = cluster.workers[peer.id];
        worker && worker.send(message);
      });
    } else {
      process.send(message);
    }
  }
  async exit(code = 0) {
    await super.exit(code);
  }
};

// node_modules/acebase/dist/esm/thread-safe.js
var DEBUG_MODE3 = false;
var _lockTimeoutMsg = 'Lock "${name}" timed out! lock.release() was not called in a timely fashion';
var _lockWaitTimeoutMsg = 'Lock "${name}" wait time expired, failed to lock target';
var _threadSafeLocks = /* @__PURE__ */ new Map();
var ThreadSafe = class {
  static lock(target, options = { timeout: 6e4 * 15, critical: true, name: "unnamed lock", shared: false }) {
    if (typeof options !== "object") {
      options = {};
    }
    if (typeof options.timeout !== "number") {
      options.timeout = 60 * 1e3;
    }
    if (typeof options.critical !== "boolean") {
      options.critical = true;
    }
    if (typeof options.name !== "string") {
      options.name = typeof target === "string" ? target : "unnamed lock";
    }
    if (typeof options.shared !== "boolean") {
      options.shared = false;
    }
    if (options.shared) {
    }
    let lock = _threadSafeLocks.get(target);
    const timeoutHandler = (critical) => {
      console.error(_lockTimeoutMsg.replace("${name}", lock.name));
      const copy = Object.assign({}, lock);
      const originalName = lock.name;
      lock.release = () => {
        throw new Error(`Cannot release lock "${originalName}" because it timed out earlier`);
      };
      lock = copy;
      if (critical) {
        _threadSafeLocks.delete(target);
        lock._queue.forEach((item) => {
          clearTimeout(item.waitTimeout);
          item.reject(new Error(`Could not achieve lock because the current lock ("${lock.name}") was not released in time (and lock is flagged critical)`));
        });
      } else {
        next();
      }
    };
    const next = () => {
      clearTimeout(lock._timeout);
      if (lock._queue.length === 0) {
        return _threadSafeLocks.delete(target);
      }
      const item = lock._queue.shift();
      clearTimeout(item.waitTimeout);
      lock._timeout = setTimeout(timeoutHandler, item.options.timeout, item.options.critical);
      lock.target = item.options.target || target;
      lock.achieved = new Date();
      lock.name = item.options.name;
      lock.stack = DEBUG_MODE3 ? new Error().stack : "not available";
      item.resolve(lock);
    };
    if (!lock) {
      lock = {
        target: options.target || target,
        achieved: new Date(),
        release() {
          next();
        },
        name: options.name,
        stack: DEBUG_MODE3 ? new Error().stack : "not available",
        _timeout: setTimeout(timeoutHandler, options.timeout, options.critical),
        _queue: []
      };
      _threadSafeLocks.set(target, lock);
      return Promise.resolve(lock);
    } else {
      return new Promise((resolve, reject) => {
        const waitTimeout = setTimeout(() => {
          lock._queue.splice(lock._queue.indexOf(item), 1);
          if (lock._queue.length === 0) {
            _threadSafeLocks.delete(target);
          }
          reject(_lockWaitTimeoutMsg.replace("${name}", options.name));
        }, options.timeout);
        const item = { resolve, reject, waitTimeout, options };
        lock._queue.push(item);
      });
    }
  }
};

// node_modules/acebase/dist/esm/binary.js
function writeByteLength(bytes, index, length3) {
  bytes[index] = length3 >> 24 & 255;
  bytes[index + 1] = length3 >> 16 & 255;
  bytes[index + 2] = length3 >> 8 & 255;
  bytes[index + 3] = length3 & 255;
  return bytes;
}
function readByteLength(bytes, index) {
  const length3 = bytes[index] << 24 | bytes[index + 1] << 16 | bytes[index + 2] << 8 | bytes[index + 3];
  return length3;
}
var MAX_SIGNED_NUMBER = Math.pow(2, 31) - 1;
function writeSignedNumber(bytes, index, offset) {
  const negative = offset < 0;
  if (negative) {
    offset = -offset;
  }
  if (offset > MAX_SIGNED_NUMBER) {
    throw new Error(`reference offset to big to store in 31 bits`);
  }
  bytes[index] = offset >> 24 & 127 | (negative ? 128 : 0);
  bytes[index + 1] = offset >> 16 & 255;
  bytes[index + 2] = offset >> 8 & 255;
  bytes[index + 3] = offset & 255;
  return bytes;
}
function readSignedNumber(bytes, index) {
  let nr = (bytes[index] & 127) << 24 | bytes[index + 1] << 16 | bytes[index + 2] << 8 | bytes[index + 3];
  const isNegative = (bytes[index] & 128) > 0;
  if (isNegative) {
    nr = -nr;
  }
  return nr;
}
var MAX_SIGNED_OFFSET = Math.pow(2, 47) - 1;
function writeSignedOffset(bytes, index, offset, large = false) {
  if (!large) {
    return writeSignedNumber(bytes, index, offset);
  }
  const negative = offset < 0;
  if (negative) {
    offset = -offset;
  }
  if (offset > MAX_SIGNED_OFFSET) {
    throw new Error(`reference offset to big to store in 47 bits`);
  }
  let n = offset;
  for (let i = 0; i < 6; i++) {
    const b = n & 255;
    bytes[index + 5 - i] = b;
    n = n <= b ? 0 : (n - b) / 256;
  }
  if (negative) {
    bytes[index] |= 128;
  }
  return bytes;
}
function readSignedOffset(bytes, index, large = false) {
  if (!large) {
    return readSignedNumber(bytes, index);
  }
  let offset = 0;
  const isNegative = (bytes[index] & 128) > 0;
  for (let i = 0; i < 6; i++) {
    let b = bytes[index + i];
    if (i === 0 && isNegative) {
      b ^= 128;
    }
    offset += b * Math.pow(2, (5 - i) * 8);
  }
  if (isNegative) {
    offset = -offset;
  }
  return offset;
}
var Uint8ArrayBuilder = class {
  constructor(bytes = null, bufferSize = 4096) {
    this._data = new Uint8Array();
    this._length = 0;
    this._bufferSize = bufferSize;
    bytes && this.append(bytes);
  }
  append(bytes) {
    if (bytes instanceof Uint8ArrayBuilder) {
      bytes = bytes.data;
    }
    this.reserve(bytes.length);
    this._data.set(bytes, this._length);
    this._length += bytes.length;
    return this;
  }
  push(...bytes) {
    if (bytes.length === 0) {
      console.warn("WARNING: pushing 0 bytes to Uint8ArrayBuilder!");
    }
    return this.append(bytes);
  }
  static writeUint32(positiveNumber, target, index) {
    if (target) {
      new DataView(target).setUint32(index, positiveNumber, false);
    } else {
      const bytes = new Uint8Array(4);
      const view = new DataView(bytes);
      view.setUint32(index, positiveNumber);
      return bytes;
    }
  }
  reserve(length3) {
    const freeBytes = this._data.byteLength - this._length;
    if (freeBytes < length3) {
      const bytesShort = length3 - freeBytes;
      const addBytes = this._bufferSize * Math.ceil(bytesShort * 1.1 / this._bufferSize);
      const newLength = this._data.byteLength + addBytes;
      const newData = new Uint8Array(newLength);
      newData.set(this._data, 0);
      this._data = newData;
    }
  }
  get dataView() {
    return new DataView(this._data.buffer, this._data.byteOffset, this._data.byteLength);
  }
  write(data, index) {
    if (typeof index !== "number") {
      throw new Error(`no index passed to write method`);
    }
    const grow = index + data.byteLength - this._length;
    if (grow > 0) {
      this.reserve(grow);
      this._length += grow;
    }
    this._data.set(data, index);
  }
  writeByte(byte, index) {
    if (typeof index !== "number") {
      this.reserve(1);
      index = this._length;
      this._length += 1;
    }
    this.dataView.setUint8(index, byte);
  }
  writeUint16(positiveNumber, index) {
    if (typeof index !== "number") {
      this.reserve(2);
      index = this._length;
      this._length += 2;
    }
    this.dataView.setUint16(index, positiveNumber, false);
  }
  writeUint32(positiveNumber, index) {
    if (typeof index !== "number") {
      this.reserve(4);
      index = this._length;
      this._length += 4;
    }
    this.dataView.setUint32(index, positiveNumber, false);
  }
  writeUint32_old(positiveNumber, index) {
    const bytes = writeByteLength([], 0, positiveNumber);
    if (index >= 0) {
      this._data.set(bytes, index);
      return this;
    }
    return this.append(bytes);
  }
  writeInt32(signedNumber, index) {
    if (typeof index !== "number") {
      this.reserve(4);
      index = this._length;
      this._length += 4;
    }
    if (signedNumber > MAX_SIGNED_NUMBER || signedNumber < -MAX_SIGNED_NUMBER) {
      throw new Error(`number to big to store in uint32`);
    }
    const negative = signedNumber < 0;
    if (negative) {
      const nr = -signedNumber;
      const view = this.dataView;
      view.setInt8(index, nr >> 24 & 127 | (negative ? 128 : 0));
      view.setInt8(index + 1, nr >> 16 & 255);
      view.setInt8(index + 2, nr >> 8 & 255);
      view.setInt8(index + 3, nr & 255);
    } else {
      this.dataView.setInt32(index, signedNumber, false);
    }
    return this;
  }
  writeInt32_old(signedNumber, index) {
    const bytes = writeSignedNumber([], 0, signedNumber);
    if (index >= 0) {
      this._data.set(bytes, index);
      return this;
    }
    return this.append(bytes);
  }
  writeInt48(signedNumber, index) {
    if (typeof index !== "number") {
      this.reserve(6);
      index = this._length;
      this._length += 6;
    }
    if (signedNumber > MAX_SIGNED_OFFSET || signedNumber < -MAX_SIGNED_OFFSET) {
      throw new Error(`number to big to store in int48`);
    }
    const negative = signedNumber < 0;
    let n = negative ? -signedNumber : signedNumber;
    for (let i = 0; i < 6; i++) {
      let b = n & 255;
      if (negative && i === 5) {
        b |= 128;
      }
      this.data[index + 5 - i] = b;
      n = n <= b ? 0 : (n - b) / 256;
    }
    return this;
  }
  writeInt48_old(signedNumber, index) {
    const bytes = writeSignedOffset([], 0, signedNumber, true);
    if (index >= 0) {
      this._data.set(bytes, index);
      return this;
    }
    return this.append(bytes);
  }
  get data() {
    return this._data.subarray(0, this._length);
  }
  get length() {
    return this._length;
  }
  slice(begin, end) {
    if (begin < 0) {
      return this._data.subarray(this._length + begin, this._length);
    } else {
      return this._data.subarray(begin, end || this._length);
    }
  }
  splice(index, remove) {
    if (typeof remove !== "number") {
      remove = this.length - index;
    }
    const removed = this._data.slice(index, index + remove);
    if (index + remove >= this.length) {
      this._length = index;
    } else {
      this._data.copyWithin(index, index + remove, this._length);
      this._length -= remove;
    }
    return removed;
  }
};

// node_modules/acebase/dist/esm/detailed-error.js
var DetailedError = class extends Error {
  constructor(code, message, originalError = null) {
    super(message);
    this.code = code;
    this.originalError = originalError;
  }
  get codes() {
    const arr = [];
    let err = this;
    while (err) {
      arr.push(err instanceof DetailedError ? err.code : "thrown");
      err = err instanceof DetailedError ? err.originalError : null;
    }
    return arr;
  }
  get stacks() {
    const arr = [];
    let err = this;
    while (err) {
      arr.push(err.stack);
      err = err instanceof DetailedError ? err.originalError : null;
    }
    return arr.join("\r\n-----------------\r\n");
  }
  hasErrorCode(code) {
    let err = this;
    while (err.code !== code && err.originalError) {
      err = err.originalError;
    }
    return err.code === code;
  }
  static hasErrorCode(err, code) {
    if (!(err instanceof DetailedError)) {
      return false;
    }
    return err.hasErrorCode(code);
  }
};

// node_modules/acebase/dist/esm/btree/config.js
var WRITE_SMALL_LEAFS = true;
var MAX_SMALL_LEAF_VALUE_LENGTH = 127 - 4;
var MAX_LEAF_ENTRY_VALUES = Math.pow(2, 32) - 1;

// node_modules/acebase/dist/esm/btree/binary-tree-builder.js
var { bigintToBytes: bigintToBytes2, encodeString: encodeString2, numberToBytes: numberToBytes2 } = utils_exports;
var KEY_TYPE = {
  UNDEFINED: 0,
  STRING: 1,
  NUMBER: 2,
  BOOLEAN: 3,
  DATE: 4,
  BIGINT: 5
};
var FLAGS = {
  UNIQUE_KEYS: 1,
  HAS_METADATA: 2,
  HAS_FREE_SPACE: 4,
  HAS_FILL_FACTOR: 8,
  HAS_SMALL_LEAFS: 16,
  HAS_LARGE_PTRS: 32,
  ENTRY_HAS_EXT_DATA: 128,
  IS_LEAF: 1,
  LEAF_HAS_EXT_DATA: 2
};
var BinaryBPlusTreeBuilder = class {
  constructor(options = { uniqueKeys: true, smallLeafs: WRITE_SMALL_LEAFS, maxEntriesPerNode: 3, fillFactor: 95, metadataKeys: [], byteLength: 0, freeBytes: 0 }) {
    this.uniqueKeys = options.uniqueKeys;
    this.maxEntriesPerNode = options.maxEntriesPerNode;
    this.metadataKeys = options.metadataKeys;
    this.byteLength = options.byteLength;
    this.freeBytes = options.freeBytes;
    this.smallLeafs = options.smallLeafs;
    this.fillFactor = options.fillFactor;
  }
  getHeader() {
    const indexTypeFlags = (this.uniqueKeys ? FLAGS.UNIQUE_KEYS : 0) | (this.metadataKeys.length > 0 ? FLAGS.HAS_METADATA : 0) | (this.freeBytes > 0 ? FLAGS.HAS_FREE_SPACE : 0) | (typeof this.fillFactor === "number" && this.fillFactor > 0 && this.fillFactor <= 100 ? FLAGS.HAS_FILL_FACTOR : 0) | (this.smallLeafs === true ? FLAGS.HAS_SMALL_LEAFS : 0) | FLAGS.HAS_LARGE_PTRS;
    const bytes = [
      0,
      0,
      0,
      0,
      indexTypeFlags,
      this.maxEntriesPerNode
    ];
    writeByteLength(bytes, 0, this.byteLength);
    if (this.fillFactor > 0 && this.fillFactor <= 100) {
      bytes.push(this.fillFactor);
    }
    if (this.freeBytes > 0) {
      writeByteLength(bytes, bytes.length, this.freeBytes);
    }
    if (this.metadataKeys.length > 0) {
      const index = bytes.length;
      bytes.push(0, 0, 0, 0);
      bytes.push(this.metadataKeys.length);
      this.metadataKeys.forEach((key) => {
        bytes.push(key.length);
        for (let i = 0; i < key.length; i++) {
          bytes.push(key.charCodeAt(i));
        }
      });
      const length3 = bytes.length - index - 4;
      writeByteLength(bytes, index, length3);
    }
    return bytes;
  }
  createNode(info, options = { addFreeSpace: true, maxLength: 0 }) {
    assert(info.entries.length > 0, "node has no entries!");
    const bytes = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    bytes.push(info.entries.length);
    info.entries.forEach((entry) => {
      const keyBytes = BinaryBPlusTreeBuilder.getKeyBytes(entry.key);
      bytes.push(...keyBytes);
      assert(entry.ltIndex >= 0, `node entry "${entry.key}" has ltIndex < 0: ${entry.ltIndex}`);
      const ltChildOffset = entry.ltIndex === 0 ? 0 : entry.ltIndex - 5 - (info.index + bytes.length);
      assert(options.allowMissingChildIndexes || ltChildOffset !== 0, "A node entry's ltChildOffset must ALWAYS be set!");
      writeSignedOffset(bytes, bytes.length, ltChildOffset, true);
    });
    const gtChildOffset = info.gtIndex === 0 ? 0 : info.gtIndex - 5 - (info.index + bytes.length);
    assert(options.allowMissingChildIndexes || gtChildOffset !== 0, "A node's gtChildOffset must ALWAYS be set!");
    writeSignedOffset(bytes, bytes.length, gtChildOffset, true);
    let byteLength = bytes.length;
    if (options.maxLength > 0 && byteLength > options.maxLength) {
      throw new DetailedError("max-node-size-reached", `Node byte size (${byteLength}) grew above maximum of ${options.maxLength}`);
    }
    if (options.addFreeSpace) {
      let freeSpace = 0;
      if (options.maxLength > 0) {
        freeSpace = options.maxLength - byteLength;
        byteLength = options.maxLength;
      } else {
        const freeEntries = this.maxEntriesPerNode - info.entries.length;
        const avgEntrySize = Math.ceil((byteLength - 14) / info.entries.length);
        freeSpace = Math.ceil(freeEntries * avgEntrySize * 1.1);
        byteLength += freeSpace;
      }
      for (let i = 0; i < freeSpace; i++) {
        bytes.push(0);
      }
      writeByteLength(bytes, 5, freeSpace);
    }
    writeByteLength(bytes, 0, byteLength);
    return bytes;
  }
  createLeaf(info, options = { addFreeSpace: true }) {
    let hasExtData = typeof info.extData === "object" && info.extData.length > 0;
    const bytes = new Uint8ArrayBuilder([
      0,
      0,
      0,
      0,
      FLAGS.IS_LEAF | (hasExtData ? FLAGS.LEAF_HAS_EXT_DATA : 0),
      0,
      0,
      0,
      0
    ]);
    const leafFlagsIndex = 4;
    const prevLeafOffset = info.prevIndex === 0 ? 0 : info.prevIndex - (info.index + 9);
    bytes.writeInt48(prevLeafOffset);
    let nextLeafOffset = info.nextIndex === 0 ? 0 : info.nextIndex === "adjacent" ? 0 : info.nextIndex - (info.index + 15);
    bytes.writeInt48(nextLeafOffset);
    const extDataHeaderIndex = bytes.length;
    bytes.push(
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    );
    bytes.push(info.entries.length);
    const moreDataBlocks = [];
    info.entries.forEach((entry) => {
      const keyBytes = BinaryBPlusTreeBuilder.getKeyBytes(entry.key);
      bytes.push(...keyBytes);
      const valLengthIndex = bytes.length;
      if (hasExtData && info.extData.rebuild && entry.extData && !entry.extData.loaded) {
        throw new DetailedError("ext-data-not-loaded", "extData cannot be rebuilt if an entry's extData isn't loaded");
      }
      if (hasExtData && entry.extData && !info.extData.rebuild) {
        bytes.push(FLAGS.ENTRY_HAS_EXT_DATA);
        if (!this.uniqueKeys) {
          bytes.writeUint32(entry.extData.totalValues);
        }
        bytes.writeUint32(entry.extData.leafOffset);
        return;
      } else if (this.smallLeafs) {
        bytes.push(0);
      } else {
        bytes.push(0, 0, 0, 0);
      }
      const valueBytes = new Uint8ArrayBuilder([]);
      const addValue = (entryValue) => {
        const { recordPointer, metadata } = entryValue;
        valueBytes.push(recordPointer.length);
        valueBytes.append(recordPointer);
        this.metadataKeys.forEach((key) => {
          const metadataValue = metadata[key];
          const mdBytes = BinaryBPlusTreeBuilder.getKeyBytes(metadataValue);
          valueBytes.append(mdBytes);
        });
      };
      if (this.uniqueKeys) {
        addValue(entry.values[0]);
      } else {
        entry.values.forEach((entryValue) => {
          addValue(entryValue);
        });
      }
      if (this.smallLeafs && valueBytes.length > MAX_SMALL_LEAF_VALUE_LENGTH) {
        if (!this.uniqueKeys) {
          bytes.writeUint32(entry.values.length);
        }
        const extPointerIndex = bytes.length;
        bytes.push(0, 0, 0, 0);
        bytes.data[valLengthIndex] = FLAGS.ENTRY_HAS_EXT_DATA;
        if (hasExtData && !info.extData.rebuild) {
          assert(typeof options.addExtData === "function", "to add ext_data to existing leaf, provide addExtData function to options");
          const { extIndex } = options.addExtData(extPointerIndex, valueBytes.data);
          bytes.writeUint32(extIndex, extPointerIndex);
        } else {
          moreDataBlocks.push({
            pointerIndex: extPointerIndex,
            bytes: valueBytes
          });
        }
      } else {
        const valLength = valueBytes.length + (this.uniqueKeys ? 0 : 4);
        if (this.smallLeafs) {
          bytes.data[valLengthIndex] = valLength;
        } else {
          bytes.writeUint32(valLength, valLengthIndex);
        }
        if (!this.uniqueKeys) {
          bytes.writeUint32(entry.values.length);
        }
        bytes.append(valueBytes);
      }
    });
    if (moreDataBlocks.length > 0) {
      if (!hasExtData && typeof options.maxLength === "number" && options.maxLength > 0) {
        const minExtDataLength = options.addFreeSpace ? Math.ceil(moreDataBlocks.reduce((length3, block) => length3 + 8 + Math.ceil(block.bytes.length * 1.1), 0) * 1.1) : moreDataBlocks.reduce((length3, block) => length3 + 8 + block.bytes.length, 0);
        const freeBytes = options.maxLength - bytes.length;
        if (freeBytes < minExtDataLength) {
          throw new DetailedError("leaf-too-small-for-extdata", "leaf needs rebuild: not enough free space to extend leaf with ext_data");
        }
        options.maxLength -= minExtDataLength;
        info.extData = {
          length: minExtDataLength
        };
      }
      hasExtData = true;
      bytes.data[leafFlagsIndex] |= FLAGS.LEAF_HAS_EXT_DATA;
    }
    if (!hasExtData) {
      bytes.data[leafFlagsIndex] &= ~FLAGS.LEAF_HAS_EXT_DATA;
      bytes.splice(extDataHeaderIndex, 8);
    }
    let byteLength = bytes.length;
    if (options.maxLength > 0 && byteLength > options.maxLength) {
      throw new DetailedError("max-leaf-size-reached", `leaf byte size grew above maximum of ${options.maxLength}`);
    }
    let freeSpace = 0;
    if (options.addFreeSpace) {
      if (options.maxLength > 0) {
        freeSpace = options.maxLength - byteLength;
        byteLength = options.maxLength;
      } else {
        const freeEntries = this.maxEntriesPerNode - info.entries.length;
        const avgEntrySize = info.entries.length === 0 ? 1 : Math.ceil((byteLength - 18) / info.entries.length);
        freeSpace = Math.ceil(freeEntries * avgEntrySize * 1.1);
        byteLength += freeSpace;
      }
      bytes.append(new Uint8Array(freeSpace));
      bytes.writeUint32(freeSpace, 5);
    }
    bytes.writeUint32(byteLength, 0);
    if (moreDataBlocks.length > 0) {
      const fbm = options.addFreeSpace ? 0.1 : 0;
      const maxEntries = this.maxEntriesPerNode;
      const extDataSize = {
        minimum: moreDataBlocks.reduce((total, block) => total + 8 + block.bytes.length + Math.ceil(block.bytes.length * fbm), 0),
        get average() {
          return Math.ceil(this.minimum * (1 + fbm));
        },
        get ideal() {
          const avgExtBlockSize = Math.ceil(this.minimum / moreDataBlocks.length);
          const extDataValueRatio = moreDataBlocks.length / info.entries.length;
          const idealSize = Math.ceil(maxEntries * extDataValueRatio) * avgExtBlockSize;
          return idealSize;
        },
        used: 0
      };
      extDataSize.used = info.extData ? info.extData.length : extDataSize.ideal;
      if (info.extData && info.extData.length < extDataSize.minimum) {
        let bytesShort = extDataSize.ideal - info.extData.length;
        extDataSize.used = extDataSize.ideal;
        if (freeSpace < bytesShort) {
          bytesShort = extDataSize.average - info.extData.length;
          extDataSize.used = extDataSize.average;
        }
        if (freeSpace < bytesShort) {
          bytesShort = extDataSize.minimum - info.extData.length;
          extDataSize.used = extDataSize.minimum;
        }
        if (freeSpace >= bytesShort) {
          byteLength -= bytesShort;
          freeSpace -= bytesShort;
          bytes.writeUint32(byteLength, 0);
          bytes.writeUint32(freeSpace, 5);
          bytes.splice(bytes.length - bytesShort);
          info.extData.length += bytesShort;
        } else {
          throw new DetailedError("max-leaf-extdata-size-reached", `leaf extdata grows larger than the ${info.extData.length} bytes available to it`);
        }
      }
      const leafEndIndex = bytes.length;
      bytes.reserve(extDataSize.used);
      while (moreDataBlocks.length > 0) {
        const block = moreDataBlocks.shift();
        const offset = bytes.length - leafEndIndex;
        bytes.writeUint32(offset, block.pointerIndex);
        const free = options.addFreeSpace ? Math.ceil(block.bytes.length * fbm) : 0;
        const blockLength = block.bytes.length + free;
        bytes.writeUint32(blockLength);
        bytes.writeUint32(free);
        bytes.append(block.bytes.data);
        bytes.append(new Uint8Array(free));
      }
      const extByteLength = bytes.length - leafEndIndex;
      const extFreeByteLength = info.extData ? info.extData.length - extByteLength : options.addFreeSpace ? extDataSize.used - extByteLength : 0;
      hasExtData = true;
      if (info.extData) {
        info.extData.freeBytes = extFreeByteLength;
      } else {
        info.extData = {
          length: extByteLength + extFreeByteLength,
          freeBytes: extFreeByteLength
        };
      }
      bytes.append(new Uint8Array(extFreeByteLength));
      byteLength = bytes.length;
    } else if (hasExtData) {
      byteLength += info.extData.length;
    }
    if (hasExtData) {
      bytes.data[leafFlagsIndex] |= FLAGS.LEAF_HAS_EXT_DATA;
      bytes.writeUint32(info.extData.length, extDataHeaderIndex);
      bytes.writeUint32(info.extData.freeBytes, extDataHeaderIndex + 4);
    }
    if (info.nextIndex === "adjacent") {
      nextLeafOffset = byteLength - 15;
      bytes.writeInt48(nextLeafOffset, 15);
    }
    return bytes.data;
  }
  getLeafEntryValueBytes(recordPointer, metadata) {
    const bytes = [];
    bytes.push(recordPointer.length);
    bytes.push(...recordPointer);
    this.metadataKeys.forEach((key) => {
      const metadataValue = metadata[key];
      const valueBytes = BPlusTree.getBinaryKeyData(metadataValue);
      bytes.push(...valueBytes);
    });
    return bytes;
  }
  static getKeyBytes(key) {
    let keyBytes = [];
    let keyType = KEY_TYPE.UNDEFINED;
    switch (typeof key) {
      case "undefined": {
        keyType = KEY_TYPE.UNDEFINED;
        break;
      }
      case "string": {
        keyType = KEY_TYPE.STRING;
        keyBytes = Array.from(encodeString2(key));
        assert(keyBytes.length < 256, `key byte size for "${key}" is too large, max is 255`);
        break;
      }
      case "number": {
        keyType = KEY_TYPE.NUMBER;
        keyBytes = numberToBytes2(key);
        while (keyBytes[keyBytes.length - 1] === 0) {
          keyBytes.pop();
        }
        break;
      }
      case "bigint": {
        keyType = KEY_TYPE.BIGINT;
        keyBytes = bigintToBytes2(key);
        break;
      }
      case "boolean": {
        keyType = KEY_TYPE.BOOLEAN;
        keyBytes = [key ? 1 : 0];
        break;
      }
      case "object": {
        if (key instanceof Date) {
          keyType = KEY_TYPE.DATE;
          keyBytes = numberToBytes2(key.getTime());
        } else if (key === null) {
          keyType = KEY_TYPE.UNDEFINED;
        } else {
          throw new DetailedError("invalid-object-key-type", `Unsupported object key type: ${key}`);
        }
        break;
      }
      default: {
        throw new DetailedError("invalid-key-type", `Unsupported key type: ${typeof key}`);
      }
    }
    const bytes = [];
    bytes.push(keyType);
    bytes.push(keyBytes.length);
    bytes.push(...keyBytes);
    return bytes;
  }
};

// node_modules/acebase/dist/esm/btree/binary-writer.js
var { numberToBytes: numberToBytes3, bytesToNumber: bytesToNumber2 } = utils_exports;
var BinaryWriter = class {
  constructor(stream4, writeFn) {
    this._stream = stream4;
    this._write = writeFn;
    this._written = 0;
  }
  static forArray(bytes) {
    let bytesWritten = 0;
    const stream4 = {
      get bytesWritten() {
        return bytesWritten;
      },
      write(data) {
        for (let i = 0; i < data.byteLength; i++) {
          bytes.push(data[i]);
        }
        bytesWritten += data.byteLength;
        return true;
      },
      end(callback) {
        callback();
        return this;
      },
      once(event, callback) {
        if (event === "drain") {
          callback();
        }
        return this;
      }
    };
    const writer = new BinaryWriter(stream4, async (data, position) => {
      for (let i = bytes.length; i < position; i++) {
        bytes[i] = 0;
      }
      for (let i = 0; i < data.byteLength; i++) {
        bytes[position + i] = data[i];
      }
    });
    return writer;
  }
  static forUint8ArrayBuilder(builder) {
    let bytesWritten = 0;
    const stream4 = {
      get bytesWritten() {
        return bytesWritten;
      },
      write(data) {
        builder.append(data);
        bytesWritten += data.byteLength;
        return true;
      },
      end(callback) {
        callback();
        return this;
      },
      once(event, callback) {
        if (event === "drain") {
          callback();
        }
        return this;
      }
    };
    const writer = new BinaryWriter(stream4, async (data, position) => {
      builder.write(data, position);
    });
    return writer;
  }
  static forFunction(writeFn) {
    const maxSimultaniousWrites = 50;
    let currentPosition = 0;
    let bytesWritten = 0;
    let pendingWrites = 0;
    const drainCallbacks = [];
    let endCallback = null;
    let ended = false;
    const stream4 = {
      get bytesWritten() {
        return bytesWritten;
      },
      write(data) {
        assert(!ended, "streaming was ended already!");
        if (pendingWrites === maxSimultaniousWrites) {
          console.warn('Warning: you should wait for "drain" event before writing new data!');
        }
        pendingWrites++;
        const success = () => {
          bytesWritten += data.byteLength;
          pendingWrites--;
          if (ended && pendingWrites === 0) {
            endCallback();
          }
          const drainCallback = drainCallbacks.shift();
          drainCallback && drainCallback();
        };
        const fail = (err) => {
          console.error(`Failed to write to stream: ${err.message}`);
          success();
        };
        writeFn(data, currentPosition).then(success).catch(fail);
        currentPosition += data.byteLength;
        const ok = pendingWrites < maxSimultaniousWrites;
        return ok;
      },
      end(callback) {
        if (ended) {
          throw new Error("end can only be called once");
        }
        ended = true;
        endCallback = callback;
        if (pendingWrites === 0) {
          callback();
        }
        return this;
      },
      once(event, callback) {
        assert(event === "drain", 'Custom stream can only handle "drain" event');
        drainCallbacks.push(callback);
        return this;
      }
    };
    const writer = new BinaryWriter(stream4, (data, position) => {
      return writeFn(data, position);
    });
    return writer;
  }
  get length() {
    return this._written;
  }
  get queued() {
    return this._written - this._stream.bytesWritten;
  }
  append(data) {
    const buffer = data instanceof Array ? Uint8Array.from(data) : data;
    return new Promise((resolve) => {
      const ok = this._stream.write(buffer);
      this._written += buffer.byteLength;
      if (!ok) {
        this._stream.once("drain", resolve);
      } else {
        resolve();
      }
    });
  }
  write(data, position) {
    const buffer = data instanceof Array ? Uint8Array.from(data) : data;
    return this._write(buffer, position);
  }
  end() {
    return new Promise((resolve) => {
      this._stream.end(resolve);
    });
  }
  static getBytes(value) {
    return BinaryBPlusTreeBuilder.getKeyBytes(value);
  }
  static numberToBytes(number) {
    return numberToBytes3(number);
  }
  static bytesToNumber(bytes) {
    return bytesToNumber2(bytes);
  }
  static writeUint32(number, bytes, index) {
    return writeByteLength(bytes, index, number);
  }
  static writeInt32(signedNumber, bytes, index) {
    return writeSignedNumber(bytes, index, signedNumber);
  }
};

// node_modules/acebase/dist/esm/btree/tree-leaf-entry-value.js
var BPlusTreeLeafEntryValue = class {
  constructor(recordPointer, metadata) {
    this.recordPointer = recordPointer;
    this.metadata = metadata;
  }
  get value() {
    return this.recordPointer;
  }
};

// node_modules/acebase/dist/esm/btree/tree-leaf-entry.js
var BPlusTreeLeafEntry = class {
  constructor(leaf, key, value) {
    this.leaf = leaf;
    this.key = key;
    if (typeof value !== "undefined" && !(value instanceof BPlusTreeLeafEntryValue)) {
      throw new Error("value must be an instance of BPlusTreeLeafEntryValue");
    }
    this.values = typeof value === "undefined" ? [] : [value];
  }
};

// node_modules/acebase/dist/esm/btree/tree-node-entry.js
var BPlusTreeNodeEntry = class {
  constructor(node, key) {
    this.node = node;
    this.key = key;
    this.ltChild = null;
  }
};

// node_modules/acebase/dist/esm/btree/typesafe-compare.js
function _getComparibleValue(val) {
  if (typeof val === "undefined" || val === null) {
    val = null;
  } else if (val instanceof Date) {
    val = val.getTime();
  }
  return val;
}
function _isEqual(val1, val2) {
  val1 = _getComparibleValue(val1);
  val2 = _getComparibleValue(val2);
  if (typeof val1 !== typeof val2) {
    return false;
  }
  return val1 === val2;
}
function _isNotEqual(val1, val2) {
  val1 = _getComparibleValue(val1);
  val2 = _getComparibleValue(val2);
  if (typeof val1 !== typeof val2) {
    return true;
  }
  return val1 != val2;
}
function _isLess(val1, val2) {
  val1 = _getComparibleValue(val1);
  val2 = _getComparibleValue(val2);
  if (val2 === null) {
    return false;
  }
  if (val1 === null) {
    return val2 !== null;
  }
  if (typeof val1 !== typeof val2) {
    return typeof val1 < typeof val2;
  }
  return val1 < val2;
}
function _isLessOrEqual(val1, val2) {
  val1 = _getComparibleValue(val1);
  val2 = _getComparibleValue(val2);
  if (val1 === null) {
    return true;
  } else if (val2 === null) {
    return false;
  }
  if (typeof val1 !== typeof val2) {
    return typeof val1 < typeof val2;
  }
  return val1 <= val2;
}
function _isMore(val1, val2) {
  val1 = _getComparibleValue(val1);
  val2 = _getComparibleValue(val2);
  if (val1 === null) {
    return false;
  } else if (val2 === null) {
    return true;
  }
  if (typeof val1 !== typeof val2) {
    return typeof val1 > typeof val2;
  }
  return val1 > val2;
}
function _isMoreOrEqual(val1, val2) {
  val1 = _getComparibleValue(val1);
  val2 = _getComparibleValue(val2);
  if (val1 === null) {
    return val2 === null;
  } else if (val2 === null) {
    return true;
  }
  if (typeof val1 !== typeof val2) {
    return typeof val1 > typeof val2;
  }
  return val1 >= val2;
}
function _sortCompare(val1, val2) {
  val1 = _getComparibleValue(val1);
  val2 = _getComparibleValue(val2);
  if (val1 === null && val2 !== null) {
    return -1;
  }
  if (val1 !== null && val2 === null) {
    return 1;
  }
  if (typeof val1 !== typeof val2) {
    if (typeof val1 < typeof val2) {
      return -1;
    }
    if (typeof val1 > typeof val2) {
      return 1;
    }
  }
  if (val1 < val2) {
    return -1;
  }
  if (val1 > val2) {
    return 1;
  }
  return 0;
}
function _compareBinary(val1, val2) {
  return val1.length === val2.length && val1.every((byte, index) => val2[index] === byte);
}

// node_modules/acebase/dist/esm/btree/tree-node.js
var BPlusTreeNode = class {
  constructor(tree, parent) {
    this.tree = tree;
    this.parent = parent;
    this.entries = [];
    this.gtChild = null;
  }
  toString() {
    let str = "Node: [" + this.entries.map((entry) => entry.key).join(" | ") + "]";
    str += " --> ";
    str += this.entries.map((entry) => entry.ltChild.toString()).join(", ");
    str += ", " + this.gtChild.toString();
    return str;
  }
  insertKey(newKey, fromLeaf, newLeaf) {
    if (this.entries.findIndex((entry) => _isEqual(entry.key, newKey)) >= 0) {
      throw new DetailedError("node-key-exists", `Key ${newKey} is already present in node`);
    }
    const newNodeEntry = new BPlusTreeNodeEntry(this, newKey);
    if (this.gtChild === fromLeaf) {
      newNodeEntry.ltChild = fromLeaf;
      this.gtChild = newLeaf;
      this.entries.push(newNodeEntry);
    } else {
      const oldNodeEntry = this.entries.find((entry) => entry.ltChild === fromLeaf);
      const insertIndex = this.entries.indexOf(oldNodeEntry);
      newNodeEntry.ltChild = fromLeaf;
      oldNodeEntry.ltChild = newLeaf;
      this.entries.splice(insertIndex, 0, newNodeEntry);
    }
    this._checkSize();
  }
  _checkSize() {
    if (this.entries.length > this.tree.maxEntriesPerNode) {
      const splitIndex = Math.ceil(this.tree.maxEntriesPerNode / 2);
      const moveEntries = this.entries.splice(splitIndex);
      const moveUpEntry = moveEntries.shift();
      const ltChild = moveUpEntry.ltChild;
      moveUpEntry.ltChild = this;
      const gtChild = this.gtChild;
      this.gtChild = ltChild;
      if (this.parent === null) {
        const newRoot = new BPlusTreeNode(this.tree, null);
        newRoot.entries = [moveUpEntry];
        const newSibling = new BPlusTreeNode(this.tree, newRoot);
        newSibling.entries = moveEntries;
        moveEntries.forEach((entry) => entry.ltChild.parent = newSibling);
        newRoot.gtChild = newSibling;
        newSibling.gtChild = gtChild;
        gtChild.parent = newSibling;
        this.parent = newRoot;
        this.tree.root = newRoot;
        this.tree.depth++;
      } else {
        const newSibling = new BPlusTreeNode(this.tree, this.parent);
        newSibling.entries = moveEntries;
        moveEntries.forEach((entry) => entry.ltChild.parent = newSibling);
        newSibling.gtChild = gtChild;
        gtChild.parent = newSibling;
        const insertIndex = this.parent.entries.findIndex((entry) => _isMore(entry.key, moveUpEntry.key));
        if (insertIndex < 0) {
          this.parent.entries.push(moveUpEntry);
          this.parent.gtChild = newSibling;
        } else {
          const insertBefore = this.parent.entries[insertIndex];
          insertBefore.ltChild = newSibling;
          this.parent.entries.splice(insertIndex, 0, moveUpEntry);
        }
        this.parent._checkSize();
      }
    }
  }
  async toBinary(keepFreeSpace, writer) {
    const bytes = [];
    const startIndex = writer.length;
    bytes.push(0, 0, 0, 0);
    bytes.push(0);
    bytes.push(0, 0, 0, 0);
    bytes.push(this.entries.length);
    const pointers = [];
    const references = [];
    this.entries.forEach((entry) => {
      const keyBytes = BPlusTree.getBinaryKeyData(entry.key);
      bytes.push(...keyBytes);
      const index2 = startIndex + bytes.length;
      bytes.push(0, 0, 0, 0, 0, 0);
      references.push({ name: `<${entry.key}`, index: index2, target: entry.ltChild });
    });
    const index = startIndex + bytes.length;
    bytes.push(0, 0, 0, 0, 0, 0);
    references.push({ name: `>${this.entries[this.entries.length - 1].key}`, index, target: this.gtChild });
    let freeBytes = 0;
    if (keepFreeSpace) {
      const avgEntrySize = Math.ceil(bytes.length / this.entries.length);
      const freeEntries = this.tree.maxEntriesPerNode - this.entries.length;
      freeBytes = freeEntries * avgEntrySize;
      for (let i = 0; i < freeBytes; i++) {
        bytes.push(0);
      }
      writeByteLength(bytes, 5, freeBytes);
    }
    writeByteLength(bytes, 0, bytes.length);
    await writer.append(bytes);
    for (let childIndex = 0; childIndex < this.entries.length + 1; childIndex++) {
      const entry = this.entries[childIndex];
      const childNode = entry ? entry.ltChild : this.gtChild;
      const name = entry ? `<${entry.key}` : `>=${this.entries[this.entries.length - 1].key}`;
      const index2 = writer.length;
      const refIndex = references.findIndex((ref2) => ref2.target === childNode);
      const ref = references.splice(refIndex, 1)[0];
      const offset = index2 - (ref.index + 5);
      const child_ptr = writeSignedOffset([], 0, offset, true);
      await writer.write(child_ptr, ref.index);
      const child = await childNode.toBinary(keepFreeSpace, writer);
      if (childNode instanceof BPlusTreeLeaf) {
        pointers.push({
          name,
          leaf: childNode,
          index: index2
        });
      }
      child.pointers?.forEach((pointer) => {
        pointers.push(pointer);
      });
      child.references.forEach((ref2) => {
        references.push(ref2);
      });
    }
    await BPlusTreeNode.resolveBinaryReferences(writer, references, pointers);
    return { references, pointers };
  }
  static async resolveBinaryReferences(writer, references, pointers) {
    for (let pointerIndex = 0; pointerIndex < pointers.length; pointerIndex++) {
      const pointer = pointers[pointerIndex];
      let i;
      while ((i = references.findIndex((ref) => ref.target === pointer.leaf)) >= 0) {
        const ref = references.splice(i, 1)[0];
        const offset = pointer.index - ref.index;
        const bytes = writeSignedOffset([], 0, offset, true);
        await writer.write(bytes, ref.index);
      }
    }
  }
};

// node_modules/acebase/dist/esm/btree/utils.js
function _checkNewEntryArgs(key, recordPointer, metadataKeys, metadata) {
  const storageTypesText = "supported types are string, number, boolean, Date and undefined";
  const isStorableType = (val) => {
    return ["number", "string", "boolean", "bigint", "undefined"].includes(typeof val) || val instanceof Date;
  };
  if (!isStorableType(key)) {
    return new TypeError(`key contains a value that cannot be stored. ${storageTypesText}`);
  }
  if (!(recordPointer instanceof Array || recordPointer instanceof Uint8Array)) {
    return new TypeError("recordPointer must be a byte array or Uint8Array");
  }
  if (recordPointer.length > 255) {
    return new Error("Unable to store recordPointers larger than 255 bytes");
  }
  try {
    metadataKeys && metadataKeys.forEach((key2) => {
      if (!(key2 in metadata)) {
        throw new TypeError(`metadata must include key "${key2}"`);
      }
      if (!isStorableType(typeof metadata[key2])) {
        throw new TypeError(`metadata "${key2}" contains a value that cannot be stored. ${storageTypesText}`);
      }
    });
  } catch (err) {
    return err;
  }
}
var _appendToArray = (targetArray, arr2) => {
  const n = 255;
  let start = 0;
  while (start < arr2.length) {
    targetArray.push(...arr2.slice(start, start + n));
    start += n;
  }
};

// node_modules/acebase/dist/esm/btree/tree-leaf.js
var BPlusTreeLeaf = class {
  constructor(parent) {
    this.parent = parent;
    this.entries = [];
    this.prevLeaf = null;
    this.nextLeaf = null;
  }
  get tree() {
    return this.parent instanceof BPlusTree ? this.parent : this.parent.tree;
  }
  add(key, recordPointer, metadata) {
    if (typeof recordPointer === "string") {
      console.warn(`WARNING: converting recordPointer "${recordPointer}" to byte array. This is deprecated, will fail in the future`);
      const bytes = [];
      for (let i = 0; i < recordPointer.length; i++) {
        bytes.push(recordPointer.charCodeAt(i));
      }
      recordPointer = bytes;
    }
    const err = _checkNewEntryArgs(key, recordPointer, this.tree.metadataKeys, metadata);
    if (err) {
      throw err;
    }
    const entryValue = new BPlusTreeLeafEntryValue(recordPointer, metadata);
    const entryIndex = this.entries.findIndex((entry2) => _isEqual(entry2.key, key));
    if (entryIndex >= 0) {
      if (this.tree.uniqueKeys) {
        throw new DetailedError("duplicate-node-key", `Cannot insert duplicate key ${key}`);
      }
      const entry2 = this.entries[entryIndex];
      entry2.values.push(entryValue);
      return entry2;
    }
    const entry = new BPlusTreeLeafEntry(this, key, entryValue);
    if (this.entries.length === 0) {
      this.entries.push(entry);
    } else {
      const insertIndex = this.entries.findIndex((otherEntry) => _isMore(otherEntry.key, entry.key));
      if (insertIndex < 0) {
        this.entries.push(entry);
      } else {
        this.entries.splice(insertIndex, 0, entry);
      }
      if (this.entries.length > this.tree.maxEntriesPerNode) {
        const splitIndex = Math.ceil(this.tree.maxEntriesPerNode / 2);
        const moveEntries = this.entries.splice(splitIndex);
        const copyUpKey = moveEntries[0].key;
        if (this.parent instanceof BPlusTree) {
          const tree = this.parent;
          this.parent = new BPlusTreeNode(tree, null);
          tree.root = this.parent;
          tree.depth = 2;
          const newLeaf = new BPlusTreeLeaf(this.parent);
          newLeaf.entries = moveEntries;
          const newEntry = new BPlusTreeNodeEntry(this.parent, copyUpKey);
          newEntry.ltChild = this;
          this.parent.gtChild = newLeaf;
          this.parent.entries = [newEntry];
          newLeaf.prevLeaf = this;
          if (this.nextLeaf) {
            newLeaf.nextLeaf = this.nextLeaf;
            newLeaf.nextLeaf.prevLeaf = newLeaf;
          }
          this.nextLeaf = newLeaf;
        } else {
          const newLeaf = new BPlusTreeLeaf(this.parent);
          newLeaf.entries = moveEntries;
          this.parent.insertKey(copyUpKey, this, newLeaf);
          newLeaf.prevLeaf = this;
          if (this.nextLeaf) {
            newLeaf.nextLeaf = this.nextLeaf;
            newLeaf.nextLeaf.prevLeaf = newLeaf;
          }
          this.nextLeaf = newLeaf;
        }
      }
    }
    return entry;
  }
  toString() {
    const str = "Leaf: [" + this.entries.map((entry) => entry.key).join(" | ") + "]";
    return str;
  }
  async toBinary(keepFreeSpace = false, writer) {
    assert(this.entries.every((entry, index, arr) => index === 0 || _isMore(entry.key, arr[index - 1].key)), "Leaf entries are not sorted ok");
    const bytes = [];
    const startIndex = writer.length;
    bytes.push(0, 0, 0, 0);
    const leafFlagsIndex = bytes.length;
    bytes.push(FLAGS.IS_LEAF);
    bytes.push(0, 0, 0, 0);
    const references = [];
    this.prevLeaf && references.push({ name: `<${this.entries[0].key}`, target: this.prevLeaf, index: startIndex + bytes.length });
    bytes.push(0, 0, 0, 0, 0, 0);
    this.nextLeaf && references.push({ name: `>${this.entries[this.entries.length - 1].key}`, target: this.nextLeaf, index: startIndex + bytes.length });
    bytes.push(0, 0, 0, 0, 0, 0);
    const extDataHeaderIndex = bytes.length;
    bytes.push(
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    );
    bytes.push(this.entries.length);
    const entriesStartIndex = bytes.length;
    const moreDataBlocks = [];
    this.entries.forEach((entry) => {
      assert(entry.values.length <= MAX_LEAF_ENTRY_VALUES, "too many leaf entry values to store in binary");
      const keyBytes = BPlusTree.getBinaryKeyData(entry.key);
      bytes.push(...keyBytes);
      const valLengthIndex = bytes.length;
      if (WRITE_SMALL_LEAFS) {
        bytes.push(0);
      } else {
        bytes.push(0, 0, 0, 0);
      }
      const valueBytes = [];
      const writeValue = (entryValue) => {
        const { recordPointer, metadata } = entryValue;
        valueBytes.push(recordPointer.length);
        valueBytes.push(...recordPointer);
        this.tree.metadataKeys.forEach((key) => {
          const metadataValue = metadata[key];
          const mdBytes = BPlusTree.getBinaryKeyData(metadataValue);
          valueBytes.push(...mdBytes);
        });
      };
      if (this.tree.uniqueKeys) {
        writeValue(entry.values[0]);
      } else {
        entry.values.forEach((entryValue) => {
          writeValue(entryValue);
        });
      }
      if (WRITE_SMALL_LEAFS && valueBytes.length > MAX_SMALL_LEAF_VALUE_LENGTH) {
        if (!this.tree.uniqueKeys) {
          writeByteLength(bytes, bytes.length, entry.values.length);
        }
        const extPointerIndex = bytes.length;
        bytes.push(0, 0, 0, 0);
        bytes[valLengthIndex] = FLAGS.ENTRY_HAS_EXT_DATA;
        moreDataBlocks.push({
          pointerIndex: extPointerIndex,
          bytes: valueBytes
        });
      } else {
        const valLength = valueBytes.length + (this.tree.uniqueKeys ? 0 : 4);
        if (WRITE_SMALL_LEAFS) {
          bytes[valLengthIndex] = valLength;
        } else {
          writeByteLength(bytes, valLengthIndex, valLength);
        }
        if (!this.tree.uniqueKeys) {
          writeByteLength(bytes, bytes.length, entry.values.length);
        }
        _appendToArray(bytes, valueBytes);
      }
    });
    const entriesDataSize = bytes.length - entriesStartIndex;
    const avgBytesPerEntry = this.entries.length === 0 ? 25 : Math.ceil(entriesDataSize / this.entries.length);
    const availableEntries = this.tree.maxEntriesPerNode - this.entries.length;
    const freeBytesLength = keepFreeSpace ? Math.ceil(availableEntries * avgBytesPerEntry * 1.1) : 0;
    for (let i = 0; i < freeBytesLength; i++) {
      bytes.push(0);
    }
    const hasExtData = moreDataBlocks.length > 0;
    if (hasExtData) {
      bytes[leafFlagsIndex] |= FLAGS.LEAF_HAS_EXT_DATA;
    } else {
      bytes.splice(extDataHeaderIndex, 8);
    }
    const totalLeafSize = bytes.length;
    writeByteLength(bytes, 0, totalLeafSize);
    writeByteLength(bytes, 5, freeBytesLength);
    if (hasExtData) {
      const leafEndIndex = bytes.length;
      moreDataBlocks.forEach((block) => {
        const offset = bytes.length - leafEndIndex;
        writeByteLength(bytes, block.pointerIndex, offset);
        const free = keepFreeSpace ? Math.ceil(block.bytes.length * 0.1) : 0;
        const blockLength = block.bytes.length + free;
        writeByteLength(bytes, bytes.length, blockLength);
        writeByteLength(bytes, bytes.length, free);
        bytes.push(0, 0, 0, 0);
        _appendToArray(bytes, block.bytes);
        for (let i = 0; i < free; i++) {
          bytes.push(0);
        }
      });
      const extByteLength = bytes.length - leafEndIndex;
      const extFreeByteLength = keepFreeSpace ? Math.ceil(extByteLength * 0.1) : 0;
      writeByteLength(bytes, extDataHeaderIndex, extByteLength + extFreeByteLength);
      writeByteLength(bytes, extDataHeaderIndex + 4, extFreeByteLength);
      for (let i = 0; i < extFreeByteLength; i++) {
        bytes.push(0);
      }
    }
    await writer.append(bytes);
    return { references };
  }
};

// node_modules/acebase/dist/esm/btree/tree.js
var { bigintToBytes: bigintToBytes3, bytesToBigint: bytesToBigint2, bytesToNumber: bytesToNumber3, decodeString: decodeString2, encodeString: encodeString3, numberToBytes: numberToBytes4 } = utils_exports;
var BPlusTree = class {
  constructor(maxEntriesPerNode, uniqueKeys, metadataKeys = []) {
    this.maxEntriesPerNode = maxEntriesPerNode;
    this.uniqueKeys = uniqueKeys;
    this.metadataKeys = metadataKeys;
    this.root = new BPlusTreeLeaf(this);
    this.depth = 1;
    this.fillFactor = 100;
  }
  add(key, value, metadata) {
    let leaf;
    if (this.root instanceof BPlusTreeLeaf) {
      leaf = this.root;
    } else {
      leaf = this.findLeaf(key);
    }
    leaf.add(key, value, metadata);
    return this;
  }
  findLeaf(key) {
    const findLeaf = (node) => {
      if (node instanceof BPlusTreeLeaf) {
        return node;
      }
      for (let i = 0; i < node.entries.length; i++) {
        const entry = node.entries[i];
        if (_isLess(key, entry.key)) {
          node = entry.ltChild;
          if (!node) {
            return null;
          }
          if (node instanceof BPlusTreeLeaf) {
            return node;
          } else {
            return findLeaf(node);
          }
        }
      }
      assert(_isMoreOrEqual(key, node.entries[node.entries.length - 1].key));
      return findLeaf(node.gtChild);
    };
    return findLeaf(this.root);
  }
  find(key) {
    const leaf = this.findLeaf(key);
    const entry = leaf.entries.find((entry2) => _isEqual(entry2.key, key));
    if (!entry) {
      return null;
    }
    if (this.uniqueKeys) {
      return entry.values[0];
    } else {
      return entry.values;
    }
  }
  search(op, val) {
    if (["in", "!in", "between", "!between"].includes(op) && !(val instanceof Array)) {
      throw new TypeError(`val must be an array when using operator ${op}`);
    } else if (val instanceof Array) {
      throw new TypeError(`val cannot be an array when using operator ${op}`);
    }
    if (["exists", "!exists"].includes(op)) {
      op = op === "exists" ? "!=" : "==";
      val = void 0;
    }
    if (val === null) {
      val = void 0;
    }
    const results = [];
    const add = (entry) => {
      const obj = { key: entry.key };
      if (this.uniqueKeys) {
        obj.value = entry.values[0];
      } else {
        obj.values = entry.values;
      }
      results.push(obj);
    };
    if (["<", "<="].includes(op)) {
      let leaf = this.findLeaf(val);
      while (leaf) {
        for (let i = leaf.entries.length - 1; i >= 0; i--) {
          const entry = leaf.entries[i];
          if (op === "<=" && _isLessOrEqual(entry.key, val)) {
            add(entry);
          } else if (op === "<" && _isLess(entry.key, val)) {
            add(entry);
          }
        }
        leaf = leaf.prevLeaf;
      }
    } else if ([">", ">="].includes(op)) {
      let leaf = this.findLeaf(val);
      while (leaf) {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (op === ">=" && _isMoreOrEqual(entry.key, val)) {
            add(entry);
          } else if (op === ">" && _isMore(entry.key, val)) {
            add(entry);
          }
        }
        leaf = leaf.nextLeaf;
      }
    } else if (op === "==") {
      const leaf = this.findLeaf(val);
      const entry = leaf.entries.find((entry2) => _isEqual(entry2.key, val));
      if (entry) {
        add(entry);
      }
    } else if (op === "!=") {
      let leaf = this.firstLeaf();
      while (leaf) {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (_isNotEqual(entry.key, val)) {
            add(entry);
          }
        }
        leaf = leaf.nextLeaf;
      }
    } else if (op === "in") {
      const sorted = val.slice().sort();
      let searchKey = sorted.shift();
      let leaf;
      let trySameLeaf = false;
      while (searchKey) {
        if (!trySameLeaf) {
          leaf = this.findLeaf(searchKey);
        }
        const entry = leaf.entries.find((entry2) => _isEqual(entry2.key, val));
        if (!entry && trySameLeaf) {
          trySameLeaf = false;
          continue;
        }
        if (entry) {
          add(entry);
        }
        searchKey = sorted.shift();
        trySameLeaf = true;
      }
    } else if (op === "!in") {
      const keys = val;
      let leaf = this.firstLeaf();
      while (leaf) {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (keys.findIndex((val2) => _isEqual(entry.key, val2)) < 0) {
            add(entry);
          }
        }
        leaf = leaf.nextLeaf;
      }
    } else if (op === "between") {
      const keys = val;
      let bottom = keys[0], top = keys[1];
      if (top < bottom) {
        const swap2 = top;
        top = bottom;
        bottom = swap2;
      }
      let leaf = this.findLeaf(bottom);
      let stop = false;
      while (!stop && leaf) {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (_isMoreOrEqual(entry.key, bottom) && _isLessOrEqual(entry.key, top)) {
            add(entry);
          }
          if (_isMore(entry.key, top)) {
            stop = true;
            break;
          }
        }
        leaf = leaf.nextLeaf;
      }
    } else if (op === "!between") {
      const keys = val;
      let bottom = keys[0], top = keys[1];
      if (top < bottom) {
        const swap2 = top;
        top = bottom;
        bottom = swap2;
      }
      let leaf = this.firstLeaf();
      let stop = false;
      while (leaf && !stop) {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (_isLess(entry.key, bottom)) {
            add(entry);
          } else {
            stop = true;
            break;
          }
        }
        leaf = leaf.nextLeaf;
      }
      leaf = this.findLeaf(top);
      while (leaf) {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (_isMore(entry.key, top)) {
            add(entry);
          }
        }
        leaf = leaf.nextLeaf;
      }
    }
    return results;
  }
  firstLeaf() {
    let node = this.root;
    while (!(node instanceof BPlusTreeLeaf)) {
      node = node.entries[0].ltChild;
    }
    return node;
  }
  lastLeaf() {
    let node = this.root;
    while (!(node instanceof BPlusTreeLeaf)) {
      node = node.gtChild;
    }
    return node;
  }
  all() {
    let leaf = this.firstLeaf();
    const all3 = [];
    while (leaf) {
      all3.push(...leaf.entries.map((entry) => entry.key));
      leaf = leaf.nextLeaf;
    }
    return all3;
  }
  reverseAll() {
    let leaf = this.lastLeaf();
    const all3 = [];
    while (leaf) {
      all3.push(...leaf.entries.map((entry) => entry.key));
      leaf = leaf.prevLeaf;
    }
    return all3;
  }
  static get debugBinary() {
    return false;
  }
  static addBinaryDebugString(str, byte) {
    if (this.debugBinary) {
      return [str, byte];
    } else {
      return byte;
    }
  }
  static getKeyFromBinary(bytes, index) {
    const keyType = bytes[index];
    index++;
    const keyLength = bytes[index];
    index++;
    let keyData = bytes.slice(index, index + keyLength);
    index += keyLength;
    if ([KEY_TYPE.NUMBER, KEY_TYPE.BIGINT, KEY_TYPE.DATE].includes(keyType)) {
      keyData = Array.from(keyData);
    }
    let key;
    switch (keyType) {
      case KEY_TYPE.UNDEFINED: {
        break;
      }
      case KEY_TYPE.STRING: {
        key = decodeString2(keyData);
        break;
      }
      case KEY_TYPE.NUMBER: {
        if (keyData.length < 8) {
          if (keyData instanceof Array) {
            keyData.push(...[0, 0, 0, 0, 0, 0, 0, 0].slice(keyData.length));
          } else {
            throw new Error(`Issue found during TS port: keyData is a Buffer, type is NUMBER and its length < 8, so it needs 0's padding`);
          }
        }
        key = bytesToNumber3(keyData);
        break;
      }
      case KEY_TYPE.BIGINT: {
        key = bytesToBigint2(keyData);
        break;
      }
      case KEY_TYPE.BOOLEAN: {
        key = keyData[0] === 1;
        break;
      }
      case KEY_TYPE.DATE: {
        key = new Date(bytesToNumber3(keyData));
        break;
      }
      default: {
        throw new DetailedError("unknown-key-type", `Unknown key type ${keyType}`);
      }
    }
    return { key, length: keyLength, byteLength: keyLength + 2 };
  }
  static getBinaryKeyData(key) {
    let keyBytes = [];
    let keyType = KEY_TYPE.UNDEFINED;
    switch (typeof key) {
      case "undefined": {
        keyType = KEY_TYPE.UNDEFINED;
        break;
      }
      case "string": {
        keyType = KEY_TYPE.STRING;
        keyBytes = Array.from(encodeString3(key));
        break;
      }
      case "number": {
        keyType = KEY_TYPE.NUMBER;
        keyBytes = numberToBytes4(key);
        while (keyBytes[keyBytes.length - 1] === 0) {
          keyBytes.pop();
        }
        break;
      }
      case "bigint": {
        keyType = KEY_TYPE.BIGINT;
        keyBytes = bigintToBytes3(key);
        break;
      }
      case "boolean": {
        keyType = KEY_TYPE.BOOLEAN;
        keyBytes = [key ? 1 : 0];
        break;
      }
      case "object": {
        if (key instanceof Date) {
          keyType = KEY_TYPE.DATE;
          keyBytes = numberToBytes4(key.getTime());
        } else {
          throw new DetailedError("invalid-object-key-type", "Unsupported object key type");
        }
        break;
      }
      default: {
        throw new DetailedError("invalid-key-type", `Unsupported key type: ${typeof key}`);
      }
    }
    const bytes = [];
    bytes.push(keyType);
    bytes.push(keyBytes.length);
    bytes.push(...keyBytes);
    return bytes;
  }
  async toBinary(keepFreeSpace = false, writer) {
    if (!(writer instanceof BinaryWriter)) {
      throw new Error("writer argument must be an instance of BinaryWriter");
    }
    const indexTypeFlags = (this.uniqueKeys ? FLAGS.UNIQUE_KEYS : 0) | (this.metadataKeys.length > 0 ? FLAGS.HAS_METADATA : 0) | (keepFreeSpace ? FLAGS.HAS_FREE_SPACE : 0) | FLAGS.HAS_FILL_FACTOR | (WRITE_SMALL_LEAFS ? FLAGS.HAS_SMALL_LEAFS : 0) | FLAGS.HAS_LARGE_PTRS;
    const bytes = [
      0,
      0,
      0,
      0,
      indexTypeFlags,
      this.maxEntriesPerNode,
      this.fillFactor
    ];
    if (keepFreeSpace) {
      bytes.push(0, 0, 0, 0);
    }
    if (this.metadataKeys.length > 0) {
      const index = bytes.length;
      bytes.push(0, 0, 0, 0);
      bytes.push(this.metadataKeys.length);
      this.metadataKeys.forEach((key) => {
        bytes.push(key.length);
        for (let i = 0; i < key.length; i++) {
          bytes.push(key.charCodeAt(i));
        }
      });
      const length3 = bytes.length - index - 4;
      writeByteLength(bytes, index, length3);
    }
    const headerLength = bytes.length;
    await writer.append(bytes);
    const { references } = await this.root.toBinary(keepFreeSpace, writer);
    assert(references.length === 0, "All references must be resolved now");
    let freeBytesLength = 0;
    if (keepFreeSpace) {
      freeBytesLength = Math.ceil((writer.length - headerLength) * 0.1);
      const bytesPerWrite = 1024 * 100;
      const writes = Math.ceil(freeBytesLength / bytesPerWrite);
      for (let i = 0; i < writes; i++) {
        const length3 = i + 1 < writes ? bytesPerWrite : freeBytesLength % bytesPerWrite;
        const zeroes = new Uint8Array(length3);
        await writer.append(zeroes);
      }
    }
    const byteLength = writer.length;
    const lbytes = writeByteLength([], 0, byteLength);
    await writer.write(lbytes, 0);
    if (keepFreeSpace) {
      const fbytes = writeByteLength([], 0, freeBytesLength);
      await writer.write(fbytes, 7);
    }
    await writer.end();
  }
  static get typeSafeComparison() {
    return {
      isMore(val1, val2) {
        return _isMore(val1, val2);
      },
      isMoreOrEqual(val1, val2) {
        return _isMoreOrEqual(val1, val2);
      },
      isLess(val1, val2) {
        return _isLess(val1, val2);
      },
      isLessOrEqual(val1, val2) {
        return _isLessOrEqual(val1, val2);
      },
      isEqual(val1, val2) {
        return _isEqual(val1, val2);
      },
      isNotEqual(val1, val2) {
        return _isNotEqual(val1, val2);
      }
    };
  }
};

// node_modules/acebase/dist/esm/btree/binary-reader.js
var { bytesToNumber: bytesToNumber4 } = utils_exports;
var BinaryReader = class {
  constructor(file, chunkSize = 4096) {
    this.chunkSize = chunkSize;
    this.data = null;
    this.offset = 0;
    this.index = 0;
    this.chunkSize = chunkSize;
    if (typeof file === "function") {
      this.read = file;
    } else {
      let fd;
      if (typeof file === "number") {
        fd = file;
      } else if (typeof file === "string") {
        const init = this.init.bind(this);
        this.init = async () => {
          fd = await pfs.open(file, "r");
          return init();
        };
        this.close = async () => {
          return pfs.close(fd);
        };
      } else {
        throw new DetailedError("invalid-file-argument", "invalid file argument");
      }
      this.read = async (index, length3) => {
        const buffer = Buffer.alloc(length3);
        const { bytesRead } = await pfs.read(fd, buffer, 0, length3, index);
        if (bytesRead < length3) {
          return buffer.slice(0, bytesRead);
        }
        return buffer;
      };
    }
  }
  async init() {
    const chunk = await this.read(0, this.chunkSize);
    assert(chunk instanceof Buffer, "read function must return a Buffer");
    this.data = chunk;
    this.offset = 0;
    this.index = 0;
  }
  clone() {
    const clone = Object.assign(new BinaryReader(this.read, this.chunkSize), this);
    clone.offset = 0;
    clone.index = 0;
    clone.data = Buffer.alloc(0);
    return clone;
  }
  async get(byteCount) {
    await this.assert(byteCount);
    const slice = this.data.slice(this.index, this.index + byteCount);
    if (slice.byteLength !== byteCount) {
      throw new DetailedError("invalid_byte_length", `Expected to read ${byteCount} bytes from tree, got ${slice.byteLength}`);
    }
    this.index += byteCount;
    return slice;
  }
  async getInt32() {
    const buffer = await this.get(4);
    return readSignedNumber(buffer, 0);
  }
  async getUint32() {
    const buffer = await this.get(4);
    return readByteLength(buffer, 0);
  }
  async getValue() {
    const header = await this.get(2);
    const length3 = header[1];
    await this.seek(-2);
    const buffer = await this.get(length3 + 2);
    return BinaryReader.readValue(buffer, 0).value;
  }
  async more(chunks = 1) {
    const length3 = chunks * this.chunkSize;
    const nextChunk = await this.read(this.offset + this.data.length, length3);
    assert(nextChunk instanceof Buffer, "read function must return a Buffer");
    this.data = this.data.slice(this.index);
    this.offset += this.index;
    this.index = 0;
    const newData = Buffer.alloc(this.data.length + nextChunk.length);
    newData.set(this.data, 0);
    newData.set(nextChunk, this.data.length);
    this.data = newData;
  }
  async seek(offset) {
    if (this.index + offset < this.data.length) {
      this.index += offset;
    } else {
      const dataIndex = this.offset + this.index + offset;
      const newChunk = await this.read(dataIndex, this.chunkSize);
      this.data = newChunk;
      this.offset = dataIndex;
      this.index = 0;
    }
  }
  async assert(byteCount) {
    if (byteCount < 0) {
      throw new DetailedError("invalid_byte_count", `Cannot read ${byteCount} bytes from tree`);
    }
    if (this.index + byteCount > this.data.byteLength) {
      await this.more(Math.ceil(byteCount / this.chunkSize));
      if (this.index + byteCount > this.data.byteLength) {
        throw new DetailedError("EOF", "end of file");
      }
    }
  }
  skip(byteCount) {
    this.index += byteCount;
  }
  rewind(byteCount) {
    this.index -= byteCount;
  }
  async go(index) {
    if (this.offset <= index && this.offset + this.data.byteLength > index) {
      this.index = index - this.offset;
    } else {
      const chunk = await this.read(index, this.chunkSize);
      this.data = chunk;
      this.offset = index;
      this.index = 0;
    }
  }
  savePosition(offsetCorrection = 0) {
    const savedIndex = this.offset + this.index + offsetCorrection;
    const go = (offset = 0) => {
      const index = savedIndex + offset;
      return this.go(index);
    };
    return {
      go,
      index: savedIndex
    };
  }
  get sourceIndex() {
    return this.offset + this.index;
  }
  static readValue(buffer, index) {
    const arr = buffer;
    const val = BPlusTree.getKeyFromBinary(arr, index);
    return { value: val.key, byteLength: val.byteLength };
  }
  static bytesToNumber(buffer) {
    const arr = buffer;
    return bytesToNumber4(arr);
  }
  static readUint32(buffer, index) {
    return readSignedNumber(buffer, index);
  }
  static readInt32(buffer, index) {
    return readByteLength(buffer, index);
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree-node-info.js
var BinaryBPlusTreeNodeInfo = class {
  constructor(info) {
    this.tree = info.tree;
    this.isLeaf = info.isLeaf;
    this.hasExtData = info.hasExtData || false;
    this.bytes = info.bytes;
    if (typeof info.sourceIndex === "undefined") {
      info.sourceIndex = info.index;
    }
    this.sourceIndex = info.sourceIndex;
    if (typeof info.dataIndex === "undefined") {
      info.dataIndex = this.sourceIndex + 9;
    }
    this.dataIndex = info.dataIndex;
    this.length = info.length;
    this.free = info.free;
    this.parentNode = info.parentNode;
    this.parentEntry = info.parentEntry;
  }
  get index() {
    return this.sourceIndex;
  }
  set index(value) {
    this.sourceIndex = value;
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree-leaf.js
var BinaryBPlusTreeLeaf = class extends BinaryBPlusTreeNodeInfo {
  static get prevLeafPtrIndex() {
    return 9;
  }
  static get nextLeafPtrIndex() {
    return 15;
  }
  static getPrevLeafOffset(leafIndex, prevLeafIndex) {
    return prevLeafIndex > 0 ? prevLeafIndex - leafIndex - 9 : 0;
  }
  static getNextLeafOffset(leafIndex, nextLeafIndex) {
    return nextLeafIndex > 0 ? nextLeafIndex - leafIndex - 15 : 0;
  }
  constructor(nodeInfo) {
    assert(typeof nodeInfo.hasExtData === "boolean", "nodeInfo.hasExtData must be specified");
    super(nodeInfo);
    this.prevLeafOffset = 0;
    this.nextLeafOffset = 0;
    this.extData = {
      length: 0,
      freeBytes: 0,
      loaded: false,
      async load() {
        throw new DetailedError("method-not-overridden", "BinaryBPlusTreeLeaf.extData.load must be overriden");
      }
    };
    this.entries = [];
  }
  get hasPrevious() {
    return typeof this.getPrevious === "function";
  }
  get hasNext() {
    return typeof this.getNext === "function";
  }
  get prevLeafIndex() {
    return this.prevLeafOffset !== 0 ? this.index + 9 + this.prevLeafOffset : 0;
  }
  set prevLeafIndex(newIndex) {
    this.prevLeafOffset = newIndex > 0 ? newIndex - this.index - 9 : 0;
  }
  get nextLeafIndex() {
    return this.nextLeafOffset !== 0 ? this.index + (this.tree.info.hasLargePtrs ? 15 : 13) + this.nextLeafOffset : 0;
  }
  set nextLeafIndex(newIndex) {
    this.nextLeafOffset = newIndex > 0 ? newIndex - this.index - (this.tree.info.hasLargePtrs ? 15 : 13) : 0;
  }
  findEntryIndex(key) {
    return this.entries.findIndex((entry) => _isEqual(entry.key, key));
  }
  findEntry(key) {
    return this.entries[this.findEntryIndex(key)];
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree-leaf-entry.js
var BinaryBPlusTreeLeafEntry = class {
  constructor(key, values) {
    this.key = key;
    this.values = values;
    this.key = key;
    this.values = values;
  }
  get value() {
    return this.values[0];
  }
  get totalValues() {
    if (typeof this._totalValues === "number") {
      return this._totalValues;
    }
    if (this.extData) {
      return this.extData.totalValues;
    }
    return this.values.length;
  }
  set totalValues(nr) {
    this._totalValues = nr;
  }
  async loadValues() {
    throw new Error("entry.loadValues must be overridden if leaf has extData");
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree-leaf-entry-value.js
var BinaryBPlusTreeLeafEntryValue = class {
  constructor(recordPointer, metadata) {
    this.recordPointer = recordPointer;
    this.metadata = metadata;
  }
  get value() {
    return this.recordPointer;
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree-node.js
var BinaryBPlusTreeNode = class extends BinaryBPlusTreeNodeInfo {
  constructor(nodeInfo) {
    super(nodeInfo);
    this.entries = [];
    this.gtChildOffset = null;
  }
  async getGtChild() {
    throw new DetailedError("method-not-overridden", "getGtChild must be overridden");
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree-node-entry.js
var BinaryBPlusTreeNodeEntry = class {
  constructor(key) {
    this.key = key;
    this.ltChildOffset = null;
  }
  async getLtChild() {
    throw new DetailedError("method not overridden", "getLtChild must be overridden");
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree-transaction-operation.js
var BinaryBPlusTreeTransactionOperation = class {
  static add(key, recordPointer, metadata) {
    return new BinaryBPlusTreeTransactionOperation({ type: "add", key, recordPointer, metadata });
  }
  static update(key, newValue, currentValue, metadata) {
    return new BinaryBPlusTreeTransactionOperation({ type: "update", key, newValue, currentValue, metadata });
  }
  static remove(key, recordPointer) {
    return new BinaryBPlusTreeTransactionOperation({ type: "remove", key, recordPointer });
  }
  constructor(operation) {
    this.type = operation.type;
    this.key = operation.key;
    if (operation.type === "add" || operation.type === "remove") {
      this.recordPointer = operation.recordPointer;
    }
    if (operation.type === "add") {
      this.metadata = operation.metadata;
    }
    if (operation.type === "update") {
      this.newValue = operation.newValue;
      this.currentValue = operation.currentValue;
    }
  }
};

// node_modules/acebase/dist/esm/btree/tree-builder.js
var BPlusTreeBuilder = class {
  constructor(uniqueKeys, fillFactor = 100, metadataKeys = []) {
    this.uniqueKeys = uniqueKeys;
    this.fillFactor = fillFactor;
    this.metadataKeys = metadataKeys;
    this.list = /* @__PURE__ */ new Map();
    this.indexedValues = 0;
  }
  add(key, recordPointer, metadata) {
    const err = _checkNewEntryArgs(key, recordPointer, this.metadataKeys, metadata);
    if (err) {
      throw err;
    }
    const entryValue = new BPlusTreeLeafEntryValue(recordPointer, metadata);
    const existing = this.list.get(key);
    if (this.uniqueKeys && typeof existing !== "undefined") {
      throw new DetailedError("unique-key-violation", `Cannot add duplicate key "${key}", tree must have unique keys`);
    } else if (existing) {
      existing.push(entryValue);
    } else {
      this.list.set(key, this.uniqueKeys ? entryValue : [entryValue]);
    }
    this.indexedValues++;
  }
  remove(key, recordPointer) {
    const isEqual = (val1, val2) => {
      if (val1 instanceof Array && val2 instanceof Array) {
        return val1.every((v, i) => val2[i] === v);
      }
      return val1 === val2;
    };
    if (this.uniqueKeys) {
      this.list.delete(key);
    } else {
      const entryValues = this.list.get(key);
      const valIndex = entryValues.findIndex((entryValue) => isEqual(entryValue.recordPointer, recordPointer));
      if (~valIndex) {
        if (entryValues.length === 1) {
          this.list.delete(key);
        } else {
          entryValues.splice(valIndex, 1);
        }
      }
    }
  }
  create(maxEntries) {
    const list = [];
    this.list.forEach((val, key) => {
      list.push({ key, val });
    });
    this.list.clear();
    this.list = null;
    list.sort((a, b) => {
      return _sortCompare(a.key, b.key);
    });
    const minNodeSize = 3;
    const maxNodeSize = 255;
    const entriesPerNode = typeof maxEntries === "number" ? maxEntries : Math.min(maxNodeSize, Math.max(minNodeSize, Math.ceil(list.length / 10)));
    const entriesPerLeaf = Math.max(minNodeSize, Math.floor(entriesPerNode * (this.fillFactor / 100)));
    const minParentEntries = Math.max(1, Math.floor(entriesPerNode / 2));
    const tree = new BPlusTree(entriesPerNode, this.uniqueKeys, this.metadataKeys);
    tree.fillFactor = this.fillFactor;
    const nrOfLeafs = Math.max(1, Math.ceil(list.length / entriesPerLeaf));
    const parentConnections = entriesPerNode + 1;
    let currentLevel = 1;
    let nrOfNodesAtLevel = nrOfLeafs;
    let nrOfParentNodes = Math.ceil(nrOfNodesAtLevel / parentConnections);
    let nodesAtLevel = [];
    while (true) {
      const creatingLeafs = currentLevel === 1;
      const parentNodes = [];
      for (let i = 0; i < nrOfParentNodes; i++) {
        const node = new BPlusTreeNode(tree, null);
        if (i > 0) {
          const prevNode = parentNodes[i - 1];
          node.prevNode = prevNode;
          prevNode.nextNode = node;
        }
        parentNodes.push(node);
      }
      for (let i = 0; i < nrOfNodesAtLevel; i++) {
        const parentIndex = Math.floor(i / parentConnections);
        const parent = parentNodes[parentIndex];
        if (creatingLeafs) {
          const leaf = new BPlusTreeLeaf(parent);
          nodesAtLevel.push(leaf);
          const prevLeaf = nodesAtLevel[nodesAtLevel.length - 2];
          if (prevLeaf) {
            leaf.prevLeaf = prevLeaf;
            prevLeaf.nextLeaf = leaf;
          }
          const fromIndex = i * entriesPerLeaf;
          const entryKVPs = list.slice(fromIndex, fromIndex + entriesPerLeaf);
          entryKVPs.forEach((kvp) => {
            const entry = new BPlusTreeLeafEntry(leaf, kvp.key);
            entry.values = this.uniqueKeys ? [kvp.val] : kvp.val;
            leaf.entries.push(entry);
          });
          const isLastLeaf = Math.floor((i + 1) / parentConnections) > parentIndex || i === nrOfNodesAtLevel - 1;
          if (isLastLeaf) {
            parent.gtChild = leaf;
            if (parentNodes.length > 1 && parent.entries.length < minParentEntries) {
              const nrOfParentEntries2Move = minParentEntries - parent.entries.length;
              const prevParent = parent.prevNode;
              for (let j = 0; j < nrOfParentEntries2Move; j++) {
                const firstChild = parent.entries.length === 0 ? leaf : parent.entries[0].ltChild;
                const moveEntry = prevParent.entries.pop();
                const moveLeaf = prevParent.gtChild;
                prevParent.gtChild = moveEntry.ltChild;
                moveEntry.key = firstChild.entries[0].key;
                moveLeaf.parent = parent;
                moveEntry.ltChild = moveLeaf;
                parent.entries.unshift(moveEntry);
                moveEntry.node = parent;
              }
            }
          } else {
            const ltChildKey = list[fromIndex + entriesPerLeaf].key;
            const parentEntry = new BPlusTreeNodeEntry(parent, ltChildKey);
            parentEntry.ltChild = leaf;
            parent.entries.push(parentEntry);
          }
        } else {
          const node = nodesAtLevel[i];
          node.parent = parent;
          const isLastNode = Math.floor((i + 1) / parentConnections) > parentIndex || i === nrOfNodesAtLevel - 1;
          if (isLastNode) {
            parent.gtChild = node;
            if (parentNodes.length > 1 && parent.entries.length < minParentEntries) {
              const nrOfParentEntries2Move = minParentEntries - parent.entries.length;
              const prevParent = parent.prevNode;
              for (let j = 0; j < nrOfParentEntries2Move; j++) {
                const firstChild = parent.entries.length === 0 ? node : parent.entries[0].ltChild;
                const moveEntry = prevParent.entries.pop();
                const moveNode = prevParent.gtChild;
                prevParent.gtChild = moveEntry.ltChild;
                let ltChild = firstChild.entries[0].ltChild;
                while (!(ltChild instanceof BPlusTreeLeaf)) {
                  ltChild = ltChild.entries[0].ltChild;
                }
                moveEntry.key = ltChild.entries[0].key;
                moveNode.parent = parent;
                moveEntry.ltChild = moveNode;
                parent.entries.unshift(moveEntry);
                moveEntry.node = parent;
              }
            }
          } else {
            let ltChild = node.nextNode;
            while (!(ltChild instanceof BPlusTreeLeaf)) {
              ltChild = ltChild.entries[0].ltChild;
            }
            const ltChildKey = ltChild.entries[0].key;
            const parentEntry = new BPlusTreeNodeEntry(parent, ltChildKey);
            parentEntry.ltChild = node;
            parent.entries.push(parentEntry);
          }
        }
      }
      if (nrOfLeafs === 1) {
        const leaf = nodesAtLevel[0];
        leaf.parent = tree;
        tree.root = leaf;
        break;
      } else if (nrOfParentNodes === 1) {
        tree.root = parentNodes[0];
        break;
      }
      currentLevel++;
      nodesAtLevel = parentNodes;
      nrOfNodesAtLevel = nodesAtLevel.length;
      nrOfParentNodes = Math.ceil(nrOfNodesAtLevel / parentConnections);
      tree.depth++;
    }
    return tree;
  }
  dumpToFile(filename) {
    const fs4 = require("fs");
    fs4.appendFileSync(filename, this.uniqueKeys + "\n");
    fs4.appendFileSync(filename, this.fillFactor + "\n");
    for (const [key, val] of this.list) {
      const json = JSON.stringify({ key, val }) + "\n";
      fs4.appendFileSync(filename, json);
    }
  }
  static fromFile(filename) {
    const fs4 = require("fs");
    const entries = fs4.readFileSync(filename, "utf8").split("\n").map((str) => str.length > 0 ? JSON.parse(str) : "");
    const last = entries.pop();
    assert(last === "");
    const uniqueKeys = entries.shift() === "true";
    const fillFactor = parseInt(entries.shift());
    const builder = new BPlusTreeBuilder(uniqueKeys, fillFactor);
    for (let i = 0; i < entries.length; i++) {
      builder.list.set(entries[i].key, entries[i].val);
    }
    return builder;
  }
};

// node_modules/acebase/dist/esm/btree/tx.js
var TxDetailedError = class extends DetailedError {
  constructor(code, msg, originalError) {
    super(code, msg, originalError);
    this.transactionErrors = null;
    this.rollbackErrors = null;
  }
};
var TX = class {
  constructor() {
    this._queue = [];
    this._rollbackSteps = [];
  }
  run(action, rollback) {
    assert(this._queue.length === 0, "queue must be empty");
    typeof rollback === "function" && this._rollbackSteps.push(rollback);
    const p = action instanceof Promise ? action : action();
    return p.catch((err) => {
      console.error(`TX.run error: ${err.message}. Initiating rollback`);
      const steps = this._rollbackSteps.map((step) => step());
      return Promise.all(steps).then(() => {
        throw err;
      }).catch((err2) => {
        console.error(`Critical: could not rollback changes. Error: ${err2.message}`);
        err.rollbackError = err2;
        throw err;
      });
    });
  }
  queue(step) {
    this._queue.push({
      name: step.name || `Step ${this._queue.length + 1}`,
      action: step.action,
      rollback: step.rollback,
      state: "idle",
      error: null
    });
  }
  async execute(parallel = true) {
    if (!parallel) {
      const rollbackSteps2 = [];
      let result;
      while (this._queue.length > 0) {
        const step = this._queue.shift();
        rollbackSteps2.push(step.rollback);
        try {
          const prevResult = result;
          result = await step.action(prevResult);
        } catch (err2) {
          const actions2 = rollbackSteps2.map((step2) => step2());
          await Promise.all(actions2).catch((err22) => {
            console.error(`Critical: could not rollback changes. Error: ${err22.message}`);
            err2.rollbackError = err22;
            throw err2;
          });
          throw err2;
        }
      }
      return result;
    }
    const executeStepAction = async (step, action) => {
      try {
        const promise = step[action]();
        if (!(promise instanceof Promise)) {
          throw new DetailedError("invalid-tx-step-code", `step "${step.name}" action "${action}" must return a promise`);
        }
        const result = await promise;
        step.state = "success";
        step.result = result;
      } catch (err2) {
        step.state = "failed";
        step.error = err2;
      }
      return step;
    };
    const actions = this._queue.map((step) => executeStepAction(step, "action"));
    let results = await Promise.all(actions);
    let success = results.every((step) => step.state === "success");
    if (success) {
      return;
    }
    const transactionErrors = results.filter((step) => step.state === "failed").map((result) => result.error);
    const rollbackSteps = this._queue.filter((step) => typeof step.rollback === "function").map((step) => executeStepAction(step, "rollback"));
    results = await Promise.all(rollbackSteps);
    success = results.every((step) => step.state === "success");
    if (success) {
      const err2 = new TxDetailedError("tx-failed", "Tx failed, rolled back. See .info for details");
      err2.transactionErrors = transactionErrors;
      throw err2;
    }
    const err = new TxDetailedError("tx-rollback-failed", "Critical: could not rollback failed transaction. See transactionErrors and rollbackErrors for details");
    err.transactionErrors = transactionErrors;
    err.rollbackErrors = results.filter((step) => step.state === "failed").map((result) => result.error);
    console.error("Critical: could not rollback transaction. Errors:", err.rollbackErrors);
    throw err;
  }
};

// node_modules/acebase/dist/esm/btree/binary-tree.js
var { bigintToBytes: bigintToBytes4 } = utils_exports;
var BlacklistingSearchOperator = class {
  constructor(callback) {
    this.check = callback;
  }
};
var NoTreeInfoError = class extends Error {
  constructor() {
    super("Tree info has not been read");
  }
};
async function noop2() {
}
var BinaryBPlusTree = class {
  constructor(init) {
    this._chunkSize = init.chunkSize ?? 1024;
    this._autoGrow = false;
    this.id = init.id;
    this.debug = init.debug;
    if (init.readFn instanceof Array) {
      let data = init.readFn;
      if (BPlusTree.debugBinary) {
        this.debugData = data;
        data = this.debugData.map((entry) => entry instanceof Array ? entry[1] : entry);
      }
      this._readFn = async (i, length3) => {
        const slice = data.slice(i, i + length3);
        return Buffer.from(slice);
      };
    } else if (typeof init.readFn === "function") {
      this._readFn = init.readFn;
    } else {
      throw new TypeError("readFn must be a byte array or function that reads from a data source");
    }
    if (typeof init.writeFn === "function") {
      this._writeFn = init.writeFn;
    } else if (typeof init.writeFn === "undefined" && init.readFn instanceof Array) {
      const sourceData = init.readFn;
      this._writeFn = (data, index) => {
        for (let i = 0; i < data.length; i++) {
          sourceData[index + i] = data[i];
        }
      };
    } else {
      this._writeFn = () => {
        throw new Error("Cannot write data, no writeFn was supplied");
      };
    }
  }
  static async test(data, debug) {
    const tree = new BinaryBPlusTree({ readFn: data, debug });
    let leaf = await tree.getFirstLeaf();
    while (leaf) {
      for (let i = 0; i < leaf.entries.length; i++) {
        const entry = leaf.entries[i];
        const found = await tree.find(entry.key);
        if (found === null) {
          throw new Error(`Tree entry ${entry.key} could not be found using tree.find`);
        }
      }
      leaf = leaf.getNext ? await leaf.getNext() : null;
    }
  }
  get autoGrow() {
    return this._autoGrow;
  }
  set autoGrow(grow) {
    this._autoGrow = grow === true;
  }
  async _loadInfo() {
    await this._getReader();
  }
  async _getReader() {
    const reader = new BinaryReader(this._readFn, this._chunkSize);
    await reader.init();
    const header = await reader.get(6);
    const originalByteLength = header[0] << 24 | header[1] << 16 | header[2] << 8 | header[3];
    if (!this._originalByteLength) {
      this._originalByteLength = originalByteLength;
    }
    this.info = {
      headerLength: 6,
      byteLength: originalByteLength,
      isUnique: (header[4] & FLAGS.UNIQUE_KEYS) > 0,
      hasMetadata: (header[4] & FLAGS.HAS_METADATA) > 0,
      hasFreeSpace: (header[4] & FLAGS.HAS_FREE_SPACE) > 0,
      hasFillFactor: (header[4] & FLAGS.HAS_FILL_FACTOR) > 0,
      hasSmallLeafs: (header[4] & FLAGS.HAS_SMALL_LEAFS) > 0,
      hasLargePtrs: (header[4] & FLAGS.HAS_LARGE_PTRS) > 0,
      freeSpace: 0,
      get freeSpaceIndex() {
        return this.hasFillFactor ? 7 : 6;
      },
      entriesPerNode: header[5],
      fillFactor: 100,
      metadataKeys: []
    };
    let additionalHeaderBytes = 0;
    if (this.info.hasFillFactor) {
      additionalHeaderBytes += 1;
    }
    if (this.info.hasFreeSpace) {
      additionalHeaderBytes += 4;
    }
    if (this.info.hasMetadata) {
      additionalHeaderBytes += 4;
    }
    if (additionalHeaderBytes > 0) {
      this.info.headerLength += additionalHeaderBytes;
      const ahbBuffer = await reader.get(additionalHeaderBytes);
      let i = 0;
      if (this.info.hasFillFactor) {
        this.info.fillFactor = ahbBuffer[i];
        i++;
      }
      if (this.info.hasFreeSpace) {
        this.info.freeSpace = ahbBuffer[i] << 24 | ahbBuffer[i + 1] << 16 | ahbBuffer[i + 2] << 8 | ahbBuffer[i + 3];
        i += 4;
      }
      if (this.info.hasMetadata) {
        const length3 = ahbBuffer[i] << 24 | ahbBuffer[i + 1] << 16 | ahbBuffer[i + 2] << 8 | ahbBuffer[i + 3];
        this.info.headerLength += length3;
        const mdBuffer = await reader.get(length3);
        const keyCount = mdBuffer[0];
        let index = 1;
        for (let i2 = 0; i2 < keyCount; i2++) {
          const keyLength = mdBuffer[index];
          index++;
          let key = "";
          for (let j = 0; j < keyLength; j++) {
            key += String.fromCharCode(mdBuffer[index + j]);
          }
          index += keyLength;
          this.info.metadataKeys.push(key);
        }
      }
    }
    return reader;
  }
  async _readChild(reader) {
    const index = reader.sourceIndex;
    const headerLength = 9;
    const header = await reader.get(headerLength);
    const byteLength = header[0] << 24 | header[1] << 16 | header[2] << 8 | header[3];
    const isLeaf = (header[4] & FLAGS.IS_LEAF) > 0;
    const hasExtData = (header[4] & FLAGS.LEAF_HAS_EXT_DATA) > 0;
    const freeBytesLength = header[5] << 24 | header[6] << 16 | header[7] << 8 | header[8];
    const dataLength = byteLength - headerLength - freeBytesLength;
    const bytes = await reader.get(dataLength);
    assert(bytes.length === dataLength, "less bytes read than requested?");
    const childInfo = new BinaryBPlusTreeNodeInfo({
      tree: this,
      isLeaf,
      hasExtData,
      bytes,
      sourceIndex: index,
      dataIndex: index + headerLength,
      length: byteLength,
      free: freeBytesLength
    });
    return childInfo;
  }
  _getLeaf(leafInfo, reader, options) {
    if (!this.info) {
      throw new Error("Tree info has not been read");
    }
    const leaf = new BinaryBPlusTreeLeaf(leafInfo);
    const bytes = leaf.bytes;
    const prevLeafOffset = readSignedOffset(bytes, 0, this.info.hasLargePtrs);
    let index = this.info.hasLargePtrs ? 6 : 4;
    const nextLeafOffset = readSignedOffset(bytes, index, this.info.hasLargePtrs);
    index += this.info.hasLargePtrs ? 6 : 4;
    leaf.prevLeafOffset = prevLeafOffset;
    leaf.nextLeafOffset = nextLeafOffset;
    if (leafInfo.hasExtData) {
      leaf.extData.length = readByteLength(bytes, index);
      leaf.extData.freeBytes = readByteLength(bytes, index + 4);
      index += 8;
      leaf.extData.load = async () => {
        if (leaf.extData.loaded) {
          return;
        }
        const index2 = leaf.sourceIndex + leaf.length;
        const length3 = leaf.extData.length - leaf.extData.freeBytes;
        const r = reader.clone();
        r.chunkSize = length3;
        await r.go(index2);
        const bytes2 = await r.get(length3);
        leaf.entries.forEach((entry) => {
          if (entry.extData) {
            entry.extData.loadFromExtData(bytes2);
          }
        });
        leaf.extData.loaded = true;
      };
    }
    const entriesLength = bytes[index];
    index++;
    const readValue = () => {
      const result = readEntryValue(bytes, index);
      index += result.byteLength;
      return result.entryValue;
    };
    const readEntryValue = (bytes2, index2) => {
      assert(index2 < bytes2.length, "invalid data");
      if (index2 >= bytes2.length) {
        throw new Error("invalid data");
      }
      const startIndex = index2;
      const valueLength = bytes2[index2];
      if (index2 + valueLength > bytes2.length) {
        const bytesShort = index2 + valueLength - bytes2.length;
        throw new Error(`DEV ERROR: Cannot read entry value past the end of the read buffer (${bytesShort} bytes short)`);
      }
      index2++;
      const value = [];
      for (let j = 0; j < valueLength; j++) {
        value[j] = bytes2[index2 + j];
      }
      index2 += valueLength;
      const metadata = this.info.hasMetadata ? {} : void 0;
      this.info.metadataKeys.forEach((key) => {
        const valueInfo = BPlusTree.getKeyFromBinary(bytes2, index2);
        metadata[key] = valueInfo.key;
        index2 += valueInfo.byteLength;
      });
      return {
        entryValue: new BinaryBPlusTreeLeafEntryValue(value, metadata),
        byteLength: index2 - startIndex
      };
    };
    for (let i = 0; i < entriesLength; i++) {
      const keyInfo = BPlusTree.getKeyFromBinary(bytes, index);
      const key = keyInfo.key;
      index += keyInfo.byteLength;
      const hasExtData = this.info.hasSmallLeafs && (bytes[index] & FLAGS.ENTRY_HAS_EXT_DATA) > 0;
      const valLength = this.info.hasSmallLeafs ? hasExtData ? 0 : bytes[index] : bytes[index] << 24 | bytes[index + 1] << 16 | bytes[index + 2] << 8 | bytes[index + 3];
      index += this.info.hasSmallLeafs ? 1 : 4;
      if (options && options.stats) {
        const entry = new BinaryBPlusTreeLeafEntry(key, null);
        if (this.info.isUnique) {
          entry.totalValues = 1;
        } else {
          entry.totalValues = bytes[index] << 24 | bytes[index + 1] << 16 | bytes[index + 2] << 8 | bytes[index + 3];
        }
        leaf.entries.push(entry);
        if (hasExtData) {
          index += this.info.isUnique ? 4 : 8;
        } else {
          index += valLength;
        }
      } else if (this.info.isUnique) {
        const entryValue = readValue();
        leaf.entries.push(new BinaryBPlusTreeLeafEntry(key, [entryValue]));
      } else {
        const valuesListLengthIndex = leafInfo.dataIndex + index;
        let valuesLength = bytes[index] << 24 | bytes[index + 1] << 16 | bytes[index + 2] << 8 | bytes[index + 3];
        index += 4;
        if (hasExtData) {
          let extDataOffset = readByteLength(bytes, index);
          index += 4;
          const extDataBlockIndex = leafInfo.sourceIndex + leafInfo.length + extDataOffset;
          const entry = new BinaryBPlusTreeLeafEntry(key, new Array(valuesLength));
          const tree = this;
          Object.defineProperties(entry, {
            values: {
              get() {
                return this.extData.values;
              },
              set(values) {
                this.extData.values = values;
              }
            }
          });
          entry.extData = {
            _headerLoaded: false,
            _length: -1,
            _freeBytes: -1,
            _values: null,
            _listLengthIndex: valuesListLengthIndex,
            get length() {
              if (this._headerLoaded) {
                return this._length;
              }
              throw new Error("ext_data header not read yet");
            },
            get freeBytes() {
              if (this._headerLoaded) {
                return this._freeBytes;
              }
              throw new Error("ext_data header not read yet");
            },
            get values() {
              if (this._values !== null) {
                return this._values;
              }
              throw new Error("ext_data values were not read yet. use entry.extData.loadValues() first");
            },
            set values(values) {
              this._values = values;
            },
            leafOffset: extDataOffset,
            index: extDataBlockIndex,
            get totalValues() {
              return valuesLength;
            },
            set totalValues(n) {
              valuesLength = n;
            },
            get loaded() {
              return this._values !== null;
            },
            get _headerLength() {
              return 8;
            },
            async loadValues(existingLock = null) {
              const self2 = this;
              const lock = await self2.loadHeader(existingLock || true);
              await reader.go(self2.index + self2._headerLength);
              const extData = await reader.get(self2._length - self2._freeBytes);
              self2._values = [];
              let index2 = 0;
              for (let i2 = 0; i2 < valuesLength; i2++) {
                const result = readEntryValue(extData, index2);
                index2 += result.byteLength;
                self2._values.push(result.entryValue);
              }
              self2.totalValues = valuesLength;
              if (!existingLock) {
                lock.release();
              }
              if (index2 !== self2._length - self2._freeBytes) {
                throw new Error("DEV ERROR: index should now be at the known end of the data");
              }
              return self2._values;
            },
            async loadHeader(lockOptions) {
              const self2 = this;
              const keepLock = lockOptions === true;
              const existingLock = typeof lockOptions === "object" ? lockOptions : null;
              reader = reader.clone();
              const lock = existingLock || await ThreadSafe.lock(leaf);
              await reader.go(self2.index);
              const extHeader = await reader.get(self2._headerLength);
              self2._headerLoaded = true;
              self2._length = readByteLength(extHeader, 0);
              self2._freeBytes = readByteLength(extHeader, 4);
              assert(self2._length >= 0 && self2._freeBytes >= 0 && self2._freeBytes < self2._length, "invalid data");
              if (keepLock || existingLock) {
                return lock;
              } else {
                return lock.release();
              }
            },
            loadFromExtData(allExtData) {
              const self2 = this;
              let index2 = extDataOffset;
              self2._headerLoaded = true;
              self2._length = readByteLength(allExtData, index2);
              self2._freeBytes = readByteLength(allExtData, index2 + 4);
              index2 += self2._headerLength;
              self2._values = [];
              for (let i2 = 0; i2 < valuesLength; i2++) {
                const result = readEntryValue(allExtData, index2);
                index2 += result.byteLength;
                self2._values.push(result.entryValue);
              }
              self2.totalValues = valuesLength;
            },
            async addValue(recordPointer, metadata) {
              const self2 = this;
              const lock = await self2.loadHeader(true);
              const builder = new BinaryBPlusTreeBuilder({ metadataKeys: tree.info.metadataKeys });
              const extValueData = builder.getLeafEntryValueBytes(recordPointer, metadata);
              let extBlockMoves = false;
              let newValueIndex = -1;
              if (extValueData.length > self2._freeBytes) {
                const requiredSpace = (() => {
                  const grossNewLength = entry.extData.length - entry.extData.freeBytes + extValueData.length;
                  const newValues = Math.ceil((entry.totalValues + 1) * 1.1);
                  const avgValueLength = Math.ceil((entry.extData.length - entry.extData.freeBytes) / entry.extData.totalValues);
                  const netNewLength = avgValueLength * newValues;
                  const newFreeBytes = netNewLength - grossNewLength;
                  return {
                    bytes: netNewLength + self2._headerLength,
                    length: netNewLength,
                    freeBytes: newFreeBytes
                  };
                })();
                if (requiredSpace.bytes > leaf.extData.freeBytes) {
                  lock.release();
                  throw new DetailedError("max-extdata-size-reached", "No space left to add value to leaf ext_data_block");
                } else {
                  await entry.extData.loadValues(lock);
                  const oldOffset = extDataOffset;
                  const newOffset = leaf.extData.length - leaf.extData.freeBytes;
                  extDataOffset = newOffset;
                  entry.extData.index += newOffset - oldOffset;
                  entry.extData._length = requiredSpace.length;
                  entry.extData._freeBytes = requiredSpace.freeBytes;
                  leaf.extData.freeBytes -= requiredSpace.bytes;
                  extBlockMoves = true;
                }
              } else {
                newValueIndex = self2.index + self2._headerLength + self2._length - self2._freeBytes;
                entry.extData._freeBytes -= extValueData.length;
              }
              const extDataBlock = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              ];
              writeByteLength(extDataBlock, 0, entry.extData.length);
              writeByteLength(extDataBlock, 4, entry.extData.freeBytes);
              if (extBlockMoves) {
                const builder2 = new BinaryBPlusTreeBuilder({ metadataKeys: tree.info.metadataKeys });
                entry.extData.values.forEach((val) => {
                  const valData = builder2.getLeafEntryValueBytes(val.recordPointer, val.metadata);
                  _appendToArray(extDataBlock, valData);
                });
                _appendToArray(extDataBlock, extValueData);
                if (extDataBlock.length - 8 + entry.extData.freeBytes !== entry.extData.length) {
                  throw new Error("DEV ERROR: new ext_block size is not equal to calculated size");
                }
              }
              const valueListLengthData = [0, 0, 0, 0];
              writeByteLength(valueListLengthData, 0, self2.totalValues + 1);
              try {
                const promises = [
                  tree._writeFn(extDataBlock, self2.index),
                  tree._writeFn(valueListLengthData, self2._listLengthIndex)
                ];
                if (extBlockMoves) {
                  let writeBytes = [0, 0, 0, 0];
                  writeByteLength(writeBytes, 0, extDataOffset);
                  let p = tree._writeFn(writeBytes, self2._listLengthIndex + 4);
                  promises.push(p);
                  const leafExtFreeBytesIndex = leaf.dataIndex + (tree.info.hasLargePtrs ? 6 : 4) * 2 + 4;
                  writeBytes = [0, 0, 0, 0];
                  writeByteLength(writeBytes, 0, leaf.extData.freeBytes);
                  p = tree._writeFn(writeBytes, leafExtFreeBytesIndex);
                  promises.push(p);
                } else {
                  const p = tree._writeFn(extValueData, newValueIndex);
                  promises.push(p);
                }
                await Promise.all(promises);
                self2.totalValues++;
              } finally {
                await lock.release();
              }
            },
            async removeValue(recordPointer) {
              const self2 = this;
              const values = await self2.loadValues();
              const index2 = values.findIndex((val) => _compareBinary(val.recordPointer, recordPointer));
              if (!~index2) {
                return;
              }
              values.splice(index2, 1);
              const bytes2 = [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              ];
              writeByteLength(bytes2, 0, self2._length);
              const builder = new BinaryBPlusTreeBuilder({ metadataKeys: tree.info.metadataKeys });
              values.forEach((val) => {
                const valData = builder.getLeafEntryValueBytes(val.recordPointer, val.metadata);
                _appendToArray(bytes2, valData);
              });
              const freeBytes = self2._length - bytes2.length + 8;
              writeByteLength(bytes2, 4, freeBytes);
              const valueListLengthData = writeByteLength([], 0, self2.totalValues - 1);
              await Promise.all([
                tree._writeFn(bytes2, self2.index),
                tree._writeFn(valueListLengthData, self2._listLengthIndex)
              ]);
              self2.totalValues--;
              self2._freeBytes = freeBytes;
            }
          };
          entry.loadValues = async function loadValues() {
            const lock = await ThreadSafe.lock(leaf);
            await reader.go(extDataBlockIndex);
            const extHeader = await reader.get(8);
            const length3 = readByteLength(extHeader, 0);
            const freeBytes = readByteLength(extHeader, 4);
            const data = await reader.get(length3 - freeBytes);
            entry._values = [];
            let index2 = 0;
            for (let i2 = 0; i2 < this.totalValues; i2++) {
              const result = readEntryValue(data, index2);
              index2 += result.byteLength;
              entry._values.push(result.entryValue);
            }
            lock.release();
            return entry._values;
          };
          leaf.entries.push(entry);
        } else {
          const entryValues = [];
          for (let j = 0; j < valuesLength; j++) {
            const entryValue = readValue();
            entryValues.push(entryValue);
          }
          leaf.entries.push(new BinaryBPlusTreeLeafEntry(key, entryValues));
        }
      }
    }
    if (prevLeafOffset !== 0) {
      leaf.getPrevious = async () => {
        const freshReader = reader.clone();
        await freshReader.go(leaf.prevLeafIndex);
        const childInfo = await this._readChild(freshReader);
        assert(childInfo.isLeaf, `previous leaf is *not* a leaf. Current leaf index: ${leaf.sourceIndex}, next leaf offset: ${prevLeafOffset}, target index: ${leaf.dataIndex + prevLeafOffset}`);
        const prevLeaf = await this._getLeaf(childInfo, freshReader, options);
        return prevLeaf;
      };
    }
    if (nextLeafOffset !== 0) {
      leaf.getNext = async (repairMode = false) => {
        const freshReader = reader.clone();
        await freshReader.go(leaf.nextLeafIndex);
        let childInfo;
        try {
          childInfo = await this._readChild(freshReader);
        } catch (err) {
          if (repairMode) {
            const lastKey = leaf.entries.slice(-1)[0].key;
            this.debug.warn(`B+Tree repair caught error: ${err.message}`);
            this.debug.warn(`B+Tree repair starting at key >= "${lastKey}"`);
            const currentLeaf = await (async () => {
              if (leaf.parentNode) {
                return leaf;
              }
              try {
                return await this._findLeaf(lastKey);
              } catch (err2) {
                throw new DetailedError("tree-repair", `Cannot repair B+Tree: unable to find current leaf using its last key`, err2);
              }
            })();
            if (currentLeaf.index !== leaf.index) {
              throw new DetailedError("tree-repair", `Cannot repair B+Tree: loaded current leaf at index ${currentLeaf.index} is not the same as start leaf @${leaf.index}`, err);
            }
            const currentEntryIndex = currentLeaf.parentNode.entries.indexOf(currentLeaf.parentEntry);
            if (currentEntryIndex === -1) {
              if (currentLeaf.parentNode.gtChildIndex !== currentLeaf.index) {
                throw new DetailedError("tree-repair", `Cannot repair B+Tree: leaf's parent node entry points to the wrong index ${currentLeaf.parentNode.gtChildIndex} of current leaf ${currentLeaf.index}`);
              }
              if (!currentLeaf.parentNode.parentNode) {
                this.debug.warn(`B+Tree repair: no more leafs in tree`);
                return null;
              }
            }
            const getNextNode = async (currentNode2) => {
              const entryIndex = currentNode2.parentNode.entries.indexOf(currentNode2.parentEntry);
              if (entryIndex === -1) {
                if (currentNode2.parentNode) {
                  const nextParent = await getNextNode(currentNode2.parentNode);
                  const nextNodeInfo2 = await nextParent.entries[0].getLtChild();
                  const nextNode2 = new BinaryBPlusTreeNode(nextNodeInfo2);
                  return nextNode2;
                }
                return null;
              }
              const nextEntry = currentNode2.parentNode.entries[entryIndex + 1];
              const nextNodeInfo = nextEntry ? await nextEntry.getLtChild() : await currentNode2.parentNode.getGtChild();
              const nextNode = new BinaryBPlusTreeNode(nextNodeInfo);
              return nextNode;
            };
            const getNextNodeEntry = async (currentNode2, currentIndex) => {
              if (currentIndex > currentNode2.entries.length) {
                const nextNode = await getNextNode(currentNode2.parentNode);
                if (!nextNode) {
                  return null;
                }
                return { node: nextNode, entry: nextNode.entries[0], index: 0 };
              }
              return { node: currentNode2, entry: currentNode2.entries[currentIndex + 1] ?? null, index: currentIndex + 1 };
            };
            let { node: currentNode, entry: currentNodeEntry, index: currentNodeEntryIndex } = await getNextNodeEntry(currentLeaf.parentNode, currentEntryIndex);
            while (currentNode) {
              const entryKey = `${currentNodeEntry ? "<" : ">="} "${currentNodeEntry?.key ?? currentNode.entries.slice(-1)[0].key}"`;
              try {
                const nodeInfo = currentNodeEntry ? await currentNodeEntry.getLtChild() : await currentNode.getGtChild();
                assert(nodeInfo.isLeaf, "not a leaf!");
                const nextLeaf2 = new BinaryBPlusTreeLeaf(nodeInfo);
                this.debug.warn(`B+Tree repair: using leaf for key ${entryKey} at index ${nextLeaf2.index}`);
                return nextLeaf2;
              } catch (err2) {
                this.debug.warn(`B+Tree repair: failed to load leaf for key ${entryKey} at index ${currentNodeEntry?.ltChildIndex ?? currentNode.gtChildIndex}: ${err2.message}. Proceeding with next node entry.`);
                ({ node: currentNode, entry: currentNodeEntry, index: currentNodeEntryIndex } = await getNextNodeEntry(currentNode, currentNodeEntryIndex));
              }
            }
            this.debug.warn(`B+Tree repair: there are no more leafs to load`);
            return null;
          }
          throw err;
        }
        assert(childInfo.isLeaf, `next leaf is *not* a leaf. Current leaf index: ${leaf.sourceIndex}, next leaf offset: ${nextLeafOffset}, target index: ${leaf.dataIndex + 4 + nextLeafOffset}`);
        const nextLeaf = await this._getLeaf(childInfo, freshReader, options);
        assert(nextLeaf.entries.length === 0 || leaf.entries.length === 0 || _isMore(nextLeaf.entries[0].key, leaf.entries[leaf.entries.length - 1].key), "next leaf has lower keys than previous leaf?!");
        return nextLeaf;
      };
    }
    assert(leaf.entries.every((entry, index2, arr) => index2 === 0 || _isMore(entry.key, arr[index2 - 1].key)), "Invalid B+Tree: leaf entries are not sorted ok");
    return leaf;
  }
  async _writeNode(nodeInfo) {
    assert(nodeInfo.entries.length > 0, "node has no entries!");
    assert(nodeInfo.entries.every((entry, index, arr) => index === 0 || _isMore(entry.key, arr[index - 1].key)), "Node entries are not sorted ok");
    try {
      const builder = new BinaryBPlusTreeBuilder({
        uniqueKeys: this.info.isUnique,
        maxEntriesPerNode: this.info.entriesPerNode,
        metadataKeys: this.info.metadataKeys,
        byteLength: this.info.byteLength,
        freeBytes: this.info.freeSpace
      });
      const bytes = builder.createNode({
        index: nodeInfo.index,
        entries: nodeInfo.entries.map((entry) => ({ key: entry.key, ltIndex: entry.ltChildIndex })),
        gtIndex: nodeInfo.gtChildIndex
      }, {
        addFreeSpace: true,
        maxLength: nodeInfo.length
      });
      assert(bytes.length <= nodeInfo.length, "too many bytes allocated for node");
      return await this._writeFn(bytes, nodeInfo.index);
    } catch (err) {
      throw new DetailedError("write-node-fail", `Failed to write node: ${err.message}`, err);
    }
  }
  async _writeLeaf(leafInfo, options = { addFreeSpace: true }) {
    assert(leafInfo.entries.every((entry, index, arr) => index === 0 || _isMore(entry.key, arr[index - 1].key)), "Leaf entries are not sorted ok");
    try {
      const builder = new BinaryBPlusTreeBuilder({
        uniqueKeys: this.info.isUnique,
        maxEntriesPerNode: this.info.entriesPerNode,
        metadataKeys: this.info.metadataKeys,
        smallLeafs: this.info.hasSmallLeafs,
        byteLength: this.info.byteLength,
        freeBytes: this.info.freeSpace,
        fillFactor: this.info.fillFactor
      });
      const extData = leafInfo.extData ? {
        length: leafInfo.extData.length,
        freeBytes: leafInfo.extData.freeBytes,
        rebuild: leafInfo.extData.loaded
      } : null;
      const addFreeSpace = options.addFreeSpace !== false;
      const writes = [];
      const bytes = builder.createLeaf({
        index: leafInfo.index,
        prevIndex: leafInfo.prevLeafIndex,
        nextIndex: leafInfo.nextLeafIndex,
        entries: leafInfo.entries,
        extData
      }, {
        addFreeSpace,
        maxLength: leafInfo.length,
        addExtData: (pointerIndex, data) => {
          const extIndex = extData.length - extData.freeBytes;
          const fileIndex = leafInfo.sourceIndex + leafInfo.length + extIndex;
          const bytes2 = new Uint8ArrayBuilder();
          const minRequired = data.length + 8;
          if (extData.freeBytes < minRequired) {
            throw new DetailedError("max-extdata-size-reached", "Not enough free space in ext_data");
          }
          const maxFree = extData.freeBytes - minRequired;
          const free = addFreeSpace ? Math.min(maxFree, Math.ceil(data.length * 0.1)) : 0;
          const length3 = data.length + free;
          bytes2.writeUint32(length3);
          bytes2.writeUint32(free);
          bytes2.append(data);
          bytes2.append(new Uint8Array(free));
          extData.freeBytes -= bytes2.length;
          const writePromise = this._writeFn(bytes2.data, fileIndex);
          writes.push(writePromise);
          return { extIndex };
        }
      });
      const maxLength = leafInfo.length + (leafInfo.extData && leafInfo.extData.loaded ? leafInfo.extData.length : 0);
      assert(bytes.length <= maxLength, "more bytes needed than allocated for leaf");
      const promise = this._writeFn(bytes, leafInfo.index);
      writes.push(promise);
      const result = await Promise.all(writes);
      return result;
    } catch (err) {
      throw new DetailedError("write-leaf-fail", `Failed to write leaf: ${err.message}`, err);
    }
  }
  _getNode(nodeInfo, reader) {
    const node = new BinaryBPlusTreeNode(nodeInfo);
    const bytes = node.bytes;
    const entriesLength = bytes[0];
    assert(entriesLength > 0, "Node read failure: no entries");
    let index = 1;
    for (let i = 0; i < entriesLength; i++) {
      const keyInfo = BPlusTree.getKeyFromBinary(bytes, index);
      const key = keyInfo.key;
      index += keyInfo.byteLength;
      const entry = new BinaryBPlusTreeNodeEntry(key);
      node.entries.push(entry);
      entry.ltChildOffset = readSignedOffset(bytes, index, this.info.hasLargePtrs);
      assert(entry.ltChildOffset !== 0, "Node read failure: invalid ltChildOffset 0");
      entry.ltChildIndex = node.index + index + 9 + entry.ltChildOffset + (this.info.hasLargePtrs ? 5 : 3);
      entry.getLtChild = async () => {
        await reader.go(entry.ltChildIndex);
        const childNodeInfo = await this._readChild(reader);
        childNodeInfo.parentNode = node;
        childNodeInfo.parentEntry = entry;
        return childNodeInfo;
      };
      index += this.info.hasLargePtrs ? 6 : 4;
    }
    node.gtChildOffset = readSignedOffset(bytes, index, this.info.hasLargePtrs);
    assert(node.gtChildOffset !== 0, "Node read failure: invalid gtChildOffset 0");
    node.gtChildIndex = node.index + index + 9 + node.gtChildOffset + (this.info.hasLargePtrs ? 5 : 3);
    node.getGtChild = async () => {
      await reader.go(node.gtChildIndex);
      const childNodeInfo = await this._readChild(reader);
      childNodeInfo.parentNode = node;
      childNodeInfo.parentEntry = null;
      return childNodeInfo;
    };
    return node;
  }
  async _threadSafe(mode, fn) {
    if (!this.id) {
      throw new DetailedError("tree-id-not-set", "Set tree.id property to something unique for locking purposes");
    }
    const lock = await ThreadSafe.lock(this.id, { timeout: 15 * 60 * 1e3, shared: mode === "shared" });
    try {
      let result = fn();
      if (result instanceof Promise) {
        result = await result;
      }
      return result;
    } finally {
      lock.release();
    }
  }
  async getFirstLeaf(options) {
    return this._threadSafe("shared", () => this._getFirstLeaf(options));
  }
  async _getFirstLeaf(options) {
    const reader = await this._getReader();
    let nodeInfo = await this._readChild(reader);
    while (!nodeInfo.isLeaf) {
      const node = this._getNode(nodeInfo, reader);
      const firstEntry = node.entries[0];
      assert(firstEntry, "node has no entries!");
      nodeInfo = await firstEntry.getLtChild();
    }
    const leaf = this._getLeaf(nodeInfo, reader, options);
    return leaf;
  }
  async getLastLeaf(options) {
    return this._threadSafe("shared", () => this._getLastLeaf(options));
  }
  async _getLastLeaf(options) {
    const reader = await this._getReader();
    let nodeInfo = await this._readChild(reader);
    while (!nodeInfo.isLeaf) {
      const node = this._getNode(nodeInfo, reader);
      nodeInfo = await node.getGtChild();
    }
    const leaf = this._getLeaf(nodeInfo, reader, options);
    return leaf;
  }
  async findLeaf(searchKey, options) {
    return this._threadSafe("shared", () => this._findLeaf(searchKey, options));
  }
  async _findLeaf(searchKey, options) {
    const reader = await this._getReader();
    let nodeInfo = await this._readChild(reader);
    while (!nodeInfo.isLeaf) {
      const node = this._getNode(nodeInfo, reader);
      if (node.entries.length === 0) {
        throw new Error("read node has no entries!");
      }
      const targetEntry = node.entries.find((entry) => _isLess(searchKey, entry.key));
      if (targetEntry) {
        nodeInfo = await targetEntry.getLtChild();
      } else {
        nodeInfo = await node.getGtChild();
      }
    }
    const leaf = this._getLeaf(nodeInfo, reader, options);
    return leaf;
  }
  search(op, param, include = { entries: true, values: false, keys: false, count: false }) {
    return this._threadSafe("shared", () => this._search(op, param, include));
  }
  _search(op, param, include = { entries: true, values: false, keys: false, count: false }) {
    if (typeof op === "string" && ["in", "!in", "between", "!between"].includes(op) && !(param instanceof Array)) {
      throw new TypeError(`param must be an array when using operator ${op}`);
    }
    if (typeof op === "string" && ["exists", "!exists"].includes(op)) {
      op = op === "exists" ? "!=" : "==";
      param = void 0;
    }
    if (param === null) {
      param = void 0;
    }
    const getLeafOptions = { stats: !(include.entries || include.values) };
    const results = {
      entries: [],
      keys: [],
      keyCount: 0,
      valueCount: 0,
      values: []
    };
    let blacklistRpTree;
    if (op instanceof BlacklistingSearchOperator) {
      blacklistRpTree = new BPlusTree(255, true);
    }
    const filterRecordPointers = include.filter ? include.filter.reduce((arr, entry) => {
      arr = arr.concat(entry.values.map((val) => String.fromCharCode(...val.recordPointer)));
      return arr;
    }, []) : null;
    let totalMatches = 0;
    let totalAdded = 0;
    const valuePromises = [];
    const emptyValue = [];
    const add = (entry) => {
      totalMatches += entry.totalValues;
      const requireValues = filterRecordPointers || include.entries || include.values || op instanceof BlacklistingSearchOperator;
      if (requireValues && typeof entry.extData === "object" && !entry.extData.loaded) {
        const p = entry.extData.loadValues().then(() => {
          return add(entry);
        });
        valuePromises.push(p);
        return p;
      }
      if (filterRecordPointers || op instanceof BlacklistingSearchOperator) {
        entry.values.forEach((val) => {
          val.rp = String.fromCharCode(...val.recordPointer);
        });
      }
      if (filterRecordPointers) {
        const values = entry.values.filter((val) => filterRecordPointers.includes(val.rp));
        if (values.length === 0) {
          return;
        }
        entry.values = values;
        entry.totalValues = values.length;
      }
      if (op instanceof BlacklistingSearchOperator) {
        entry.values = entry.values.filter((val) => {
          return blacklistRpTree.find(val.rp) === null;
        });
        if (entry.values.length === 0) {
          return;
        }
        const blacklistValues = op.check(entry);
        if (blacklistValues instanceof Array) {
          blacklistValues.forEach((val) => {
            blacklistRpTree.add(val.rp, emptyValue);
          });
          entry.values = blacklistValues === entry.values ? [] : entry.values.filter((value) => blacklistValues.indexOf(value) < 0);
          const removed = { values: 0, entries: 0 };
          if (include.values) {
            for (let i = 0; i < results.values.length; i++) {
              const val = results.values[i];
              if (blacklistRpTree.find(val.rp)) {
                results.values.splice(i, 1);
                i--;
                removed.values++;
              }
            }
          }
          if (include.entries) {
            for (let i = 0; i < results.entries.length; i++) {
              const entry2 = results.entries[i];
              for (let j = 0; j < entry2.values.length; j++) {
                const val = entry2.values[j];
                if (blacklistRpTree.find(val.rp)) {
                  entry2.values.splice(j, 1);
                  j--;
                  if (!include.values) {
                    removed.values++;
                  }
                  if (entry2.values.length === 0) {
                    results.entries.splice(i, 1);
                    i--;
                    removed.entries++;
                    if (include.keys) {
                      results.keys.splice(results.keys.indexOf(entry2.key), 1);
                    }
                  }
                }
              }
            }
          }
          results.valueCount -= removed.values;
          results.keyCount -= removed.entries;
          if (entry.values.length === 0) {
            return;
          }
        }
        for (let i = 0; i < entry.values.length; i++) {
          const currentValue = entry.values[i];
          let remove = false;
          if (include.values) {
            const index = results.values.findIndex((val) => val.rp === currentValue.rp);
            remove = index >= 0;
          } else if (include.entries) {
            for (let j = 0; j < results.entries.length; j++) {
              const entry2 = results.entries[j];
              const index = entry2.values.findIndex((val) => val.rp === currentValue.rp);
              remove = index >= 0;
              if (remove) {
                break;
              }
            }
          }
          if (remove) {
            entry.values.splice(i, 1);
            i--;
          }
        }
        if (entry.values.length === 0) {
          return;
        }
      }
      if (include.entries) {
        results.entries.push(entry);
      }
      if (include.keys) {
        results.keys.push(entry.key);
      }
      if (include.values) {
        entry.values.forEach((val) => results.values.push(val));
      }
      if (include.count) {
        results.keyCount++;
        results.valueCount += entry.totalValues;
      }
      totalAdded += entry.totalValues;
    };
    const ret = () => {
      if (valuePromises.length > 0) {
        return Promise.all(valuePromises).then(() => results);
      } else {
        return results;
      }
    };
    if (op instanceof BlacklistingSearchOperator) {
      const processLeaf = (leaf) => {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          add(entry);
        }
        if (leaf.hasNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      return this._getFirstLeaf(getLeafOptions).then(processLeaf);
    } else if (["<", "<="].indexOf(op) >= 0) {
      const processLeaf = (leaf) => {
        let stop = false;
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (op === "<=" && _isLessOrEqual(entry.key, param)) {
            add(entry);
          } else if (op === "<" && _isLess(entry.key, param)) {
            add(entry);
          } else {
            stop = true;
            break;
          }
        }
        if (!stop && leaf.getNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      return this._getFirstLeaf(getLeafOptions).then(processLeaf);
    } else if ([">", ">="].indexOf(op) >= 0) {
      const processLeaf = (leaf) => {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (op === ">=" && _isMoreOrEqual(entry.key, param)) {
            add(entry);
          } else if (op === ">" && _isMore(entry.key, param)) {
            add(entry);
          }
        }
        if (leaf.hasNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      return this._findLeaf(param, getLeafOptions).then(processLeaf);
    } else if (op === "==") {
      return this._findLeaf(param, getLeafOptions).then((leaf) => {
        const entry = leaf.entries.find((entry2) => _isEqual(entry2.key, param));
        if (entry) {
          add(entry);
        }
        return ret();
      });
    } else if (op === "!=") {
      const processLeaf = (leaf) => {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (_isNotEqual(entry.key, param)) {
            add(entry);
          }
        }
        if (leaf.hasNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      return this._getFirstLeaf(getLeafOptions).then(processLeaf);
    } else if (op === "like") {
      if (typeof param !== "string") {
        throw new TypeError(`search param value must be a string for operator 'like'`);
      }
      const wildcardIndex = ~(~param.indexOf("*") || ~param.indexOf("?"));
      const startSearch = wildcardIndex > 0 ? param.slice(0, wildcardIndex) : "";
      const pattern = "^" + param.replace(/\*/g, ".*").replace(/\?/g, ".") + "$";
      const re = new RegExp(pattern, "i");
      const processLeaf = (leaf) => {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (re.test(entry.key.toString())) {
            add(entry);
          }
        }
        let stop = false;
        if (wildcardIndex > 0 && leaf.entries.length > 0) {
          const lastEntry = leaf.entries[leaf.entries.length - 1];
          stop = lastEntry.key.toString().slice(0, wildcardIndex) > startSearch;
        }
        if (!stop && leaf.getNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      if (wildcardIndex === 0) {
        return this._getFirstLeaf(getLeafOptions).then(processLeaf);
      } else {
        return this._findLeaf(startSearch, getLeafOptions).then(processLeaf);
      }
    } else if (op === "!like") {
      if (typeof param !== "string") {
        throw new TypeError(`search param value must be a string for operator '!like'`);
      }
      const pattern = "^" + param.replace(/\*/g, ".*").replace(/\?/g, ".") + "$";
      const re = new RegExp(pattern, "i");
      const processLeaf = (leaf) => {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (!re.test(entry.key.toString())) {
            add(entry);
          }
        }
        if (leaf.hasNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      return this._getFirstLeaf(getLeafOptions).then(processLeaf);
    } else if (op === "in") {
      if (!(param instanceof Array)) {
        throw new TypeError(`search param value must be an array for operator 'in'`);
      }
      const sorted = param.slice().sort();
      let searchKey = sorted.shift();
      const processLeaf = (leaf) => {
        while (true) {
          const entry = leaf.entries.find((entry2) => _isEqual(entry2.key, searchKey));
          if (entry) {
            add(entry);
          }
          searchKey = sorted.shift();
          if (!searchKey) {
            return ret();
          } else if (_isMore(searchKey, leaf.entries[leaf.entries.length - 1].key)) {
            return this._findLeaf(searchKey).then(processLeaf);
          }
        }
      };
      return this._findLeaf(searchKey, getLeafOptions).then(processLeaf);
    } else if (op === "!in") {
      if (!(param instanceof Array)) {
        throw new TypeError(`search param value must be an array for operator '!in'`);
      }
      const keys = param;
      const processLeaf = (leaf) => {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          if (keys.findIndex((key) => _isEqual(key, entry.key)) < 0) {
            add(entry);
          }
        }
        if (leaf.hasNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      return this._getFirstLeaf(getLeafOptions).then(processLeaf);
    } else if (op === "between") {
      if (!(param instanceof Array)) {
        throw new TypeError(`search param value must be an array for operator 'between'`);
      }
      let bottom = param[0], top = param[1];
      if (top < bottom) {
        const swap2 = top;
        top = bottom;
        bottom = swap2;
      }
      return this._findLeaf(bottom, getLeafOptions).then((leaf) => {
        let stop = false;
        const processLeaf = (leaf2) => {
          for (let i = 0; i < leaf2.entries.length; i++) {
            const entry = leaf2.entries[i];
            if (_isMoreOrEqual(entry.key, bottom) && _isLessOrEqual(entry.key, top)) {
              add(entry);
            }
            if (_isMore(entry.key, top)) {
              stop = true;
              break;
            }
          }
          if (stop || !leaf2.getNext) {
            return ret();
          } else {
            return leaf2.getNext().then(processLeaf);
          }
        };
        return processLeaf(leaf);
      });
    } else if (op === "!between") {
      if (!(param instanceof Array)) {
        throw new TypeError(`search param value must be an array for operator '!between'`);
      }
      let bottom = param[0], top = param[1];
      if (top < bottom) {
        const swap2 = top;
        top = bottom;
        bottom = swap2;
      }
      return this._getFirstLeaf(getLeafOptions).then((leaf) => {
        let stop = false;
        const processLeaf = (leaf2) => {
          for (let i = 0; i < leaf2.entries.length; i++) {
            const entry = leaf2.entries[i];
            if (_isLess(entry.key, bottom)) {
              add(entry);
            } else {
              stop = true;
              break;
            }
          }
          if (!stop && leaf2.getNext) {
            return leaf2.getNext().then(processLeaf);
          }
        };
        return processLeaf(leaf);
      }).then(() => {
        return this._findLeaf(top, getLeafOptions);
      }).then((leaf) => {
        const processLeaf = (leaf2) => {
          for (let i = 0; i < leaf2.entries.length; i++) {
            const entry = leaf2.entries[i];
            if (_isMore(entry.key, top)) {
              add(entry);
            }
          }
          if (!leaf2.getNext) {
            return ret();
          } else {
            return leaf2.getNext().then(processLeaf);
          }
        };
        return processLeaf(leaf);
      });
    } else if (op === "matches" || op === "!matches") {
      if (!(param instanceof RegExp)) {
        throw new TypeError(`search param value must be a RegExp for operator 'matches' and '!matches'`);
      }
      const re = param;
      const processLeaf = (leaf) => {
        for (let i = 0; i < leaf.entries.length; i++) {
          const entry = leaf.entries[i];
          const isMatch = re.test(entry.key.toString());
          if (isMatch && op === "matches" || !isMatch && op === "!matches") {
            add(entry);
          }
        }
        if (leaf.hasNext) {
          return leaf.getNext().then(processLeaf);
        } else {
          return ret();
        }
      };
      return this._getFirstLeaf(getLeafOptions).then(processLeaf);
    } else {
      throw new Error(`Unknown search operator "${op}"`);
    }
  }
  async find(searchKey, options) {
    return this._threadSafe("shared", () => this._find(searchKey, options));
  }
  async _find(searchKey, options) {
    const leaf = options?.leaf ?? await this._findLeaf(searchKey, options);
    const entry = leaf.entries.find((entry2) => _isEqual(searchKey, entry2.key));
    if (!this.info) {
      throw new NoTreeInfoError();
    }
    if (options && options.stats) {
      return entry?.totalValues ?? 0;
    } else if (entry) {
      if (entry.extData) {
        await entry.extData.loadValues();
      }
      return this.info.isUnique ? entry.values[0] : entry.values;
    } else {
      return null;
    }
  }
  async findAll(keys, options) {
    return this._threadSafe("shared", () => this._findAll(keys, options));
  }
  async _findAll(keys, options = { existingOnly: true, stats: false }) {
    options.stats = options.stats === true;
    if (keys.length <= 2) {
      const promises = keys.map(async (key) => {
        const result = await this._find(key, { stats: options.stats });
        const value = options.stats ? null : result;
        const totalValues = options.stats ? result : value === null ? 0 : value instanceof Array ? value.length : 1;
        return { key, value, totalValues };
      });
      const results2 = await Promise.all(promises);
      return options.existingOnly ? results2.filter((r) => options.stats ? r.totalValues > 0 : r.value !== null) : results2;
    }
    const results = [];
    let lastLeaf = await this._getLastLeaf();
    while (lastLeaf.entries.length === 0 && lastLeaf.hasPrevious) {
      lastLeaf = await lastLeaf.getPrevious();
    }
    if (lastLeaf.entries.length === 0) {
      return [];
    }
    const lastEntry = lastLeaf.entries.slice(-1)[0];
    const lastKey = lastEntry.key;
    keys = keys.slice().sort();
    if (_isMore(keys[0], lastKey)) {
      return options.existingOnly ? [] : keys.map((key) => ({ key, value: null, totalValues: 0 }));
    }
    let firstLeaf = await this._getFirstLeaf();
    while (firstLeaf.entries.length === 0 && firstLeaf.hasNext) {
      firstLeaf = await firstLeaf.getNext();
    }
    const firstEntry = firstLeaf.entries[0];
    const firstKey = firstEntry.key;
    if (_isLess(keys.slice(-1)[0], firstKey)) {
      return options.existingOnly ? [] : keys.map((key) => ({ key, value: null, totalValues: 0 }));
    }
    const lookups = [];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (_isLess(key, firstKey) || _isMore(key, lastKey)) {
        options.existingOnly || results.push({ key, value: null, totalValues: 0 });
      } else {
        lookups.push(key);
      }
    }
    lookups.sort((a, b) => _isLess(a, b) ? -1 : 1);
    for (let i = 0; i < lookups.length; ) {
      let key = lookups[i];
      const leaf = await this._findLeaf(key);
      const lastKey2 = leaf.entries.slice(-1)[0]?.key;
      const expectedKeysInLeaf = lookups.slice(i).filter((key2) => _isLessOrEqual(key2, lastKey2));
      if (!options.stats && leaf.hasExtData && !leaf.extData.loaded && expectedKeysInLeaf.length > 1) {
        await leaf.extData.load();
      }
      const promises = [];
      do {
        const lookupKey = key;
        const p = this._find(lookupKey, { leaf, stats: options.stats }).then((result) => {
          const value = options.stats ? null : result;
          const totalValues = options.stats ? result : value === null ? 0 : value instanceof Array ? value.length : 1;
          const exists2 = options.stats ? totalValues > 0 : value !== null;
          if (exists2 || !options.existingOnly) {
            results.push({ key: lookupKey, value, totalValues });
          }
        });
        promises.push(p);
        key = lookups[++i];
      } while (lastKey2 && i < lookups.length && _isLessOrEqual(key, lastKey2));
      await Promise.all(promises);
    }
    return results;
  }
  async _growTree(bytesNeeded) {
    if (!this.info) {
      throw new NoTreeInfoError();
    }
    if (!this._autoGrow) {
      throw new Error("Cannot grow tree - autoGrow not enabled");
    }
    const grow = bytesNeeded - this.info.freeSpace;
    this.info.byteLength += grow;
    this.info.freeSpace += grow;
    await this._writeAllocationBytes();
  }
  async writeAllocationBytes() {
    return this._threadSafe("exclusive", () => this._writeAllocationBytes());
  }
  async _writeAllocationBytes() {
    if (!this.info) {
      throw new NoTreeInfoError();
    }
    await Promise.all([
      this._writeFn(writeByteLength([], 0, this.info.byteLength), 0),
      this._writeFn(writeByteLength([], 0, this.info.freeSpace), this.info.freeSpaceIndex)
    ]);
  }
  async setAllocationBytes(buffer, byteLength, freeSpace) {
    buffer.set(writeByteLength([], 0, byteLength), 0);
    buffer.set(writeByteLength([], 0, freeSpace), this.info.freeSpaceIndex);
  }
  async _registerFreeSpace(index, length3) {
    if (!this.info) {
      throw new NoTreeInfoError();
    }
    if (!this._fst) {
      this._fst = [];
    }
    if (index + length3 === this.info.byteLength - this.info.freeSpace) {
      this.info.freeSpace += length3;
      await this._writeFn(writeByteLength([], 0, this.info.freeSpace), this.info.freeSpaceIndex);
    } else {
      this._fst.push({ index, length: length3 });
      this._fst.sort((a, b) => a.index < b.index ? -1 : 1);
      let i = 0;
      while (i + 1 < this._fst.length) {
        const block = this._fst[i];
        const next = this._fst[i + 1];
        if (next.index === block.index + block.length) {
          block.length += next.length;
          this._fst.splice(i + 1, 1);
        } else {
          i++;
        }
      }
    }
  }
  async _claimFreeSpace(bytesRequired) {
    if (!this.info) {
      throw new NoTreeInfoError();
    }
    if (bytesRequired > this.info.freeSpace) {
      throw new Error("Attempt to claim more bytes than available in trailing free space");
    }
    this.info.freeSpace -= bytesRequired;
    await this._writeFn(writeByteLength([], 0, this.info.freeSpace), this.info.freeSpaceIndex);
  }
  async _requestFreeSpace(bytesRequired) {
    if (!this.info) {
      throw new NoTreeInfoError();
    }
    if (bytesRequired === 0) {
      throw new Error("Requesting 0 bytes");
    }
    if (!this._fst) {
      this._fst = [];
    }
    const available = this._fst.filter((block) => block.length >= bytesRequired);
    if (available.length > 0) {
      const best = available.sort((a, b) => a.length - b.length)[0];
      this._fst.splice(this._fst.indexOf(best), 1);
      return best;
    } else {
      const wastedSpace = this._fst.reduce((total, block) => total + block.length, 0);
      const maxWaste = Math.round(this._originalByteLength * 0.5);
      if (wastedSpace > maxWaste) {
        throw new Error("too much space being wasted. tree rebuild is needed");
      }
      if (this.info.freeSpace < bytesRequired) {
        if (this.autoGrow) {
          await this._growTree(bytesRequired);
        } else {
          throw new DetailedError("tree-full-no-autogrow", `tree doesn't have ${bytesRequired} free bytes and autoGrow is not enabled`);
        }
      }
      const index = this.info.byteLength - this.info.freeSpace;
      this.info.freeSpace -= bytesRequired;
      await this._writeFn(writeByteLength([], 0, this.info.freeSpace), this.info.freeSpaceIndex);
      return { index, length: bytesRequired };
    }
  }
  async _rebuildLeaf(leaf, options = {
    growData: false,
    growExtData: false,
    rollbackOnFailure: true,
    prevLeaf: null,
    nextLeaf: null
  }) {
    const newLeafExtDataLength = options.growExtData ? Math.ceil(leaf.extData.length * 1.1) : leaf.extData.length;
    const extDataGrowth = newLeafExtDataLength - leaf.extData.length;
    const newLeafLength = options.growData ? Math.ceil(leaf.length * 1.1) : leaf.length;
    const leafGrows = options.growData || options.growExtData;
    const bytesNeeded = newLeafLength + newLeafExtDataLength;
    if (!this.info) {
      throw new NoTreeInfoError();
    }
    if (this.info.freeSpace < bytesNeeded && !options.growData && options.growExtData && leaf.free >= extDataGrowth) {
      if (!leaf.extData.loaded) {
        await leaf.extData.load();
      }
      leaf.length -= extDataGrowth;
      leaf.free -= extDataGrowth;
      leaf.extData.length += extDataGrowth;
      leaf.extData.freeBytes += extDataGrowth;
      options.applyChanges && options.applyChanges(leaf);
      return this._writeLeaf(leaf);
    }
    const reads = [];
    if (leaf.hasExtData) {
      if (!leaf.extData.loaded) {
        reads.push(leaf.extData.load());
      } else if (!leafGrows) {
        options.applyChanges && options.applyChanges(leaf);
        return this._writeLeaf(leaf);
      }
    }
    if (reads.length > 0) {
      await Promise.all(reads);
    }
    const oneLeafTree = !leaf.parentNode;
    try {
      let allocated;
      if (oneLeafTree) {
        const available = leaf.length + leaf.extData.length + this.info.freeSpace;
        if (bytesNeeded < available) {
          await this._claimFreeSpace(bytesNeeded - leaf.length - leaf.extData.length);
          allocated = { index: leaf.index, length: bytesNeeded };
        } else if (this.autoGrow) {
          const growBytes = bytesNeeded - available;
          await this._growTree(growBytes);
          allocated = { index: leaf.index, length: bytesNeeded };
        } else {
          throw new Error("Not enough space to overwrite one leaf tree");
        }
      } else {
        allocated = await this._requestFreeSpace(bytesNeeded);
      }
      const newLeaf = new BinaryBPlusTreeLeaf({
        isLeaf: true,
        index: allocated.index,
        length: allocated.length - newLeafExtDataLength,
        hasExtData: leaf.hasExtData,
        tree: leaf.tree
      });
      newLeaf.prevLeafIndex = leaf.prevLeafIndex;
      newLeaf.nextLeafIndex = leaf.nextLeafIndex;
      newLeaf.entries = leaf.entries.map((entry) => new BinaryBPlusTreeLeafEntry(entry.key, entry.values.slice()));
      if (leaf.hasExtData) {
        newLeaf.extData = {
          loaded: true,
          length: newLeafExtDataLength,
          freeBytes: leaf.extData.freeBytes + (newLeafExtDataLength - leaf.extData.length),
          load: noop2
        };
      }
      if (leaf.parentEntry) {
        leaf.parentEntry.ltChildIndex = newLeaf.index;
      } else if (leaf.parentNode) {
        leaf.parentNode.gtChildIndex = newLeaf.index;
      }
      const freedBytes = leaf.length + leaf.extData.length;
      options.applyChanges && options.applyChanges(newLeaf);
      const tx = new TX();
      tx.queue({
        name: "new leaf",
        action: async () => {
          const result = await this._writeLeaf(newLeaf);
          return `${result.length} leaf writes`;
        },
        rollback: async () => {
          if (oneLeafTree) {
            if (options.rollbackOnFailure === false) {
              return;
            }
            return this._writeLeaf(leaf, { addFreeSpace: false });
          } else {
            return this._registerFreeSpace(allocated.index, allocated.length);
          }
        }
      });
      if (leaf.hasPrevious) {
        const prevLeaf = {
          nextPointerIndex: leaf.prevLeafIndex + BinaryBPlusTreeLeaf.nextLeafPtrIndex,
          oldOffset: BinaryBPlusTreeLeaf.getNextLeafOffset(leaf.prevLeafIndex, leaf.index),
          newOffset: BinaryBPlusTreeLeaf.getNextLeafOffset(leaf.prevLeafIndex, newLeaf.index)
        };
        tx.queue({
          name: "prev leaf next_leaf_ptr",
          action: async () => {
            const bytes = writeSignedOffset([], 0, prevLeaf.newOffset, true);
            return this._writeFn(bytes, prevLeaf.nextPointerIndex);
          },
          rollback: async () => {
            const bytes = writeSignedOffset([], 0, prevLeaf.oldOffset, true);
            return this._writeFn(bytes, prevLeaf.nextPointerIndex);
          }
        });
      }
      if (leaf.hasNext) {
        const nextLeaf = {
          prevPointerIndex: leaf.nextLeafIndex + BinaryBPlusTreeLeaf.prevLeafPtrIndex,
          oldOffset: BinaryBPlusTreeLeaf.getPrevLeafOffset(leaf.nextLeafIndex, leaf.index),
          newOffset: BinaryBPlusTreeLeaf.getPrevLeafOffset(leaf.nextLeafIndex, newLeaf.index)
        };
        tx.queue({
          name: "next leaf prev_leaf_ptr",
          action: async () => {
            const bytes = writeSignedOffset([], 0, nextLeaf.newOffset, true);
            return this._writeFn(bytes, nextLeaf.prevPointerIndex);
          },
          rollback: async () => {
            const bytes = writeSignedOffset([], 0, nextLeaf.oldOffset, true);
            return this._writeFn(bytes, nextLeaf.prevPointerIndex);
          }
        });
      }
      if (leaf.parentNode) {
        tx.queue({
          name: "parent node",
          action: async () => {
            return this._writeNode(leaf.parentNode);
          },
          rollback: async () => {
            if (leaf.parentEntry) {
              leaf.parentEntry.ltChildIndex = leaf.index;
            } else {
              leaf.parentNode.gtChildIndex = leaf.index;
            }
            if (options.nextLeaf.parentNode === leaf.parentNode) {
              if (options.nextLeaf.parentEntry) {
                options.nextLeaf.parentEntry.ltChildIndex = options.nextLeaf.index;
              } else {
                options.nextLeaf.parentNode.gtChildIndex = options.nextLeaf.index;
              }
            }
            return this._writeNode(leaf.parentNode);
          }
        });
      }
      const results = await tx.execute(true);
      if (!oneLeafTree) {
        await this._registerFreeSpace(leaf.index, freedBytes);
      }
      return results;
    } catch (err) {
      throw new DetailedError("rebuild-leaf-failed", `Failed to rebuild leaf: ${err.message}`, err);
    }
  }
  async _splitNode(node, options = { keepEntries: 0, cancelCallback: null }) {
    if (typeof options.cancelCallback !== "function") {
      throw new Error("specify options.cancelCallback to undo any changes when a rollback needs to be performed");
    }
    try {
      if (!node.parentNode) {
        throw new DetailedError("cannot-split-top-level-node", "Cannot split top-level node, tree rebuild is needed");
      }
      if (node.parentNode.entries.length >= this.info.entriesPerNode) {
        const { node1, node2 } = await this._splitNode(node.parentNode, { cancelCallback: noop2 });
        const parentEntry1 = node1.entries.find((e) => e.ltChildIndex === node.index);
        const parentEntry2 = node2.entries.find((e) => e.ltChildIndex === node.index);
        if (parentEntry1) {
          node.parentNode = node1;
          node.parentEntry = parentEntry1;
        } else if (parentEntry2) {
          node.parentNode = node2;
          node.parentEntry = parentEntry2;
        } else if (node1.gtChildIndex === node.index) {
          node.parentNode = node1;
          node.parentEntry = null;
        } else if (node2.gtChildIndex === node.index) {
          node.parentNode = node2;
          node.parentEntry = null;
        } else {
          throw new Error("DEV ERROR: new parent nodes do not reference this node");
        }
      }
      if (typeof options.keepEntries !== "number" || options.keepEntries === 0) {
        options.keepEntries = Math.floor(node.entries.length / 2);
      }
      if (options.keepEntries > this.info.entriesPerNode - 2) {
        options.keepEntries = this.info.entriesPerNode - 2;
      }
      const newNodeLength = node.length;
      const allocated = await this._requestFreeSpace(newNodeLength);
      const newNode = new BinaryBPlusTreeNode({
        isLeaf: false,
        length: newNodeLength,
        index: allocated.index,
        tree: node.tree
      });
      newNode.gtChildIndex = node.gtChildIndex;
      const movingEntries = node.entries.splice(options.keepEntries);
      const disappearingEntry = movingEntries.shift();
      node.gtChildIndex = disappearingEntry.ltChildIndex;
      newNode.entries.push(...movingEntries);
      const oldParentNode = new BinaryBPlusTreeNode({
        isLeaf: false,
        index: node.parentNode.index,
        length: node.parentNode.length,
        free: node.parentNode.free
      });
      oldParentNode.gtChildIndex = node.parentNode.gtChildIndex;
      oldParentNode.entries = node.parentNode.entries.map((entry) => {
        const newEntry = new BinaryBPlusTreeNodeEntry(entry.key);
        newEntry.ltChildIndex = entry.ltChildIndex;
        return newEntry;
      });
      if (node.parentEntry !== null) {
        const newEntryKey = node.parentEntry.key;
        node.parentEntry.key = disappearingEntry.key;
        const insertIndex = node.parentNode.entries.indexOf(node.parentEntry) + 1;
        const newNodeEntry = new BinaryBPlusTreeNodeEntry(newEntryKey);
        newNodeEntry.ltChildIndex = newNode.index;
        node.parentNode.entries.splice(insertIndex, 0, newNodeEntry);
      } else {
        const newNodeEntry = new BinaryBPlusTreeNodeEntry(disappearingEntry.key);
        newNodeEntry.ltChildIndex = node.index;
        node.parentNode.entries.push(newNodeEntry);
        node.parentNode.gtChildIndex = newNode.index;
      }
      const tx = new TX();
      tx.queue({
        name: "write new node",
        action: async () => {
          return this._writeNode(newNode);
        },
        rollback: async () => {
          return this._registerFreeSpace(allocated.index, allocated.length);
        }
      });
      tx.queue({
        name: "rewrite current node",
        action: async () => {
          return this._writeNode(node);
        },
        rollback: async () => {
          node.entries.push(...movingEntries);
          const p = options.cancelCallback();
          if (p instanceof Promise) {
            return p.then(() => {
              return this._writeNode(node);
            });
          }
          return this._writeNode(node);
        }
      });
      tx.queue({
        name: "rewrite parent node",
        action: async () => {
          return this._writeNode(node.parentNode);
        },
        rollback: async () => {
          return this._writeNode(oldParentNode);
        }
      });
      await tx.execute(true);
      return { node1: node, node2: newNode };
    } catch (err) {
      throw new DetailedError("split-node-failed", `Unable to split node: ${err.message}`, err);
    }
  }
  async _splitLeaf(leaf, options = { nextLeaf: null, keepEntries: 0, cancelCallback: null }) {
    if (typeof options.cancelCallback !== "function") {
      throw new Error("specify options.cancelCallback to undo any changes when a rollback needs to be performed");
    }
    if (!leaf.parentNode) {
      throw new DetailedError("single-leaf-tree-split", "Cannot split leaf because it is a single-leaf tree. Tree needs to be rebuilt");
    }
    if (leaf.parentNode.entries.length >= this.info.entriesPerNode) {
      const { node1, node2 } = await this._splitNode(leaf.parentNode, { keepEntries: options.keepEntries, cancelCallback: noop2 });
      const parentEntry1 = node1.entries.find((e) => e.ltChildIndex === leaf.index);
      const parentEntry2 = node2.entries.find((e) => e.ltChildIndex === leaf.index);
      if (parentEntry1) {
        leaf.parentNode = node1;
        leaf.parentEntry = parentEntry1;
      } else if (parentEntry2) {
        leaf.parentNode = node2;
        leaf.parentEntry = parentEntry2;
      } else if (node1.gtChildIndex === leaf.index) {
        leaf.parentNode = node1;
        leaf.parentEntry = null;
      } else if (node2.gtChildIndex === leaf.index) {
        leaf.parentNode = node2;
        leaf.parentEntry = null;
      } else {
        throw new Error("DEV ERROR: new parent nodes have no reference this leaf");
      }
    }
    if (typeof options.keepEntries !== "number" || options.keepEntries === 0) {
      options.keepEntries = leaf.hasNext ? Math.floor(leaf.entries.length / 2) : Math.floor(this.info.entriesPerNode * (this.info.fillFactor / 100));
    }
    const reads = [];
    if (!options.nextLeaf && leaf.hasNext) {
      reads.push(leaf.getNext().then((nextLeaf) => {
        options.nextLeaf = nextLeaf;
      }));
    }
    if (leaf.hasExtData && !leaf.extData.loaded) {
      reads.push(leaf.extData.load());
    }
    if (reads.length > 0) {
      await Promise.all(reads);
    }
    try {
      const movingEntries = leaf.entries.slice(options.keepEntries);
      const extDataLengths = leaf.entries.filter((entry) => entry.extData).map((entry) => entry.extData.length + 8 - entry.extData.freeBytes);
      const avgExtDataLength = extDataLengths.length === 0 ? 0 : extDataLengths.reduce((total, length3) => total + length3, 0) / extDataLengths.length;
      const movingExtDataLength = movingEntries.reduce((total, entry) => total + (entry.extData ? entry.extData.length + 8 - entry.extData.freeBytes : 0), 0);
      const newLeafExtDataLength = Math.ceil(avgExtDataLength * this.info.entriesPerNode);
      const newLeafLength = leaf.length;
      const allocated = await this._requestFreeSpace(newLeafLength + newLeafExtDataLength);
      const nextLeaf = options.nextLeaf;
      const newLeaf = new BinaryBPlusTreeLeaf({
        isLeaf: true,
        length: newLeafLength,
        index: allocated.index,
        tree: leaf.tree,
        hasExtData: newLeafExtDataLength > 0
      });
      if (newLeafExtDataLength > 0) {
        newLeaf.extData = {
          loaded: true,
          length: newLeafExtDataLength,
          freeBytes: newLeafExtDataLength - movingExtDataLength,
          load: noop2
        };
      }
      newLeaf.prevLeafIndex = leaf.index;
      newLeaf.nextLeafIndex = nextLeaf ? nextLeaf.index : 0;
      leaf.nextLeafIndex = newLeaf.index;
      if (nextLeaf) {
        nextLeaf.prevLeafIndex = newLeaf.index;
      }
      leaf.entries.splice(-movingEntries.length);
      newLeaf.entries.push(...movingEntries);
      const oldParentNode = new BinaryBPlusTreeNode({
        isLeaf: false,
        index: leaf.parentNode.index,
        length: leaf.parentNode.length,
        free: leaf.parentNode.free
      });
      oldParentNode.gtChildIndex = leaf.parentNode.gtChildIndex;
      oldParentNode.entries = leaf.parentNode.entries.map((entry) => {
        const newEntry = new BinaryBPlusTreeNodeEntry(entry.key);
        newEntry.ltChildIndex = entry.ltChildIndex;
        return newEntry;
      });
      if (leaf.parentEntry !== null) {
        const newEntryKey = leaf.parentEntry.key;
        leaf.parentEntry.key = movingEntries[0].key;
        const insertIndex = leaf.parentNode.entries.indexOf(leaf.parentEntry) + 1;
        const newNodeEntry = new BinaryBPlusTreeNodeEntry(newEntryKey);
        newNodeEntry.ltChildIndex = newLeaf.index;
        leaf.parentNode.entries.splice(insertIndex, 0, newNodeEntry);
      } else {
        const newNodeEntry = new BinaryBPlusTreeNodeEntry(movingEntries[0].key);
        newNodeEntry.ltChildIndex = leaf.index;
        leaf.parentNode.entries.push(newNodeEntry);
        leaf.parentNode.gtChildIndex = newLeaf.index;
      }
      const tx = new TX();
      tx.queue({
        name: "write new leaf",
        action: async () => {
          return this._writeLeaf(newLeaf);
        },
        rollback: async () => {
          return this._registerFreeSpace(allocated.index, allocated.length);
        }
      });
      nextLeaf && tx.queue({
        name: "rewrite next leaf",
        action: async () => {
          return this._writeLeaf(nextLeaf);
        },
        rollback: async () => {
          nextLeaf.prevLeafIndex = leaf.index;
          return this._writeLeaf(nextLeaf);
        }
      });
      tx.queue({
        name: "rewrite current leaf",
        action: async () => {
          return this._writeLeaf(leaf);
        },
        rollback: async () => {
          leaf.entries.push(...movingEntries);
          leaf.nextLeafIndex = nextLeaf ? nextLeaf.index : 0;
          await options.cancelCallback();
          return this._writeLeaf(leaf);
        }
      });
      tx.queue({
        name: "rewrite parent node",
        action: async () => {
          return this._writeNode(leaf.parentNode);
        },
        rollback: async () => {
          return this._writeNode(oldParentNode);
        }
      });
      const results = await tx.execute(true);
      return results;
    } catch (err) {
      throw new DetailedError("split-leaf-failed", `Unable to split leaf: ${err.message}`, err);
    }
  }
  async add(key, recordPointer, metadata) {
    return this._threadSafe("exclusive", () => this._add(key, recordPointer, metadata));
  }
  async _add(key, recordPointer, metadata) {
    if (!this.info) {
      await this._loadInfo();
    }
    const err = _checkNewEntryArgs(key, recordPointer, this.info.metadataKeys, metadata);
    if (err) {
      throw err;
    }
    const entryValue = new BinaryBPlusTreeLeafEntryValue(recordPointer, metadata);
    if (!this.id) {
      throw new DetailedError("tree-id-not-set", "To edit tree, set the id property to something unique for locking purposes");
    }
    try {
      const leaf = await this._findLeaf(key);
      if (!this.info.hasLargePtrs) {
        throw new DetailedError("small-ptrs-deprecated", "small ptrs have deprecated, tree will have to be rebuilt");
      }
      const entryIndex = leaf.entries.findIndex((entry2) => _isEqual(key, entry2.key));
      let addNew = false;
      if (this.info.isUnique) {
        if (entryIndex >= 0) {
          throw new DetailedError("unique-key-violation", `Cannot add duplicate key "${key}": tree expects unique keys`);
        }
        addNew = true;
      } else {
        if (entryIndex >= 0) {
          const entry2 = leaf.entries[entryIndex];
          if (entry2.extData) {
            try {
              return await entry2.extData.addValue(recordPointer, metadata);
            } catch (err2) {
              if (err2.code !== "max-extdata-size-reached") {
                throw err2;
              }
              const rebuildOptions = {
                growData: false,
                growExtData: true,
                applyChanges: (leaf2) => {
                  const entry3 = leaf2.entries.find((entry4) => _isEqual(entry4.key, key));
                  entry3.values.push(new BinaryBPlusTreeLeafEntryValue(recordPointer, metadata));
                }
              };
              return await this._rebuildLeaf(leaf, rebuildOptions);
            }
          }
          entry2.values.push(entryValue);
        } else {
          addNew = true;
        }
      }
      if (!addNew) {
        try {
          return await this._writeLeaf(leaf);
        } catch (err2) {
          const extDataError = DetailedError.hasErrorCode(err2, "max-extdata-size-reached");
          try {
            return await this._rebuildLeaf(leaf, {
              growData: !extDataError,
              growExtData: extDataError,
              rollbackOnFailure: false
            });
          } catch (err3) {
            throw new DetailedError("add-value-failed", `Can't add value to key '${key}': ${err3.message}`, err3);
          }
        }
      }
      const entry = new BinaryBPlusTreeLeafEntry(key, [entryValue]);
      const insertBeforeIndex = leaf.entries.findIndex((entry2) => _isMore(entry2.key, key));
      const isLastEntry = insertBeforeIndex === -1;
      if (isLastEntry) {
        leaf.entries.push(entry);
      } else {
        leaf.entries.splice(insertBeforeIndex, 0, entry);
      }
      if (leaf.entries.length <= this.info.entriesPerNode) {
        try {
          return await this._writeLeaf(leaf);
        } catch (err2) {
          if (!DetailedError.hasErrorCode(err2, "max-leaf-size-reached")) {
            throw err2;
          }
          return await this._rebuildLeaf(leaf, {
            growData: true,
            growExtData: leaf.hasExtData,
            rollbackOnFailure: false
          });
        }
      }
      const undoAdd = () => {
        const index = leaf.entries.indexOf(entry);
        index >= 0 && leaf.entries.splice(index, 1);
      };
      if (!leaf.parentNode) {
        undoAdd();
        throw new DetailedError("slt-no-space-available", `Cannot add key "${key}", no space left in single leaf tree`);
      }
      return await this._splitLeaf(leaf, { cancelCallback: undoAdd, keepEntries: isLastEntry ? this.info.entriesPerNode : 0 });
    } catch (err2) {
      throw new DetailedError("add-key-failed", `Can't add key '${key}': ${err2.message}`, err2);
    }
  }
  async _process(operations) {
    if (!this.info) {
      await this._loadInfo();
    }
    if (!this.info.isUnique) {
      throw new DetailedError("non-unique-tree", 'DEV ERROR: process() should not be called on non-unique trees because of ext_data complexity, cannot handle that yet. Use old "transaction" logic instead');
    }
    if (operations.length === 0) {
      return;
    }
    operations.filter((op) => op.type === "add").forEach(({ key, recordPointer, metadata }) => {
      const err = _checkNewEntryArgs(key, recordPointer, this.info.metadataKeys, metadata);
      if (err) {
        throw err;
      }
    });
    operations.filter((op) => op.type === "update").forEach(({ key, newValue }) => {
      const err = _checkNewEntryArgs(key, newValue.recordPointer, this.info.metadataKeys, newValue.metadata);
      if (err) {
        throw err;
      }
    });
    if (!this.info.hasLargePtrs) {
      throw new DetailedError("small-ptrs-deprecated", "small ptrs have deprecated, tree will have to be rebuilt");
    }
    let batchedOps = [];
    try {
      operations.sort((a, b) => _isLess(a.key, b.key) ? -1 : 1);
      let leaf = await this._findLeaf(operations[0].key);
      let undo = [];
      const saveLeaf = async () => {
        if (leaf.entries.length > this.info.entriesPerNode) {
          const cancelCallback = () => undo.splice(0).reverse().forEach((fn) => fn());
          const keepEntries = leaf.hasNext ? 0 : this.info.entriesPerNode;
          await this._splitLeaf(leaf, { cancelCallback, keepEntries });
        } else if (leaf.entries.length > 0 || !leaf.parentNode) {
          try {
            await this._writeLeaf(leaf);
          } catch (err) {
            await this._rebuildLeaf(leaf, {
              growData: true,
              growExtData: true,
              rollbackOnFailure: false
            });
          }
        } else if (leaf.parentNode.entries.length > 1) {
          await this._removeLeaf(leaf);
        } else {
          await this._writeLeaf(leaf);
          const options = {
            allocatedBytes: this.info.byteLength,
            fillFactor: this.info.fillFactor,
            increaseMaxEntries: false
          };
          await this._rebuild(BinaryWriter.forFunction(this._writeFn), options);
          await this._loadInfo();
        }
      };
      while (operations.length > 0) {
        const op = operations.shift();
        const { type, key, recordPointer, metadata, newValue, currentValue } = op;
        const applyToThisLeaf = (() => {
          if (type === "add" && leaf.entries.length >= this.info.entriesPerNode) {
            return false;
          }
          const pointsThisDirection = (node) => {
            if (node.parentEntry) {
              return _isLess(key, node.parentEntry.key);
            } else if (node.parentNode) {
              if (!_isMoreOrEqual(key, node.parentNode.entries.slice(-1)[0].key)) {
                return false;
              }
              return pointsThisDirection(node.parentNode);
            } else {
              return true;
            }
          };
          return pointsThisDirection(leaf);
        })();
        if (!applyToThisLeaf) {
          await saveLeaf();
          batchedOps = [];
          undo = [];
          leaf = await this._findLeaf(key);
        }
        batchedOps.push(op);
        const entryIndex = leaf.entries.findIndex((entry2) => _isEqual(key, entry2.key));
        const entry = leaf.entries[entryIndex];
        if (type === "remove") {
          if (!entry) {
            throw new DetailedError("key-not-found", `Cannot remove key "${key}" because it is not present in the tree`);
          } else {
            leaf.entries.splice(entryIndex, 1);
            undo.push(() => {
              leaf.entries.splice(entryIndex, 0, entry);
            });
          }
        } else if (type === "add") {
          if (entry) {
            throw new DetailedError("unique-key-violation", `Cannot add duplicate key "${key}": tree expects unique keys`);
          } else {
            const value = new BinaryBPlusTreeLeafEntryValue(recordPointer, metadata);
            const entry2 = new BinaryBPlusTreeLeafEntry(key, [value]);
            const insertBeforeIndex = leaf.entries.findIndex((entry3) => _isMore(entry3.key, key));
            const isLastEntry = insertBeforeIndex === -1;
            if (isLastEntry) {
              leaf.entries.push(entry2);
            } else {
              leaf.entries.splice(insertBeforeIndex, 0, entry2);
            }
            undo.push(() => leaf.entries.splice(leaf.entries.indexOf(entry2), 1));
          }
        } else if (type === "update") {
          if (!entry) {
            throw new DetailedError("key-not-found", `Cannot update key "${key}" because it is not present in the tree`);
          } else {
            entry.values[0] = newValue;
            undo.push(() => entry.values[0] = currentValue);
          }
        }
      }
      if (batchedOps.length > 0) {
        await saveLeaf();
      }
    } catch (err) {
      operations.push(...batchedOps);
      throw err;
    }
  }
  async remove(key, recordPointer) {
    return this._threadSafe("exclusive", () => this._remove(key, recordPointer));
  }
  async _remove(key, recordPointer) {
    try {
      const leaf = await this._findLeaf(key);
      if (!this.info.hasLargePtrs) {
        throw new DetailedError("small-ptrs-deprecated", "small ptrs have deprecated, tree will have to be rebuilt");
      }
      const entryIndex = leaf.entries.findIndex((entry) => _isEqual(key, entry.key));
      if (entryIndex < 0) {
        return;
      }
      if (this.info.isUnique || typeof recordPointer === "undefined" || leaf.entries[entryIndex].totalValues === 1) {
        leaf.entries.splice(entryIndex, 1);
      } else if (leaf.entries[entryIndex].extData) {
        return leaf.entries[entryIndex].extData.removeValue(recordPointer);
      } else {
        const valueIndex = leaf.entries[entryIndex].values.findIndex((val) => _compareBinary(val.recordPointer, recordPointer));
        if (valueIndex < 0) {
          return;
        }
        leaf.entries[entryIndex].values.splice(valueIndex, 1);
      }
      if (leaf.parentNode && leaf.entries.length === 0) {
        if (leaf.parentNode.entries.length === 1) {
          throw new DetailedError("leaf-empty", "leaf is now empty and parent node has only 1 entry, tree will have to be rebuilt");
        }
        return await this._removeLeaf(leaf);
      }
      return await this._writeLeaf(leaf);
    } catch (err) {
      throw new DetailedError("remove-key-failed", `Can't remove key '${key}': ${err.message}`, err);
    }
  }
  async _removeLeaf(leaf) {
    try {
      assert(leaf.parentNode && leaf.parentNode.entries.length >= 2, "Leaf to remove must have a parent node with at least 2 entries");
      assert(leaf.entries.length === 0, "Leaf to remove must be empty");
      const freedBytes = leaf.length + leaf.extData.length;
      const tx = new TX();
      if (leaf.hasPrevious) {
        const prevLeaf = {
          nextPointerIndex: leaf.prevLeafIndex + BinaryBPlusTreeLeaf.nextLeafPtrIndex,
          oldOffset: BinaryBPlusTreeLeaf.getNextLeafOffset(leaf.prevLeafIndex, leaf.index),
          newOffset: BinaryBPlusTreeLeaf.getNextLeafOffset(leaf.prevLeafIndex, leaf.nextLeafIndex)
        };
        tx.queue({
          name: "prev leaf next_leaf_ptr",
          action: async () => {
            const bytes = writeSignedOffset([], 0, prevLeaf.newOffset, true);
            return this._writeFn(bytes, prevLeaf.nextPointerIndex);
          },
          rollback: async () => {
            const bytes = writeSignedOffset([], 0, prevLeaf.oldOffset, true);
            return this._writeFn(bytes, prevLeaf.nextPointerIndex);
          }
        });
      }
      if (leaf.hasNext) {
        const nextLeaf = {
          prevPointerIndex: leaf.nextLeafIndex + BinaryBPlusTreeLeaf.prevLeafPtrIndex,
          oldOffset: BinaryBPlusTreeLeaf.getPrevLeafOffset(leaf.nextLeafIndex, leaf.index),
          newOffset: BinaryBPlusTreeLeaf.getPrevLeafOffset(leaf.nextLeafIndex, leaf.prevLeafIndex)
        };
        tx.queue({
          name: "next leaf prev_leaf_ptr",
          action: async () => {
            const bytes = writeSignedOffset([], 0, nextLeaf.newOffset, true);
            return this._writeFn(bytes, nextLeaf.prevPointerIndex);
          },
          rollback: async () => {
            const bytes = writeSignedOffset([], 0, nextLeaf.oldOffset, true);
            return this._writeFn(bytes, nextLeaf.prevPointerIndex);
          }
        });
      }
      const parentNodeInfo = {
        entries: leaf.parentNode.entries.slice(),
        gtChildIndex: leaf.parentNode.gtChildIndex
      };
      if (leaf.parentEntry) {
        const removeEntryIndex = leaf.parentNode.entries.indexOf(leaf.parentEntry);
        leaf.parentNode.entries.splice(removeEntryIndex, 1);
      } else {
        const lastEntry = leaf.parentNode.entries.splice(-1)[0];
        leaf.parentNode.gtChildIndex = lastEntry.ltChildIndex;
      }
      tx.queue({
        name: "parent node",
        action: async () => {
          return this._writeNode(leaf.parentNode);
        },
        rollback: async () => {
          leaf.parentNode.entries = parentNodeInfo.entries;
          leaf.parentNode.gtChildIndex = parentNodeInfo.gtChildIndex;
          return this._writeNode(leaf.parentNode);
        }
      });
      await tx.execute(true);
      await this._registerFreeSpace(leaf.index, freedBytes);
    } catch (err) {
      throw new DetailedError("remove-leaf-failed", `Failed to remove leaf: ${err.message}`, err);
    }
  }
  async update(key, newRecordPointer, currentRecordPointer, newMetadata) {
    return this._threadSafe("exclusive", () => this._update(key, newRecordPointer, currentRecordPointer, newMetadata));
  }
  async _update(key, newRecordPointer, currentRecordPointer, newMetadata) {
    try {
      if (currentRecordPointer === null) {
        currentRecordPointer = void 0;
      }
      const newEntryValue = new BPlusTreeLeafEntryValue(newRecordPointer, newMetadata);
      const leaf = await this._findLeaf(key);
      const entryIndex = leaf.entries.findIndex((entry2) => _isEqual(entry2.key, key));
      if (!~entryIndex) {
        throw new DetailedError("key-not-found", `Key to update ("${key}") not found`);
      }
      const entry = leaf.entries[entryIndex];
      if (this.info.isUnique) {
        entry.values = [newEntryValue];
      } else if (typeof currentRecordPointer === "undefined") {
        throw new DetailedError("current-value-not-given", "To update a non-unique key, the current value must be passed as parameter");
      } else {
        const valueIndex = entry.values.findIndex((val) => _compareBinary(val.recordPointer, currentRecordPointer));
        if (!~valueIndex) {
          throw new DetailedError("key-value-pair-not-found", `Key/value combination to update not found (key: "${key}") `);
        }
        entry.values[valueIndex] = newEntryValue;
      }
      return await this._writeLeaf(leaf);
    } catch (err) {
      throw new DetailedError("update-value-failed", `Could not update value for key '${key}': ${err.message}`, err);
    }
  }
  async transaction(operations) {
    return this._threadSafe("exclusive", () => this._transaction(operations));
  }
  async _transaction(operations) {
    if (!this.info) {
      const reader = await this._getReader();
      if (typeof reader.close === "function") {
        reader.close();
      }
    }
    if (this.info.isUnique) {
      return this._process(operations);
    }
    while (operations.length > 0) {
      const op = operations.shift();
      try {
        switch (op.type) {
          case "add": {
            await this._add(op.key, op.recordPointer, op.metadata);
            break;
          }
          case "remove": {
            await this._remove(op.key, op.recordPointer);
            break;
          }
          case "update": {
            await this._update(op.key, op.newValue.recordPointer, op.currentValue.recordPointer, op.newValue.metadata);
            break;
          }
        }
      } catch (err) {
        operations.unshift(op);
        throw err;
      }
    }
  }
  async toTree(fillFactor = 100) {
    const builder = await this.toTreeBuilder(fillFactor);
    return builder.create();
  }
  async toTreeBuilder(fillFactor) {
    return this._threadSafe("shared", () => this._toTreeBuilder(fillFactor));
  }
  async _toTreeBuilder(fillFactor) {
    const treeBuilder = new BPlusTreeBuilder(this.info.isUnique, fillFactor, this.info.metadataKeys);
    let leaf = await this._getFirstLeaf();
    while (leaf) {
      leaf.entries.forEach((entry) => {
        entry.values.forEach((entryValue) => treeBuilder.add(entry.key, entryValue.value, entryValue.metadata));
      });
      leaf = leaf.getNext ? await leaf.getNext() : null;
    }
    return treeBuilder;
  }
  async rebuild(writer, options) {
    return this._threadSafe("exclusive", () => this._rebuild(writer, options));
  }
  async _rebuild(writer, options = {
    allocatedBytes: 0,
    fillFactor: 95,
    keepFreeSpace: true,
    increaseMaxEntries: true,
    reserveSpaceForNewEntries: 0,
    repairMode: false
  }) {
    const perf = {};
    const mark = (name) => {
      const keys = name.split(".");
      const key = keys.pop();
      const target = keys.reduce((t, key2) => key2 in t ? t[key2] : t[key2] = {}, perf);
      target[key] = Date.now();
    };
    const measure = (mark1, mark2) => {
      const getMark = (name) => {
        const keys = name.split(".");
        const key = keys.pop();
        const target = keys.reduce((t, key2) => key2 in t ? t[key2] : t[key2] = {}, perf);
        return target[key];
      };
      return getMark(mark2) - getMark(mark1);
    };
    mark("start");
    if (!(writer instanceof BinaryWriter)) {
      throw new DetailedError("invalid-argument", "writer argument must be an instance of BinaryWriter");
    }
    if (!this.info) {
      await this._getReader();
    }
    const originalChunkSize = this._chunkSize;
    options = options || {};
    options.fillFactor = options.fillFactor || this.info.fillFactor || 95;
    options.keepFreeSpace = options.keepFreeSpace !== false;
    options.increaseMaxEntries = options.increaseMaxEntries !== false;
    options.treeStatistics = options.treeStatistics || { byteLength: 0, totalEntries: 0, totalValues: 0, totalLeafs: 0, depth: 0, entriesPerNode: 0 };
    if (typeof options.allocatedBytes === "number") {
      options.treeStatistics.byteLength = options.allocatedBytes;
    }
    let maxEntriesPerNode = this.info.entriesPerNode;
    if (options.increaseMaxEntries && maxEntriesPerNode < 255) {
      maxEntriesPerNode = Math.min(255, Math.round(maxEntriesPerNode * 1.1));
    }
    options.treeStatistics.entriesPerNode = maxEntriesPerNode;
    const leafStats = {
      totalEntries: 0,
      totalValues: 0,
      totalEntryBytes: 0,
      totalKeyBytes: 0,
      readLeafs: 0,
      readEntries: 0,
      writtenLeafs: 0,
      writtenEntries: 0,
      get averageEntryLength() {
        return Math.ceil(this.totalEntryBytes / this.totalEntries);
      },
      get averageKeyLength() {
        return Math.ceil(this.totalKeyBytes / this.totalEntries);
      }
    };
    const getKeySize = (key) => {
      if (typeof key === "number" || key instanceof Date) {
        return 4;
      }
      if (typeof key === "string") {
        return key.length;
      }
      if (typeof key === "boolean") {
        return 1;
      }
      if (typeof key === "bigint") {
        return bigintToBytes4(key).length;
      }
    };
    try {
      const getLeafStartKeys = async (entriesPerLeaf) => {
        mark("getLeafStartKeys.start");
        const leafStartKeys = [];
        let entriesFromLastLeafStart = 0;
        let leaf = await this._getFirstLeaf();
        let loop = 1;
        while (leaf) {
          mark(`getLeafStartKeys.loop${loop++}`);
          if (leaf.entries.length === 0) {
            leaf = leaf.getNext ? await leaf.getNext(options.repairMode) : null;
            continue;
          }
          leafStats.totalEntries += leaf.entries.length;
          leafStats.totalValues += leaf.entries.reduce((total, entry) => total + entry.totalValues, 0);
          leafStats.totalEntryBytes += leaf.length;
          leafStats.totalKeyBytes += leaf.entries.reduce((total, entry) => total + getKeySize(entry.key), 0);
          if (leafStartKeys.length === 0 || entriesFromLastLeafStart === entriesPerLeaf) {
            leafStartKeys.push(leaf.entries[0].key);
            entriesFromLastLeafStart = 0;
          }
          if (entriesFromLastLeafStart + leaf.entries.length <= entriesPerLeaf) {
            entriesFromLastLeafStart += leaf.entries.length;
          } else {
            let cutIndex = entriesPerLeaf - entriesFromLastLeafStart;
            let firstLeafEntry = leaf.entries[cutIndex];
            leafStartKeys.push(firstLeafEntry.key);
            entriesFromLastLeafStart = leaf.entries.length - cutIndex;
            while (entriesFromLastLeafStart > entriesPerLeaf) {
              cutIndex += entriesPerLeaf;
              firstLeafEntry = leaf.entries[cutIndex];
              leafStartKeys.push(firstLeafEntry.key);
              entriesFromLastLeafStart = leaf.entries.length - cutIndex;
            }
          }
          leaf = leaf.getNext ? await leaf.getNext(options.repairMode) : null;
        }
        mark("getLeafStartKeys.end");
        return leafStartKeys;
      };
      let lastLeaf = null;
      let getEntryCalls = 1;
      const getEntries = async (n) => {
        if (getEntryCalls === 1) {
          mark("getEntries.first");
        }
        mark(`getEntries.start${getEntryCalls}`);
        try {
          const leaf = lastLeaf ? lastLeaf.getNext ? await lastLeaf.getNext(options.repairMode) : null : await this._getFirstLeaf();
          if (leaf) {
            if (leaf.hasExtData && !leaf.extData.loaded) {
              await leaf.extData.load();
            }
            lastLeaf = leaf;
            leafStats.readLeafs++;
            leafStats.readEntries += leaf.entries.length;
            if (leaf.entries.length === 0 && leaf.getNext) {
              return getEntries(n);
            }
            return leaf.entries;
          } else {
            return [];
          }
        } finally {
          mark(`getEntries.end${getEntryCalls++}`);
          mark("getEntries.last");
        }
      };
      mark("tree.createStart");
      await BinaryBPlusTree.create({
        getLeafStartKeys,
        getEntries,
        writer,
        treeStatistics: options.treeStatistics,
        fillFactor: options.fillFactor,
        maxEntriesPerNode,
        isUnique: this.info.isUnique,
        metadataKeys: this.info.metadataKeys,
        allocatedBytes: options.allocatedBytes,
        keepFreeSpace: options.keepFreeSpace,
        reserveSpaceForNewEntries: options.reserveSpaceForNewEntries,
        debug: this.debug
      });
      mark("tree.createEnd");
      options.treeStatistics.totalLeafs = leafStats.writtenLeafs;
      options.treeStatistics.totalEntries = leafStats.totalEntries;
      options.treeStatistics.totalValues = leafStats.totalValues;
      this._chunkSize = originalChunkSize;
    } catch (err) {
      throw new DetailedError("tree_rebuild_error", "Failed to rebuild tree", err);
    } finally {
      mark("end");
    }
  }
  static async create(options) {
    const { writer, debug } = options;
    if (typeof options.maxEntriesPerNode !== "number") {
      options.maxEntriesPerNode = 255;
    }
    if (typeof options.fillFactor !== "number") {
      options.fillFactor = 100;
    }
    const entriesPerLeaf = Math.round(options.maxEntriesPerNode * (options.fillFactor / 100));
    const entriesPerNode = entriesPerLeaf;
    try {
      const leafStartKeys = await options.getLeafStartKeys(entriesPerLeaf);
      const createLeafs = leafStartKeys.length;
      options.treeStatistics.totalLeafs = createLeafs;
      let childLevelNodes = leafStartKeys;
      const levels = [];
      while (childLevelNodes.length > 1) {
        childLevelNodes = childLevelNodes.reduce((nodes, child, index2, arr) => {
          const entriesLeft = arr.length - index2;
          let currentNode = nodes[nodes.length - 1];
          const isLast = index2 === arr.length - 1 || currentNode.entries.length === entriesPerNode || entriesLeft === 3 && currentNode.entries.length + entriesLeft > entriesPerNode;
          if (isLast) {
            const key = typeof child === "object" && "gtMaxKey" in child ? child.gtMaxKey : arr[index2 + 1];
            currentNode.gtMaxKey = key;
            currentNode.gtChildIndex = index2;
            if (index2 < arr.length - 1) {
              currentNode = { entries: [], gtChildIndex: -1, gtMaxKey: null };
              nodes.push(currentNode);
            }
          } else {
            const key = typeof child === "object" && "gtMaxKey" in child ? child.gtMaxKey : arr[index2 + 1];
            currentNode.entries.push({ key, ltChildIndex: index2 });
          }
          return nodes;
        }, [{ entries: [], gtChildIndex: -1, gtMaxKey: null }]);
        levels.push(childLevelNodes);
      }
      options.treeStatistics.depth = levels.length;
      options.treeStatistics.writtenLeafs = 0;
      options.treeStatistics.writtenEntries = 0;
      const builder = new BinaryBPlusTreeBuilder({
        uniqueKeys: options.isUnique,
        byteLength: options.allocatedBytes,
        maxEntriesPerNode: options.maxEntriesPerNode,
        freeBytes: options.keepFreeSpace ? 1 : 0,
        metadataKeys: options.metadataKeys,
        smallLeafs: WRITE_SMALL_LEAFS,
        fillFactor: options.fillFactor
      });
      let header = builder.getHeader();
      let index = header.length;
      const leafIndexes = [];
      let largestLeafLength = 0;
      await writer.append(header);
      let l = levels.length;
      while (l > 0) {
        l--;
        const nodes = levels[l];
        const writes = [];
        nodes.forEach((node) => {
          node.index = index;
          const bytes = builder.createNode({
            index: node.index,
            entries: node.entries.map((entry) => ({ key: entry.key, ltIndex: 0 })),
            gtIndex: 0
          }, { addFreeSpace: options.keepFreeSpace, allowMissingChildIndexes: true });
          node.byteLength = bytes.length;
          index += bytes.length;
          const p = writer.append(bytes);
          writes.push(p);
        });
        await Promise.all(writes);
      }
      const newLeafEntries = [];
      let prevIndex = 0;
      let currentLeafIndex = 0;
      let totalWrittenEntries = 0;
      const writeLeaf = async (entries2) => {
        let emptyLeaf = false;
        if (entries2.length === 0 && leafStartKeys.length === 0) {
          emptyLeaf = true;
        }
        const i = leafIndexes.length;
        leafIndexes.push(index);
        const isLastLeaf = emptyLeaf || leafIndexes.length === leafStartKeys.length;
        const newLeaf = builder.createLeaf({ index, prevIndex, nextIndex: isLastLeaf ? 0 : "adjacent", entries: entries2 }, { addFreeSpace: options.keepFreeSpace });
        largestLeafLength = Math.max(largestLeafLength, newLeaf.length);
        prevIndex = index;
        index += newLeaf.length;
        totalWrittenEntries += entries2.length;
        return writer.append(newLeaf);
      };
      const flush = async (flushAll = false) => {
        const cutEntryKey = leafStartKeys[currentLeafIndex + 1];
        let entries2;
        if (typeof cutEntryKey === "undefined") {
          if (flushAll) {
            entries2 = newLeafEntries.splice(0);
          } else {
            return;
          }
        } else {
          const cutEntryIndex = newLeafEntries.findIndex((entry) => _isEqual(entry.key, cutEntryKey));
          if (cutEntryIndex === -1) {
            return;
          }
          entries2 = newLeafEntries.splice(0, cutEntryIndex);
        }
        options.treeStatistics.writtenLeafs++;
        options.treeStatistics.writtenEntries += entries2.length;
        currentLeafIndex++;
        await writeLeaf(entries2);
        if (newLeafEntries.length >= entriesPerLeaf || flushAll && newLeafEntries.length > 0) {
          await flush(flushAll);
        }
      };
      const processEntries = async (entries2) => {
        if (entries2.length === 0) {
          return flush(true);
        }
        newLeafEntries.push(...entries2);
        const writePromise = flush(false);
        const readNextPromise = options.getEntries(options.maxEntriesPerNode);
        const [moreEntries] = await Promise.all([readNextPromise, writePromise]);
        await processEntries(moreEntries);
      };
      const entries = await options.getEntries(options.maxEntriesPerNode);
      await processEntries(entries);
      let byteLength = index;
      let freeBytes = 0;
      if (options.allocatedBytes > 0) {
        freeBytes = options.allocatedBytes - byteLength;
        byteLength = options.allocatedBytes;
      } else {
        freeBytes = Math.max(Math.ceil(byteLength * 0.1), Math.ceil(largestLeafLength * 1.1), Math.ceil(Math.ceil((options.reserveSpaceForNewEntries || 0) / entriesPerLeaf) * largestLeafLength * 1.1));
        byteLength += freeBytes;
      }
      builder.byteLength = byteLength;
      builder.freeBytes = freeBytes;
      header = builder.getHeader();
      options.treeStatistics.byteLength = byteLength;
      options.treeStatistics.freeBytes = freeBytes;
      const bytesPerWrite = 1024 * 100;
      const writeBatches = Math.ceil(builder.freeBytes / bytesPerWrite);
      for (let i = 0; i < writeBatches; i++) {
        const length3 = i + 1 < writeBatches ? bytesPerWrite : builder.freeBytes % bytesPerWrite;
        const zeroes = new Uint8Array(length3);
        await writer.append(zeroes);
      }
      await writer.end();
      const writePromises = [
        writer.write(header, 0)
      ];
      levels.forEach((nodes, index2) => {
        nodes.forEach((node) => {
          if (index2 === 0) {
            node.gtChildIndex = leafIndexes[node.gtChildIndex];
            node.entries.forEach((entry) => {
              entry.ltChildIndex = leafIndexes[entry.ltChildIndex];
            });
          } else {
            node.gtChildIndex = levels[index2 - 1][node.gtChildIndex].index;
            node.entries.forEach((entry) => {
              entry.ltChildIndex = levels[index2 - 1][entry.ltChildIndex].index;
            });
          }
          const bytes = builder.createNode({
            index: node.index,
            entries: node.entries.map((entry) => ({ key: entry.key, ltIndex: entry.ltChildIndex })),
            gtIndex: node.gtChildIndex
          }, { addFreeSpace: options.keepFreeSpace, maxLength: node.byteLength });
          const p = writer.write(bytes, node.index);
          writePromises.push(p);
        });
      });
      await Promise.all(writePromises);
    } catch (err) {
      throw new DetailedError("tree_create_error", "Failed to create BinaryBlusTree", err);
    }
  }
  static createFromEntryStream(reader, writer, options) {
    const { debug } = options;
    const getLeafStartKeys = async (entriesPerLeaf) => {
      options.treeStatistics.totalEntries = 0;
      await reader.init();
      const leafStartKeys = [];
      while (true) {
        options.treeStatistics.totalEntries++;
        const entryIndex = reader.sourceIndex;
        try {
          const entryLength = await reader.getUint32();
          if (options.treeStatistics.totalEntries % entriesPerLeaf === 1) {
            const key = await reader.getValue();
            leafStartKeys.push(key);
            await reader.go(entryIndex + entryLength);
          } else {
            await reader.go(entryIndex + entryLength);
          }
        } catch (err) {
          if (err.code === "EOF") {
            break;
          }
          throw err;
        }
      }
      await reader.go(0);
      return leafStartKeys;
    };
    const getEntries = async (n) => {
      const entries = [];
      reader.chunkSize = 1024 * 1024;
      while (true) {
        try {
          const entryLength = await reader.getUint32();
          const buffer = await reader.get(entryLength - 4);
          const k = BinaryReader.readValue(buffer, 0);
          const entry = new BinaryBPlusTreeLeafEntry(k.value, []);
          let index = k.byteLength;
          const totalValues = BinaryReader.readUint32(buffer, index);
          index += 4;
          for (let i = 0; i < totalValues; i++) {
            const valueLength = BinaryReader.readUint32(buffer, index);
            index += 4;
            const val = buffer.slice(index, index + valueLength);
            index += valueLength;
            const rpLength = val[0];
            const recordPointer = val.slice(1, 1 + rpLength);
            let valIndex = 1 + rpLength;
            const metadata = {};
            for (let j = 0; j < options.metadataKeys.length; j++) {
              const mdKey = options.metadataKeys[j];
              const mdValue = BinaryReader.readValue(val, valIndex);
              metadata[mdKey] = mdValue.value;
              valIndex += mdValue.byteLength;
            }
            const value = new BinaryBPlusTreeLeafEntryValue(recordPointer, metadata);
            entry.values.push(value);
          }
          entries.push(entry);
          if (entries.length >= n) {
            break;
          }
        } catch (err) {
          if (err.code === "EOF") {
            break;
          }
          throw err;
        }
      }
      return entries;
    };
    return BinaryBPlusTree.create({
      getLeafStartKeys,
      getEntries,
      writer,
      treeStatistics: options.treeStatistics,
      fillFactor: options.fillFactor,
      allocatedBytes: options.allocatedBytes,
      isUnique: options.isUnique,
      keepFreeSpace: options.keepFreeSpace,
      maxEntriesPerNode: options.maxEntriesPerNode,
      metadataKeys: options.metadataKeys,
      debug
    });
  }
};
BinaryBPlusTree.EntryValue = BinaryBPlusTreeLeafEntryValue;
BinaryBPlusTree.TransactionOperation = BinaryBPlusTreeTransactionOperation;

// node_modules/acebase/dist/esm/quicksort.js
function fastQuickSort(arr, compareFn = (a, b) => a - b) {
  if (arr.length <= 1) {
    return arr;
  }
  const stack = [];
  let entry = [
    0,
    arr.length,
    2 * Math.floor(Math.log(arr.length) / Math.log(2))
  ];
  stack.push(entry);
  while (stack.length > 0) {
    entry = stack.pop();
    const start = entry[0];
    const end = entry[1];
    let depth = entry[2];
    if (depth == 0) {
      arr = shellSortBound(arr, start, end, compareFn);
      continue;
    }
    depth--;
    const pivot = Math.round((start + end) / 2);
    const pivotNewIndex = inplaceQuickSortPartition(arr, start, end, pivot, compareFn);
    if (end - pivotNewIndex > 16) {
      entry = [pivotNewIndex, end, depth];
      stack.push(entry);
    }
    if (pivotNewIndex - start > 16) {
      entry = [start, pivotNewIndex, depth];
      stack.push(entry);
    }
  }
  arr = insertionSort(arr, compareFn);
  return arr;
}
function shellSortBound(arr, start, end, compareFn) {
  let inc = Math.round((start + end) / 2), i, j, t;
  while (inc >= start) {
    for (i = inc; i < end; i++) {
      t = arr[i];
      j = i;
      while (j >= inc && compareFn(arr[j - inc], t) > 0) {
        arr[j] = arr[j - inc];
        j -= inc;
      }
      arr[j] = t;
    }
    inc = Math.round(inc / 2.2);
  }
  return arr;
}
function swap(arr, a, b) {
  const t = arr[a];
  arr[a] = arr[b];
  arr[b] = t;
}
function insertionSort(arr, compareFn) {
  for (let i = 1, l = arr.length; i < l; i++) {
    const value = arr[i];
    let j;
    for (j = i - 1; j >= 0; j--) {
      if (compareFn(arr[j], value) <= 0) {
        break;
      }
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = value;
  }
  return arr;
}
function inplaceQuickSortPartition(arr, start, end, pivotIndex, compareFn) {
  let i = start, j = end;
  const pivot = arr[pivotIndex];
  while (true) {
    while (compareFn(arr[i], pivot) < 0) {
      i++;
    }
    j--;
    while (compareFn(pivot, arr[j]) < 0) {
      j--;
    }
    if (!(i < j)) {
      return i;
    }
    swap(arr, i, j);
    i++;
  }
}

// node_modules/acebase/dist/esm/data-index/query-stats.js
var IndexQueryStats = class {
  constructor(type, args, start = false) {
    this.type = type;
    this.args = args;
    this.started = 0;
    this.stopped = 0;
    this.steps = [];
    this.result = null;
    this.queries = 1;
    if (start) {
      this.start();
    }
  }
  start() {
    this.started = Date.now();
  }
  stop(result = null) {
    this.stopped = Date.now();
    this.result = result;
  }
  get duration() {
    return this.stopped - this.started;
  }
};

// node_modules/acebase/dist/esm/data-index/query-results.js
var IndexQueryResult = class {
  constructor(key, path3, value, metadata) {
    this.key = key;
    this.path = path3;
    this.value = value;
    this.metadata = metadata;
  }
};
var IndexQueryResults = class extends Array {
  static fromResults(results, filterKey) {
    const arr = new IndexQueryResults(results.length);
    results.forEach((result, i) => arr[i] = result);
    arr.filterKey = filterKey;
    return arr;
  }
  filterMetadata(key, op, compare) {
    if (typeof compare === "undefined") {
      compare = null;
    }
    if (op === "exists" || op === "!exists") {
      op = op === "exists" ? "!=" : "==";
      compare = null;
    }
    const filtered = this.filter((result) => {
      let value = key === this.filterKey ? result.value : result.metadata ? result.metadata[key] : null;
      if (typeof value === "undefined") {
        value = null;
      }
      if (op === "<") {
        return value < compare;
      }
      if (op === "<=") {
        return value <= compare;
      }
      if (op === ">") {
        return value > compare;
      }
      if (op === ">=") {
        return value >= compare;
      }
      if (op === "==") {
        return value == compare;
      }
      if (op === "!=") {
        return value != compare;
      }
      if (op === "like" || op === "!like") {
        if (typeof compare !== "string") {
          return op === "!like";
        }
        const pattern = "^" + compare.replace(/\*/g, ".*").replace(/\?/g, ".") + "$";
        const re = new RegExp(pattern, "i");
        const isLike = re.test(value);
        return op === "like" ? isLike : !isLike;
      }
      if (op === "in" || op === "!in") {
        const isIn = compare instanceof Array && compare.includes(value);
        return op === "in" ? isIn : !isIn;
      }
      if (op == "between" || op === "!between") {
        if (!(compare instanceof Array)) {
          return op === "!between";
        }
        let bottom = compare[0], top = compare[1];
        if (top < bottom) {
          const swap2 = top;
          top = bottom;
          bottom = swap2;
        }
        const isBetween = value >= bottom && value <= top;
        return op === "between" ? isBetween : !isBetween;
      }
      if (op === "matches" || op === "!matches") {
        if (!(compare instanceof RegExp)) {
          return op === "!matches";
        }
        const re = compare;
        const isMatch = re.test(value);
        return op === "matches" ? isMatch : !isMatch;
      }
    });
    return IndexQueryResults.fromResults(filtered, this.filterKey);
  }
  constructor(...args) {
    super(...args);
    this.hints = [];
    this.stats = null;
  }
};

// node_modules/acebase/dist/esm/data-index/data-index.js
var { compareValues: compareValues2, getChildValues: getChildValues2, numberToBytes: numberToBytes5, bytesToNumber: bytesToNumber5, encodeString: encodeString4, decodeString: decodeString3 } = utils_exports;
var DISK_BLOCK_SIZE = 4096;
var FILL_FACTOR = 50;
var INDEX_INFO_VALUE_TYPE = {
  UNDEFINED: 0,
  STRING: 1,
  NUMBER: 2,
  BOOLEAN: 3,
  ARRAY: 4
};
function _createRecordPointer(wildcards, keyOrIndex) {
  const recordPointer = [wildcards.length];
  for (let i = 0; i < wildcards.length; i++) {
    const wildcard = wildcards[i];
    recordPointer.push(wildcard.length);
    for (let j = 0; j < wildcard.length; j++) {
      recordPointer.push(wildcard.charCodeAt(j));
    }
  }
  const key = typeof keyOrIndex === "number" ? `[${keyOrIndex}]` : keyOrIndex;
  recordPointer.push(key.length);
  for (let i = 0; i < key.length; i++) {
    recordPointer.push(key.charCodeAt(i));
  }
  return recordPointer;
}
function _parseRecordPointer(path3, recordPointer) {
  if (recordPointer.length === 0) {
    throw new Error("Invalid record pointer length");
  }
  const wildcardsLength = recordPointer[0];
  const wildcards = [];
  let index = 1;
  for (let i = 0; i < wildcardsLength; i++) {
    let wildcard = "";
    const length3 = recordPointer[index];
    for (let j = 0; j < length3; j++) {
      wildcard += String.fromCharCode(recordPointer[index + j + 1]);
    }
    wildcards.push(wildcard);
    index += length3 + 1;
  }
  const keyLength = recordPointer[index];
  let key = "";
  for (let i = 0; i < keyLength; i++) {
    key += String.fromCharCode(recordPointer[index + i + 1]);
  }
  index += keyLength + 1;
  if (wildcards.length > 0) {
    let i = 0;
    path3 = path3.replace(/\*/g, () => {
      const wildcard = wildcards[i];
      i++;
      return wildcard;
    });
  }
  const keyOrIndex = key[0] === "[" && key.slice(-1) === "]" ? parseInt(key.slice(1, -1)) : key;
  return { key: keyOrIndex, path: `${path3}/${key}`, wildcards };
}
var DataIndex = class {
  static get STATE() {
    return {
      INIT: "init",
      READY: "ready",
      BUILD: "build",
      REBUILD: "rebuild",
      ERROR: "error",
      REMOVED: "removed",
      CLOSED: "closed"
    };
  }
  constructor(storage, path3, key, options = {}) {
    this.storage = storage;
    this.state = DataIndex.STATE.INIT;
    this._buildError = null;
    this._cache = /* @__PURE__ */ new Map();
    this._cacheTimeoutSettings = {
      duration: 60 * 1e3,
      sliding: true
    };
    if (["string", "undefined"].indexOf(typeof options.include) < 0 && !(options.include instanceof Array)) {
      throw new Error(`includeKeys argument must be a string, an Array of strings, or undefined. Passed type=${typeof options.include}`);
    }
    if (typeof options.include === "string") {
      options.include = [options.include];
    }
    const pathKeys = PathInfo.getPathKeys(path3).map((key2) => typeof key2 === "string" && key2.startsWith("$") ? "*" : key2);
    this.path = new PathInfo(pathKeys).path;
    this.key = key;
    this.caseSensitive = options.caseSensitive === true;
    this.textLocale = options.textLocale || "en";
    this.textLocaleKey = options.textLocaleKey;
    this.includeKeys = options.include || [];
    this.indexMetadataKeys = [];
    this._buildError = null;
    this._updateQueue = [];
    this.trees = {
      "default": {
        fileIndex: 0,
        byteLength: 0,
        class: "BPlusTree",
        version: 1,
        entries: 0,
        values: 0
      }
    };
  }
  get allMetadataKeys() {
    return this.includeKeys.concat(this.indexMetadataKeys);
  }
  setCacheTimeout(seconds, sliding = false) {
    this._cacheTimeoutSettings = {
      duration: seconds * 1e3,
      sliding
    };
  }
  cache(op, param, results) {
    const val = JSON.stringify(transport_exports.serialize2(param));
    if (typeof results === "undefined") {
      let cache;
      if (this._cache.has(op) && this._cache.get(op).has(val)) {
        cache = this._cache.get(op).get(val);
      }
      if (cache) {
        cache.reads++;
        if (this._cacheTimeoutSettings.sliding) {
          cache.extendLife();
        }
        return cache.results;
      }
      return null;
    } else {
      let opCache = this._cache.get(op);
      if (!opCache) {
        opCache = /* @__PURE__ */ new Map();
        this._cache.set(op, opCache);
      }
      const scheduleClear = () => {
        const timeout = setTimeout(() => opCache.delete(val), this._cacheTimeoutSettings.duration);
        timeout.unref && timeout.unref();
        return timeout;
      };
      const cache = {
        results,
        added: Date.now(),
        reads: 0,
        timeout: scheduleClear(),
        extendLife: () => {
          clearTimeout(cache.timeout);
          cache.timeout = scheduleClear();
        }
      };
      opCache.set(val, cache);
    }
  }
  async delete() {
    const idx = await this._getTree("exclusive");
    await idx.close();
    const filePath = this.fileName;
    await pfs.rm(filePath);
    this.state = DataIndex.STATE.REMOVED;
    idx.release();
  }
  async close() {
    const idx = await this._getTree("exclusive");
    await idx.close();
    this.state = DataIndex.STATE.CLOSED;
    idx.release();
  }
  static async readFromFile(storage, fileName) {
    const filePath = fileName.includes("/") ? fileName : `${storage.settings.path}/${storage.name}.acebase/${fileName}`;
    const fd = await pfs.open(filePath, pfs.flags.read);
    try {
      let result = await pfs.read(fd, Buffer.alloc(10));
      if (result.buffer.toString() !== "ACEBASEIDX") {
        throw new Error(`File "${filePath}" is not an AceBase index. If you get this error after updating acebase, delete the index file and rebuild it`);
      }
      result = await pfs.read(fd, Buffer.alloc(1));
      const versionNr = result.buffer[0];
      if (versionNr !== 1) {
        throw new Error(`Index "${filePath}" version ${versionNr} is not supported by this version of AceBase. npm update your acebase packages`);
      }
      result = await pfs.read(fd, Buffer.alloc(4));
      const headerLength = result.buffer[0] << 24 | result.buffer[1] << 16 | result.buffer[2] << 8 | result.buffer[3];
      result = await pfs.read(fd, Buffer.alloc(headerLength - 11));
      const header = Uint8Array.from(result.buffer);
      let index = 0;
      const readKey = () => {
        const keyLength = header[index];
        let keyName = "";
        index++;
        for (let j = 0; j < keyLength; j++) {
          keyName += String.fromCharCode(header[index + j]);
        }
        index += keyLength;
        return keyName;
      };
      const readValue = () => {
        const valueType = header[index];
        index++;
        let valueLength = 0;
        if (valueType === INDEX_INFO_VALUE_TYPE.UNDEFINED) {
          valueLength = 0;
        } else if (valueType === INDEX_INFO_VALUE_TYPE.BOOLEAN) {
          valueLength = 1;
        } else {
          valueLength = header[index] << 8 | header[index + 1];
          index += 2;
        }
        let value;
        if (valueType === INDEX_INFO_VALUE_TYPE.STRING) {
          value = decodeString3(header.slice(index, index + valueLength));
        } else if (valueType === INDEX_INFO_VALUE_TYPE.NUMBER) {
          value = bytesToNumber5(header.slice(index, index + valueLength));
        } else if (valueType === INDEX_INFO_VALUE_TYPE.BOOLEAN) {
          value = header[index] === 1;
        } else if (valueType === INDEX_INFO_VALUE_TYPE.ARRAY) {
          const arr = [];
          for (let j = 0; j < valueLength; j++) {
            arr.push(readValue());
          }
          return arr;
        }
        index += valueLength;
        return value;
      };
      const readInfo = () => {
        const infoCount = header[index];
        index++;
        const info = {};
        for (let i = 0; i < infoCount; i++) {
          const key = readKey();
          const value = readValue();
          info[key] = value;
        }
        return info;
      };
      const indexInfo = readInfo();
      const indexOptions = {
        caseSensitive: indexInfo.cs,
        textLocale: indexInfo.locale,
        textLocaleKey: indexInfo.localeKey,
        include: indexInfo.include
      };
      if (!(indexInfo.type in DataIndex.KnownIndexTypes)) {
        throw new Error(`Unknown index type ${indexInfo.type}`);
      }
      const Index = DataIndex.KnownIndexTypes[indexInfo.type];
      const dataIndex = new Index(storage, indexInfo.path, indexInfo.key, indexOptions);
      dataIndex._fileName = filePath;
      const treesCount = header[index];
      index++;
      for (let i = 0; i < treesCount; i++) {
        const treeName = readKey();
        const treeInfo = dataIndex.trees[treeName] = {};
        treeInfo.fileIndex = header[index] << 24 | header[index + 1] << 16 | header[index + 2] << 8 | header[index + 3];
        index += 4;
        treeInfo.byteLength = header[index] << 24 | header[index + 1] << 16 | header[index + 2] << 8 | header[index + 3];
        index += 4;
        const info = readInfo();
        Object.assign(treeInfo, info);
      }
      await pfs.close(fd);
      dataIndex.state = DataIndex.STATE.READY;
      return dataIndex;
    } catch (err) {
      storage.debug.error(err);
      pfs.close(fd);
      throw err;
    }
  }
  get type() {
    return "normal";
  }
  get fileName() {
    if (this._fileName) {
      return this._fileName;
    }
    const dir = `${this.storage.settings.path}/${this.storage.name}.acebase`;
    const storagePrefix = this.storage.settings.type !== "data" ? `[${this.storage.settings.type}]-` : "";
    const escape = (key) => key.replace(/\//g, "~").replace(/\*/g, "#");
    const escapedPath = escape(this.path);
    const escapedKey = escape(this.key);
    const includes = this.includeKeys.length > 0 ? "," + this.includeKeys.map((key) => escape(key)).join(",") : "";
    const extension = (this.type !== "normal" ? `${this.type}.` : "") + "idx";
    return `${dir}/${storagePrefix}${escapedPath}-${escapedKey}${includes}.${extension}`;
  }
  get description() {
    const keyPath = `/${this.path}/*/${this.key}`;
    const includedKeys = this.includeKeys.length > 0 ? "+" + this.includeKeys.join(",") : "";
    let description = `${keyPath}${includedKeys}`;
    if (this.type !== "normal") {
      description += ` (${this.type})`;
    }
    return description;
  }
  _getWildcardKeys(path3) {
    const pathKeys = PathInfo.getPathKeys(path3);
    const indexKeys = PathInfo.getPathKeys(this.path);
    return indexKeys.reduce((wildcards, key, i) => {
      if (key === "*") {
        wildcards.push(pathKeys[i]);
      }
      return wildcards;
    }, []);
  }
  _updateTree(path3, oldValue, newValue, oldRecordPointer, newRecordPointer, metadata) {
    const canBeIndexed = ["number", "boolean", "string", "bigint"].indexOf(typeof newValue) >= 0 || newValue instanceof Date;
    const operations = [];
    if (oldValue !== null) {
      const op = BinaryBPlusTree.TransactionOperation.remove(oldValue, oldRecordPointer);
      operations.push(op);
    }
    if (newValue !== null && canBeIndexed) {
      const op = BinaryBPlusTree.TransactionOperation.add(newValue, newRecordPointer, metadata);
      operations.push(op);
    }
    return this._processTreeOperations(path3, operations);
  }
  async _rebuild(idx) {
    const newIndexFile = this.fileName + ".tmp";
    const fd = await pfs.open(newIndexFile, pfs.flags.write);
    const treeStatistics = {
      byteLength: 0,
      totalEntries: 0,
      totalValues: 0
    };
    const headerStats = {
      written: false,
      length: 0,
      promise: null,
      updateTreeLength: void 0
    };
    const writer = async (data, index) => {
      if (!headerStats.written) {
        if (!headerStats.promise) {
          headerStats.promise = this._writeIndexHeader(fd, treeStatistics).then((result) => {
            headerStats.written = true;
            headerStats.length = result.length;
            headerStats.updateTreeLength = result.treeLengthCallback;
          });
        }
        await headerStats.promise;
      }
      await pfs.write(fd, data, 0, data.length, headerStats.length + index);
    };
    this.state = DataIndex.STATE.REBUILD;
    try {
      await idx.tree.rebuild(BinaryWriter.forFunction(writer), { treeStatistics });
      await idx.close();
      await headerStats.updateTreeLength(treeStatistics.byteLength);
      await pfs.close(fd);
      const renameFile = async (retry = 0) => {
        try {
          await pfs.rename(newIndexFile, this.fileName);
        } catch (err) {
          if (err.code === "EPERM" && retry < 10) {
            await new Promise((resolve) => setTimeout(resolve, 100));
            await renameFile(retry + 1);
          }
          throw err;
        }
      };
      await renameFile();
      this.state = DataIndex.STATE.READY;
      idx.release();
    } catch (err) {
      this.storage.debug.error("Index rebuild error: ", err);
      this.state = DataIndex.STATE.ERROR;
      this._buildError = err;
      idx.release();
      throw err;
    }
  }
  async _processTreeOperations(path3, operations) {
    const startTime = Date.now();
    if (this._buildError) {
      throw new Error("Cannot update index because there was an error building it");
    }
    let idx = await this._getTree("exclusive");
    const go = async (retry = 0) => {
      const opsCount = operations.length;
      try {
        await idx.tree.transaction(operations);
        idx.release();
        return false;
      } catch (err) {
        this.storage.debug.verbose(`Could not update index ${this.description}: ${err.message}`.colorize(ColorStyle.yellow));
        if (retry > 0 && opsCount === operations.length) {
          throw new Error(`DEV ERROR: unable to process operations because tree was rebuilt, and that didn't help?! --> ${err.stack}`);
        }
        await this._rebuild(idx);
        this.storage.debug.verbose("Index was rebuilt, retrying pending operations");
        idx = await this._getTree("exclusive");
        await go(retry + 1);
        return true;
      }
    };
    const rebuilt = await go();
    const doneTime = Date.now();
    const ms = doneTime - startTime;
    const duration = ms < 5e3 ? ms + "ms" : Math.round(ms / 1e3) + "s";
    this.storage.debug.verbose(`Index ${this.description} was ${rebuilt ? "rebuilt" : "updated"} successfully for "/${path3}", took ${duration}`.colorize(ColorStyle.green));
    return await this._processUpdateQueue();
  }
  clearCache(forPath) {
    this._cache.clear();
  }
  async _processUpdateQueue() {
    const queue = this._updateQueue.splice(0);
    if (queue.length === 0) {
      return;
    }
    this._cache.clear();
    const promises = queue.map((update) => {
      return this._updateTree(update.path, update.oldValue, update.newValue, update.recordPointer, update.recordPointer, update.metadata).then(() => {
        update.resolve();
      }).catch((err) => {
        update.reject(err);
      });
    });
    await Promise.all(promises);
  }
  async handleRecordUpdate(path3, oldValue, newValue, indexMetadata) {
    this.storage.debug.verbose(`Handling index ${this.description} update request for "/${path3}"`);
    const getValues = (key, oldValue2, newValue2) => PathInfo.getPathKeys(key).reduce((values, key2) => getChildValues2(key2, values.oldValue, values.newValue), { oldValue: oldValue2, newValue: newValue2 });
    const updatedKey = PathInfo.get(path3).key;
    if (typeof updatedKey === "number") {
      throw new Error("Not implemented: updated key is a number!");
    }
    const keyValues = this.key === "{key}" ? { oldValue: oldValue === null ? null : updatedKey, newValue: newValue === null ? null : updatedKey } : getValues(this.key, oldValue, newValue);
    const includedValues = this.includeKeys.map((key) => getValues(key, oldValue, newValue));
    if (!this.caseSensitive) {
      const allValues = [keyValues].concat(includedValues);
      allValues.forEach((values) => {
        if (typeof values.oldValue === "string") {
          values.oldValue = values.oldValue.toLocaleLowerCase(this.textLocale);
        }
        if (typeof values.newValue === "string") {
          values.newValue = values.newValue.toLocaleLowerCase(this.textLocale);
        }
      });
    }
    const keyValueChanged = compareValues2(keyValues.oldValue, keyValues.newValue) !== "identical";
    const includedValuesChanged = includedValues.some((values) => compareValues2(values.oldValue, values.newValue) !== "identical");
    if (!keyValueChanged && !includedValuesChanged) {
      this.storage.debug.verbose(`Update on "/${path3}" has no effective changes for index ${this.description}`);
      return;
    }
    const wildcardKeys = this._getWildcardKeys(path3);
    const recordPointer = _createRecordPointer(wildcardKeys, updatedKey);
    const metadata = (() => {
      const obj = {};
      indexMetadata && Object.assign(obj, indexMetadata);
      if (typeof newValue === "object" && newValue !== null) {
        this.includeKeys.forEach((key) => obj[key] = newValue[key]);
      }
      return obj;
    })();
    if (this.state === DataIndex.STATE.ERROR) {
      throw new Error(`Cannot update index ${this.description}: it's in the error state: ${this._buildError?.stack}`);
    } else if (this.state === DataIndex.STATE.READY) {
      this._cache.clear();
      this.storage.debug.verbose(`Updating index ${this.description} tree for "/${path3}"`);
      return await this._updateTree(path3, keyValues.oldValue, keyValues.newValue, recordPointer, recordPointer, metadata);
    } else {
      this.storage.debug.log(`Queueing index ${this.description} update for "/${path3}"`);
      const update = {
        path: path3,
        oldValue: keyValues.oldValue,
        newValue: keyValues.newValue,
        recordPointer,
        metadata,
        resolve: null,
        reject: null
      };
      const p = new Promise((resolve, reject) => {
        update.resolve = resolve;
        update.reject = reject;
      }).catch((err) => {
        this.storage.debug.error(`Unable to process queued update for "/${path3}" on index ${this.description}:`, err);
      });
      this._updateQueue.push(update);
    }
  }
  async _lock(mode = "exclusive", timeout = 6e4) {
    return ThreadSafe.lock(this.fileName, { shared: mode === "shared", timeout });
  }
  async count(op, val) {
    if (!this.caseSensitive) {
      if (typeof val === "string") {
        val = val.toLocaleLowerCase(this.textLocale);
      } else if (val instanceof Array) {
        val = val.map((val2) => {
          if (typeof val2 === "string") {
            return val2.toLocaleLowerCase(this.textLocale);
          }
          return val2;
        });
      }
    }
    const cacheKey = op + "{count}";
    const cache = this.cache(cacheKey, val);
    if (cache) {
      return cache;
    }
    const idx = await this._getTree("shared");
    const result = await idx.tree.search(op, val, { count: true, keys: true, values: false });
    idx.release();
    this.cache(cacheKey, val, result.valueCount);
    return result.valueCount;
  }
  async take(skip, take, options = {}) {
    const ascending = options.ascending !== false;
    const sort = options.metadataSort?.length > 0 ? options.metadataSort : [];
    sort.forEach((s) => {
      if (!this.allMetadataKeys.includes(s.key)) {
        throw new Error(`Cannot sort on metadata key ${s.key} because it is not present in index ${this.fileName}`);
      }
    });
    const cacheKey = JSON.stringify({ skip, take, options });
    const cache = this.cache("take", cacheKey);
    if (cache) {
      return cache;
    }
    const stats = new IndexQueryStats("take", { skip, take, ascending }, true);
    const idx = await this._getTree("shared");
    const results = new IndexQueryResults();
    results.filterKey = this.key;
    let skipped = 0;
    let leaf = await (ascending ? idx.tree.getFirstLeaf() : idx.tree.getLastLeaf());
    do {
      if (!ascending) {
        leaf.entries.reverse();
      }
      for (let i = 0; i < leaf.entries.length && results.length < take; i++) {
        const entry = leaf.entries[i];
        const value = entry.key;
        if (sort.length > 0 && entry.totalValues > 1 && skipped + entry.totalValues > skip) {
          if (leaf.hasExtData && !leaf.extData.loaded) {
            await leaf.extData.load();
          }
          const applySort = (index, a, b) => {
            const { key, ascending: ascending2 } = sort[index];
            if (a.metadata[key] < b.metadata[key]) {
              return ascending2 ? -1 : 1;
            } else if (a.metadata[key] > b.metadata[key]) {
              return ascending2 ? 1 : -1;
            } else if (index + 1 === sort.length) {
              return 1;
            }
            return applySort(index + 1, a, b);
          };
          entry.values.sort((a, b) => applySort(0, a, b));
        }
        for (let j = 0; j < entry.totalValues && results.length < take; j++) {
          if (skipped < skip) {
            skipped++;
            continue;
          }
          if (leaf.hasExtData && !leaf.extData.loaded) {
            await leaf.extData.load();
          }
          const entryValue = entry.values[j];
          const recordPointer = _parseRecordPointer(this.path, entryValue.recordPointer);
          const metadata = entryValue.metadata;
          const result = new IndexQueryResult(recordPointer.key, recordPointer.path, value, metadata);
          results.push(result);
        }
      }
      leaf = results.length === take ? null : await (ascending ? leaf.getNext?.() : leaf.getPrevious?.());
    } while (leaf);
    idx.release();
    stats.stop(results.length);
    results.stats = stats;
    this.cache("take", cacheKey, results);
    return results;
  }
  static get validOperators() {
    return ["<", "<=", "==", "!=", ">=", ">", "exists", "!exists", "between", "!between", "like", "!like", "matches", "!matches", "in", "!in"];
  }
  get validOperators() {
    return DataIndex.validOperators;
  }
  async query(op, val, options = {}) {
    if (!(op instanceof BlacklistingSearchOperator) && !DataIndex.validOperators.includes(op)) {
      throw new TypeError(`Cannot use operator "${op}" to query index "${this.description}"`);
    }
    if (!this.caseSensitive) {
      if (typeof val === "string") {
        val = val.toLocaleLowerCase(this.textLocale);
      } else if (val instanceof Array) {
        val = val.map((val2) => {
          if (typeof val2 === "string") {
            return val2.toLocaleLowerCase(this.textLocale);
          }
          return val2;
        });
      }
    }
    const stats = new IndexQueryStats("query", { op, val }, true);
    let entries;
    const isCacheable = !(op instanceof BlacklistingSearchOperator);
    const cache = isCacheable && this.cache(op, val);
    if (cache) {
      entries = cache;
    } else {
      const idx = await this._getTree("shared");
      const searchOptions = {
        entries: true
      };
      const result = await idx.tree.search(op, val, searchOptions);
      entries = result.entries;
      idx.release();
      isCacheable && this.cache(op, val, entries);
    }
    const results = new IndexQueryResults();
    results.filterKey = this.key;
    results.entryValues = [];
    if (options.filter) {
      const filterStep = new IndexQueryStats("filter", {
        entries: entries.length,
        entryValues: entries.reduce((total, entry) => total + entry.values.length, 0),
        filterValues: options.filter.entryValues.length
      }, true);
      stats.steps.push(filterStep);
      let values = [];
      const valueEntryIndexes = [];
      entries.forEach((entry) => {
        valueEntryIndexes.push(values.length);
        values = values.concat(entry.values);
      });
      const filterValues = options.filter.entryValues;
      const preProcess = (values2, tree = false) => {
        if (tree && values2.rpTree) {
          return;
        }
        const builder = tree ? new BPlusTreeBuilder(true, 100) : null;
        for (let i = 0; i < values2.length; i++) {
          const val2 = values2[i];
          let rp = val2.rp || "";
          if (rp === "") {
            for (let j = 0; j < val2.recordPointer.length; j++) {
              rp += val2.recordPointer[j].toString(36);
            }
            val2.rp = rp;
          }
          if (tree && !builder.list.has(rp)) {
            builder.add(rp, [i]);
          }
        }
        if (tree) {
          values2.rpTree = builder.create();
        }
      };
      const smallestSet = filterValues.length < values.length ? filterValues : values;
      preProcess(smallestSet, false);
      const otherSet = smallestSet === filterValues ? values : filterValues;
      preProcess(otherSet, true);
      for (let i = 0; i < smallestSet.length; i++) {
        const value = smallestSet[i];
        let match = null;
        let matchIndex;
        const tree = otherSet.rpTree;
        const rpEntryValue = tree.find(value.rp);
        if (rpEntryValue) {
          const j = rpEntryValue.recordPointer[0];
          match = smallestSet === values ? value : otherSet[j];
          matchIndex = match === value ? i : j;
        }
        if (match) {
          const recordPointer = _parseRecordPointer(this.path, match.recordPointer);
          const metadata = match.metadata;
          const entry = entries[valueEntryIndexes.findIndex((entryIndex, i2, arr) => i2 + 1 === arr.length || entryIndex <= matchIndex && arr[i2 + 1] > matchIndex)];
          const result = new IndexQueryResult(recordPointer.key, recordPointer.path, entry.key, metadata);
          results.push(result);
          results.entryValues.push(match);
        }
      }
      filterStep.stop({ results: results.length, values: results.entryValues.length });
    } else {
      const uniqueRecordPointers = /* @__PURE__ */ new Set();
      entries.forEach((entry) => {
        entry.values.forEach((value) => {
          const recordPointer = _parseRecordPointer(this.path, value.recordPointer);
          if (!uniqueRecordPointers.has(recordPointer.path)) {
            uniqueRecordPointers.add(recordPointer.path);
            const metadata = value.metadata;
            const result = new IndexQueryResult(recordPointer.key, recordPointer.path, entry.key, metadata);
            results.push(result);
            results.entryValues.push(value);
          }
        });
      });
      uniqueRecordPointers.clear();
    }
    stats.stop(results.length);
    results.stats = stats;
    return results;
  }
  async build(options) {
    if ([DataIndex.STATE.BUILD, DataIndex.STATE.REBUILD].includes(this.state)) {
      throw new Error("Index is already being built");
    }
    this.state = this.state === DataIndex.STATE.READY ? DataIndex.STATE.REBUILD : DataIndex.STATE.BUILD;
    this._buildError = null;
    const path3 = this.path;
    const wildcardNames = Array.from(path3.match(/\*|\$[a-z0-9_]+/gi) ?? []);
    const wildcardsPattern = "^" + path3.replace(/\*|\$[a-z0-9_]+/gi, "([a-z0-9_]+)") + "/";
    const wildcardRE = new RegExp(wildcardsPattern, "i");
    const tid = ID.generate();
    const keys = PathInfo.getPathKeys(path3);
    const indexableTypes = [VALUE_TYPES.STRING, VALUE_TYPES.NUMBER, VALUE_TYPES.BOOLEAN, VALUE_TYPES.DATETIME, VALUE_TYPES.BIGINT];
    const allowedKeyValueTypes = options && options.valueTypes ? options.valueTypes : indexableTypes;
    this.storage.debug.log(`Index build ${this.description} started`.colorize(ColorStyle.blue));
    let indexedValues = 0;
    const buildFile = this.fileName + ".build";
    const createBuildFile = () => {
      return new Promise((resolve, reject) => {
        const buildWriteStream = pfs.fs.createWriteStream(buildFile, { flags: pfs.flags.readAndAppendAndCreate });
        const streamState = { wait: false, chunks: [] };
        buildWriteStream.on("error", (err) => {
          console.error(err);
          reject(err);
        });
        buildWriteStream.on("open", async () => {
          await getAll("", 0);
          this.storage.debug.log(`done writing values to ${buildFile}`);
          if (streamState.wait) {
            buildWriteStream.once("drain", () => {
              buildWriteStream.end(resolve);
            });
          } else {
            buildWriteStream.end(resolve);
          }
        });
        buildWriteStream.on("drain", () => {
          const totalBytes = streamState.chunks.reduce((total, bytes) => total + bytes.length, 0);
          const buffer = new Uint8Array(totalBytes);
          let offset = 0;
          streamState.chunks.forEach((bytes) => {
            buffer.set(bytes, offset);
            offset += bytes.length;
          });
          streamState.chunks = [];
          streamState.wait = !buildWriteStream.write(buffer, (err) => {
            assert(!err, `Failed to write to stream: ${err && err.message}`);
          });
        });
        const writeToStream = (bytes) => {
          if (streamState.wait) {
            streamState.chunks.push(bytes);
            assert(streamState.chunks.length < 1e5, "Something going wrong here");
          } else {
            streamState.wait = !buildWriteStream.write(Buffer.from(bytes), (err) => {
              assert(!err, `Failed to write to stream: ${err && err.message}`);
            });
          }
        };
        const isWildcardKey = (key) => typeof key === "string" && (key === "*" || key.startsWith("$"));
        const getAll = async (currentPath, keyIndex) => {
          let path4 = currentPath;
          while (keys[keyIndex] && !isWildcardKey(keys[keyIndex])) {
            path4 = PathInfo.getChildPath(path4, keys[keyIndex]);
            keyIndex++;
          }
          const isTargetNode = keyIndex === keys.length;
          const getChildren2 = async () => {
            const childKeys = [];
            try {
              await this.storage.getChildren(path4).next((child) => {
                const keyOrIndex = typeof child.index === "number" ? child.index : child.key;
                if (!child.address || child.type !== VALUE_TYPES.OBJECT) {
                  return;
                } else {
                  childKeys.push(keyOrIndex);
                }
              });
            } catch (reason) {
              this.storage.debug.warn(`Could not get children of "/${path4}": ${reason.message}`);
            }
            const maxBatchSize = Math.round(Math.pow(500, Math.pow(0.5, wildcardNames.length)));
            const batches = [];
            while (childKeys.length > 0) {
              const batchChildren = childKeys.splice(0, maxBatchSize);
              batches.push(batchChildren);
            }
            while (batches.length > 0) {
              const batch = batches.shift();
              await Promise.all(batch.map(async (childKey) => {
                const childPath = PathInfo.getChildPath(path4, childKey);
                if (!isTargetNode) {
                  return getAll(childPath, keyIndex + 1);
                } else {
                  const wildcardValues = childPath.match(wildcardRE).slice(1);
                  const neededKeys = [this.key].concat(this.includeKeys);
                  const keyFilter = neededKeys.filter((key) => key !== "{key}" && !wildcardNames.includes(key));
                  if (this.textLocaleKey) {
                    keyFilter.push(this.textLocaleKey);
                  }
                  let keyValue = null;
                  let locale = this.textLocale;
                  const metadata = (() => {
                    const obj = {};
                    this.includeKeys.forEach((key) => obj[key] = void 0);
                    return obj;
                  })();
                  const addValue = (key, value) => {
                    if (key === this.key) {
                      keyValue = value;
                    } else if (key === this.textLocaleKey && typeof value === "string") {
                      locale = value;
                    } else {
                      metadata[key] = value;
                    }
                  };
                  const gotNamedWildcardKeys = ["{key}"].concat(wildcardNames).filter((key) => key !== "*");
                  neededKeys.filter((key) => gotNamedWildcardKeys.includes(key)).forEach((key) => {
                    if (key === "{key}") {
                      keyValue = childKey;
                    } else {
                      const index = wildcardNames.indexOf(key);
                      if (index < 0) {
                        throw new Error(`Requested key variable "${key}" not found in index path`);
                      }
                      const value = wildcardValues[index];
                      addValue(key, value);
                    }
                  });
                  const gotAllData = neededKeys.every((key) => gotNamedWildcardKeys.includes(key));
                  if (!gotAllData) {
                    const keyPromises = [];
                    const seenKeys = gotNamedWildcardKeys.slice();
                    const { value: obj } = await this.storage.getNode(childPath, { include: keyFilter, tid });
                    keyFilter.forEach((key) => {
                      const val = PathInfo.getPathKeys(key).reduce((val2, key2) => typeof val2 === "object" && key2 in val2 ? val2[key2] : void 0, obj);
                      if (typeof val === "undefined") {
                        return;
                      }
                      seenKeys.push(key);
                      const type = getValueType(val);
                      if (key === this.key && !allowedKeyValueTypes.includes(type)) {
                        keyValue = null;
                        return;
                      } else if (key !== this.key && !indexableTypes.includes(type)) {
                        return;
                      }
                      addValue(key, val);
                    });
                    if (!seenKeys.includes(this.key)) {
                      keyValue = void 0;
                    }
                    await Promise.all(keyPromises);
                  }
                  const addIndexValue = (value, recordPointer, metadata2) => {
                    if (typeof value === "string" && value.length > 255) {
                      console.warn(`Truncating key value "${value}" because it is too large to index`);
                      value = value.slice(0, 255);
                    }
                    if (!this.caseSensitive) {
                      if (typeof value === "string") {
                        value = value.toLocaleLowerCase(locale);
                      }
                      Object.keys(metadata2).forEach((key) => {
                        const value2 = metadata2[key];
                        if (typeof value2 === "string") {
                          metadata2[key] = value2.toLocaleLowerCase(locale);
                        }
                      });
                    }
                    const bytes = [
                      0,
                      0,
                      0,
                      0,
                      0
                    ];
                    const keyBytes = BinaryWriter.getBytes(value);
                    bytes.push(...keyBytes);
                    bytes.push(recordPointer.length);
                    bytes.push(...recordPointer);
                    this.allMetadataKeys && this.allMetadataKeys.forEach((key) => {
                      let metadataValue = metadata2[key];
                      if (typeof metadataValue === "string" && metadataValue.length > 255) {
                        console.warn(`Truncating "${key}" metadata value "${metadataValue}" because it is too large to index`);
                        metadataValue = metadataValue.slice(0, 255);
                      }
                      const valueBytes = BinaryWriter.getBytes(metadataValue);
                      bytes.push(...valueBytes);
                    });
                    BinaryWriter.writeUint32(bytes.length, bytes, 0);
                    writeToStream(bytes);
                    indexedValues++;
                  };
                  if (keyValue !== null) {
                    const recordPointer = _createRecordPointer(wildcardValues, childKey);
                    if (options?.addCallback) {
                      keyValue = options.addCallback(addIndexValue, keyValue, recordPointer, metadata, { path: childPath, wildcards: wildcardValues, key: childKey, locale });
                    } else {
                      addIndexValue(keyValue, recordPointer, metadata);
                    }
                    this.storage.debug.log(`Indexed "/${childPath}/${this.key}" value: '${keyValue}' (${typeof keyValue})`.colorize(ColorStyle.cyan));
                  }
                }
              }));
            }
          };
          return getChildren2();
        };
      });
    };
    const mergeFile = `${buildFile}.merge`;
    const createMergeFile = async () => {
      if (indexedValues === 0) {
        return await pfs.rm(buildFile).catch((err) => {
        });
      }
      try {
        const exists2 = await pfs.exists(mergeFile);
        if (exists2) {
          const err = new Error("File already exists");
          err.code = "EEXIST";
          throw err;
        }
        const fd = await pfs.open(buildFile, pfs.flags.readAndWrite);
        const writer = BinaryWriter.forFunction(async (data, position) => {
          const buffer = data instanceof Buffer ? data : Buffer.from(data);
          await pfs.write(fd, buffer, 0, buffer.byteLength, position);
        });
        const reader = new BinaryReader(fd, 512 * 1024);
        await reader.init();
        const maxValues = 1e5;
        const readNext = async () => {
          try {
            let processed = true;
            let buffer;
            let entryIndex;
            while (processed) {
              entryIndex = reader.sourceIndex;
              const entryLength = await reader.getUint32();
              if (entryLength < 4) {
                throw new Error(`Invalid entry length ${entryLength} at build file index ${entryIndex}`);
              }
              buffer = await reader.get(entryLength - 4);
              processed = buffer[0] === 1;
            }
            let index = 1;
            const keyValue = BinaryReader.readValue(buffer, index);
            index += keyValue.byteLength;
            const len = buffer.byteLength - index;
            const val = buffer.slice(index, index + len);
            return {
              key: keyValue.value,
              value: val,
              index: entryIndex,
              length: buffer.byteLength + 4,
              flagProcessed() {
                buffer[0] = 1;
                buffer = null;
                return writer.write([1], this.index + 4);
              }
            };
          } catch (err) {
            if (err.code === "EOF") {
              return null;
            }
            throw err;
          }
        };
        let batchNr = 0;
        let batchStartEntry = null;
        const path4 = buildFile.slice(0, buildFile.lastIndexOf("/"));
        const entries = await pfs.readdir(path4);
        let high = 0;
        const checkFile = buildFile.slice(path4.length + 1) + ".";
        entries.forEach((entry) => {
          if (typeof entry === "string" && entry.startsWith(checkFile)) {
            const match = /\.([0-9]+)$/.exec(entry);
            if (!match) {
              return;
            }
            const nr = parseInt(match[1]);
            high = Math.max(high, nr);
          }
        });
        batchNr = high;
        let more = true;
        while (more) {
          batchNr++;
          const map2 = /* @__PURE__ */ new Map();
          let processedValues = 0;
          if (batchStartEntry !== null) {
            await reader.go(batchStartEntry.index);
            batchStartEntry = null;
          }
          let next;
          while ((next = await readNext()) !== null) {
            processedValues++;
            const isDate2 = next.key instanceof Date;
            const key = isDate2 ? next.key.getTime() : next.key;
            let values = map2.get(key);
            if (values) {
              values.push(next.value);
              next.flagProcessed();
            } else if (processedValues < maxValues) {
              values = [next.value];
              if (isDate2) {
                values.dateKey = true;
              }
              map2.set(key, values);
              next.flagProcessed();
            } else {
              more = true;
              batchStartEntry = next;
              break;
            }
          }
          if (map2.size === 0) {
            batchNr--;
            break;
          }
          const sortedKeys = fastQuickSort([...map2.keys()], (a, b) => {
            if (BPlusTree.typeSafeComparison.isLess(a, b)) {
              return -1;
            }
            if (BPlusTree.typeSafeComparison.isMore(a, b)) {
              return 1;
            }
            return 0;
          });
          const batchStream = pfs.fs.createWriteStream(`${buildFile}.${batchNr}`, { flags: pfs.flags.appendAndCreate });
          for (const key of sortedKeys) {
            const values = map2.get(key);
            const isDateKey = values.dateKey === true;
            const bytes = [
              0,
              0,
              0,
              0
            ];
            let b = BinaryWriter.getBytes(isDateKey ? new Date(key) : key);
            bytes.push(...b);
            b = BinaryWriter.writeUint32(values.length, [0, 0, 0, 0], 0);
            bytes.push(...b);
            for (let j = 0; j < values.length; j++) {
              const value = values[j];
              b = BinaryWriter.writeUint32(value.length, [0, 0, 0, 0], 0);
              bytes.push(...b);
              bytes.push(...value);
            }
            BinaryWriter.writeUint32(bytes.length, bytes, 0);
            const ok = batchStream.write(Uint8Array.from(bytes));
            if (!ok) {
              await new Promise((resolve) => {
                batchStream.once("drain", resolve);
              });
            }
          }
          await new Promise((resolve) => {
            batchStream.end(resolve);
          });
        }
        await pfs.close(fd);
        await pfs.rm(buildFile);
        const batches = batchNr;
        if (batches === 0) {
          return;
        }
        const outputStream = pfs.fs.createWriteStream(mergeFile, { flags: pfs.flags.writeAndCreate });
        const readers = [];
        const bufferChunkSize = Math.max(10240, Math.round(10 * 1024 * 1024 / batches));
        for (let i = 0; i < batches; i++) {
          const reader2 = new BinaryReader(`${buildFile}.${i + 1}`, bufferChunkSize);
          readers.push(reader2);
        }
        await Promise.all(readers.map((reader2) => reader2.init()));
        let sortedEntryIndexes = [];
        const entriesPerBatch = new Array(batches);
        const loadEntry = async (batchIndex) => {
          const reader2 = readers[batchIndex];
          try {
            const entryLength = await reader2.getUint32();
            const buffer = await reader2.get(entryLength - 4);
            const keyValue = BinaryReader.readValue(buffer, 0);
            const key = keyValue.value;
            const values = buffer.slice(keyValue.byteLength);
            const existing = entriesPerBatch.find((entry2) => entry2 && entry2.key === key);
            if (existing) {
              const currentValues = BinaryReader.readUint32(existing.values, 0);
              const additionalValues = BinaryReader.readUint32(values, 0);
              const concatenated = new Uint8Array(existing.values.byteLength + values.byteLength - 4);
              concatenated.set(existing.values, 0);
              concatenated.set(values.slice(4), existing.values.byteLength);
              BinaryWriter.writeUint32(currentValues + additionalValues, concatenated, 0);
              existing.values = concatenated;
              return loadEntry(batchIndex);
            }
            const entry = { key, values };
            entriesPerBatch[batchIndex] = entry;
            if (sortedEntryIndexes.length > 0) {
              const oldSortEntryIndex = sortedEntryIndexes.findIndex((sortEntry) => sortEntry.index === batchIndex);
              sortedEntryIndexes.splice(oldSortEntryIndex, 1);
              let newSortEntryIndex = oldSortEntryIndex;
              while (newSortEntryIndex < sortedEntryIndexes.length && BPlusTree.typeSafeComparison.isMore(entry.key, sortedEntryIndexes[newSortEntryIndex].key)) {
                newSortEntryIndex++;
              }
              const newSortEntry = { index: batchIndex, key: entry.key };
              sortedEntryIndexes.splice(newSortEntryIndex, 0, newSortEntry);
            }
          } catch (err) {
            if (err.code === "EOF") {
              entriesPerBatch[batchIndex] = null;
              assert(sortedEntryIndexes.length > 0);
              const sortEntryIndex = sortedEntryIndexes.findIndex((sortEntry) => sortEntry.index === batchIndex);
              sortedEntryIndexes.splice(sortEntryIndex, 1);
            } else {
              throw err;
            }
          }
        };
        const promises = readers.map((reader2, index) => loadEntry(index));
        await Promise.all(promises);
        sortedEntryIndexes = entriesPerBatch.map((entry, index) => ({ index, key: entry.key })).sort((a, b) => {
          if (BPlusTree.typeSafeComparison.isLess(a.key, b.key)) {
            return -1;
          }
          if (BPlusTree.typeSafeComparison.isMore(a.key, b.key)) {
            return 1;
          }
          return 0;
        });
        while (sortedEntryIndexes.length > 0) {
          const smallestDetails = sortedEntryIndexes[0];
          const batchIndex = smallestDetails.index;
          const smallestEntry = entriesPerBatch[batchIndex];
          const bytes = [
            0,
            0,
            0,
            0
          ];
          const keyBytes = BinaryWriter.getBytes(smallestEntry.key);
          bytes.push(...keyBytes);
          const byteLength = bytes.length + smallestEntry.values.byteLength;
          BinaryWriter.writeUint32(byteLength, bytes, 0);
          const buffer = new Uint8Array(byteLength);
          buffer.set(bytes, 0);
          buffer.set(smallestEntry.values, bytes.length);
          const ok = outputStream.write(buffer, (err) => {
            assert(!err, "Error while writing?");
          });
          if (!ok) {
            await new Promise((resolve) => {
              outputStream.once("drain", resolve);
            });
          }
          await loadEntry(batchIndex);
        }
        await new Promise((resolve) => {
          outputStream.end(resolve);
        });
        const crPromises = readers.map((reader2) => reader2.close());
        await Promise.all(crPromises);
        const dbfPromises = [];
        for (let i = 1; i <= batches; i++) {
          dbfPromises.push(pfs.rm(`${buildFile}.${i}`));
        }
        await Promise.all(dbfPromises);
      } catch (err) {
        if (err?.code !== "EEXIST") {
          throw err;
        }
      }
    };
    const startTime = Date.now();
    const lock = await this._lock("exclusive", 24 * 60 * 60 * 1e3);
    try {
      try {
        await createBuildFile();
      } catch (err) {
        if (err.code !== "EEXIST") {
          throw err;
        }
      }
      this.storage.debug.log(`done writing build file ${buildFile}`);
      await createMergeFile();
      this.storage.debug.log(`done writing merge file ${mergeFile}`);
      const [readFD, writeFD] = await Promise.all([
        indexedValues === 0 ? -1 : pfs.open(mergeFile, pfs.flags.read),
        pfs.open(this.fileName, pfs.flags.write)
      ]);
      const treeStatistics = {
        totalEntries: 0,
        totalValues: 0
      };
      const headerStats = {
        written: false,
        updateTreeLength: (treeByteLength) => {
          throw new Error("header hasn't been written yet");
        },
        length: DISK_BLOCK_SIZE,
        promise: void 0
      };
      const writer = BinaryWriter.forFunction(async (data, index) => {
        if (!headerStats.written) {
          if (!headerStats.promise) {
            headerStats.promise = this._writeIndexHeader(writeFD, treeStatistics).then(async (result) => {
              headerStats.written = true;
              headerStats.length = result.length;
              headerStats.updateTreeLength = result.treeLengthCallback;
              if (this.state === DataIndex.STATE.REBUILD) {
                await pfs.truncate(this.fileName, headerStats.length);
              }
            });
          }
          await headerStats.promise;
        }
        await pfs.write(writeFD, data, 0, data.length, headerStats.length + index);
      });
      const reader = indexedValues > 0 ? new BinaryReader(readFD) : new BinaryReader(async (index, length3) => Buffer.from([]));
      await BinaryBPlusTree.createFromEntryStream(reader, writer, {
        treeStatistics,
        fillFactor: FILL_FACTOR,
        maxEntriesPerNode: 255,
        isUnique: false,
        keepFreeSpace: true,
        metadataKeys: this.allMetadataKeys,
        debug: this.storage.debug
      });
      await Promise.all([
        pfs.fsync(writeFD).then(() => pfs.close(writeFD)),
        indexedValues > 0 && pfs.close(readFD)
      ]);
      if (indexedValues > 0) {
        await pfs.rm(mergeFile);
      }
      const doneTime = Date.now();
      const duration = Math.round((doneTime - startTime) / 1e3 / 60);
      this.storage.debug.log(`Index ${this.description} was built successfully, took ${duration} minutes`.colorize(ColorStyle.green));
      this.state = DataIndex.STATE.READY;
    } catch (err) {
      this.storage.debug.error(`Error building index ${this.description}: ${err?.message || err}`);
      this.state = DataIndex.STATE.ERROR;
      this._buildError = err;
      throw err;
    } finally {
      lock.release();
    }
    this._processUpdateQueue();
    return this;
  }
  test(obj, op, val) {
    throw new Error("test method must be overridden by subclass");
  }
  _getIndexHeaderBytes(treeStatistics) {
    const indexEntries = treeStatistics.totalEntries;
    const indexedValues = treeStatistics.totalValues;
    const addNameBytes = (bytes, name) => {
      bytes.push(name.length);
      for (let i = 0; i < name.length; i++) {
        bytes.push(name.charCodeAt(i));
      }
    };
    const addValueBytes = (bytes, value) => {
      let valBytes = [];
      if (typeof value === "undefined") {
        bytes.push(INDEX_INFO_VALUE_TYPE.UNDEFINED);
        return;
      } else if (typeof value === "string") {
        bytes.push(INDEX_INFO_VALUE_TYPE.STRING);
        valBytes = Array.from(encodeString4(value));
      } else if (typeof value === "number") {
        bytes.push(INDEX_INFO_VALUE_TYPE.NUMBER);
        valBytes = numberToBytes5(value);
      } else if (typeof value === "boolean") {
        bytes.push(INDEX_INFO_VALUE_TYPE.BOOLEAN);
        bytes.push(value ? 1 : 0);
        return;
      } else if (value instanceof Array) {
        bytes.push(INDEX_INFO_VALUE_TYPE.ARRAY);
        if (value.length > 65535) {
          throw new Error("Array is too large to store. Max length is 0xffff");
        }
        bytes.push(value.length >> 8 & 255);
        bytes.push(value.length & 255);
        value.forEach((val) => {
          addValueBytes(bytes, val);
        });
        return;
      } else {
        throw new Error(`Invalid value type "${typeof value}"`);
      }
      bytes.push(valBytes.length >> 8 & 255);
      bytes.push(valBytes.length & 255);
      bytes.push(...valBytes);
    };
    const addInfoBytes = (bytes, obj) => {
      const keys = Object.keys(obj);
      bytes.push(keys.length);
      keys.forEach((key) => {
        addNameBytes(bytes, key);
        const value = obj[key];
        addValueBytes(bytes, value);
      });
    };
    const header = [
      65,
      67,
      69,
      66,
      65,
      83,
      69,
      73,
      68,
      88,
      1,
      0,
      0,
      0,
      0
    ];
    const indexInfo = {
      type: this.type,
      version: 1,
      path: this.path,
      key: this.key,
      include: this.includeKeys,
      cs: this.caseSensitive,
      locale: this.textLocale,
      localeKey: this.textLocaleKey
    };
    addInfoBytes(header, indexInfo);
    header.push(1);
    const treeName = "default";
    const treeDetails = this.trees[treeName];
    addNameBytes(header, treeName);
    const treeRefIndex = header.length;
    header.push(0, 0, 0, 0);
    header.push(0, 0, 0, 0);
    treeDetails.entries = indexEntries;
    treeDetails.values = indexedValues;
    const extraTreeInfo = {
      class: treeDetails.class,
      version: treeDetails.version,
      entries: indexEntries,
      values: indexedValues
    };
    addInfoBytes(header, extraTreeInfo);
    while (header.length % DISK_BLOCK_SIZE !== 0) {
      header.push(0);
    }
    const headerLength = header.length;
    treeDetails.fileIndex = headerLength;
    header[11] = headerLength >> 24 & 255;
    header[12] = headerLength >> 16 & 255;
    header[13] = headerLength >> 8 & 255;
    header[14] = headerLength & 255;
    header[treeRefIndex] = headerLength >> 24 & 255;
    header[treeRefIndex + 1] = headerLength >> 16 & 255;
    header[treeRefIndex + 2] = headerLength >> 8 & 255;
    header[treeRefIndex + 3] = headerLength & 255;
    return { header, headerLength, treeRefIndex, treeDetails };
  }
  async _writeIndexHeader(fd, treeStatistics) {
    const { header, headerLength, treeRefIndex } = this._getIndexHeaderBytes(treeStatistics);
    await pfs.write(fd, Buffer.from(header));
    return {
      length: headerLength,
      treeLengthCallback: async (treeByteLength) => {
        const bytes = [
          treeByteLength >> 24 & 255,
          treeByteLength >> 16 & 255,
          treeByteLength >> 8 & 255,
          treeByteLength & 255
        ];
        await pfs.write(fd, Buffer.from(bytes), 0, bytes.length, treeRefIndex + 4);
      }
    };
  }
  async _writeIndex(builder) {
    const totalEntries = builder.list.size;
    const totalValues = builder.indexedValues;
    const fd = await pfs.open(this.fileName, pfs.flags.write);
    const { header, headerLength, treeRefIndex, treeDetails } = this._getIndexHeaderBytes({ totalEntries, totalValues });
    try {
      await pfs.write(fd, Buffer.from(header));
      const tree = builder.create();
      const stream4 = pfs.fs.createWriteStream(null, { fd, autoClose: false });
      const references = [];
      const writer = new BinaryWriter(stream4, async (data, position) => {
        references.push({ data, position });
      });
      await tree.toBinary(true, writer);
      while (references.length > 0) {
        const ref = references.shift();
        await pfs.write(fd, ref.data, 0, ref.data.byteLength, headerLength + ref.position);
      }
      const treeByteLength = writer.length;
      const bytes = [
        treeByteLength >> 24 & 255,
        treeByteLength >> 16 & 255,
        treeByteLength >> 8 & 255,
        treeByteLength & 255
      ];
      treeDetails.byteLength = treeByteLength;
      await pfs.write(fd, Buffer.from(bytes), 0, bytes.length, treeRefIndex + 4);
      await pfs.close(fd);
    } catch (err) {
      this.storage.debug.error(err);
      throw err;
    }
  }
  async _getTree(lockMode = "exclusive") {
    if ([DataIndex.STATE.ERROR, DataIndex.STATE.CLOSED, DataIndex.STATE.REMOVED].includes(this.state)) {
      throw new Error(`Can't open index ${this.description} with state "${this.state}"`);
    }
    const lock = await this._lock(lockMode);
    if (!this._idx) {
      const fd = await pfs.open(this.fileName, pfs.flags.readAndWrite);
      const reader = async (index, length3) => {
        const buffer = Buffer.alloc(length3);
        const { bytesRead } = await pfs.read(fd, buffer, 0, length3, this.trees.default.fileIndex + index);
        if (bytesRead < length3) {
          return buffer.slice(0, bytesRead);
        }
        return buffer;
      };
      const writer = async (data, index) => {
        const buffer = data.constructor === Uint8Array ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(data);
        const result = await pfs.write(fd, buffer, 0, data.length, this.trees.default.fileIndex + index);
        return result;
      };
      const tree = new BinaryBPlusTree({
        readFn: reader,
        chunkSize: DISK_BLOCK_SIZE,
        writeFn: writer,
        debug: this.storage.debug,
        id: ID.generate()
      });
      tree.autoGrow = true;
      this._idx = { fd, tree };
    }
    return {
      tree: this._idx.tree,
      close: async () => {
        const fd = this._idx.fd;
        this._idx = null;
        await pfs.close(fd).catch((err) => {
          this.storage.debug.warn(`Could not close index file "${this.fileName}":`, err);
        });
      },
      release() {
        lock.release();
      }
    };
  }
};

// node_modules/acebase/dist/esm/data-index/query-hint.js
var IndexQueryHint = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
};

// node_modules/acebase/dist/esm/data-index/fulltext-index-query-hint.js
var FullTextIndexQueryHint = class extends IndexQueryHint {
  static get types() {
    return Object.freeze({
      missingWord: "missing",
      genericWord: "generic",
      ignoredWord: "ignored"
    });
  }
  constructor(type, value) {
    super(type, value);
  }
  get description() {
    switch (this.type) {
      case FullTextIndexQueryHint.types.missingWord: {
        return `Word "${this.value}" does not occur in the index, you might want to remove it from your query`;
      }
      case FullTextIndexQueryHint.types.genericWord: {
        return `Word "${this.value}" is very generic and occurs many times in the index. Removing the word from your query will speed up the results and minimally impact the size of the result set`;
      }
      case FullTextIndexQueryHint.types.ignoredWord: {
        return `Word "${this.value}" was ignored because it is either blacklisted, occurs in a stoplist, or did not match other criteria such as minimum (wildcard) word length`;
      }
      default: {
        return "Uknown hint";
      }
    }
  }
};

// node_modules/acebase/dist/esm/unidecode.js
var Unidecode = __toESM(require_unidecode(), 1);
var unidecode = Unidecode.default ?? Unidecode;
var unidecode_default = unidecode;

// node_modules/acebase/dist/esm/data-index/fulltext-index.js
var WordInfo = class {
  constructor(word, indexes, sourceIndexes) {
    this.word = word;
    this.indexes = indexes;
    this.sourceIndexes = sourceIndexes;
  }
  get occurs() {
    return this.indexes.length;
  }
};
var TextInfo = class {
  static get locales() {
    return {
      "default": {
        pattern: "[A-Za-z0-9']+",
        flags: "gmi"
      },
      "en": {
        stoplist: ["i", "me", "my", "myself", "we", "our", "ours", "ourselves", "you", "your", "yours", "yourself", "yourselves", "he", "him", "his", "himself", "she", "her", "hers", "herself", "it", "its", "itself", "they", "them", "their", "theirs", "themselves", "what", "which", "who", "whom", "this", "that", "these", "those", "am", "is", "are", "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "a", "an", "the", "and", "but", "if", "or", "because", "as", "until", "while", "of", "at", "by", "for", "with", "about", "against", "between", "into", "through", "during", "before", "after", "above", "below", "to", "from", "up", "down", "in", "out", "on", "off", "over", "under", "again", "further", "then", "once", "here", "there", "when", "where", "why", "how", "all", "any", "both", "each", "few", "more", "most", "other", "some", "such", "no", "nor", "not", "only", "own", "same", "so", "than", "too", "very", "s", "t", "can", "will", "just", "don", "should", "now"]
      },
      get(locale) {
        const settings = {};
        Object.assign(settings, this.default);
        if (typeof this[locale] === "undefined" && locale.indexOf("-") > 0) {
          locale = locale.split("-")[1];
        }
        if (typeof this[locale] === "undefined") {
          return settings;
        }
        Object.keys(this[locale]).forEach((key) => {
          settings[key] = this[locale][key];
        });
        return settings;
      }
    };
  }
  getWordInfo(word) {
    return this.words.get(word);
  }
  toSequence() {
    const arr = [];
    for (const { word, indexes } of this.words.values()) {
      for (const index of indexes) {
        arr[index] = word;
      }
    }
    return arr;
  }
  toArray() {
    const arr = [];
    for (const word of this.words.keys()) {
      arr.push(word);
    }
    return arr;
  }
  get uniqueWordCount() {
    return this.words.size;
  }
  get wordCount() {
    let total = 0;
    for (const wordInfo of this.words.values()) {
      total += wordInfo.occurs;
    }
    return total;
  }
  constructor(text, options) {
    this.locale = options.locale || "en";
    const localeSettings = TextInfo.locales.get(this.locale);
    let pattern = localeSettings.pattern;
    if (options.pattern && options.pattern instanceof RegExp) {
      pattern = options.pattern.source;
    } else if (typeof options.pattern === "string") {
      pattern = options.pattern;
    }
    if (options.includeChars) {
      assert(pattern.indexOf("[") >= 0, "pattern does not contain []");
      let insert = "";
      for (let i = 0; i < options.includeChars.length; i++) {
        insert += "\\" + options.includeChars[i];
      }
      let pos = -1;
      while (true) {
        const index = pattern.indexOf("[", pos + 1) + 1;
        if (index === 0) {
          break;
        }
        pattern = pattern.slice(0, index) + insert + pattern.slice(index);
        pos = index;
      }
    }
    let flags = localeSettings.flags;
    if (typeof options.flags === "string") {
      flags = options.flags;
    }
    const re = new RegExp(pattern, flags);
    const minLength = typeof options.minLength === "number" ? options.minLength : 1;
    const maxLength = typeof options.maxLength === "number" ? options.maxLength : 25;
    let blacklist = options.blacklist instanceof Array ? options.blacklist : [];
    if (localeSettings.stoplist instanceof Array && options.useStoplist === true) {
      blacklist = blacklist.concat(localeSettings.stoplist);
    }
    const whitelist = options.whitelist instanceof Array ? options.whitelist : [];
    const words = this.words = /* @__PURE__ */ new Map();
    this.ignored = [];
    if (text === null || typeof text === "undefined") {
      return;
    }
    if (options.prepare) {
      text = options.prepare(text, this.locale, `"${options.includeChars ?? ""}`);
    }
    function safe_unidecode(str) {
      let ret;
      while (str !== (ret = unidecode_default(str))) {
        str = ret;
      }
      return ret;
    }
    text = safe_unidecode(text);
    text = text.replace(/'/g, "");
    let wordIndex = 0;
    while (true) {
      const match = re.exec(text);
      if (match === null) {
        break;
      }
      let word = match[0];
      if (typeof options.stemming === "function") {
        const stemmed = options.stemming(word, this.locale);
        if (typeof stemmed !== "string") {
          if (this.ignored.indexOf(word) < 0) {
            this.ignored.push(word);
          }
          continue;
        }
        word = stemmed;
      }
      word = word.toLocaleLowerCase(this.locale);
      if (word.length < minLength || ~blacklist.indexOf(word)) {
        if (!~whitelist.indexOf(word)) {
          if (this.ignored.indexOf(word) < 0) {
            this.ignored.push(word);
          }
          continue;
        }
      } else if (word.length > maxLength) {
        word = word.slice(0, maxLength);
      }
      let wordInfo = words.get(word);
      if (wordInfo) {
        wordInfo.indexes.push(wordIndex);
        wordInfo.sourceIndexes.push(match.index);
      } else {
        wordInfo = new WordInfo(word, [wordIndex], [match.index]);
        words.set(word, wordInfo);
      }
      wordIndex++;
    }
  }
};
var FullTextIndex = class extends DataIndex {
  constructor(storage, path3, key, options) {
    if (key === "{key}") {
      throw new Error("Cannot create fulltext index on node keys");
    }
    super(storage, path3, key, options);
    this.indexMetadataKeys = ["_occurs_"];
    this.config = options.config || {};
    if (this.config.localeKey) {
      storage.debug.warn(`fulltext index config option "localeKey" has been deprecated, as it is now supported for all indexes. Move the setting to the global index settings`);
      this.textLocaleKey = this.config.localeKey;
    }
  }
  get type() {
    return "fulltext";
  }
  getTextInfo(val, locale) {
    return new TextInfo(val, {
      locale: locale ?? this.textLocale,
      prepare: this.config.prepare,
      stemming: this.config.transform,
      blacklist: this.config.blacklist,
      whitelist: this.config.whitelist,
      useStoplist: this.config.useStoplist,
      minLength: this.config.minLength,
      maxLength: this.config.maxLength
    });
  }
  test(obj, op, val) {
    if (obj === null) {
      return op === "fulltext:!contains";
    }
    const text = obj[this.key];
    if (typeof text === "undefined") {
      return op === "fulltext:!contains";
    }
    const locale = obj?.[this.textLocaleKey] ?? this.textLocale;
    const textInfo = this.getTextInfo(text, locale);
    if (op === "fulltext:contains") {
      if (~val.indexOf(" OR ")) {
        const tests = val.split(" OR ");
        return tests.some((val2) => this.test(text, op, val2));
      } else if (~val.indexOf('"')) {
        const phraseRegex = /"(.+?)"/g;
        const phrases = [];
        while (true) {
          const match = phraseRegex.exec(val);
          if (match === null) {
            break;
          }
          const phrase = match[1];
          phrases.push(phrase);
          val = val.slice(0, match.index) + val.slice(match.index + match[0].length);
          phraseRegex.lastIndex = 0;
        }
        if (val.length > 0) {
          phrases.push(val);
        }
        return phrases.every((phrase) => {
          const phraseInfo = this.getTextInfo(phrase, locale);
          const phraseWords = phraseInfo.toSequence();
          const occurrencesPerWord = phraseWords.map((word, i) => {
            const { indexes } = textInfo.words.get(word);
            return indexes;
          });
          const hasSequenceAtIndex = (wordIndex, occurrenceIndex) => {
            const startIndex = occurrencesPerWord[wordIndex]?.[occurrenceIndex];
            return occurrencesPerWord.slice(wordIndex + 1).every((occurences, i) => {
              return occurences.some((index, j) => {
                if (index !== startIndex + 1) {
                  return false;
                }
                return hasSequenceAtIndex(wordIndex + i, j);
              });
            });
          };
          return occurrencesPerWord[0].some((occurrence, i) => {
            return hasSequenceAtIndex(0, i);
          });
        });
      } else {
        const wordsInfo = this.getTextInfo(val, locale);
        return wordsInfo.toSequence().every((word) => {
          return textInfo.words.has(word);
        });
      }
    }
  }
  async handleRecordUpdate(path3, oldValue, newValue) {
    let oldText = oldValue !== null && typeof oldValue === "object" && this.key in oldValue ? oldValue[this.key] : null;
    let newText = newValue !== null && typeof newValue === "object" && this.key in newValue ? newValue[this.key] : null;
    const oldLocale = oldValue?.[this.textLocaleKey] ?? this.textLocale, newLocale = newValue?.[this.textLocaleKey] ?? this.textLocale;
    if (typeof oldText === "object" && oldText instanceof Array) {
      oldText = oldText.join(" ");
    }
    if (typeof newText === "object" && newText instanceof Array) {
      newText = newText.join(" ");
    }
    const oldTextInfo = this.getTextInfo(oldText, oldLocale);
    const newTextInfo = this.getTextInfo(newText, newLocale);
    const oldWords = oldTextInfo.toArray();
    const newWords = newTextInfo.toArray();
    const removed = oldWords.filter((word) => newWords.indexOf(word) < 0);
    const added = newWords.filter((word) => oldWords.indexOf(word) < 0);
    const changed = oldWords.filter((word) => newWords.indexOf(word) >= 0).filter((word) => {
      const oldInfo = oldTextInfo.getWordInfo(word);
      const newInfo = newTextInfo.getWordInfo(word);
      return oldInfo.occurs !== newInfo.occurs || oldInfo.indexes.some((index, i) => newInfo.indexes[i] !== index);
    });
    changed.forEach((word) => {
      removed.push(word);
      added.push(word);
    });
    const promises = [];
    removed.forEach((word) => {
      const p = super.handleRecordUpdate(path3, { [this.key]: word }, { [this.key]: null });
      promises.push(p);
    });
    added.forEach((word) => {
      const mutated = {};
      Object.assign(mutated, newValue);
      mutated[this.key] = word;
      const wordInfo = newTextInfo.getWordInfo(word);
      let occurs = wordInfo.indexes.join(",");
      if (occurs.length > 255) {
        console.warn(`FullTextIndex ${this.description}: word "${word}" occurs too many times in "${path3}/${this.key}" to store in index metadata. Truncating occurrences`);
        const cutIndex = occurs.lastIndexOf(",", 255);
        occurs = occurs.slice(0, cutIndex);
      }
      const indexMetadata = {
        "_occurs_": occurs
      };
      const p = super.handleRecordUpdate(path3, { [this.key]: null }, mutated, indexMetadata);
      promises.push(p);
    });
    await Promise.all(promises);
  }
  build() {
    return super.build({
      addCallback: (add, text, recordPointer, metadata, env2) => {
        if (typeof text === "object" && text instanceof Array) {
          text = text.join(" ");
        }
        if (typeof text === "undefined") {
          text = "";
        }
        const locale = env2.locale || this.textLocale;
        const textInfo = this.getTextInfo(text, locale);
        if (textInfo.words.size === 0) {
          this.storage.debug.warn(`No words found in "${typeof text === "string" && text.length > 50 ? text.slice(0, 50) + "..." : text}" to fulltext index "${env2.path}"`);
        }
        textInfo.words.forEach((wordInfo) => {
          let occurs = wordInfo.indexes.join(",");
          if (occurs.length > 255) {
            console.warn(`FullTextIndex ${this.description}: word "${wordInfo.word}" occurs too many times to store in index metadata. Truncating occurrences`);
            const cutIndex = occurs.lastIndexOf(",", 255);
            occurs = occurs.slice(0, cutIndex);
          }
          const wordMetadata = {
            "_occurs_": occurs
          };
          Object.assign(wordMetadata, metadata);
          add(wordInfo.word, recordPointer, wordMetadata);
        });
        return textInfo.toArray();
      },
      valueTypes: [VALUE_TYPES.STRING]
    });
  }
  static get validOperators() {
    return ["fulltext:contains", "fulltext:!contains"];
  }
  get validOperators() {
    return FullTextIndex.validOperators;
  }
  async query(op, val, options) {
    if (op instanceof BlacklistingSearchOperator) {
      throw new Error(`Not implemented: Can't query fulltext index with blacklisting operator yet`);
    }
    if (op === "fulltext:contains" || op === "fulltext:!contains") {
      return this.contains(op, val, options);
    } else {
      throw new Error(`Fulltext indexes can only be queried with operators ${FullTextIndex.validOperators.map((op2) => `"${op2}"`).join(", ")}`);
    }
  }
  async contains(op, val, options = {
    phrase: false,
    locale: void 0,
    minimumWildcardWordLength: 2
  }) {
    if (!FullTextIndex.validOperators.includes(op)) {
      throw new Error(`Fulltext indexes can only be queried with operators ${FullTextIndex.validOperators.map((op2) => `"${op2}"`).join(", ")}`);
    }
    const cache = this.cache(op, val);
    if (cache) {
      return Promise.resolve(cache);
    }
    const stats = new IndexQueryStats(options.phrase ? "fulltext_phrase_query" : "fulltext_query", val, true);
    const getTextInfo = (text) => {
      const info2 = new TextInfo(text, {
        locale: options.locale || this.textLocale,
        prepare: this.config.prepare,
        stemming: this.config.transform,
        minLength: this.config.minLength,
        maxLength: this.config.maxLength,
        blacklist: this.config.blacklist,
        whitelist: this.config.whitelist,
        useStoplist: this.config.useStoplist,
        includeChars: "*?"
      });
      const words2 = info2.toArray();
      let i;
      while (i = words2.findIndex((w) => /^[*?]+$/.test(w)), i >= 0) {
        const word = words2[i];
        info2.ignored.push(word);
        info2.words.delete(word);
      }
      if (options.minimumWildcardWordLength > 0) {
        for (const word of words2) {
          const starIndex = word.indexOf("*");
          if (starIndex > 0 && starIndex < options.minimumWildcardWordLength) {
            info2.ignored.push(word);
            info2.words.delete(word);
            i--;
          }
        }
      }
      return info2;
    };
    if (val.includes(" OR ")) {
      const queries = val.split(" OR ");
      const promises = queries.map((q) => this.query(op, q, options));
      const resultSets = await Promise.all(promises);
      stats.steps.push(...resultSets.map((results3) => results3.stats));
      const mergeStep = new IndexQueryStats("merge_expand", { sets: resultSets.length, results: resultSets.reduce((total, set) => total + set.length, 0) }, true);
      stats.steps.push(mergeStep);
      const merged = resultSets[0];
      resultSets.slice(1).forEach((results3) => {
        results3.forEach((result) => {
          const exists2 = ~merged.findIndex((r) => r.path === result.path);
          if (!exists2) {
            merged.push(result);
          }
        });
      });
      const results2 = IndexQueryResults.fromResults(merged, this.key);
      mergeStep.stop(results2.length);
      stats.stop(results2.length);
      results2.stats = stats;
      results2.hints.push(...resultSets.reduce((hints, set) => {
        hints.push(...set.hints);
        return hints;
      }, []));
      return results2;
    }
    if (val.includes('"')) {
      const phraseRegex = /"(.+?)"/g;
      const phrases = [];
      while (true) {
        const match = phraseRegex.exec(val);
        if (match === null) {
          break;
        }
        const phrase = match[1];
        phrases.push(phrase);
        val = val.slice(0, match.index) + val.slice(match.index + match[0].length);
        phraseRegex.lastIndex = 0;
      }
      const phraseOptions = {};
      Object.assign(phraseOptions, options);
      phraseOptions.phrase = true;
      const promises = phrases.map((phrase) => this.query(op, phrase, phraseOptions));
      if (val.length > 0 && getTextInfo(val).wordCount > 0) {
        const promise = this.query(op, val, options);
        promises.push(promise);
      }
      const resultSets = await Promise.all(promises);
      stats.steps.push(...resultSets.map((results2) => results2.stats));
      const mergeStep = new IndexQueryStats("merge_reduce", { sets: resultSets.length, results: resultSets.reduce((total, set) => total + set.length, 0) }, true);
      resultSets.length > 1 && stats.steps.push(mergeStep);
      const shortestSet = resultSets.sort((a, b) => a.length < b.length ? -1 : 1)[0];
      const otherSets = resultSets.slice(1);
      const matches = shortestSet.reduce((matches2, match) => {
        const path3 = match.path;
        const matchedInAllSets = otherSets.every((set) => set.findIndex((match2) => match2.path === path3) >= 0);
        if (matchedInAllSets) {
          matches2.push(match);
        }
        return matches2;
      }, new IndexQueryResults());
      matches.filterKey = this.key;
      mergeStep.stop(matches.length);
      stats.stop(matches.length);
      matches.stats = stats;
      matches.hints.push(...resultSets.reduce((hints, set) => {
        hints.push(...set.hints);
        return hints;
      }, []));
      return matches;
    }
    const info = getTextInfo(val);
    function addIgnoredWordHints(results2) {
      info.ignored.forEach((word) => {
        const hint = new FullTextIndexQueryHint(FullTextIndexQueryHint.types.ignoredWord, word);
        results2.hints.push(hint);
      });
    }
    const words = info.toArray();
    if (words.length === 0) {
      stats.stop(0);
      const results2 = IndexQueryResults.fromResults([], this.key);
      results2.stats = stats;
      addIgnoredWordHints(results2);
      return results2;
    }
    if (op === "fulltext:!contains") {
      const wordChecks = words.map((word) => {
        if (word.includes("*") || word.includes("?")) {
          const pattern = "^" + word.replace(/\*/g, ".*").replace(/\?/g, ".") + "$";
          const re = new RegExp(pattern, "i");
          return re;
        }
        return word;
      });
      const customOp = new BlacklistingSearchOperator((entry) => {
        const blacklist = wordChecks.some((word) => {
          if (word instanceof RegExp) {
            return word.test(entry.key);
          }
          return entry.key === word;
        });
        if (blacklist) {
          return entry.values;
        }
      });
      stats.type = "fulltext_blacklist_scan";
      const results2 = await super.query(customOp);
      stats.stop(results2.length);
      results2.filterKey = this.key;
      results2.stats = stats;
      addIgnoredWordHints(results2);
      this.cache(op, val, results2);
      return results2;
    }
    const countPromises = words.map((word) => {
      const wildcardIndex = ~(~word.indexOf("*") || ~word.indexOf("?"));
      const wordOp = wildcardIndex >= 0 ? "like" : "==";
      const step = new IndexQueryStats("count", { op: wordOp, word }, true);
      stats.steps.push(step);
      return super.count(wordOp, word).then((count) => {
        step.stop(count);
        return { word, count };
      });
    });
    const counts = await Promise.all(countPromises);
    counts.sort((a, b) => {
      if (a.count < b.count) {
        return -1;
      } else if (a.count > b.count) {
        return 1;
      }
      return 0;
    });
    let results;
    if (counts[0].count === 0) {
      stats.stop(0);
      this.storage.debug.log(`Word "${counts[0].word}" not found in index, 0 results for query ${op} "${val}"`);
      results = new IndexQueryResults(0);
      results.filterKey = this.key;
      results.stats = stats;
      addIgnoredWordHints(results);
      counts.forEach((c3) => {
        if (c3.count === 0) {
          const hint = new FullTextIndexQueryHint(FullTextIndexQueryHint.types.missingWord, c3.word);
          results.hints.push(hint);
        }
      });
      this.cache(op, val, results);
      return results;
    }
    const allWords = counts.map((c3) => c3.word);
    const queryWord = async (word, filter2) => {
      const wildcardIndex = ~(~word.indexOf("*") || ~word.indexOf("?"));
      const wordOp = wildcardIndex >= 0 ? "like" : "==";
      const results2 = await super.query(wordOp, word, { filter: filter2 });
      stats.steps.push(results2.stats);
      return results2;
    };
    let wordIndex = 0;
    const resultsPerWord = new Array(words.length);
    const nextWord = async () => {
      const word = allWords[wordIndex];
      const t1 = Date.now();
      const fr = await queryWord(word, results);
      const t2 = Date.now();
      this.storage.debug.log(`fulltext search for "${word}" took ${t2 - t1}ms`);
      resultsPerWord[words.indexOf(word)] = fr;
      results = fr;
      wordIndex++;
      if (results.length === 0 || wordIndex === allWords.length) {
        return;
      }
      await nextWord();
    };
    await nextWord();
    if (options.phrase === true && allWords.length > 1) {
      const step = new IndexQueryStats("phrase_check", val, true);
      stats.steps.push(step);
      results = results.reduce((matches, match) => {
        const path3 = match.path;
        const wordMatches = resultsPerWord.map((results2) => {
          return results2.find((result) => result.path === path3);
        });
        wordMatches.forEach((match2) => {
          match2.metadata._occurs_ = match2.metadata._occurs_.split(",").map(parseInt);
        });
        const check = (wordMatchIndex, prevWordIndex) => {
          const sourceIndexes = wordMatches[wordMatchIndex].metadata._occurs_;
          if (typeof prevWordIndex !== "number") {
            for (let i = 0; i < sourceIndexes.length; i++) {
              const found = check(1, sourceIndexes[i]);
              if (found) {
                return true;
              }
            }
            return false;
          }
          if (sourceIndexes.includes(prevWordIndex + 1)) {
            if (wordMatchIndex === wordMatches.length - 1) {
              return true;
            }
            return check(wordMatchIndex + 1, prevWordIndex + 1);
          } else {
            return false;
          }
        };
        if (check(0)) {
          matches.push(match);
        }
        return matches;
      }, new IndexQueryResults());
      step.stop(results.length);
    }
    results.filterKey = this.key;
    stats.stop(results.length);
    results.stats = stats;
    addIgnoredWordHints(results);
    delete results.entryValues;
    this.cache(op, val, results);
    return results;
  }
};

// node_modules/acebase/dist/esm/geohash.js
var base32 = "0123456789bcdefghjkmnpqrstuvwxyz";
var encode2 = function(lat, lon, precision) {
  if (typeof precision == "undefined") {
    for (let p = 1; p <= 12; p++) {
      const hash = encode2(lat, lon, p);
      const posn = decode(hash);
      if (posn.lat == lat && posn.lon == lon) {
        return hash;
      }
    }
    precision = 12;
  }
  lat = Number(lat);
  lon = Number(lon);
  precision = Number(precision);
  if (isNaN(lat) || isNaN(lon) || isNaN(precision)) {
    throw new Error("Invalid geohash");
  }
  let idx = 0;
  let bit = 0;
  let evenBit = true;
  let geohash = "";
  let latMin = -90, latMax = 90;
  let lonMin = -180, lonMax = 180;
  while (geohash.length < precision) {
    if (evenBit) {
      const lonMid = (lonMin + lonMax) / 2;
      if (lon >= lonMid) {
        idx = idx * 2 + 1;
        lonMin = lonMid;
      } else {
        idx = idx * 2;
        lonMax = lonMid;
      }
    } else {
      const latMid = (latMin + latMax) / 2;
      if (lat >= latMid) {
        idx = idx * 2 + 1;
        latMin = latMid;
      } else {
        idx = idx * 2;
        latMax = latMid;
      }
    }
    evenBit = !evenBit;
    if (++bit == 5) {
      geohash += base32.charAt(idx);
      bit = 0;
      idx = 0;
    }
  }
  return geohash;
};
var decode = function(geohash) {
  const b = bounds(geohash);
  const latMin = b.sw.lat, lonMin = b.sw.lon;
  const latMax = b.ne.lat, lonMax = b.ne.lon;
  let lat = (latMin + latMax) / 2;
  let lon = (lonMin + lonMax) / 2;
  lat = Number(lat.toFixed(Math.floor(2 - Math.log(latMax - latMin) / Math.LN10)));
  lon = Number(lon.toFixed(Math.floor(2 - Math.log(lonMax - lonMin) / Math.LN10)));
  return { lat, lon };
};
var bounds = function(geohash) {
  if (geohash.length === 0) {
    throw new Error("Invalid geohash");
  }
  geohash = geohash.toLowerCase();
  let evenBit = true;
  let latMin = -90, latMax = 90;
  let lonMin = -180, lonMax = 180;
  for (let i = 0; i < geohash.length; i++) {
    const chr = geohash.charAt(i);
    const idx = base32.indexOf(chr);
    if (idx == -1) {
      throw new Error("Invalid geohash");
    }
    for (let n = 4; n >= 0; n--) {
      const bitN = idx >> n & 1;
      if (evenBit) {
        const lonMid = (lonMin + lonMax) / 2;
        if (bitN == 1) {
          lonMin = lonMid;
        } else {
          lonMax = lonMid;
        }
      } else {
        const latMid = (latMin + latMax) / 2;
        if (bitN == 1) {
          latMin = latMid;
        } else {
          latMax = latMid;
        }
      }
      evenBit = !evenBit;
    }
  }
  const bounds2 = {
    sw: { lat: latMin, lon: lonMin },
    ne: { lat: latMax, lon: lonMax }
  };
  return bounds2;
};

// node_modules/acebase/dist/esm/data-index/geo-index.js
function _getGeoRadiusPrecision(radiusM) {
  if (typeof radiusM !== "number") {
    return;
  }
  if (radiusM < 0.01) {
    return 12;
  }
  if (radiusM < 0.075) {
    return 11;
  }
  if (radiusM < 0.6) {
    return 10;
  }
  if (radiusM < 2.3) {
    return 9;
  }
  if (radiusM < 19) {
    return 8;
  }
  if (radiusM < 76) {
    return 7;
  }
  if (radiusM < 610) {
    return 6;
  }
  if (radiusM < 2400) {
    return 5;
  }
  if (radiusM < 19500) {
    return 4;
  }
  if (radiusM < 78700) {
    return 3;
  }
  if (radiusM < 626e3) {
    return 2;
  }
  return 1;
}
function _getGeoHash(obj) {
  if (typeof obj.lat !== "number" || typeof obj.long !== "number") {
    return;
  }
  const precision = 10;
  const geohash = encode2(obj.lat, obj.long, precision);
  return geohash;
}
function _hashesInRadius(lat, lon, radiusM, precision) {
  const isInCircle = (checkLat, checkLon, lat2, lon2, radiusM2) => {
    const deltaLon = checkLon - lon2;
    const deltaLat = checkLat - lat2;
    return Math.pow(deltaLon, 2) + Math.pow(deltaLat, 2) <= Math.pow(radiusM2, 2);
  };
  const getCentroid = (latitude, longitude, height2, width2) => {
    const y_cen = latitude + height2 / 2;
    const x_cen = longitude + width2 / 2;
    return { x: x_cen, y: y_cen };
  };
  const convertToLatLon = (y2, x2, lat2, lon2) => {
    const pi = 3.14159265359;
    const r_earth = 6371e3;
    const lat_diff = y2 / r_earth * (180 / pi);
    const lon_diff = x2 / r_earth * (180 / pi) / Math.cos(lat2 * pi / 180);
    const final_lat = lat2 + lat_diff;
    const final_lon = lon2 + lon_diff;
    return { lat: final_lat, lon: final_lon };
  };
  const x = 0;
  const y = 0;
  const points = [];
  const geohashes = [];
  const gridWidths = [5009400, 1252300, 156500, 39100, 4900, 1200, 152.9, 38.2, 4.8, 1.2, 0.149, 0.037];
  const gridHeights = [4992600, 624100, 156e3, 19500, 4900, 609.4, 152.4, 19, 4.8, 0.595, 0.149, 0.0199];
  const height = gridHeights[precision - 1] / 2;
  const width = gridWidths[precision - 1] / 2;
  const latMoves = Math.ceil(radiusM / height);
  const lonMoves = Math.ceil(radiusM / width);
  for (let i = 0; i <= latMoves; i++) {
    const tmpLat = y + height * i;
    for (let j = 0; j < lonMoves; j++) {
      const tmpLon = x + width * j;
      if (isInCircle(tmpLat, tmpLon, y, x, radiusM)) {
        const center = getCentroid(tmpLat, tmpLon, height, width);
        points.push(convertToLatLon(center.y, center.x, lat, lon));
        points.push(convertToLatLon(-center.y, center.x, lat, lon));
        points.push(convertToLatLon(center.y, -center.x, lat, lon));
        points.push(convertToLatLon(-center.y, -center.x, lat, lon));
      }
    }
  }
  points.forEach((point) => {
    const hash = encode2(point.lat, point.lon, precision);
    if (geohashes.indexOf(hash) < 0) {
      geohashes.push(hash);
    }
  });
  geohashes.forEach((currentHash, index, arr) => {
    const precision2 = currentHash.length;
    const parentHash = currentHash.substr(0, precision2 - 1);
    let hashNeighbourMatches = 0;
    const removeIndexes = [];
    arr.forEach((otherHash, otherIndex) => {
      if (otherHash.startsWith(parentHash)) {
        removeIndexes.push(otherIndex);
        if (otherHash.length == precision2) {
          hashNeighbourMatches++;
        }
      }
    });
    if (hashNeighbourMatches === 32) {
      for (let i = removeIndexes.length - 1; i >= 0; i--) {
        arr.splice(i, 1);
      }
      arr.splice(index, 0, parentHash);
    }
  });
  return geohashes;
}
var GeoIndex = class extends DataIndex {
  constructor(storage, path3, key, options) {
    if (key === "{key}") {
      throw new Error("Cannot create geo index on node keys");
    }
    super(storage, path3, key, options);
  }
  get type() {
    return "geo";
  }
  async handleRecordUpdate(path3, oldValue, newValue) {
    const mutated = { old: {}, new: {} };
    oldValue !== null && typeof oldValue === "object" && Object.assign(mutated.old, oldValue);
    newValue !== null && typeof newValue === "object" && Object.assign(mutated.new, newValue);
    if (mutated.old[this.key] !== null && typeof mutated.old[this.key] === "object") {
      mutated.old[this.key] = _getGeoHash(mutated.old[this.key]);
    }
    if (mutated.new[this.key] !== null && typeof mutated.new[this.key] === "object") {
      mutated.new[this.key] = _getGeoHash(mutated.new[this.key]);
    }
    super.handleRecordUpdate(path3, mutated.old, mutated.new);
  }
  build() {
    return super.build({
      addCallback: (add, obj, recordPointer, metadata) => {
        if (typeof obj !== "object") {
          this.storage.debug.warn(`GeoIndex cannot index location because value "${obj}" is not an object`);
          return;
        }
        if (typeof obj.lat !== "number" || typeof obj.long !== "number") {
          this.storage.debug.warn(`GeoIndex cannot index location because lat (${obj.lat}) or long (${obj.long}) are invalid`);
          return;
        }
        const geohash = _getGeoHash(obj);
        add(geohash, recordPointer, metadata);
        return geohash;
      },
      valueTypes: [VALUE_TYPES.OBJECT]
    });
  }
  static get validOperators() {
    return ["geo:nearby"];
  }
  get validOperators() {
    return GeoIndex.validOperators;
  }
  test(obj, op, val) {
    if (!this.validOperators.includes(op)) {
      throw new Error(`Unsupported operator "${op}"`);
    }
    if (obj == null || typeof obj !== "object") {
      return false;
    }
    const src = obj[this.key];
    if (typeof src !== "object" || typeof src.lat !== "number" || typeof src.long !== "number") {
      return false;
    }
    if (typeof val !== "object" || typeof val.lat !== "number" || typeof val.long !== "number" || typeof val.radius !== "number") {
      return false;
    }
    const isInCircle = (checkLat, checkLon, lat, lon, radiusM) => {
      const deltaLon = checkLon - lon;
      const deltaLat = checkLat - lat;
      return Math.pow(deltaLon, 2) + Math.pow(deltaLat, 2) <= Math.pow(radiusM, 2);
    };
    return isInCircle(src.lat, src.long, val.lat, val.long, val.radius);
  }
  async query(op, val, options) {
    if (op instanceof BlacklistingSearchOperator) {
      throw new Error(`Not implemented: Can't query geo index with blacklisting operator yet`);
    }
    if (options) {
      this.storage.debug.warn("Not implemented: query options for geo indexes are ignored");
    }
    if (op === "geo:nearby") {
      if (val === null || typeof val !== "object" || !("lat" in val) || !("long" in val) || !("radius" in val) || typeof val.lat !== "number" || typeof val.long !== "number" || typeof val.radius !== "number") {
        throw new Error(`geo nearby query expects an object with numeric lat, long and radius properties`);
      }
      return this.nearby(val);
    } else {
      throw new Error(`Geo indexes can only be queried with operators ${GeoIndex.validOperators.map((op2) => `"${op2}"`).join(", ")}`);
    }
  }
  async nearby(val) {
    const op = "geo:nearby";
    const cached = this.cache(op, val);
    if (cached) {
      return cached;
    }
    if (typeof val.lat !== "number" || typeof val.long !== "number" || typeof val.radius !== "number") {
      throw new Error("geo:nearby query must supply an object with properties .lat, .long and .radius");
    }
    const stats = new IndexQueryStats("geo_nearby_query", val, true);
    const precision = _getGeoRadiusPrecision(val.radius / 10);
    const targetHashes = _hashesInRadius(val.lat, val.long, val.radius, precision);
    stats.queries = targetHashes.length;
    const promises = targetHashes.map((hash) => {
      return super.query("like", `${hash}*`);
    });
    const resultSets = await Promise.all(promises);
    const results = new IndexQueryResults();
    results.filterKey = this.key;
    resultSets.forEach((set) => {
      set.forEach((match) => results.push(match));
    });
    stats.stop(results.length);
    results.stats = stats;
    this.cache(op, val, results);
    return results;
  }
};

// node_modules/acebase/dist/esm/data-index/array-index-query-hint.js
var ArrayIndexQueryHint = class extends IndexQueryHint {
  static get types() {
    return Object.freeze({
      missingValue: "missing"
    });
  }
  constructor(type, value) {
    super(type, value);
  }
  get description() {
    const val = typeof this.value === "string" ? `"${this.value}"` : this.value;
    switch (this.type) {
      case ArrayIndexQueryHint.types.missingValue: {
        return `Value ${val} does not occur in the index, you might want to remove it from your query`;
      }
      default: {
        return "Uknown hint";
      }
    }
  }
};

// node_modules/acebase/dist/esm/data-index/array-index.js
var ArrayIndex = class extends DataIndex {
  constructor(storage, path3, key, options) {
    if (key === "{key}") {
      throw new Error("Cannot create array index on node keys");
    }
    super(storage, path3, key, options);
  }
  get type() {
    return "array";
  }
  async handleRecordUpdate(path3, oldValue, newValue) {
    const tmpOld = oldValue !== null && typeof oldValue === "object" && this.key in oldValue ? oldValue[this.key] : null;
    const tmpNew = newValue !== null && typeof newValue === "object" && this.key in newValue ? newValue[this.key] : null;
    let oldEntries;
    if (tmpOld instanceof Array) {
      oldEntries = tmpOld.reduce((unique, entry) => {
        !unique.includes(entry) && unique.push(entry);
        return unique;
      }, []);
    } else {
      oldEntries = [];
    }
    if (oldEntries.length === 0) {
      oldEntries.push(void 0);
    }
    let newEntries;
    if (tmpNew instanceof Array) {
      newEntries = tmpNew.reduce((unique, entry) => {
        !unique.includes(entry) && unique.push(entry);
        return unique;
      }, []);
    } else {
      newEntries = [];
    }
    if (newEntries.length === 0) {
      newEntries.push(void 0);
    }
    const removed = oldEntries.filter((entry) => !newEntries.includes(entry));
    const added = newEntries.filter((entry) => !oldEntries.includes(entry));
    const mutated = { old: {}, new: {} };
    Object.assign(mutated.old, oldValue);
    Object.assign(mutated.new, newValue);
    const promises = [];
    removed.forEach((entry) => {
      mutated.old[this.key] = entry;
      mutated.new[this.key] = null;
      const p = super.handleRecordUpdate(path3, mutated.old, mutated.new);
      promises.push(p);
    });
    added.forEach((entry) => {
      mutated.old[this.key] = null;
      mutated.new[this.key] = entry;
      const p = super.handleRecordUpdate(path3, mutated.old, mutated.new);
      promises.push(p);
    });
    await Promise.all(promises);
  }
  build() {
    return super.build({
      addCallback: (add, array, recordPointer, metadata) => {
        if (!(array instanceof Array) || array.length === 0) {
          add(void 0, recordPointer, metadata);
          return [];
        }
        array.reduce((unique, value) => {
          !unique.includes(value) && unique.push(value);
          return unique;
        }, []).forEach((value) => {
          add(value, recordPointer, metadata);
        });
        return array;
      },
      valueTypes: [VALUE_TYPES.ARRAY]
    });
  }
  static get validOperators() {
    return ["contains", "!contains"];
  }
  get validOperators() {
    return ArrayIndex.validOperators;
  }
  async query(op, val, options) {
    if (op instanceof BlacklistingSearchOperator) {
      throw new Error(`Not implemented: Can't query array index with blacklisting operator yet`);
    }
    if (!ArrayIndex.validOperators.includes(op)) {
      throw new Error(`Array indexes can only be queried with operators ${ArrayIndex.validOperators.map((op2) => `"${op2}"`).join(", ")}`);
    }
    if (options) {
      this.storage.debug.warn("Not implemented: query options for array indexes are ignored");
    }
    const cache = this.cache(op, val);
    if (cache) {
      return cache;
    }
    const stats = new IndexQueryStats("array_index_query", val, true);
    if ((op === "contains" || op === "!contains") && val instanceof Array && val.length === 0) {
      stats.type = "array_index_scan";
      const results = await super.query(new BlacklistingSearchOperator((_) => []));
      stats.stop(results.length);
      results.filterKey = this.key;
      results.stats = stats;
      return results;
    } else if (op === "contains") {
      if (val instanceof Array) {
        const countPromises = val.map((value) => {
          const wildcardIndex = typeof value !== "string" ? -1 : ~(~value.indexOf("*") || ~value.indexOf("?"));
          const valueOp = ~wildcardIndex ? "like" : "==";
          const step = new IndexQueryStats("count", value, true);
          stats.steps.push(step);
          return this.count(valueOp, value).then((count) => {
            step.stop(count);
            return { value, count };
          });
        });
        const counts = await Promise.all(countPromises);
        counts.sort((a, b) => {
          if (a.count < b.count) {
            return -1;
          } else if (a.count > b.count) {
            return 1;
          }
          return 0;
        });
        let results;
        if (counts[0].count === 0) {
          stats.stop(0);
          this.storage.debug.log(`Value "${counts[0].value}" not found in index, 0 results for query ${op} ${val}`);
          results = new IndexQueryResults(0);
          results.filterKey = this.key;
          results.stats = stats;
          counts.forEach((c3) => {
            if (c3.count === 0) {
              const hint = new ArrayIndexQueryHint(ArrayIndexQueryHint.types.missingValue, c3.value);
              results.hints.push(hint);
            }
          });
          this.cache(op, val, results);
          return results;
        }
        const allValues = counts.map((c3) => c3.value);
        const queryValue = (value, filter2) => {
          const wildcardIndex = typeof value !== "string" ? -1 : ~(~value.indexOf("*") || ~value.indexOf("?"));
          const valueOp = ~wildcardIndex ? "like" : "==";
          return super.query(valueOp, value, { filter: filter2 }).then((results2) => {
            stats.steps.push(results2.stats);
            return results2;
          });
        };
        let valueIndex = 0;
        const nextValue = async () => {
          const value = allValues[valueIndex];
          const fr = await queryValue(value, results);
          results = fr;
          valueIndex++;
          if (results.length === 0 || valueIndex === allValues.length) {
            return;
          }
          await nextValue();
        };
        await nextValue();
        results.filterKey = this.key;
        stats.stop(results.length);
        results.stats = stats;
        delete results.entryValues;
        this.cache(op, val, results);
        return results;
      } else {
        const valueOp = typeof val === "string" && (val.includes("*") || val.includes("?")) ? "like" : "==";
        const results = await super.query(valueOp, val);
        stats.steps.push(results.stats);
        results.stats = stats;
        delete results.entryValues;
        return results;
      }
    } else if (op === "!contains") {
      const customOp = new BlacklistingSearchOperator((entry) => {
        const blacklist = val === entry.key || val instanceof Array && val.includes(entry.key);
        if (blacklist) {
          return entry.values;
        }
      });
      stats.type = "array_index_blacklist_scan";
      const results = await super.query(customOp);
      stats.stop(results.length);
      results.filterKey = this.key;
      results.stats = stats;
      this.cache(op, val, results);
      return results;
    }
  }
};

// node_modules/acebase/dist/esm/data-index/index.js
DataIndex.KnownIndexTypes = {
  normal: DataIndex,
  fulltext: FullTextIndex,
  geo: GeoIndex,
  array: ArrayIndex
};

// node_modules/acebase/dist/esm/storage/create-index.js
async function createIndex(context, path3, key, options) {
  if (!context.storage.indexes.supported) {
    throw new Error("Indexes are not supported in current environment because it requires Node.js fs");
  }
  const { ipc, debug, indexes, storage } = context;
  const rebuild = options && options.rebuild === true;
  const indexType = options && options.type || "normal";
  let includeKeys = options && options.include || [];
  if (typeof includeKeys === "string") {
    includeKeys = [includeKeys];
  }
  const existingIndex = indexes.find((index2) => index2.path === path3 && index2.key === key && index2.type === indexType && index2.includeKeys.length === includeKeys.length && index2.includeKeys.every((key2, index3) => includeKeys[index3] === key2));
  if (existingIndex && options.config) {
    existingIndex.config = options.config;
  }
  if (existingIndex && rebuild !== true) {
    debug.log(`Index on "/${path3}/*/${key}" already exists`.colorize(ColorStyle.inverse));
    return existingIndex;
  }
  if (!ipc.isMaster) {
    const result = await ipc.sendRequest({ type: "index.create", path: path3, key, options });
    if (result.ok) {
      return storage.indexes.add(result.fileName);
    }
    throw new Error(result.reason);
  }
  await pfs.mkdir(`${storage.settings.path}/${storage.name}.acebase`).catch((err) => {
    if (err.code !== "EEXIST") {
      throw err;
    }
  });
  const index = existingIndex || (() => {
    const { include, caseSensitive, textLocale, textLocaleKey } = options;
    const indexOptions = { include, caseSensitive, textLocale, textLocaleKey };
    switch (indexType) {
      case "array":
        return new ArrayIndex(storage, path3, key, { ...indexOptions });
      case "fulltext":
        return new FullTextIndex(storage, path3, key, { ...indexOptions, config: options.config });
      case "geo":
        return new GeoIndex(storage, path3, key, { ...indexOptions });
      default:
        return new DataIndex(storage, path3, key, { ...indexOptions });
    }
  })();
  if (!existingIndex) {
    indexes.push(index);
  }
  try {
    await index.build();
  } catch (err) {
    context.debug.error(`Index build on "/${path3}/*/${key}" failed: ${err.message} (code: ${err.code})`.colorize(ColorStyle.red));
    if (!existingIndex) {
      indexes.splice(indexes.indexOf(index), 1);
    }
    throw err;
  }
  ipc.sendNotification({ type: "index.created", fileName: index.fileName, path: path3, key, options });
  return index;
}

// node_modules/acebase/dist/esm/storage/index.js
var { compareValues: compareValues3, getChildValues: getChildValues3, encodeString: encodeString5, defer: defer2 } = utils_exports;
var DEBUG_MODE4 = false;
var SUPPORTED_EVENTS = ["value", "child_added", "child_changed", "child_removed", "mutated", "mutations"];
SUPPORTED_EVENTS.push(...SUPPORTED_EVENTS.map((event) => `notify_${event}`));
var NOOP = () => {
};
var SchemaValidationError = class extends Error {
  constructor(reason) {
    super(`Schema validation failed: ${reason}`);
    this.reason = reason;
  }
};
var StorageSettings = class {
  constructor(settings = {}) {
    this.maxInlineValueSize = 50;
    this.removeVoidProperties = false;
    this.path = ".";
    this.lockTimeout = 120;
    this.type = "data";
    this.readOnly = false;
    if (typeof settings.maxInlineValueSize === "number") {
      this.maxInlineValueSize = settings.maxInlineValueSize;
    }
    if (typeof settings.removeVoidProperties === "boolean") {
      this.removeVoidProperties = settings.removeVoidProperties;
    }
    if (typeof settings.path === "string") {
      this.path = settings.path;
    }
    if (this.path.endsWith("/")) {
      this.path = this.path.slice(0, -1);
    }
    if (typeof settings.lockTimeout === "number") {
      this.lockTimeout = settings.lockTimeout;
    }
    if (typeof settings.type === "string") {
      this.type = settings.type;
    }
    if (typeof settings.readOnly === "boolean") {
      this.readOnly = settings.readOnly;
    }
    if (["object", "string"].includes(typeof settings.ipc)) {
      this.ipc = settings.ipc;
    }
  }
};
var Storage = class extends SimpleEventEmitter {
  createTid() {
    return DEBUG_MODE4 ? ++this._lastTid : ID.generate();
  }
  constructor(name, settings, env2) {
    super();
    this.name = name;
    this.settings = settings;
    this._schemas = [];
    this._indexes = [];
    this._annoucedIndexes = /* @__PURE__ */ new Map();
    this.indexes = {
      get supported() {
        return pfs?.hasFileSystem;
      },
      create: (path3, key, options = {
        rebuild: false
      }) => {
        const context = { storage: this, debug: this.debug, indexes: this._indexes, ipc: this.ipc };
        return createIndex(context, path3, key, options);
      },
      get: (path3, key = null) => {
        if (path3.includes("$")) {
          const pathKeys = PathInfo.getPathKeys(path3).map((key2) => typeof key2 === "string" && key2.startsWith("$") ? "*" : key2);
          path3 = new PathInfo(pathKeys).path;
        }
        return this._indexes.filter((index) => index.path === path3 && (key === null || key === index.key));
      },
      getAll: (targetPath, options = { parentPaths: true, childPaths: true }) => {
        const pathKeys = PathInfo.getPathKeys(targetPath);
        return this._indexes.filter((index) => {
          const indexKeys = PathInfo.getPathKeys(index.path + "/*");
          if (options.parentPaths && indexKeys.every((key, i) => {
            return key === "*" || pathKeys[i] === key;
          }) && [index.key].concat(...index.includeKeys).includes(pathKeys[indexKeys.length])) {
            return true;
          } else if (indexKeys.length < pathKeys.length) {
            return false;
          } else if (!options.childPaths && indexKeys.length !== pathKeys.length) {
            return false;
          }
          return pathKeys.every((key, i) => {
            return [key, "*"].includes(indexKeys[i]);
          });
        });
      },
      list: () => {
        return this._indexes.slice();
      },
      load: async () => {
        this._indexes.splice(0);
        if (!pfs.hasFileSystem) {
          return;
        }
        let files = [];
        try {
          files = await pfs.readdir(`${this.settings.path}/${this.name}.acebase`);
        } catch (err) {
          if (err.code !== "ENOENT") {
            this.debug.error(err);
          }
        }
        const promises = [];
        files.forEach((fileName) => {
          if (!fileName.endsWith(".idx")) {
            return;
          }
          const needsStoragePrefix = this.settings.type !== "data";
          const hasStoragePrefix = /^\[[a-z]+\]-/.test(fileName);
          if (!needsStoragePrefix && !hasStoragePrefix || needsStoragePrefix && fileName.startsWith(`[${this.settings.type}]-`)) {
            const p = this.indexes.add(fileName);
            promises.push(p);
          }
        });
        await Promise.all(promises);
      },
      add: async (fileName) => {
        const existingIndex = this._indexes.find((index) => index.fileName === fileName);
        if (existingIndex) {
          return existingIndex;
        } else if (this._annoucedIndexes.has(fileName)) {
          const index = await this._annoucedIndexes.get(fileName);
          return index;
        }
        try {
          const indexPromise = DataIndex.readFromFile(this, fileName);
          this._annoucedIndexes.set(fileName, indexPromise);
          const index = await indexPromise;
          this._indexes.push(index);
          this._annoucedIndexes.delete(fileName);
          return index;
        } catch (err) {
          this.debug.error(err);
          return null;
        }
      },
      delete: async (fileName) => {
        const index = await this.indexes.remove(fileName);
        await index.delete();
        this.ipc.sendNotification({ type: "index.deleted", fileName: index.fileName, path: index.path, keys: index.key });
      },
      remove: async (fileName) => {
        const index = this._indexes.find((index2) => index2.fileName === fileName);
        if (!index) {
          throw new Error(`Index ${fileName} not found`);
        }
        this._indexes.splice(this._indexes.indexOf(index), 1);
        return index;
      },
      close: async () => {
        const promises = this.indexes.list().map((index) => index.close().catch((err) => this.debug.error(err)));
        await Promise.all(promises);
      }
    };
    this._eventSubscriptions = {};
    this.subscriptions = {
      add: (path3, type, callback) => {
        if (SUPPORTED_EVENTS.indexOf(type) < 0) {
          throw new TypeError(`Invalid event type "${type}"`);
        }
        let pathSubs = this._eventSubscriptions[path3];
        if (!pathSubs) {
          pathSubs = this._eventSubscriptions[path3] = [];
        }
        pathSubs.push({ created: Date.now(), type, callback });
        this.emit("subscribe", { path: path3, event: type, callback });
      },
      remove: (path3, type, callback) => {
        const pathSubs = this._eventSubscriptions[path3];
        if (!pathSubs) {
          return;
        }
        const next = () => pathSubs.findIndex((ps) => (type ? ps.type === type : true) && (callback ? ps.callback === callback : true));
        let i;
        while ((i = next()) >= 0) {
          pathSubs.splice(i, 1);
        }
        this.emit("unsubscribe", { path: path3, event: type, callback });
      },
      hasValueSubscribersForPath(path3) {
        const valueNeeded = this.getValueSubscribersForPath(path3);
        return !!valueNeeded;
      },
      getValueSubscribersForPath: (path3) => {
        const pathInfo = new PathInfo(path3);
        const valueSubscribers = [];
        Object.keys(this._eventSubscriptions).forEach((subscriptionPath) => {
          if (pathInfo.equals(subscriptionPath) || pathInfo.isDescendantOf(subscriptionPath)) {
            const pathSubs = this._eventSubscriptions[subscriptionPath];
            const eventPath = PathInfo.fillVariables(subscriptionPath, path3);
            pathSubs.filter((sub) => !sub.type.startsWith("notify_")).forEach((sub) => {
              let dataPath = null;
              if (sub.type === "value") {
                dataPath = eventPath;
              } else if (["mutated", "mutations"].includes(sub.type) && pathInfo.isDescendantOf(eventPath)) {
                dataPath = path3;
              } else if (sub.type === "child_changed" && path3 !== eventPath) {
                const childKey = PathInfo.getPathKeys(path3.slice(eventPath.length).replace(/^\//, ""))[0];
                dataPath = PathInfo.getChildPath(eventPath, childKey);
              } else if (["child_added", "child_removed"].includes(sub.type) && pathInfo.isChildOf(eventPath)) {
                const childKey = PathInfo.getPathKeys(path3.slice(eventPath.length).replace(/^\//, ""))[0];
                dataPath = PathInfo.getChildPath(eventPath, childKey);
              }
              if (dataPath !== null && !valueSubscribers.some((s) => s.type === sub.type && s.eventPath === eventPath)) {
                valueSubscribers.push({ type: sub.type, eventPath, dataPath, subscriptionPath });
              }
            });
          }
        });
        return valueSubscribers;
      },
      getAllSubscribersForPath: (path3) => {
        const pathInfo = PathInfo.get(path3);
        const subscribers = [];
        Object.keys(this._eventSubscriptions).forEach((subscriptionPath) => {
          if (pathInfo.isOnTrailOf(subscriptionPath)) {
            const pathSubs = this._eventSubscriptions[subscriptionPath];
            const eventPath = PathInfo.fillVariables(subscriptionPath, path3);
            pathSubs.forEach((sub) => {
              let dataPath = null;
              if (sub.type === "value" || sub.type === "notify_value") {
                dataPath = eventPath;
              } else if (["child_changed", "notify_child_changed"].includes(sub.type)) {
                const childKey = path3 === eventPath || pathInfo.isAncestorOf(eventPath) ? "*" : PathInfo.getPathKeys(path3.slice(eventPath.length).replace(/^\//, ""))[0];
                dataPath = PathInfo.getChildPath(eventPath, childKey);
              } else if (["mutated", "mutations", "notify_mutated", "notify_mutations"].includes(sub.type)) {
                dataPath = path3;
              } else if (["child_added", "child_removed", "notify_child_added", "notify_child_removed"].includes(sub.type) && (pathInfo.isChildOf(eventPath) || path3 === eventPath || pathInfo.isAncestorOf(eventPath))) {
                const childKey = path3 === eventPath || pathInfo.isAncestorOf(eventPath) ? "*" : PathInfo.getPathKeys(path3.slice(eventPath.length).replace(/^\//, ""))[0];
                dataPath = PathInfo.getChildPath(eventPath, childKey);
              }
              if (dataPath !== null && !subscribers.some((s) => s.type === sub.type && s.eventPath === eventPath && s.subscriptionPath === subscriptionPath)) {
                subscribers.push({ type: sub.type, eventPath, dataPath, subscriptionPath });
              }
            });
          }
        });
        return subscribers;
      },
      trigger: (event, path3, dataPath, oldValue, newValue, context) => {
        const pathSubscriptions = this._eventSubscriptions[path3] || [];
        pathSubscriptions.filter((sub) => sub.type === event).forEach((sub) => {
          sub.callback(null, dataPath, newValue, oldValue, context);
        });
      }
    };
    this.debug = new DebugLogger(env2.logLevel, `[${name}${typeof settings.type === "string" && settings.type !== "data" ? `:${settings.type}` : ""}]`);
    const ipcName = name + (typeof settings.type === "string" ? `_${settings.type}` : "");
    if (settings.ipc === "socket" || settings.ipc instanceof import_net2.Server) {
      const ipcSettings = { ipcName, server: settings.ipc instanceof import_net2.Server ? settings.ipc : null };
      this.ipc = new IPCSocketPeer(this, ipcSettings);
    } else if (settings.ipc) {
      if (typeof settings.ipc.port !== "number") {
        throw new Error("IPC port number must be a number");
      }
      if (!["master", "worker"].includes(settings.ipc.role)) {
        throw new Error(`IPC client role must be either "master" or "worker", not "${settings.ipc.role}"`);
      }
      const ipcSettings = Object.assign({ dbname: ipcName }, settings.ipc);
      this.ipc = new RemoteIPCPeer(this, ipcSettings);
    } else {
      this.ipc = new IPCPeer(this, ipcName);
    }
    this.ipc.once("exit", (code) => {
      if (this.indexes.supported) {
        this.indexes.close();
      }
    });
    this.nodeLocker = {
      lock: (path3, tid, write2, comment) => {
        return this.ipc.lock({ path: path3, tid, write: write2, comment });
      }
    };
    this._lastTid = 0;
  }
  async close() {
    await this.ipc.exit();
  }
  get path() {
    return `${this.settings.path}/${this.name}.acebase`;
  }
  valueFitsInline(value) {
    if (typeof value === "number" || typeof value === "boolean" || value instanceof Date) {
      return true;
    } else if (typeof value === "string") {
      if (value.length > this.settings.maxInlineValueSize) {
        return false;
      }
      const encoded = encodeString5(value);
      return encoded.length < this.settings.maxInlineValueSize;
    } else if (value instanceof PathReference) {
      if (value.path.length > this.settings.maxInlineValueSize) {
        return false;
      }
      const encoded = encodeString5(value.path);
      return encoded.length < this.settings.maxInlineValueSize;
    } else if (value instanceof ArrayBuffer) {
      return value.byteLength < this.settings.maxInlineValueSize;
    } else if (value instanceof Array) {
      return value.length === 0;
    } else if (typeof value === "object") {
      return Object.keys(value).length === 0;
    } else {
      throw new TypeError("What else is there?");
    }
  }
  _writeNode(path3, value, options) {
    throw new Error("This method must be implemented by subclass");
  }
  getUpdateImpact(path3, suppressEvents) {
    let topEventPath = path3;
    let hasValueSubscribers = false;
    const eventSubscriptions = suppressEvents ? [] : this.subscriptions.getAllSubscribersForPath(path3);
    const valueSubscribers = suppressEvents ? [] : this.subscriptions.getValueSubscribersForPath(path3);
    if (valueSubscribers.length > 0) {
      hasValueSubscribers = true;
      const eventPaths = valueSubscribers.map((sub) => {
        return { path: sub.dataPath, keys: PathInfo.getPathKeys(sub.dataPath) };
      }).sort((a, b) => {
        if (a.keys.length < b.keys.length) {
          return -1;
        } else if (a.keys.length > b.keys.length) {
          return 1;
        }
        return 0;
      });
      const first = eventPaths[0];
      topEventPath = first.path;
      if (valueSubscribers.filter((sub) => sub.dataPath === topEventPath).every((sub) => sub.type === "mutated" || sub.type.startsWith("notify_"))) {
        hasValueSubscribers = false;
      }
      topEventPath = PathInfo.fillVariables(topEventPath, path3);
    }
    const indexes = this.indexes.getAll(path3, { childPaths: true, parentPaths: true }).map((index) => ({ index, keys: PathInfo.getPathKeys(index.path) })).sort((a, b) => {
      if (a.keys.length < b.keys.length) {
        return -1;
      } else if (a.keys.length > b.keys.length) {
        return 1;
      }
      return 0;
    }).map((obj) => obj.index);
    const keysFilter = [];
    if (indexes.length > 0) {
      indexes.sort((a, b) => {
        if (typeof a._pathKeys === "undefined") {
          a._pathKeys = PathInfo.getPathKeys(a.path);
        }
        if (typeof b._pathKeys === "undefined") {
          b._pathKeys = PathInfo.getPathKeys(b.path);
        }
        if (a._pathKeys.length < b._pathKeys.length) {
          return -1;
        } else if (a._pathKeys.length > b._pathKeys.length) {
          return 1;
        }
        return 0;
      });
      const topIndex = indexes[0];
      const topIndexPath = topIndex.path === path3 ? path3 : PathInfo.fillVariables(`${topIndex.path}/*`, path3);
      if (topIndexPath.length < topEventPath.length) {
        topEventPath = topIndexPath;
        indexes.filter((index) => index.path === topIndex.path).forEach((index) => {
          const keys = [index.key].concat(index.includeKeys);
          keys.forEach((key) => !keysFilter.includes(key) && keysFilter.push(key));
        });
      }
    }
    return { topEventPath, eventSubscriptions, valueSubscribers, hasValueSubscribers, indexes, keysFilter };
  }
  async _writeNodeWithTracking(path3, value, options = {
    merge: false,
    waitForIndexUpdates: true,
    suppress_events: false,
    context: null,
    impact: null
  }) {
    options = options || {};
    if (!options.tid && !options.transaction) {
      throw new Error("_writeNodeWithTracking MUST be executed with a tid OR transaction!");
    }
    options.merge = options.merge === true;
    const validation = this.validateSchema(path3, value, { updates: options.merge });
    if (!validation.ok) {
      throw new SchemaValidationError(validation.reason);
    }
    const tid = options.tid;
    const transaction = options.transaction;
    let topEventData = null;
    const updateImpact = options.impact ? options.impact : this.getUpdateImpact(path3, options.suppress_events);
    const { topEventPath, eventSubscriptions, hasValueSubscribers, indexes } = updateImpact;
    let { keysFilter } = updateImpact;
    const writeNode = () => {
      if (typeof options._customWriteFunction === "function") {
        return options._customWriteFunction();
      }
      if (topEventData) {
        const pathKeys = PathInfo.getPathKeys(path3);
        const eventPathKeys = PathInfo.getPathKeys(topEventPath);
        const trailKeys = pathKeys.slice(eventPathKeys.length);
        let currentValue2 = topEventData;
        while (trailKeys.length > 0 && currentValue2 !== null) {
          const childKey = trailKeys.shift();
          currentValue2 = typeof currentValue2 === "object" && childKey in currentValue2 ? currentValue2[childKey] : null;
        }
        options.currentValue = currentValue2;
      }
      return this._writeNode(path3, value, options);
    };
    const transactionLoggingEnabled = this.settings.transactions && this.settings.transactions.log === true;
    if (eventSubscriptions.length === 0 && indexes.length === 0 && !transactionLoggingEnabled) {
      return writeNode();
    }
    if (!hasValueSubscribers && options.merge === true && keysFilter.length === 0) {
      keysFilter = Object.keys(value);
      if (topEventPath !== path3) {
        const trailPath = path3.slice(topEventPath.length);
        keysFilter = keysFilter.map((key) => `${trailPath}/${key}`);
      }
    }
    const eventNodeInfo = await this.getNodeInfo(topEventPath, { transaction, tid });
    let currentValue = null;
    if (eventNodeInfo.exists) {
      const valueOptions = { transaction, tid };
      if (keysFilter.length > 0) {
        valueOptions.include = keysFilter;
      }
      if (topEventPath === "" && typeof valueOptions.include === "undefined") {
        this.debug.warn('WARNING: One or more value event listeners on the root node are causing the entire database value to be read to facilitate change tracking. Using "value", "notify_value", "child_changed" and "notify_child_changed" events on the root node are a bad practice because of the significant performance impact. Use "mutated" or "mutations" events instead');
      }
      const node = await this.getNode(topEventPath, valueOptions);
      currentValue = node.value;
    }
    topEventData = currentValue;
    const result = await writeNode() || {};
    let newTopEventData, modifiedData;
    if (path3 === topEventPath) {
      if (options.merge) {
        if (topEventData === null) {
          newTopEventData = value instanceof Array ? [] : {};
        } else {
          newTopEventData = topEventData instanceof Array ? [] : {};
          Object.keys(topEventData).forEach((key) => {
            newTopEventData[key] = topEventData[key];
          });
        }
      } else {
        newTopEventData = value;
      }
      modifiedData = newTopEventData;
    } else {
      const trailPath = path3.slice(topEventPath.length).replace(/^\//, "");
      const trailKeys = PathInfo.getPathKeys(trailPath);
      if (topEventData === null) {
        newTopEventData = typeof trailKeys[0] === "number" ? [] : {};
      } else {
        newTopEventData = topEventData instanceof Array ? [] : {};
        Object.keys(topEventData).forEach((key) => {
          newTopEventData[key] = topEventData[key];
        });
      }
      modifiedData = newTopEventData;
      while (trailKeys.length > 0) {
        const childKey = trailKeys.shift();
        if (!options.merge && trailKeys.length === 0) {
          modifiedData[childKey] = value;
        } else {
          const original = modifiedData[childKey];
          const shallowCopy = typeof childKey === "number" ? [...original] : { ...original };
          modifiedData[childKey] = shallowCopy;
        }
        modifiedData = modifiedData[childKey];
      }
    }
    if (options.merge) {
      Object.keys(value).forEach((key) => {
        modifiedData[key] = value[key];
      });
    }
    const dataChanges = compareValues3(topEventData, newTopEventData);
    if (dataChanges === "identical") {
      result.mutations = [];
      return result;
    }
    function removeNulls(obj) {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      Object.keys(obj).forEach((prop) => {
        const val = obj[prop];
        if (val === null) {
          delete obj[prop];
          if (obj instanceof Array) {
            obj.length--;
          }
        }
        if (typeof val === "object") {
          removeNulls(val);
        }
      });
    }
    removeNulls(newTopEventData);
    const indexUpdates = [];
    indexes.map((index) => ({ index, keys: PathInfo.getPathKeys(index.path) })).sort((a, b) => {
      if (a.keys.length < b.keys.length) {
        return 1;
      } else if (a.keys.length > b.keys.length) {
        return -1;
      }
      return 0;
    }).forEach(({ index }) => {
      const pathKeys = PathInfo.getPathKeys(topEventPath);
      const indexPathKeys = PathInfo.getPathKeys(index.path + "/*");
      const trailKeys = indexPathKeys.slice(pathKeys.length);
      const oldValue = topEventData;
      const newValue = newTopEventData;
      if (trailKeys.length === 0) {
        assert(pathKeys.length === indexPathKeys.length, "check logic");
        const p = this.ipc.isMaster ? index.handleRecordUpdate(topEventPath, oldValue, newValue) : this.ipc.sendRequest({ type: "index.update", fileName: index.fileName, path: topEventPath, oldValue, newValue });
        indexUpdates.push(p);
        return;
      }
      const getAllIndexUpdates = (path4, oldValue2, newValue2) => {
        if (oldValue2 === null && newValue2 === null) {
          return [];
        }
        const pathKeys2 = PathInfo.getPathKeys(path4);
        const indexPathKeys2 = PathInfo.getPathKeys(index.path + "/*");
        const trailKeys2 = indexPathKeys2.slice(pathKeys2.length);
        if (trailKeys2.length === 0) {
          assert(pathKeys2.length === indexPathKeys2.length, "check logic");
          return [{ path: path4, oldValue: oldValue2, newValue: newValue2 }];
        }
        let results2 = [];
        let trailPath = "";
        while (trailKeys2.length > 0) {
          const subKey = trailKeys2.shift();
          if (typeof subKey === "string" && (subKey === "*" || subKey.startsWith("$"))) {
            const allKeys = oldValue2 === null ? [] : Object.keys(oldValue2);
            newValue2 !== null && Object.keys(newValue2).forEach((key) => {
              if (allKeys.indexOf(key) < 0) {
                allKeys.push(key);
              }
            });
            allKeys.forEach((key) => {
              const childPath = PathInfo.getChildPath(trailPath, key);
              const childValues = getChildValues3(key, oldValue2, newValue2);
              const subTrailPath = PathInfo.getChildPath(path4, childPath);
              const childResults = getAllIndexUpdates(subTrailPath, childValues.oldValue, childValues.newValue);
              results2 = results2.concat(childResults);
            });
            break;
          } else {
            const values = getChildValues3(subKey, oldValue2, newValue2);
            oldValue2 = values.oldValue;
            newValue2 = values.newValue;
            if (oldValue2 === null && newValue2 === null) {
              break;
            }
            trailPath = PathInfo.getChildPath(trailPath, subKey);
          }
        }
        return results2;
      };
      const results = getAllIndexUpdates(topEventPath, oldValue, newValue);
      results.forEach((result2) => {
        const p = this.ipc.isMaster ? index.handleRecordUpdate(result2.path, result2.oldValue, result2.newValue) : this.ipc.sendRequest({ type: "index.update", fileName: index.fileName, path: result2.path, oldValue: result2.oldValue, newValue: result2.newValue });
        indexUpdates.push(p);
      });
    });
    const callSubscriberWithValues = (sub, oldValue, newValue, variables = []) => {
      let trigger = true;
      let type = sub.type;
      if (type.startsWith("notify_")) {
        type = type.slice("notify_".length);
      }
      if (type === "mutated") {
        return;
      } else if (type === "child_changed" && (oldValue === null || newValue === null)) {
        trigger = false;
      } else if (type === "value" || type === "child_changed") {
        const changes = compareValues3(oldValue, newValue);
        trigger = changes !== "identical";
      } else if (type === "child_added") {
        trigger = oldValue === null && newValue !== null;
      } else if (type === "child_removed") {
        trigger = oldValue !== null && newValue === null;
      }
      if (!trigger) {
        return;
      }
      const pathKeys = PathInfo.getPathKeys(sub.dataPath);
      variables.forEach((variable) => {
        const index = pathKeys.indexOf(variable.name);
        assert(index >= 0, `Variable "${variable.name}" not found in subscription dataPath "${sub.dataPath}"`);
        pathKeys[index] = variable.value;
      });
      const dataPath = pathKeys.reduce((path4, key) => PathInfo.getChildPath(path4, key), "");
      this.subscriptions.trigger(sub.type, sub.subscriptionPath, dataPath, oldValue, newValue, options.context);
    };
    const prepareMutationEvents = (currentPath, oldValue, newValue, compareResult) => {
      const batch = [];
      const result2 = compareResult || compareValues3(oldValue, newValue);
      if (result2 === "identical") {
        return batch;
      } else if (typeof result2 === "string") {
        batch.push({ path: currentPath, oldValue, newValue });
      } else {
        result2.changed.forEach((info) => {
          const childPath = PathInfo.getChildPath(currentPath, info.key);
          const childValues = getChildValues3(info.key, oldValue, newValue);
          const childBatch = prepareMutationEvents(childPath, childValues.oldValue, childValues.newValue, info.change);
          batch.push(...childBatch);
        });
        result2.added.forEach((key) => {
          const childPath = PathInfo.getChildPath(currentPath, key);
          batch.push({ path: childPath, oldValue: null, newValue: newValue[key] });
        });
        if (oldValue instanceof Array && newValue instanceof Array) {
          result2.removed.sort((a, b) => a < b ? 1 : -1);
        }
        result2.removed.forEach((key) => {
          const childPath = PathInfo.getChildPath(currentPath, key);
          batch.push({ path: childPath, oldValue: oldValue[key], newValue: null });
        });
      }
      return batch;
    };
    if (transactionLoggingEnabled && this.settings.type !== "transaction") {
      result.mutations = (() => {
        const trailPath = path3.slice(topEventPath.length).replace(/^\//, "");
        const trailKeys = PathInfo.getPathKeys(trailPath);
        let oldValue = topEventData, newValue = newTopEventData;
        while (trailKeys.length > 0) {
          const key = trailKeys.shift();
          ({ oldValue, newValue } = getChildValues3(key, oldValue, newValue));
        }
        const compareResults = compareValues3(oldValue, newValue);
        const batch = prepareMutationEvents(path3, oldValue, newValue, compareResults);
        const mutations = batch.map((m) => ({ target: PathInfo.getPathKeys(m.path.slice(path3.length)), prev: m.oldValue, val: m.newValue }));
        return mutations;
      })();
    }
    const triggerAllEvents = () => {
      eventSubscriptions.filter((sub) => !["mutated", "mutations", "notify_mutated", "notify_mutations"].includes(sub.type)).map((sub) => {
        const keys = PathInfo.getPathKeys(sub.dataPath);
        return {
          sub,
          keys
        };
      }).sort((a, b) => {
        if (a.keys.length < b.keys.length) {
          return 1;
        } else if (a.keys.length > b.keys.length) {
          return -1;
        }
        return 0;
      }).forEach(({ sub }) => {
        const process9 = (currentPath, oldValue, newValue, variables = []) => {
          const trailPath = sub.dataPath.slice(currentPath.length).replace(/^\//, "");
          const trailKeys = PathInfo.getPathKeys(trailPath);
          while (trailKeys.length > 0) {
            const subKey = trailKeys.shift();
            if (typeof subKey === "string" && (subKey === "*" || subKey[0] === "$")) {
              const allKeys = oldValue === null ? [] : Object.keys(oldValue).map((key) => oldValue instanceof Array ? parseInt(key) : key);
              newValue !== null && Object.keys(newValue).forEach((key) => {
                const keyOrIndex = newValue instanceof Array ? parseInt(key) : key;
                !allKeys.includes(keyOrIndex) && allKeys.push(key);
              });
              allKeys.forEach((key) => {
                const childValues = getChildValues3(key, oldValue, newValue);
                const vars = variables.concat({ name: subKey, value: key });
                if (trailKeys.length === 0) {
                  callSubscriberWithValues(sub, childValues.oldValue, childValues.newValue, vars);
                } else {
                  process9(PathInfo.getChildPath(currentPath, subKey), childValues.oldValue, childValues.newValue, vars);
                }
              });
              return;
            } else {
              currentPath = PathInfo.getChildPath(currentPath, subKey);
              const childValues = getChildValues3(subKey, oldValue, newValue);
              oldValue = childValues.oldValue;
              newValue = childValues.newValue;
            }
          }
          callSubscriberWithValues(sub, oldValue, newValue, variables);
        };
        if (sub.type.startsWith("notify_") && PathInfo.get(sub.eventPath).isAncestorOf(topEventPath)) {
          const isOnParentPath = PathInfo.get(sub.eventPath).isParentOf(topEventPath);
          const trigger = sub.type === "notify_value" || sub.type === "notify_child_changed" && (!isOnParentPath || !["added", "removed"].includes(dataChanges)) || sub.type === "notify_child_removed" && dataChanges === "removed" && isOnParentPath || sub.type === "notify_child_added" && dataChanges === "added" && isOnParentPath;
          trigger && this.subscriptions.trigger(sub.type, sub.subscriptionPath, sub.dataPath, null, null, options.context);
        } else {
          process9(topEventPath, topEventData, newTopEventData);
        }
      });
      const mutationEvents = eventSubscriptions.filter((sub) => ["mutated", "mutations", "notify_mutated", "notify_mutations"].includes(sub.type));
      mutationEvents.forEach((sub) => {
        let currentPath = topEventPath;
        const trailKeys = PathInfo.getPathKeys(sub.eventPath).slice(PathInfo.getPathKeys(currentPath).length);
        const events = [];
        let oldValue = topEventData, newValue = newTopEventData;
        const processNextTrailKey = (target, currentTarget, oldValue2, newValue2, vars) => {
          if (target.length === 0) {
            return events.push({ target: currentTarget, oldValue: oldValue2, newValue: newValue2, vars });
          }
          const subKey = target[0];
          const keys = /* @__PURE__ */ new Set();
          const isWildcardKey = typeof subKey === "string" && (subKey === "*" || subKey.startsWith("$"));
          if (isWildcardKey) {
            if (oldValue2 !== null && typeof oldValue2 === "object") {
              Object.keys(oldValue2).forEach((key) => keys.add(key));
            }
            if (newValue2 !== null && typeof newValue2 === "object") {
              Object.keys(newValue2).forEach((key) => keys.add(key));
            }
          } else {
            keys.add(subKey);
          }
          for (const key of keys) {
            const childValues = getChildValues3(key, oldValue2, newValue2);
            oldValue2 = childValues.oldValue;
            newValue2 = childValues.newValue;
            processNextTrailKey(target.slice(1), currentTarget.concat(key), oldValue2, newValue2, isWildcardKey ? vars.concat({ name: subKey, value: key }) : vars);
          }
        };
        processNextTrailKey(trailKeys, [], oldValue, newValue, []);
        for (const event of events) {
          const targetPath = PathInfo.get(currentPath).child(event.target).path;
          const batch = prepareMutationEvents(targetPath, event.oldValue, event.newValue);
          if (batch.length === 0) {
            continue;
          }
          const isNotifyEvent = sub.type.startsWith("notify_");
          if (["mutated", "notify_mutated"].includes(sub.type)) {
            batch.forEach((mutation, index) => {
              const context = options.context;
              const prevVal = isNotifyEvent ? null : mutation.oldValue;
              const newVal = isNotifyEvent ? null : mutation.newValue;
              this.subscriptions.trigger(sub.type, sub.subscriptionPath, mutation.path, prevVal, newVal, context);
            });
          } else if (["mutations", "notify_mutations"].includes(sub.type)) {
            const subscriptionPathKeys = PathInfo.getPathKeys(sub.subscriptionPath);
            const values = isNotifyEvent ? null : batch.map((m) => ({ target: PathInfo.getPathKeys(m.path).slice(subscriptionPathKeys.length), prev: m.oldValue, val: m.newValue }));
            const dataPath = PathInfo.get(PathInfo.getPathKeys(targetPath).slice(0, subscriptionPathKeys.length)).path;
            this.subscriptions.trigger(sub.type, sub.subscriptionPath, dataPath, null, values, options.context);
          }
        }
      });
    };
    if (options.waitForIndexUpdates === false) {
      indexUpdates.splice(0);
    }
    await Promise.all(indexUpdates);
    defer2(triggerAllEvents);
    return result;
  }
  getChildren(path3, options) {
    throw new Error("This method must be implemented by subclass");
  }
  async getNodeValue(path3, options = {}) {
    const node = await this.getNode(path3, options);
    return node.value;
  }
  getNode(path3, options) {
    throw new Error("This method must be implemented by subclass");
  }
  getNodeInfo(path3, options) {
    throw new Error("This method must be implemented by subclass");
  }
  setNode(path3, value, options) {
    throw new Error("This method must be implemented by subclass");
  }
  updateNode(path3, updates, options) {
    throw new Error("This method must be implemented by subclass");
  }
  async transactNode(path3, callback, options = { no_lock: false, suppress_events: false, context: null }) {
    const useFakeLock = options && options.no_lock === true;
    const tid = this.createTid();
    const lock = useFakeLock ? { tid, release: NOOP } : await this.nodeLocker.lock(path3, tid, true, "transactNode");
    try {
      let changed = false;
      const changeCallback = () => {
        changed = true;
      };
      if (useFakeLock) {
        this.subscriptions.add(path3, "notify_value", changeCallback);
      }
      const node = await this.getNode(path3, { tid });
      const checkRevision = node.revision;
      let newValue;
      try {
        newValue = callback(node.value);
        if (newValue instanceof Promise) {
          newValue = await newValue.catch((err) => {
            this.debug.error(`Error in transaction callback: ${err.message}`);
          });
        }
      } catch (err) {
        this.debug.error(`Error in transaction callback: ${err.message}`);
      }
      if (typeof newValue === "undefined") {
        return;
      }
      if (useFakeLock) {
        this.subscriptions.remove(path3, "notify_value", changeCallback);
      }
      if (changed) {
        throw new NodeRevisionError("Node changed");
      }
      const cursor = await this.setNode(path3, newValue, { assert_revision: checkRevision, tid: lock.tid, suppress_events: options.suppress_events, context: options.context });
      return cursor;
    } catch (err) {
      if (err instanceof NodeRevisionError) {
        console.warn(`node value changed, running again. Error: ${err.message}`);
        return this.transactNode(path3, callback, options);
      } else {
        throw err;
      }
    } finally {
      lock.release();
    }
  }
  async matchNode(path3, criteria, options) {
    const tid = options?.tid ?? ID.generate();
    const checkNode = async (path4, criteria2) => {
      if (criteria2.length === 0) {
        return Promise.resolve(true);
      }
      const criteriaKeys = criteria2.reduce((keys, cr) => {
        let key = cr.key;
        if (typeof key === "string" && key.includes("/")) {
          key = key.slice(0, key.indexOf("/"));
        }
        if (keys.indexOf(key) < 0) {
          keys.push(key);
        }
        return keys;
      }, []);
      const unseenKeys = criteriaKeys.slice();
      let isMatch = true;
      const delayedMatchPromises = [];
      try {
        await this.getChildren(path4, { tid, keyFilter: criteriaKeys }).next((childInfo) => {
          const keyOrIndex = childInfo.key ?? childInfo.index;
          unseenKeys.includes(keyOrIndex) && unseenKeys.splice(unseenKeys.indexOf(childInfo.key), 1);
          const keyCriteria = criteria2.filter((cr) => cr.key === keyOrIndex).map((cr) => ({ op: cr.op, compare: cr.compare }));
          const keyResult = keyCriteria.length > 0 ? checkChild(childInfo, keyCriteria) : { isMatch: true, promises: [] };
          isMatch = keyResult.isMatch;
          if (isMatch) {
            delayedMatchPromises.push(...keyResult.promises);
            const childCriteria = criteria2.filter((cr) => typeof cr.key === "string" && cr.key.startsWith(`${typeof keyOrIndex === "number" ? `[${keyOrIndex}]` : keyOrIndex}/`)).map((cr) => {
              const key = cr.key.slice(cr.key.indexOf("/") + 1);
              return { key, op: cr.op, compare: cr.compare };
            });
            if (childCriteria.length > 0) {
              const childPath = PathInfo.getChildPath(path4, childInfo.key);
              const childPromise = checkNode(childPath, childCriteria).then((isMatch2) => ({ isMatch: isMatch2 }));
              delayedMatchPromises.push(childPromise);
            }
          }
          if (!isMatch || unseenKeys.length === 0) {
            return false;
          }
        });
        if (isMatch) {
          const results = await Promise.all(delayedMatchPromises);
          isMatch = results.every((res) => res.isMatch);
        }
        if (!isMatch) {
          return false;
        }
        isMatch = unseenKeys.every((keyOrIndex) => {
          const childInfo = new NodeInfo({
            ...typeof keyOrIndex === "number" && { index: keyOrIndex },
            ...typeof keyOrIndex === "string" && { key: keyOrIndex },
            exists: false
          });
          const childCriteria = criteria2.filter((cr) => typeof cr.key === "string" && cr.key.startsWith(`${typeof keyOrIndex === "number" ? `[${keyOrIndex}]` : keyOrIndex}/`)).map((cr) => ({ op: cr.op, compare: cr.compare }));
          if (childCriteria.length > 0 && !checkChild(childInfo, childCriteria).isMatch) {
            return false;
          }
          const keyCriteria = criteria2.filter((cr) => cr.key === keyOrIndex).map((cr) => ({ op: cr.op, compare: cr.compare }));
          if (keyCriteria.length === 0) {
            return true;
          }
          const result = checkChild(childInfo, keyCriteria);
          return result.isMatch;
        });
        return isMatch;
      } catch (err) {
        this.debug.error(`Error matching on "${path4}": `, err);
        throw err;
      }
    };
    const checkChild = (child, criteria2) => {
      const promises = [];
      const isMatch = criteria2.every((f) => {
        let proceed = true;
        if (f.op === "!exists" || f.op === "==" && (typeof f.compare === "undefined" || f.compare === null)) {
          proceed = !child.exists;
        } else if (f.op === "exists" || f.op === "!=" && (typeof f.compare === "undefined" || f.compare === null)) {
          proceed = child.exists;
        } else if ((f.op === "contains" || f.op === "!contains") && f.compare instanceof Array && f.compare.length === 0) {
          proceed = true;
        } else if (!child.exists) {
          proceed = false;
        } else {
          if (child.address) {
            if (child.valueType === VALUE_TYPES.OBJECT && ["has", "!has"].indexOf(f.op) >= 0) {
              const op = f.op === "has" ? "exists" : "!exists";
              const p = checkNode(child.path, [{ key: f.compare, op }]).then((isMatch2) => {
                return { key: child.key, isMatch: isMatch2 };
              });
              promises.push(p);
              proceed = true;
            } else if (child.valueType === VALUE_TYPES.ARRAY && ["contains", "!contains"].indexOf(f.op) >= 0) {
              const p = this.getNode(child.path, { tid }).then(({ value: arr }) => {
                const isMatch2 = f.op === "contains" ? f.compare instanceof Array ? f.compare.every((val) => arr.includes(val)) : arr.includes(f.compare) : f.compare instanceof Array ? !f.compare.some((val) => arr.includes(val)) : !arr.includes(f.compare);
                return { key: child.key, isMatch: isMatch2 };
              });
              promises.push(p);
              proceed = true;
            } else if (child.valueType === VALUE_TYPES.STRING) {
              const p = this.getNode(child.path, { tid }).then((node) => {
                return { key: child.key, isMatch: this.test(node.value, f.op, f.compare) };
              });
              promises.push(p);
              proceed = true;
            } else {
              proceed = false;
            }
          } else if (child.type === VALUE_TYPES.OBJECT && ["has", "!has"].indexOf(f.op) >= 0) {
            const has = f.compare in child.value;
            proceed = has && f.op === "has" || !has && f.op === "!has";
          } else if (child.type === VALUE_TYPES.ARRAY && ["contains", "!contains"].indexOf(f.op) >= 0) {
            const contains = child.value.indexOf(f.compare) >= 0;
            proceed = contains && f.op === "contains" || !contains && f.op === "!contains";
          } else {
            let ret = this.test(child.value, f.op, f.compare);
            if (ret instanceof Promise) {
              promises.push(ret);
              ret = true;
            }
            proceed = ret;
          }
        }
        return proceed;
      });
      return { isMatch, promises };
    };
    return checkNode(path3, criteria);
  }
  test(val, op, compare) {
    if (op === "<") {
      return val < compare;
    }
    if (op === "<=") {
      return val <= compare;
    }
    if (op === "==") {
      return val === compare;
    }
    if (op === "!=") {
      return val !== compare;
    }
    if (op === ">") {
      return val > compare;
    }
    if (op === ">=") {
      return val >= compare;
    }
    if (op === "in") {
      return compare.indexOf(val) >= 0;
    }
    if (op === "!in") {
      return compare.indexOf(val) < 0;
    }
    if (op === "like" || op === "!like") {
      const pattern = "^" + compare.replace(/[-[\]{}()+.,\\^$|#\s]/g, "\\$&").replace(/\?/g, ".").replace(/\*/g, ".*?") + "$";
      const re = new RegExp(pattern, "i");
      const isMatch = re.test(val.toString());
      return op === "like" ? isMatch : !isMatch;
    }
    if (op === "matches") {
      return compare.test(val.toString());
    }
    if (op === "!matches") {
      return !compare.test(val.toString());
    }
    if (op === "between") {
      return val >= compare[0] && val <= compare[1];
    }
    if (op === "!between") {
      return val < compare[0] || val > compare[1];
    }
    if (op === "has" || op === "!has") {
      const has = typeof val === "object" && compare in val;
      return op === "has" ? has : !has;
    }
    if (op === "contains" || op === "!contains") {
      const includes = typeof val === "object" && val instanceof Array && val.includes(compare);
      return op === "contains" ? includes : !includes;
    }
    return false;
  }
  async exportNode(path3, writeFn, options = { format: "json", type_safe: true }) {
    if (options?.format !== "json") {
      throw new Error("Only json output is currently supported");
    }
    const write2 = typeof writeFn !== "function" ? writeFn.write.bind(writeFn) : writeFn;
    const stringifyValue = (type, val) => {
      const escape = (str) => str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(
        /[\u0000-\u001f]/g,
        (ch) => `\\u${ch.charCodeAt(0).toString(16).padStart(4, "0")}`
      );
      if (type === VALUE_TYPES.DATETIME) {
        val = `"${val.toISOString()}"`;
        if (options.type_safe) {
          val = `{".type":"date",".val":${val}}`;
        }
      } else if (type === VALUE_TYPES.STRING) {
        val = `"${escape(val)}"`;
      } else if (type === VALUE_TYPES.ARRAY) {
        val = "[]";
      } else if (type === VALUE_TYPES.OBJECT) {
        val = "{}";
      } else if (type === VALUE_TYPES.BINARY) {
        val = `"${escape(ascii85.encode(val))}"`;
        if (options.type_safe) {
          val = `{".type":"binary",".val":${val}}`;
        }
      } else if (type === VALUE_TYPES.REFERENCE) {
        val = `"${val.path}"`;
        if (options.type_safe) {
          val = `{".type":"reference",".val":${val}}`;
        }
      } else if (type === VALUE_TYPES.BIGINT) {
        val = `"${val}"`;
        if (options.type_safe) {
          val = `{".type":"bigint",".val":${val}}`;
        }
      }
      return val;
    };
    let objStart = "", objEnd = "";
    const nodeInfo = await this.getNodeInfo(path3);
    if (!nodeInfo.exists) {
      return write2("null");
    } else if (nodeInfo.type === VALUE_TYPES.OBJECT) {
      objStart = "{";
      objEnd = "}";
    } else if (nodeInfo.type === VALUE_TYPES.ARRAY) {
      objStart = "[";
      objEnd = "]";
    } else {
      const node = await this.getNode(path3);
      const val = stringifyValue(nodeInfo.type, node.value);
      return write2(val);
    }
    if (objStart) {
      const p = write2(objStart);
      if (p instanceof Promise) {
        await p;
      }
    }
    let output = "", outputCount = 0;
    const pending = [];
    await this.getChildren(path3).next((childInfo) => {
      if (childInfo.address) {
        pending.push(childInfo);
      } else {
        if (outputCount++ > 0) {
          output += ",";
        }
        if (typeof childInfo.key === "string") {
          output += `"${childInfo.key}":`;
        }
        output += stringifyValue(childInfo.type, childInfo.value);
      }
    });
    if (output) {
      const p = write2(output);
      if (p instanceof Promise) {
        await p;
      }
    }
    while (pending.length > 0) {
      const childInfo = pending.shift();
      let output2 = outputCount++ > 0 ? "," : "";
      const key = typeof childInfo.index === "number" ? childInfo.index : childInfo.key;
      if (typeof key === "string") {
        output2 += `"${key}":`;
      }
      if (output2) {
        const p = write2(output2);
        if (p instanceof Promise) {
          await p;
        }
      }
      await this.exportNode(PathInfo.getChildPath(path3, key), write2, options);
    }
    if (objEnd) {
      const p = write2(objEnd);
      if (p instanceof Promise) {
        await p;
      }
    }
  }
  async importNode(path3, read2, options = { format: "json", method: "set" }) {
    const chunkSize = 256 * 1024;
    const maxQueueBytes = 1024 * 1024;
    const state = {
      data: "",
      index: 0,
      offset: 0,
      queue: [],
      queueStartByte: 0,
      timesFlushed: 0,
      get processedBytes() {
        return this.offset + this.index;
      }
    };
    const readNextChunk = async (append2 = false) => {
      let data = await read2(chunkSize);
      if (data === null) {
        if (state.data) {
          throw new Error(`Unexpected EOF at index ${state.offset + state.data.length}`);
        } else {
          throw new Error("Unable to read data from stream");
        }
      } else if (typeof data === "object") {
        data = utils_exports.decodeString(data);
      }
      if (append2) {
        state.data += data;
      } else {
        state.offset += state.data.length;
        state.data = data;
        state.index = 0;
      }
    };
    const readBytes = async (length3) => {
      let str = "";
      if (state.index + length3 >= state.data.length) {
        str = state.data.slice(state.index);
        length3 -= str.length;
        await readNextChunk();
      }
      str += state.data.slice(state.index, state.index + length3);
      state.index += length3;
      return str;
    };
    const assertBytes = async (length3) => {
      if (state.index + length3 > state.data.length) {
        await readNextChunk(true);
      }
      if (state.index + length3 > state.data.length) {
        throw new Error("Not enough data available from stream");
      }
    };
    const consumeToken = async (token) => {
      const str = await readBytes(token.length);
      if (str !== token) {
        throw new Error(`Unexpected character "${str[0]}" at index ${state.offset + state.index}, expected "${token}"`);
      }
    };
    const consumeSpaces = async () => {
      const spaces = [" ", "	", "\r", "\n"];
      while (true) {
        if (state.index >= state.data.length) {
          await readNextChunk();
        }
        if (spaces.includes(state.data[state.index])) {
          state.index++;
        } else {
          break;
        }
      }
    };
    const peekBytes = async (length3) => {
      await assertBytes(length3);
      const index = state.index;
      return state.data.slice(index, index + length3);
    };
    const peekValueType = async () => {
      await consumeSpaces();
      const ch = await peekBytes(1);
      switch (ch) {
        case '"':
          return "string";
        case "{":
          return "object";
        case "[":
          return "array";
        case "n":
          return "null";
        case "u":
          return "undefined";
        case "t":
        case "f":
          return "boolean";
        default: {
          if (ch === "-" || ch >= "0" && ch <= "9") {
            return "number";
          }
          throw new Error(`Unknown value at index ${state.offset + state.index}`);
        }
      }
    };
    const readString = async () => {
      await consumeToken('"');
      let str = "";
      let i = state.index;
      while (state.data[i] !== '"' || state.data[i - 1] === "\\") {
        i++;
        if (i >= state.data.length) {
          str += state.data.slice(state.index);
          await readNextChunk();
          i = 0;
        }
      }
      str += state.data.slice(state.index, i);
      state.index = i + 1;
      return unescape2(str);
    };
    const readBoolean = async () => {
      if (state.data[state.index] === "t") {
        await consumeToken("true");
      } else if (state.data[state.index] === "f") {
        await consumeToken("false");
      }
      throw new Error(`Expected true or false at index ${state.offset + state.index}`);
    };
    const readNumber = async () => {
      let str = "";
      let i = state.index;
      const nrChars = ["-", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "e", "b", "f", "x", "o", "n"];
      while (nrChars.includes(state.data[i])) {
        i++;
        if (i >= state.data.length) {
          str += state.data.slice(state.index);
          await readNextChunk();
          i = 0;
        }
      }
      str += state.data.slice(state.index, i);
      state.index = i;
      const nr = str.endsWith("n") ? BigInt(str.slice(0, -1)) : str.includes(".") ? parseFloat(str) : parseInt(str);
      return nr;
    };
    const readValue = async () => {
      await consumeSpaces();
      const type = await peekValueType();
      const value = await (() => {
        switch (type) {
          case "string":
            return readString();
          case "object":
            return {};
          case "array":
            return [];
          case "number":
            return readNumber();
          case "null":
            return null;
          case "undefined":
            return void 0;
          case "boolean":
            return readBoolean();
        }
      })();
      return { type, value };
    };
    const unescape2 = (str) => str.replace(/\\n/g, "\n").replace(/\\"/g, '"');
    const getTypeSafeValue = (path4, obj) => {
      const type = obj[".type"];
      let val = obj[".val"];
      switch (type) {
        case "Date":
        case "date": {
          val = new Date(val);
          break;
        }
        case "Buffer":
        case "binary": {
          val = unescape2(val);
          if (val.startsWith("<~")) {
            val = ascii85.decode(val);
          } else {
            throw new Error(`Import error: Unexpected encoding for value for value at path "/${path4}"`);
          }
          break;
        }
        case "PathReference":
        case "reference": {
          val = new PathReference(val);
          break;
        }
        case "bigint": {
          val = BigInt(val);
          break;
        }
        default:
          throw new Error(`Import error: Unsupported type "${type}" for value at path "/${path4}"`);
      }
      return val;
    };
    const context = { acebase_import_id: ID.generate() };
    const childOptions = { suppress_events: options.suppress_events, context };
    const enqueue = async (target, value) => {
      state.queue.push({ target, value });
      if (state.processedBytes >= state.queueStartByte + maxQueueBytes) {
        const operations = state.queue.reduce((updates, item) => {
          if (item.target.path === path3) {
            updates.push({ op: options.method === "set" && state.timesFlushed === 0 ? "set" : "update", ...item });
          } else {
            const parent = updates.find((other) => other.target.isParentOf(item.target));
            if (parent) {
              parent.value[item.target.key] = item.value;
            } else {
              updates.push({ op: options.method === "merge" ? "update" : "set", ...item });
            }
          }
          return updates;
        }, []);
        state.queueStartByte = state.processedBytes;
        state.queue = [];
        state.timesFlushed++;
      }
      if (target.path === path3) {
      }
    };
    const importObject = async (target) => {
      await consumeToken("{");
      await consumeSpaces();
      const nextChar = await peekBytes(1);
      if (nextChar === "}") {
        state.index++;
        return this.setNode(target.path, {}, childOptions);
      }
      let childCount = 0;
      let obj = {};
      let flushedBefore = false;
      const flushObject = async () => {
        let p;
        if (!flushedBefore) {
          flushedBefore = true;
          p = this.setNode(target.path, obj, childOptions);
        } else if (Object.keys(obj).length > 0) {
          p = this.updateNode(target.path, obj, childOptions);
        }
        obj = {};
        if (p) {
          await p;
        }
      };
      const promises = [];
      while (true) {
        await consumeSpaces();
        const property = await readString();
        await consumeSpaces();
        await consumeToken(":");
        await consumeSpaces();
        const { value, type } = await readValue();
        obj[property] = value;
        childCount++;
        if (["object", "array"].includes(type)) {
          promises.push(flushObject());
          if (type === "object") {
            await importObject(target.child(property));
          } else {
            await importArray(target.child(property));
          }
        }
        await consumeSpaces();
        const nextChar2 = await peekBytes(1);
        if (nextChar2 === "}") {
          state.index++;
          break;
        }
        await consumeToken(",");
      }
      const isTypedValue = childCount === 2 && ".type" in obj && ".val" in obj;
      if (isTypedValue) {
        const val = getTypeSafeValue(target.path, obj);
        return this.setNode(target.path, val, childOptions);
      }
      promises.push(flushObject());
      await Promise.all(promises);
    };
    const importArray = async (target) => {
      await consumeToken("[");
      await consumeSpaces();
      const nextChar = await peekBytes(1);
      if (nextChar === "]") {
        state.index++;
        return this.setNode(target.path, [], childOptions);
      }
      let flushedBefore = false;
      let arr = [];
      let updates = {};
      const flushArray = async () => {
        let p;
        if (!flushedBefore) {
          flushedBefore = true;
          p = this.setNode(target.path, arr, childOptions);
          arr = null;
        } else if (Object.keys(updates).length > 0) {
          p = this.updateNode(target.path, updates, childOptions);
          updates = {};
        }
        if (p) {
          await p;
        }
      };
      const pushChild = (value, index2) => {
        if (flushedBefore) {
          updates[index2] = value;
        } else {
          arr.push(value);
        }
      };
      const promises = [];
      let index = 0;
      while (true) {
        await consumeSpaces();
        const { value, type } = await readValue();
        pushChild(value, index);
        if (["object", "array"].includes(type)) {
          promises.push(flushArray());
          if (type === "object") {
            await importObject(target.child(index));
          } else {
            await importArray(target.child(index));
          }
        }
        await consumeSpaces();
        const nextChar2 = await peekBytes(1);
        if (nextChar2 === "]") {
          state.index++;
          break;
        }
        await consumeToken(",");
        index++;
      }
      promises.push(flushArray());
      await Promise.all(promises);
    };
    const start = async () => {
      const { value, type } = await readValue();
      if (["object", "array"].includes(type)) {
        const target = PathInfo.get(path3);
        if (type === "object") {
          await importObject(target);
        } else {
          await importArray(target);
        }
      } else {
        await this.setNode(path3, value, childOptions);
      }
    };
    return start();
  }
  setSchema(path3, schema, warnOnly = false) {
    if (typeof schema === "undefined") {
      throw new TypeError("schema argument must be given");
    }
    if (schema === null) {
      const i = this._schemas.findIndex((s) => s.path === path3);
      i >= 0 && this._schemas.splice(i, 1);
      return;
    }
    const definition = new SchemaDefinition(schema, {
      warnOnly,
      warnCallback: (message) => this.debug.warn(message)
    });
    const item = this._schemas.find((s) => s.path === path3);
    if (item) {
      item.schema = definition;
    } else {
      this._schemas.push({ path: path3, schema: definition });
      this._schemas.sort((a, b) => {
        const ka = PathInfo.getPathKeys(a.path), kb = PathInfo.getPathKeys(b.path);
        if (ka.length === kb.length) {
          return 0;
        }
        return ka.length < kb.length ? -1 : 1;
      });
    }
  }
  getSchema(path3) {
    const item = this._schemas.find((item2) => item2.path === path3);
    return item ? { path: path3, schema: item.schema.source, text: item.schema.text } : null;
  }
  getSchemas() {
    return this._schemas.map((item) => ({ path: item.path, schema: item.schema.source, text: item.schema.text }));
  }
  validateSchema(path3, value, options = { updates: false }) {
    let result = { ok: true };
    const pathInfo = PathInfo.get(path3);
    this._schemas.filter((s) => pathInfo.isOnTrailOf(s.path)).every((s) => {
      if (pathInfo.isDescendantOf(s.path)) {
        const ancestorPath = PathInfo.fillVariables(s.path, path3);
        const trailKeys2 = pathInfo.keys.slice(PathInfo.getPathKeys(s.path).length);
        result = s.schema.check(ancestorPath, value, options.updates, trailKeys2);
        return result.ok;
      }
      const trailKeys = PathInfo.getPathKeys(s.path).slice(pathInfo.keys.length);
      if (options.updates === true && trailKeys.length > 0 && !(trailKeys[0] in value)) {
        return result.ok;
      }
      const partial = options.updates === true && trailKeys.length === 0;
      const check = (path4, value2, trailKeys2) => {
        if (trailKeys2.length === 0) {
          return s.schema.check(path4, value2, partial);
        } else if (value2 === null) {
          return { ok: true };
        }
        const key = trailKeys2[0];
        if (typeof key === "string" && (key === "*" || key[0] === "$")) {
          if (value2 === null || typeof value2 !== "object") {
            return { ok: true };
          }
          let result2;
          Object.keys(value2).every((childKey) => {
            const childPath = PathInfo.getChildPath(path4, childKey);
            const childValue = value2[childKey];
            result2 = check(childPath, childValue, trailKeys2.slice(1));
            return result2.ok;
          });
          return result2;
        } else {
          const childPath = PathInfo.getChildPath(path4, key);
          const childValue = value2[key];
          return check(childPath, childValue, trailKeys2.slice(1));
        }
      };
      result = check(path3, value, trailKeys);
      return result.ok;
    });
    return result;
  }
};

// node_modules/acebase/dist/esm/storage/binary/index.js
var { concatTypedArrays: concatTypedArrays2, bytesToNumber: bytesToNumber6, bytesToBigint: bytesToBigint3, numberToBytes: numberToBytes6, bigintToBytes: bigintToBytes5, encodeString: encodeString6, decodeString: decodeString4, cloneObject: cloneObject2 } = utils_exports;
var REMOVED_CHILD_DATA_IMPLEMENTED = false;
var AceBaseStorageSettings = class extends StorageSettings {
  constructor(settings = {}) {
    super(settings);
    this.recordSize = 128;
    this.pageSize = 1024;
    this.type = "data";
    this.fst2 = false;
    if (typeof settings.recordSize === "number") {
      this.recordSize = settings.recordSize;
    }
    if (typeof settings.pageSize === "number") {
      this.pageSize = settings.pageSize;
    }
    if (typeof settings.type === "string") {
      this.type = settings.type;
    }
    this.transactions = new AceBaseTransactionLogSettings(settings.transactions);
  }
};
var AceBaseTransactionLogSettings = class {
  constructor(settings = {}) {
    this.log = false;
    this.maxAge = 30;
    this.noWait = false;
    if (typeof settings.log === "boolean") {
      this.log = settings.log;
    }
    if (typeof settings.maxAge === "number") {
      this.maxAge = settings.maxAge;
    }
    if (typeof settings.noWait === "boolean") {
      this.noWait = settings.noWait;
    }
  }
};
var AceBaseStorage = class extends Storage {
  constructor(name, settings, env2) {
    console.assert(settings instanceof AceBaseStorageSettings, "settings must be an instance of AceBaseStorageSettings");
    super(name, settings, env2);
    this._ready = false;
    this.nodeCache = new NodeCache();
    if (settings.maxInlineValueSize > 64) {
      throw new Error("maxInlineValueSize cannot be larger than 64");
    }
    if (settings.recordSize > 65536) {
      throw new Error("recordSize cannot be larger than 65536");
    }
    if (settings.pageSize > 65536) {
      throw new Error("pageSize cannot be larger than 65536");
    }
    this.name = name;
    this.settings = settings;
    this.stats = {
      writes: 0,
      reads: 0,
      bytesRead: 0,
      bytesWritten: 0
    };
    this.type = settings.type;
    if (this.type === "data" && settings.transactions.log === true) {
      const txSettings = new AceBaseStorageSettings({ type: "transaction", path: settings.path, removeVoidProperties: true, transactions: settings.transactions, ipc: settings.ipc });
      this.txStorage = new AceBaseStorage(name, txSettings, { logLevel: "error" });
    }
    this.once("ready", () => {
      this._ready = true;
    });
    this.ipc.on("request", async (message) => {
      console.assert(this.ipc.isMaster, "Workers should not receive requests");
      const request2 = message.data;
      const reply = (result) => {
        this.ipc.replyRequest(message, result);
      };
      try {
        switch (request2.type) {
          case "fst.allocate": {
            const allocation = await this.FST.allocate(request2.records);
            return reply({ ok: true, allocation });
          }
          case "fst.release": {
            this.FST.release(request2.ranges);
            return reply({ ok: true });
          }
          case "kit.add": {
            const index = this.KIT.getOrAdd(request2.key);
            return reply({ ok: true, index });
          }
          case "index.create": {
            const index = await this.indexes.create(request2.path, request2.key, request2.options);
            return reply({ ok: true, fileName: index.fileName });
          }
          case "index.update": {
            const index = this.indexes.list().find((index2) => index2.fileName === request2.fileName);
            if (!index) {
              return reply({ ok: false, reason: `Index ${request2.fileName} not found` });
            }
            await index.handleRecordUpdate(request2.path, request2.oldValue, request2.newValue);
            return reply({ ok: true });
          }
          default: {
            throw new Error(`Unknown ipc request "${request2.type}"`);
          }
        }
      } catch (err) {
        reply({ ok: false, reason: err.message });
      }
    });
    this.ipc.on("notification", (message) => {
      const notification = message.data;
      switch (notification.type) {
        case "kit.new_key": {
          this.KIT.keys[notification.index] = notification.key;
          break;
        }
        case "root.update": {
          return this.rootRecord.update(notification.address, false);
        }
        case "cache.update": {
          const nodeInfo = new BinaryNodeInfo(notification.info);
          nodeInfo.address = new BinaryNodeAddress(nodeInfo.address.path, nodeInfo.address.pageNr, nodeInfo.address.recordNr);
          return this.updateCache(true, nodeInfo, true);
        }
        case "cache.invalidate": {
          return this.invalidateCache(true, notification.path, notification.recursive, notification.reason);
        }
        case "index.created": {
          return this.indexes.add(notification.fileName);
        }
        case "index.deleted": {
          return this.indexes.remove(notification.fileName);
        }
        default: {
          throw new Error(`Unknown ipc notification "${notification.type}"`);
        }
      }
    });
    const KIT = {
      get fileIndex() {
        return 64;
      },
      get length() {
        return 65536 - 64;
      },
      bytesUsed: 0,
      keys: []
    };
    this.KIT = {
      get fileIndex() {
        return KIT.fileIndex;
      },
      get length() {
        return KIT.length;
      },
      get bytesUsed() {
        return KIT.bytesUsed;
      },
      get keys() {
        return KIT.keys;
      },
      getOrAdd: (key) => {
        if (key.length > 15 || key.length === 1) {
          return -1;
        }
        if (/^[0-9]+$/.test(key)) {
          return -1;
        }
        let index = KIT.keys.indexOf(key);
        if (index < 0) {
          if (!this.ipc.isMaster) {
            this.ipc.sendRequest({ type: "kit.add", key }).then((result) => {
              KIT.keys[result.index] = key;
            });
            return -1;
          }
          index = KIT.keys.push(key) - 1;
          if (this.ipc.isMaster) {
            this.ipc.sendNotification({ type: "kit.new_key", key, index });
          }
        } else {
          return index;
        }
        this.KIT.write().catch((err) => {
          throw new Error(`CRITICAL: Unable to write KIT to database file: ${err.message}`);
        });
        return index;
      },
      write: async () => {
        if (!this.ipc.isMaster) {
          throw new Error("DEV ERROR: KIT.write not allowed to run if it is a cluster worker!!");
        }
        const data = Buffer.alloc(KIT.length);
        const view = new DataView(data.buffer);
        let index = 0;
        for (let i = 0; i < KIT.keys.length; i++) {
          const key = KIT.keys[i];
          const binary = encodeString6(key);
          const keyLength = binary.byteLength;
          if (index + keyLength >= KIT.length) {
            throw new Error(`Too many keys to store in KIT, size limit of ${KIT.length} has been reached; current amount of keys is ${KIT.keys.length}`);
          }
          view.setUint8(index, keyLength);
          index++;
          data.set(binary, index);
          index += keyLength;
        }
        const bytesToWrite = Math.max(KIT.bytesUsed, index);
        KIT.bytesUsed = index;
        await this.writeData(KIT.fileIndex, data, 0, bytesToWrite);
      },
      load: async () => {
        const data = Buffer.alloc(KIT.length);
        const { bytesRead } = await pfs.read(this.file, data, 0, data.length, KIT.fileIndex).catch((err) => {
          this.debug.error("Error reading KIT from file: ", err);
          throw err;
        });
        const view = new DataView(data.buffer, 0, bytesRead);
        const keys = [];
        let index = 0;
        let keyLength = 0;
        while ((keyLength = view.getUint8(index)) > 0) {
          index++;
          const buffer = new Uint8Array(data.buffer, index, keyLength);
          const key = decodeString4(buffer);
          keys.push(key);
          index += keyLength;
        }
        KIT.bytesUsed = index;
        KIT.keys = keys;
        this.debug.log(`KIT read, ${KIT.keys.length} keys indexed`.colorize(ColorStyle.bold));
        return keys;
      }
    };
    const FST = {
      get fileIndex() {
        return 65536;
      },
      length: 65536,
      bytesUsed: 0,
      pages: 0,
      ranges: [],
      getMaxScraps: () => {
        if (!this.ipc.isMaster) {
          return 10;
        }
        return FST.ranges.length > 7500 ? 10 : 3;
      }
    };
    this.FST = {
      get fileIndex() {
        return FST.fileIndex;
      },
      get length() {
        return FST.length;
      },
      get bytesUsed() {
        return FST.bytesUsed;
      },
      get pages() {
        return FST.pages;
      },
      get ranges() {
        return FST.ranges;
      },
      get maxScraps() {
        return FST.getMaxScraps();
      },
      allocate: async (requiredRecords) => {
        if (!this.ipc.isMaster) {
          const result = await this.ipc.sendRequest({ type: "fst.allocate", records: requiredRecords });
          return result.allocation;
        }
        if (this.isLocked(true)) {
          throw new Error("database is locked");
        }
        const recordsPerPage = this.settings.pageSize;
        const allocation = [];
        let pageAdded = false;
        const ret = async (comment) => {
          await this.FST.write(pageAdded);
          return allocation;
        };
        let totalFree = FST.ranges.reduce((t, r) => t + r.end - r.start, 0);
        while (totalFree < requiredRecords) {
          const newPageNr = FST.pages;
          FST.pages++;
          const newRange = { page: newPageNr, start: 0, end: recordsPerPage };
          FST.ranges.push(newRange);
          totalFree += recordsPerPage;
          pageAdded = true;
        }
        if (requiredRecords <= recordsPerPage) {
          let r = FST.ranges.find((r2) => r2.end - r2.start === requiredRecords);
          if (r) {
            allocation.push({ pageNr: r.page, recordNr: r.start, length: requiredRecords });
            const i = FST.ranges.indexOf(r);
            FST.ranges.splice(i, 1);
            return ret("exact_range");
          }
          r = FST.ranges.find((r2) => r2.end - r2.start > requiredRecords);
          if (r) {
            allocation.push({ pageNr: r.page, recordNr: r.start, length: requiredRecords });
            r.start += requiredRecords;
            return ret("first_fitting");
          }
        }
        const sortedRanges = FST.ranges.slice().sort((a, b) => {
          const l1 = a.end - a.start;
          const l2 = b.end - b.start;
          if (l1 < l2) {
            return 1;
          }
          if (l1 > l2) {
            return -1;
          }
          if (a.page < b.page) {
            return -1;
          }
          if (a.page > b.page) {
            return 1;
          }
          return 0;
        });
        const MAX_RANGES = FST.getMaxScraps();
        const test = {
          ranges: [],
          totalRecords: 0,
          wholePages: 0,
          additionalRanges: 0
        };
        for (let i = 0; test.totalRecords < requiredRecords && i < sortedRanges.length && test.additionalRanges <= MAX_RANGES; i++) {
          const r = sortedRanges[i];
          test.ranges.push(r);
          const nrOfRecords = r.end - r.start;
          test.totalRecords += nrOfRecords;
          if (nrOfRecords === recordsPerPage) {
            test.wholePages++;
          } else {
            test.additionalRanges++;
          }
        }
        if (test.additionalRanges > MAX_RANGES) {
          const pagesToCreate = Math.ceil(requiredRecords / recordsPerPage) - test.wholePages;
          for (let i = 0; i < test.wholePages; i++) {
            const range = test.ranges[i];
            console.assert(range.start === 0 && range.end === recordsPerPage, "Available ranges were not sorted correctly, this range MUST be a whole page!!");
            const rangeIndex = FST.ranges.indexOf(range);
            FST.ranges.splice(rangeIndex, 1);
            allocation.push({ pageNr: range.page, recordNr: 0, length: recordsPerPage });
            requiredRecords -= recordsPerPage;
          }
          for (let i = 0; i < pagesToCreate; i++) {
            const newPageNr = FST.pages;
            FST.pages++;
            const useRecords = Math.min(requiredRecords, recordsPerPage);
            allocation.push({ pageNr: newPageNr, recordNr: 0, length: useRecords });
            if (useRecords < recordsPerPage) {
              FST.ranges.push({ page: newPageNr, start: useRecords, end: recordsPerPage });
            }
            requiredRecords -= useRecords;
            pageAdded = true;
          }
        } else {
          test.ranges.forEach((r, i) => {
            const length3 = r.end - r.start;
            if (length3 > requiredRecords) {
              console.assert(i === test.ranges.length - 1, "DEV ERROR: This MUST be the last range or logic is not right!");
              allocation.push({ pageNr: r.page, recordNr: r.start, length: requiredRecords });
              r.start += requiredRecords;
              requiredRecords = 0;
            } else {
              allocation.push({ pageNr: r.page, recordNr: r.start, length: length3 });
              const rangeIndex = FST.ranges.indexOf(r);
              FST.ranges.splice(rangeIndex, 1);
              requiredRecords -= length3;
            }
          });
        }
        console.assert(requiredRecords === 0, "DEV ERROR: requiredRecords MUST be zero now!");
        return ret("scraps");
      },
      release: async (ranges) => {
        if (!this.ipc.isMaster) {
          await this.ipc.sendRequest({ type: "fst.release", ranges });
          return;
        }
        if (this.isLocked(true)) {
          throw new Error("database is locked");
        }
        ranges.forEach((range) => {
          FST.ranges.push({ page: range.pageNr, start: range.recordNr, end: range.recordNr + range.length });
        });
        this.FST.sort();
        for (let i = 0; i < FST.ranges.length; i++) {
          const range = FST.ranges[i];
          let adjRange;
          for (let j = i + 1; j < FST.ranges.length; j++) {
            const otherRange = FST.ranges[j];
            if (otherRange.page !== range.page) {
              continue;
            }
            if (otherRange.start === range.end) {
              otherRange.start = range.start;
              adjRange = otherRange;
              break;
            }
            if (range.start === otherRange.end) {
              otherRange.end = range.end;
              adjRange = otherRange;
              break;
            }
          }
          if (adjRange) {
            FST.ranges.splice(i, 1);
            i--;
          }
        }
        this.FST.sort();
        this.FST.write();
      },
      sort: () => {
        FST.ranges.sort((a, b) => {
          if (a.page < b.page) {
            return -1;
          }
          if (a.page > b.page) {
            return 1;
          }
          if (a.start < b.start) {
            return -1;
          }
          if (a.start > b.start) {
            return 1;
          }
          return 0;
        });
      },
      write: async (updatedPageCount = false) => {
        const MAX_FST_RANGES = 8191;
        if (FST.ranges.length > MAX_FST_RANGES) {
          const n = FST.ranges.length - MAX_FST_RANGES;
          const ranges = FST.ranges.slice().sort((a, b) => a.end - a.start < b.end - b.start ? -1 : 1).slice(0, n);
          const totalRecords = ranges.reduce((records, range) => records + (range.end - range.start), 0);
          this.debug.warn(`FST grew too big to store in the database file, removing ${n} entries for ${totalRecords} records`);
          ranges.forEach((range) => {
            const i = FST.ranges.indexOf(range);
            FST.ranges.splice(i, 1);
          });
          if (FST.ranges.length > MAX_FST_RANGES) {
            throw new Error("DEV ERROR: Still too many entries in the FST!");
          }
        }
        const data = Buffer.alloc(FST.length);
        const view = new DataView(data.buffer);
        view.setUint32(0, FST.pages);
        view.setUint16(4, FST.ranges.length);
        let index = 6;
        for (let i = 0; i < FST.ranges.length; i++) {
          const range = FST.ranges[i];
          view.setUint32(index, range.page);
          view.setUint16(index + 4, range.start);
          view.setUint16(index + 6, range.end);
          index += 8;
        }
        const bytesToWrite = Math.max(FST.bytesUsed, index);
        FST.bytesUsed = index;
        const promise = this.writeData(FST.fileIndex, data, 0, bytesToWrite).catch((err) => {
          this.debug.error("Error writing FST: ", err);
        });
        const writes = [promise];
        if (updatedPageCount === true) {
          const newFileSize = this.rootRecord.fileIndex + FST.pages * settings.pageSize * settings.recordSize;
          const promise2 = pfs.ftruncate(this.file, newFileSize);
          writes.push(promise2);
        }
        await Promise.all(writes);
      },
      load: async () => {
        if (!this.ipc.isMaster) {
          return [];
        }
        const data = Buffer.alloc(FST.length);
        const { bytesRead } = await pfs.read(this.file, data, 0, data.length, this.FST.fileIndex).catch((err) => {
          this.debug.error("Error reading FST from file");
          this.debug.error(err);
          throw err;
        });
        const view = new DataView(data.buffer, 0, bytesRead);
        const allocatedPages = view.getUint32(0);
        const freeRangeCount = view.getUint16(4);
        const ranges = [];
        let index = 6;
        for (let i = 0; i < freeRangeCount; i++) {
          const range = {
            page: view.getUint32(index),
            start: view.getUint16(index + 4),
            end: view.getUint16(index + 6)
          };
          ranges.push(range);
          index += 8;
        }
        FST.pages = allocatedPages;
        FST.bytesUsed = index;
        FST.ranges = ranges;
        this.debug.log(`FST read, ${allocatedPages} pages allocated, ${freeRangeCount} free ranges`.colorize(ColorStyle.bold));
        return ranges;
      }
    };
    const rootRecord = {
      get fileIndex() {
        return 131072;
      },
      pageNr: 0,
      recordNr: 0,
      exists: false
    };
    this.rootRecord = {
      get fileIndex() {
        return rootRecord.fileIndex;
      },
      get pageNr() {
        return rootRecord.pageNr;
      },
      get recordNr() {
        return rootRecord.recordNr;
      },
      get exists() {
        return rootRecord.exists;
      },
      get address() {
        return new BinaryNodeAddress("", rootRecord.pageNr, rootRecord.recordNr);
      },
      update: async (address, fromIPC = false) => {
        console.assert(address.path === "");
        if (address.pageNr === rootRecord.pageNr && address.recordNr === rootRecord.recordNr) {
          return;
        }
        rootRecord.pageNr = address.pageNr;
        rootRecord.recordNr = address.recordNr;
        rootRecord.exists = true;
        if (!fromIPC) {
          this.ipc.sendNotification({ type: "root.update", address });
          const bytes = new Uint8Array(6);
          const view = new DataView(bytes.buffer);
          view.setUint32(0, address.pageNr);
          view.setUint16(4, address.recordNr);
          const bytesWritten = await this.writeData(HEADER_INDEXES.ROOT_RECORD_ADDRESS, bytes, 0, bytes.length);
          this.debug.log(`Root record address updated to ${address.pageNr}, ${address.recordNr}`.colorize(ColorStyle.bold));
        }
      }
    };
    const descriptor = encodeString6("AceBase\u26A1");
    const baseIndex = descriptor.length;
    const HEADER_INDEXES = {
      VERSION_NR: baseIndex,
      DB_LOCK: baseIndex + 1,
      ROOT_RECORD_ADDRESS: baseIndex + 2,
      RECORD_SIZE: baseIndex + 8,
      PAGE_SIZE: baseIndex + 10,
      MAX_INLINE_VALUE_SIZE: baseIndex + 12
    };
    const openDatabaseFile = async (justCreated = false) => {
      const handleError = (err, txt) => {
        this.debug.error(txt);
        this.debug.error(err);
        if (this.file) {
          pfs.close(this.file).catch((err2) => {
          });
        }
        this.emit("error", err);
        throw err;
      };
      try {
        this.file = await pfs.open(this.fileName, settings.readOnly === true ? "r" : "r+", 0);
      } catch (err) {
        handleError(err, "Failed to open database file");
      }
      const data = Buffer.alloc(64);
      let bytesRead = 0;
      try {
        const result = await pfs.read(this.file, data, 0, data.length, 0);
        bytesRead = result.bytesRead;
      } catch (err) {
        handleError(err, "Could not read database header");
      }
      const header = new Uint8Array(data);
      const hasAceBaseDescriptor = () => {
        for (let i = 0; i < descriptor.length; i++) {
          if (header[i] !== descriptor[i]) {
            return false;
          }
        }
        return true;
      };
      if (bytesRead < 64 || !hasAceBaseDescriptor()) {
        return handleError("unsupported_db", "This is not a supported database file");
      }
      let index = descriptor.length;
      if (header[index] !== 1) {
        return handleError("unsupported_db", "This database version is not supported, update your source code");
      }
      index++;
      const flagsIndex = index;
      const flags = header[flagsIndex];
      const lock = {
        enabled: (flags & 1) > 0,
        forUs: true
      };
      this.isLocked = (forUs = false) => {
        return lock.enabled && lock.forUs === forUs;
      };
      this.lock = async (forUs = false) => {
        await pfs.write(this.file, new Uint8Array([flags | 1]), 0, 1, flagsIndex);
        lock.enabled = true;
        lock.forUs = forUs;
        this.emit("locked", { forUs });
      };
      this.unlock = async () => {
        await pfs.write(this.file, new Uint8Array([flags & 254]), 0, 1, flagsIndex);
        lock.enabled = false;
        this.emit("unlocked");
      };
      this.settings.fst2 = (flags & 2) > 0;
      if (this.settings.fst2) {
        throw new Error("FST2 is not supported by this version yet");
      }
      index++;
      const view = new DataView(header.buffer, index, 6);
      rootRecord.pageNr = view.getUint32(0);
      rootRecord.recordNr = view.getUint16(4);
      if (!justCreated) {
        rootRecord.exists = true;
      }
      index += 6;
      this.settings.recordSize = header[index] << 8 | header[index + 1];
      this.settings.pageSize = header[index + 2] << 8 | header[index + 3];
      this.settings.maxInlineValueSize = header[index + 4] << 8 | header[index + 5];
      if (this.settings.recordSize === 0) {
        this.settings.recordSize = 65536;
      }
      if (this.settings.pageSize === 0) {
        this.settings.pageSize = 65536;
      }
      if (this.settings.maxInlineValueSize === 0) {
        this.settings.maxInlineValueSize = 65536;
      }
      const intro = ColorStyle.dim;
      this.debug.log(`Database "${name}" details:`.colorize(intro));
      this.debug.log("- Type: AceBase binary".colorize(intro));
      this.debug.log(`- Record size: ${this.settings.recordSize} bytes`.colorize(intro));
      this.debug.log(`- Page size: ${this.settings.pageSize} records (${this.settings.pageSize * this.settings.recordSize} bytes)`.colorize(intro));
      this.debug.log(`- Max inline value size: ${this.settings.maxInlineValueSize} bytes`.colorize(intro));
      this.debug.log(`- Root record address: ${this.rootRecord.pageNr}, ${this.rootRecord.recordNr}`.colorize(intro));
      await this.KIT.load();
      await this.FST.load();
      await this.indexes.load();
      !justCreated && this.emitOnce("ready");
      return this.file;
    };
    const createDatabaseFile = async () => {
      const version = 1;
      const headerBytes = 64;
      const flags = 0;
      const stats = new Uint8Array([
        version,
        flags,
        0,
        0,
        0,
        0,
        0,
        0,
        settings.recordSize >> 8 & 255,
        settings.recordSize & 255,
        settings.pageSize >> 8 & 255,
        settings.pageSize & 255,
        settings.maxInlineValueSize >> 8 & 255,
        settings.maxInlineValueSize & 255
      ]);
      let header = concatTypedArrays2(descriptor, stats);
      const padding2 = new Uint8Array(headerBytes - header.byteLength);
      padding2.fill(0);
      header = concatTypedArrays2(header, padding2);
      const kit = new Uint8Array(65536 - header.byteLength);
      let uint8 = concatTypedArrays2(header, kit);
      const fst = new Uint8Array(65536);
      uint8 = concatTypedArrays2(uint8, fst);
      const dir = this.fileName.slice(0, this.fileName.lastIndexOf("/"));
      if (dir !== ".") {
        await pfs.mkdir(dir).catch((err) => {
          if (err.code !== "EEXIST") {
            throw err;
          }
        });
      }
      await pfs.writeFile(this.fileName, Buffer.from(uint8.buffer));
      await openDatabaseFile(true);
      await this.setNode("", {});
      rootRecord.exists = true;
      this.emitOnce("ready");
    };
    const exists2 = fs2.existsSync(this.fileName);
    if (exists2) {
      openDatabaseFile(false);
    } else if (settings.readOnly) {
      throw new Error(`Cannot create readonly database "${name}"`);
    } else if (!this.ipc.isMaster) {
      const poll = () => {
        setTimeout(async () => {
          const exists3 = await pfs.exists(this.fileName);
          if (exists3) {
            openDatabaseFile();
          } else {
            poll();
          }
        }, 1e3);
      };
      poll();
    } else {
      createDatabaseFile();
    }
    this.ipc.once("exit", (code) => {
      this.debug.log(`Closing db ${this.ipc.dbname}`);
      pfs.close(this.file).catch((err) => {
        this.debug.error("Could not close database:", err);
      });
    });
  }
  get isReady() {
    return this._ready;
  }
  get fileName() {
    return `${this.settings.path}/${this.name}.acebase/${this.type}.db`;
  }
  async writeData(fileIndex, buffer, offset = 0, length3 = -1) {
    if (this.settings.readOnly) {
      const err = new Error(`Cannot write to readonly database ${this.fileName}`);
      err.code = "EPERM";
      throw err;
    }
    if (buffer.constructor === Uint8Array) {
      buffer = Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    console.assert(buffer instanceof Buffer, "buffer argument must be a Buffer or Uint8Array");
    if (length3 === -1) {
      length3 = buffer.byteLength;
    }
    const { bytesWritten } = await pfs.write(this.file, buffer, offset, length3, fileIndex).catch((err) => {
      this.debug.error("Error writing to file", err);
      throw err;
    });
    this.stats.writes++;
    this.stats.bytesWritten += bytesWritten;
    return bytesWritten;
  }
  async readData(fileIndex, buffer, offset = 0, length3 = -1) {
    if (length3 === -1) {
      length3 = buffer.byteLength;
    }
    if (buffer instanceof ArrayBuffer) {
      buffer = Buffer.from(buffer);
    } else if (!(buffer instanceof Buffer) && buffer.buffer instanceof ArrayBuffer) {
      buffer = Buffer.from(buffer.buffer);
      if (buffer.byteOffset > 0) {
        throw new Error("When using a TypedArray as buffer, its byteOffset MUST be 0.");
      }
    }
    try {
      const { bytesRead } = await pfs.read(this.file, buffer, offset, length3, fileIndex);
      this.stats.reads++;
      this.stats.bytesRead += bytesRead;
      return bytesRead;
    } catch (err) {
      this.debug.error("Error reading record", buffer, offset, length3, fileIndex);
      this.debug.error(err);
      throw err;
    }
  }
  updateCache(fromIPC, nodeInfo, hasMoved = true) {
    this.nodeCache.update(nodeInfo);
    if (!fromIPC && hasMoved) {
      this.ipc.sendNotification({ type: "cache.update", info: nodeInfo });
    }
  }
  invalidateCache(fromIPC, path3, recursive, reason) {
    this.nodeCache.invalidate(path3, recursive, reason);
    this.indexes.getAll(path3, { parentPaths: true, childPaths: true }).forEach((index) => {
      index.clearCache(path3);
    });
    if (!fromIPC) {
      this.ipc.sendNotification({ type: "cache.invalidate", path: path3, recursive, reason });
    }
  }
  async close() {
    const p1 = super.close();
    const p2 = this.txStorage && this.txStorage.close();
    await Promise.all([p1, p2]);
  }
  get pageByteSize() {
    return this.settings.pageSize * this.settings.recordSize;
  }
  getRecordFileIndex(pageNr, recordNr) {
    const index = this.rootRecord.fileIndex + pageNr * this.pageByteSize + recordNr * this.settings.recordSize;
    return index;
  }
  async repairNode(targetPath, options = {
    ignoreIntact: false,
    markAsRemoved: true
  }) {
    if (typeof options.ignoreIntact !== "boolean") {
      options.ignoreIntact = false;
    }
    if (typeof options.markAsRemoved !== "boolean") {
      options.markAsRemoved = true;
    }
    const targetPathInfo = PathInfo.get(targetPath);
    const { parentPath: path3, key, parent: pathInfo } = targetPathInfo;
    const tid = this.createTid();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), true, "fixRecord");
    try {
      this.invalidateCache(false, path3, true);
      let targetNodeInfo = null;
      try {
        targetNodeInfo = await this.getNodeInfo(targetPath, { tid });
      } finally {
        if (targetNodeInfo) {
          const msg = `Node at path "${targetPath}" is not broken: it is a(n) ${targetNodeInfo.valueTypeName} stored ${targetNodeInfo.address ? `@${targetNodeInfo.address.pageNr},${targetNodeInfo.address.recordNr}` : "inline"}${targetNodeInfo.value ? ` with value ${targetNodeInfo.value}` : ""}`;
          this.debug.warn(msg);
          if (!options.ignoreIntact) {
            throw new Error(msg);
          }
        }
      }
      let nodeInfo;
      try {
        nodeInfo = await this.getNodeInfo(path3, { tid });
      } catch (err) {
        throw new Error(`Can't read parent node ${path3}: ${err}`);
      }
      if (!nodeInfo.exists) {
        throw new Error(`Node at path ${path3} does not exist`);
      } else if (!nodeInfo.address) {
        throw new Error(`Node at ${path3} is not stored in its own record`);
      }
      const removedValueIndicator = "[[removed]]";
      const isArray2 = nodeInfo.valueType === VALUE_TYPES.ARRAY;
      if (isArray2 && !options.markAsRemoved) {
        this.debug.warn(`Node at path "${path3}" is an Array, cannot remove entry at index ${key}: marking it as "${removedValueIndicator}" instead`);
        options.markAsRemoved = true;
      }
      const nodeReader = new NodeReader(this, nodeInfo.address, lock, false);
      const recordInfo = await nodeReader.readHeader();
      let childInfo;
      try {
        childInfo = await nodeReader.getChildInfo(key);
      } catch (err) {
        throw new Error(`Can't get info about child "${key}" in node "${path3}: ${err}`);
      }
      if (!childInfo.address) {
        throw new Error(`Can't fix node "${targetPath}" because it is not stored in its own record`);
      }
      if (recordInfo.hasKeyIndex) {
        const oldKV = _serializeValue(this, targetPath, key, new InternalNodeReference(childInfo.valueType, childInfo.address), tid);
        const oldVal = _getValueBytes(oldKV);
        const newKV = _serializeValue(this, targetPath, key, removedValueIndicator, tid);
        const newVal = _getValueBytes(newKV);
        const tree = nodeReader.getChildTree();
        const oldEntryValue = new BinaryBPlusTree.EntryValue(oldVal);
        const newEntryValue = new BinaryBPlusTree.EntryValue(newVal);
        const op = options.markAsRemoved ? BinaryBPlusTree.TransactionOperation.update(key, newEntryValue, oldEntryValue) : BinaryBPlusTree.TransactionOperation.remove(key, oldEntryValue.recordPointer);
        try {
          await tree.transaction([op]);
        } catch (err) {
          throw new Error(`Could not update tree for "${path3}": ${err}`);
        }
      } else {
        const mergedValue = isArray2 ? [] : {};
        await nodeReader.getChildStream().next((child) => {
          const keyOrIndex = isArray2 ? child.index : child.key;
          if (keyOrIndex === key) {
            if (options.markAsRemoved) {
              mergedValue[key] = removedValueIndicator;
            }
          } else if (child.address) {
            mergedValue[keyOrIndex] = new InternalNodeReference(child.valueType, child.address);
          } else {
            mergedValue[keyOrIndex] = child.value;
          }
        });
        const newRecordInfo = await _writeNode(this, path3, mergedValue, lock, nodeReader.recordInfo);
        if (newRecordInfo !== nodeReader.recordInfo) {
          if (pathInfo.parent) {
            lock = await lock.moveToParent();
            await this._updateNode(pathInfo.parentPath, { [pathInfo.key]: new InternalNodeReference(newRecordInfo.valueType, newRecordInfo.address) }, { merge: true, tid, _internal: true });
          }
          try {
            await this.FST.release(nodeReader.recordInfo.allocation.ranges);
          } catch (err) {
            this.debug.error(`Could not release previously allocated ranges for "/${path3}": ${err}`);
          }
        }
      }
      this.debug.log(`Successfully fixed node at path "${targetPath}" by ${options.markAsRemoved ? `marking key "${key}" of parent node "${path3}" as removed ("${removedValueIndicator}")` : `removing key "${key}" from parent node "${path3}"`}`);
      this.invalidateCache(false, targetPath, true);
    } finally {
      await lock.release();
    }
  }
  async repairNodeTree(path3) {
    this.debug.warn(`Starting node tree repair for path "/${path3}"`);
    const tid = this.createTid();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), true, "repairNodeTree");
    try {
      this.invalidateCache(false, path3, true);
      const nodeInfo = await (async () => {
        try {
          return await this.getNodeInfo(path3, { tid });
        } catch (err) {
          throw new Error(`Can't read parent node ${path3}: ${err}`);
        }
      })();
      if (!nodeInfo.exists) {
        throw new Error(`Node at path ${path3} does not exist`);
      } else if (!nodeInfo.address) {
        throw new Error(`Node at ${path3} is not stored in its own record`);
      }
      const nodeReader = new NodeReader(this, nodeInfo.address, lock, false);
      const recordInfo = await nodeReader.readHeader();
      if (!recordInfo.hasKeyIndex) {
        throw new Error(`Node at ${path3} does not have a B+Tree key index`);
      }
      const tree = new BinaryBPlusTree({
        readFn: nodeReader._treeDataReader.bind(nodeReader),
        debug: this.debug,
        id: `path:${path3}`
      });
      const newRecordInfo = await _rebuildKeyTree(tree, nodeReader, { repairMode: true });
      if (newRecordInfo !== recordInfo) {
        const deallocate = new NodeAllocation(recordInfo.allocation.ranges);
        const pathInfo = PathInfo.get(path3);
        if (pathInfo.parentPath !== null) {
          lock = await lock.moveToParent();
          await this._updateNode(pathInfo.parentPath, { [pathInfo.key]: new InternalNodeReference(newRecordInfo.valueType, newRecordInfo.address) }, { merge: true, tid, _internal: true, context: { acebase_repair: { path: path3, method: "node-tree" } } });
        }
        if (deallocate.totalAddresses > 0) {
          deallocate.normalize();
          this.debug.verbose(`Releasing ${deallocate.totalAddresses} addresses (${deallocate.ranges.length} ranges) previously used by node "/${path3}" and/or descendants: ${deallocate}`.colorize(ColorStyle.grey));
          await this.FST.release(deallocate.ranges);
        }
      }
      this.debug.warn(`Successfully repaired node tree for path "/${path3}"`);
    } catch (err) {
      this.debug.error(`Failed to repair node tree for path "/${path3}": ${err.stack}`);
    } finally {
      lock.release();
    }
  }
  get transactionLoggingEnabled() {
    return this.settings.transactions && this.settings.transactions.log === true;
  }
  logMutation(type, path3, value, context, mutations) {
    if (!["set", "update"].includes(type)) {
      throw new TypeError('type must be either "set" or "update"');
    }
    if (!this.transactionLoggingEnabled) {
      throw new Error("transaction logging is not enabled on database");
    }
    if (!context.acebase_cursor) {
      throw new Error("context.acebase_cursor must have been set");
    }
    if (mutations.list.length === 0) {
      return;
    }
    if (path3.startsWith("__")) {
      return;
    }
    if (this.type === "data") {
      return this.txStorage.logMutation(type, path3, value, context, mutations);
    } else if (this.type !== "transaction") {
      throw new Error("Wrong database type");
    }
    if (value === null) {
      const pathInfo = PathInfo.get(path3);
      type = "update";
      path3 = pathInfo.parentPath;
      value = { [pathInfo.key]: null };
    }
    const updatedKeys = mutations.path === path3 ? mutations.list.filter((ch) => ch.target.length > 0 && ch.val !== null).map((ch) => ch.target[0]) : value instanceof Array ? Object.keys(value).map((key) => +key) : Object.keys(value).filter((key) => value[key] !== null);
    const deletedKeys = mutations.path === path3 ? mutations.list.filter((ch) => ch.target.length === 1 && ch.val === null).map((ch) => ch.target[0]) : [];
    const item = {
      path: path3,
      updated: updatedKeys,
      deleted: deletedKeys,
      timestamp: Date.now(),
      type,
      value,
      context,
      mutations
    };
    const cursor = context.acebase_cursor;
    const store2 = async () => {
      if (!this.isReady) {
        await this.once("ready");
      }
      try {
        await this._updateNode("history", { [cursor]: item }, { merge: true, _internal: true });
      } catch (err) {
        this.debug.error("Failed to add to transaction log: ", err);
      }
    };
    const promise = store2();
    if (!this.settings.transactions.noWait) {
      return promise.then(() => cursor);
    }
    return cursor;
  }
  async getMutations(filter2) {
    if (this.type === "data") {
      if (!this.transactionLoggingEnabled) {
        throw new Error("Transaction logging is not enabled");
      }
      return this.txStorage.getMutations(filter2);
    } else if (this.type !== "transaction") {
      throw new Error("Wrong database type");
    }
    if (!this.isReady) {
      await this.once("ready");
    }
    const cursor = filter2.cursor && filter2.cursor.slice(0, 8) || filter2.timestamp && new Date(filter2.timestamp).getTime().toString(36).padStart(8, "0") || "00000000";
    const since = typeof filter2.timestamp === "number" && filter2.timestamp || cursor && parseInt(cursor, 36) || 0;
    if (since !== 0 && cursor < this.oldestValidCursor) {
      throw new Error("Cursor too old");
    }
    if (!filter2.for || filter2.for.length === 0) {
      filter2.for = [{ path: typeof filter2.path === "string" ? filter2.path : "", events: ["value"] }];
    }
    const filterPaths = filter2.for.filter((t1) => {
      const pathInfo = PathInfo.get(t1.path);
      return !filter2.for.some((t2) => pathInfo.isDescendantOf(t2.path));
    }).map((item) => item.path);
    const tid = this.createTid();
    const lock = await this.nodeLocker.lock("history", tid.toString(), false, "getMutations");
    try {
      let mutations = [];
      const checkQueue = [];
      let done;
      const donePromise = new Promise((resolve) => done = resolve);
      let allEnumerated = false;
      const hasValue = (val) => ![void 0, null].includes(val);
      const hasPropertyValue = (val, prop) => hasValue(val) && typeof val === "object" && hasValue(val[prop]);
      const check = async (key) => {
        checkQueue.push(key);
        const { value: mutation } = await this.getNode(`history/${key}`, { tid, include: ["path", "updated", "deleted", "type", "timestamp"] });
        mutation.keys = mutation.updated.concat(mutation.deleted);
        const mutationPathInfo = PathInfo.get(mutation.path);
        const filterPath = (() => {
          const path3 = filterPaths.find((path4) => mutationPathInfo.isOnTrailOf(path4));
          return typeof path3 === "string" ? path3 : null;
        })();
        const filterPathInfo = filterPath === null ? null : PathInfo.get(filterPath);
        const load = (() => {
          if (mutation.path.startsWith("__")) {
            return "none";
          }
          if (mutation.timestamp < since || filterPath === null) {
            return "none";
          }
          if (!filterPathInfo.isDescendantOf(mutationPathInfo)) {
            return "all";
          }
          if (mutation.type === "set" || mutation.keys.concat("*").includes(filterPathInfo.keys[mutationPathInfo.keys.length]) || filterPathInfo.keys[mutationPathInfo.keys.length].toString().startsWith("$")) {
            return "target";
          }
          return "none";
        })();
        if (load !== "none") {
          const valueKey = "value" + (load === "target" ? (mutation.path.length === 0 ? "/" : "") + filterPath.slice(mutation.path.length) : "");
          const { value: tx } = await this.getNode(`history/${key}`, { tid, include: ["context", "mutations", valueKey] });
          const targetPath = mutation.path;
          let targetValue = tx.value, targetOp = mutation.type;
          if (typeof targetValue === "undefined") {
            targetValue = null;
          } else {
            mutation.deleted.forEach((key2) => targetValue[key2] = null);
          }
          for (const m of tx.mutations.list) {
            if (typeof m.val === "undefined") {
              m.val = null;
            }
            if (typeof m.prev === "undefined") {
              m.prev = null;
            }
          }
          if (load === "target") {
            targetOp = "set";
            const trailKeys = filterPathInfo.keys.slice(mutationPathInfo.keys.length);
            const process9 = (targetPath2, targetValue2, trailKeys2) => {
              const childKey = trailKeys2[0];
              trailKeys2 = trailKeys2.slice(1);
              if (childKey === "*" || childKey.toString().startsWith("$")) {
                return Object.keys(targetValue2).forEach((childKey2) => {
                  process9(targetPath2, targetValue2, [childKey2, ...trailKeys2]);
                });
              }
              targetPath2 = PathInfo.getChildPath(targetPath2, childKey);
              targetValue2 = targetValue2 !== null && childKey in targetValue2 ? targetValue2[childKey] : null;
              if (trailKeys2.length === 0) {
                const targetPathInfo = PathInfo.get(targetPath2);
                const hasTargetMutation = tx.mutations.list.some((m) => {
                  const mTargetPathInfo = PathInfo.get(tx.mutations.path).child(m.target);
                  if (mTargetPathInfo.isAncestorOf(targetPathInfo)) {
                    const trailKeys3 = targetPathInfo.keys.slice(mTargetPathInfo.keys.length);
                    const val = !hasValue(m.val) ? null : trailKeys3.reduce((val2, key2) => hasPropertyValue(val2, key2) ? val2[key2] : null, m.val);
                    const prev = !hasValue(m.prev) ? null : trailKeys3.reduce((prev2, key2) => hasPropertyValue(prev2, key2) ? prev2[key2] : null, m.prev);
                    return val !== prev;
                  }
                  return mTargetPathInfo.isOnTrailOf(targetPathInfo);
                });
                hasTargetMutation && mutations.push({ id: key, path: targetPath2, type: targetOp, timestamp: mutation.timestamp, value: targetValue2, context: tx.context, changes: tx.mutations });
              } else {
                process9(targetPath2, targetValue2, trailKeys2);
              }
            };
            process9(targetPath, targetValue, trailKeys);
          } else {
            mutations.push({ id: key, path: targetPath, type: targetOp, timestamp: mutation.timestamp, value: targetValue, context: tx.context, changes: tx.mutations });
          }
        }
        checkQueue.splice(checkQueue.indexOf(key), 1);
        if (allEnumerated && checkQueue.length === 0) {
          done();
        }
      };
      let count = 0;
      const oldestValidCursor = this.oldestValidCursor, expiredTransactions = [], inspectFurther = [];
      try {
        await this.getChildren("history", { tid }).next((childInfo) => {
          const txCursor = childInfo.key.slice(0, cursor.length);
          if (txCursor < oldestValidCursor) {
            expiredTransactions.push(childInfo.key);
          }
          if (txCursor < cursor) {
            return;
          }
          if (txCursor === cursor) {
            inspectFurther.push(childInfo.key);
          }
          count++;
          check(childInfo.key);
        });
      } catch (err) {
        if (!(err instanceof NodeNotFoundError)) {
          throw err;
        }
      }
      allEnumerated = true;
      if (count > 0) {
        await donePromise;
      }
      if (expiredTransactions.length > 0) {
        const expiredUpdate = expiredTransactions.reduce((updates, key) => {
          updates[key] = null;
          return updates;
        }, {});
        this.updateNode("history", expiredUpdate);
      }
      if (inspectFurther.length === 1 && inspectFurther[0] === filter2.cursor) {
        const index = mutations.findIndex((m) => m.id === filter2.cursor);
        index >= 0 && mutations.splice(index, 1);
      } else if (inspectFurther.length > 1) {
      }
      mutations.sort((a, b) => a.timestamp - b.timestamp);
      const hasNewKeys = (val, prev) => Object.keys(val || {}).some((key) => !(key in (prev || {})));
      const hasRemovedKeys = (val, prev) => Object.keys(prev || {}).some((key) => !(key in (val || {})));
      const allEventsFor = (...events) => events.concat(...events.map((e) => `notify_${e}`));
      const hasEvent = (events, check2) => allEventsFor(...check2).some((e) => events.includes(e));
      mutations = mutations.filter((item) => {
        const changes = (() => {
          const basePathInfo = PathInfo.get(item.changes.path);
          if (basePathInfo.isAncestorOf(item.path)) {
            for (let i = 0; i < item.changes.list.length; i++) {
              const ch = item.changes.list[i];
              const trailKeys = PathInfo.get(item.path).keys.slice(basePathInfo.keys.length);
              const onTarget = ch.target.every((key, index) => key === trailKeys[index]);
              if (!onTarget) {
                item.changes.list.splice(i, 1);
                i--;
                continue;
              }
              trailKeys.splice(0, ch.target.length);
              const val = !hasValue(ch.val) ? null : trailKeys.reduce((val2, key) => hasPropertyValue(val2, key) ? val2[key] : null, ch.val);
              const prev = !hasValue(ch.prev) ? null : trailKeys.reduce((prev2, key) => hasPropertyValue(prev2, key) ? prev2[key] : null, ch.prev);
              if (val === prev) {
                item.changes.list.splice(i, 1);
                i--;
                continue;
              }
              ch.val = val;
              ch.prev = prev;
              ch.target.push(...trailKeys);
            }
            if (item.changes.list.length === 0) {
              return [];
            }
          }
          return item.changes.list.map((m) => {
            const targetPathInfo = m.target.length === 0 ? basePathInfo : basePathInfo.child(m.target);
            return {
              id: item.id,
              type: "set",
              path: targetPathInfo.path,
              pathInfo: targetPathInfo,
              timestamp: item.timestamp,
              context: item.context,
              prev: hasValue(m.prev) ? m.prev : null,
              val: hasValue(m.val) ? m.val : null
            };
          });
        })();
        return changes.some((ch) => {
          return filter2.for.some((target) => {
            if (!ch.pathInfo.isOnTrailOf(target.path)) {
              return false;
            } else if ((ch.pathInfo.equals(target.path) || ch.pathInfo.isDescendantOf(target.path)) && hasEvent(target.events, ["value", "child_changed", "mutated", "mutations"])) {
              return true;
            } else if (ch.pathInfo.equals(target.path)) {
              if (hasEvent(target.events, ["value", "child_changed", "mutated", "mutations"])) {
                return true;
              }
              if (hasEvent(target.events, ["child_added"]) && hasNewKeys(ch.val, ch.prev)) {
                return true;
              }
              if (hasEvent(target.events, ["child_removed"]) && hasRemovedKeys(ch.val, ch.prev)) {
                return true;
              }
            } else if (ch.pathInfo.isDescendantOf(target.path)) {
              if (hasEvent(target.events, ["child_added", "child_removed"])) {
                if (!ch.pathInfo.isChildOf(target.path)) {
                  return false;
                }
                if (hasEvent(target.events, ["child_added"]) && ch.prev === null) {
                  return true;
                }
                if (hasEvent(target.events, ["child_removed"]) && ch.val === null) {
                  return true;
                }
              }
            } else {
              const trailKeys = PathInfo.getPathKeys(target.path).slice(ch.pathInfo.keys.length);
              const prev = trailKeys.reduce((prev2, key) => hasValue(prev2) && hasPropertyValue(prev2, key) ? prev2[key] : null, ch.prev);
              const val = trailKeys.reduce((val2, key) => hasValue(val2) && hasPropertyValue(val2, key) ? val2[key] : null, ch.val);
              if (prev === val) {
                return false;
              }
              if (hasEvent(target.events, ["value", "mutated", "mutations"])) {
                return true;
              }
              if (hasEvent(target.events, ["child_added"]) && hasNewKeys(val, prev)) {
                return true;
              }
              if (hasEvent(target.events, ["child_removed"]) && hasRemovedKeys(val, prev)) {
                return true;
              }
            }
            return false;
          });
        });
      });
      return { mutations, used_cursor: filter2.cursor, new_cursor: ID.generate() };
    } finally {
      lock.release();
    }
  }
  async getChanges(filter2) {
    const mutationsResult = await this.getMutations(filter2);
    const { used_cursor, new_cursor, mutations } = mutationsResult;
    const hasValue = (val) => ![void 0, null].includes(val);
    const arr = mutations.reduce((all3, item) => {
      const basePathInfo = PathInfo.get(item.changes.path);
      item.changes.list.forEach((m) => {
        const targetPathInfo = m.target.length === 0 ? basePathInfo : basePathInfo.child(m.target);
        all3 = all3.filter((prev) => !prev.pathInfo.equals(targetPathInfo) && !prev.pathInfo.isDescendantOf(targetPathInfo));
        all3.push({
          id: item.id,
          type: "set",
          path: targetPathInfo.path,
          pathInfo: targetPathInfo,
          timestamp: item.timestamp,
          context: item.context,
          prev: hasValue(m.prev) ? m.prev : null,
          val: hasValue(m.val) ? m.val : null
        });
      });
      return all3;
    }, []).reduce((all3, item) => {
      if (item.path === "") {
        all3.push(item);
      } else {
        const pathInfo = item.pathInfo;
        const parentPath = pathInfo.parentPath;
        const parentUpdate = all3.find((u) => u.path === parentPath);
        if (!parentUpdate) {
          all3.push({
            id: item.id,
            type: "update",
            path: parentPath,
            pathInfo: pathInfo.parent,
            val: { [pathInfo.key]: item.val },
            prev: { [pathInfo.key]: item.prev },
            context: item.context
          });
        } else {
          parentUpdate.val[pathInfo.key] = item.val;
          if (parentUpdate.prev !== null) {
            parentUpdate.prev[pathInfo.key] = item.prev;
          }
          parentUpdate.context = item.context;
        }
      }
      return all3;
    }, []);
    const changes = arr.map((item) => ({
      id: item.id,
      type: item.type,
      path: item.path,
      context: { acebase_cursor: item.context.acebase_cursor },
      value: item.val,
      previous: item.prev
    }));
    return { used_cursor, new_cursor, changes };
  }
  get oldestValidCursor() {
    if (this.settings.transactions.maxAge <= 0) {
      return "";
    }
    const msPerDay = 864e5, maxAgeMs = this.settings.transactions.maxAge * msPerDay, limit = Date.now() - maxAgeMs, cursor = limit.toString(36);
    return cursor;
  }
  getChildren(path3, options = {
    async: false
  }) {
    if (typeof options.async !== "boolean") {
      options.async = false;
    }
    const generator = {
      async next(valueCallback, useAsync = options.async) {
        return start(valueCallback, useAsync);
      }
    };
    const start = async (callback, isAsync = false) => {
      const tid = this.createTid();
      let canceled = false;
      const lock = await this.nodeLocker.lock(path3, tid.toString(), false, `storage.getChildren "/${path3}"`);
      try {
        const nodeInfo = await this.getNodeInfo(path3, { tid });
        if (!nodeInfo.exists) {
          throw new NodeNotFoundError(`Node "/${path3}" does not exist`);
        } else if (!nodeInfo.address) {
          return;
        }
        const reader = new NodeReader(this, nodeInfo.address, lock, true);
        const nextCallback = isAsync ? async (childInfo) => {
          canceled = await callback(childInfo) === false;
          return !canceled;
        } : (childInfo) => {
          canceled = callback(childInfo) === false;
          return !canceled;
        };
        await reader.getChildStream({ keyFilter: options.keyFilter }).next(nextCallback, isAsync);
        return canceled;
      } catch (err) {
        if (!(err instanceof NodeNotFoundError)) {
          this.debug.error(`Error getting children: ${err.stack}`);
        }
        throw err;
      } finally {
        lock.release();
      }
    };
    return generator;
  }
  async getNode(path3, options = { child_objects: true }) {
    const tid = options.tid || this.createTid();
    const lock = await this.nodeLocker.lock(path3, tid.toString(), false, `storage.getNode "/${path3}"`);
    try {
      const cursor = this.transactionLoggingEnabled ? ID.generate() : void 0;
      const nodeInfo = await this.getNodeInfo(path3, { tid });
      let value = nodeInfo.value;
      if (!nodeInfo.exists) {
        value = null;
      } else if (nodeInfo.address) {
        const reader = new NodeReader(this, nodeInfo.address, lock, true);
        value = await reader.getValue({
          include: options.include,
          exclude: options.exclude,
          child_objects: options.child_objects
        });
      }
      return {
        revision: null,
        value,
        cursor
      };
    } catch (err) {
      if (err instanceof CorruptRecordError) {
      } else {
        this.debug.error("DEBUG THIS: getNode error:", err);
      }
      throw err;
    } finally {
      lock.release();
    }
  }
  async getNodeInfo(path3, options = {
    no_cache: false,
    include_child_count: false,
    allow_expand: false
  }) {
    options.no_cache = options.no_cache === true;
    options.include_child_count = options.include_child_count === true;
    options.allow_expand = false;
    const tid = options.tid || this.createTid();
    const getChildCount = async (nodeInfo) => {
      let childCount = 0;
      if ([VALUE_TYPES.ARRAY, VALUE_TYPES.OBJECT].includes(nodeInfo.valueType) && nodeInfo.address) {
        const childLock = await this.nodeLocker.lock(path3, tid.toString(), false, `storage.getNodeInfo "/${path3}"`);
        try {
          const childReader = new NodeReader(this, nodeInfo.address, childLock, true);
          childCount = await childReader.getChildCount();
        } finally {
          childLock.release(`storage.getNodeInfo: done with path "/${path3}"`);
        }
      }
      return childCount;
    };
    if (path3 === "") {
      const rootLock = await this.nodeLocker.lock("", tid.toString(), false, 'storage.getNodeInfo "/"');
      try {
        if (!this.rootRecord.exists) {
          return new BinaryNodeInfo({ path: path3, exists: false });
        }
        const info = new BinaryNodeInfo({ path: path3, address: this.rootRecord.address, exists: true, type: VALUE_TYPES.OBJECT });
        if (options.include_child_count) {
          info.childCount = await getChildCount(info);
        }
        return info;
      } finally {
        rootLock.release();
      }
    }
    const allowCachedInfo = options.no_cache !== true && options.include_child_count !== true;
    if (allowCachedInfo) {
      const cachedInfo = this.nodeCache.find(path3, true);
      if (cachedInfo) {
        return cachedInfo;
      }
    }
    const pathInfo = PathInfo.get(path3);
    const parentPath = pathInfo.parentPath;
    const lock = await this.nodeLocker.lock(parentPath, tid.toString(), false, `storage.getNodeInfo "/${parentPath}"`);
    try {
      let childInfo = this.nodeCache.find(path3, true);
      if (childInfo instanceof Promise) {
        childInfo = await childInfo;
      }
      if (childInfo && !options.include_child_count) {
        return childInfo;
      }
      if (!childInfo) {
        this.nodeCache.announce(path3);
        const parentInfo = await this.getNodeInfo(parentPath, { tid, no_cache: options.no_cache });
        if (parentInfo.exists && parentInfo.valueType === VALUE_TYPES.REFERENCE && options.allow_expand) {
          let pathReference;
          if (parentInfo.address) {
            const reader = new NodeReader(this, parentInfo.address, lock, true);
            pathReference = await reader.getValue();
          } else {
            pathReference = parentInfo.value;
          }
          const childPath = PathInfo.getChildPath(pathReference.path, pathInfo.key);
          childInfo = await this.getNodeInfo(childPath, { tid, no_cache: options.no_cache });
        } else if (!parentInfo.exists || ![VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(parentInfo.valueType) || !parentInfo.address) {
          childInfo = new BinaryNodeInfo({ path: path3, exists: false });
        } else {
          const reader = new NodeReader(this, parentInfo.address, lock, true);
          childInfo = await reader.getChildInfo(pathInfo.key);
        }
      }
      if (options.include_child_count) {
        childInfo.childCount = await getChildCount(childInfo);
      }
      this.updateCache(false, childInfo, false);
      return childInfo;
    } catch (err) {
      this.debug.error("DEBUG THIS: getNodeInfo error", err);
      throw err;
    } finally {
      lock.release(`storage.getNodeInfo: done with path "/${parentPath}"`);
    }
  }
  async setNode(path3, value, options = {
    suppress_events: false,
    context: null
  }) {
    options.context = options.context || {};
    if (this.txStorage) {
      options.context.acebase_cursor = ID.generate();
    }
    const context = cloneObject2(options.context);
    const mutations = await this._updateNode(path3, value, { merge: false, tid: options.tid, suppress_events: options.suppress_events, context });
    if (this.txStorage && mutations) {
      const p = this.logMutation("set", path3, value, context, mutations);
      if (p instanceof Promise) {
        await p;
      }
    }
    return options.context.acebase_cursor;
  }
  async updateNode(path3, updates, options = {
    suppress_events: false,
    context: null
  }) {
    options.context = options.context || {};
    if (this.txStorage) {
      options.context.acebase_cursor = ID.generate();
    }
    const context = cloneObject2(options.context);
    const mutations = await this._updateNode(path3, updates, { merge: true, tid: options.tid, suppress_events: options.suppress_events, context });
    if (this.txStorage && mutations) {
      const p = this.logMutation("update", path3, updates, context, mutations);
      if (p instanceof Promise) {
        await p;
      }
    }
    return options.context.acebase_cursor;
  }
  async _updateNode(path3, value, options = {
    merge: true,
    _internal: false,
    suppress_events: false,
    context: null
  }) {
    const tid = options.tid || this.createTid();
    const pathInfo = PathInfo.get(path3);
    if (value === null) {
      return this._updateNode(pathInfo.parentPath, { [pathInfo.key]: null }, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
    }
    if (path3 !== "" && this.valueFitsInline(value)) {
      return this._updateNode(pathInfo.parentPath, { [pathInfo.key]: value }, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
    }
    let lock = await this.nodeLocker.lock(path3, tid.toString(), true, "_updateNode");
    try {
      const nodeInfo = await this.getNodeInfo(path3, { tid });
      if (!nodeInfo.exists && path3 !== "") {
        lock = await lock.moveToParent();
        return await this._updateNode(pathInfo.parentPath, { [pathInfo.key]: value }, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
      }
      const merge2 = nodeInfo.exists && nodeInfo.address && options.merge;
      const write2 = async () => {
        if (merge2) {
          return await _mergeNode(this, nodeInfo, value, lock);
        } else {
          return await _createNode(this, nodeInfo, value, lock, !options._internal);
        }
      };
      let result;
      if (options._internal) {
        result = await write2();
      } else {
        result = await this._writeNodeWithTracking(path3, value, {
          tid,
          merge: merge2,
          suppress_events: options.suppress_events,
          context: options.context,
          _customWriteFunction: write2
        });
      }
      const { recordMoved, recordInfo, deallocate, mutations } = result;
      let parentUpdated = false;
      if (recordMoved && pathInfo.parentPath !== null) {
        lock = await lock.moveToParent();
        await this._updateNode(pathInfo.parentPath, { [pathInfo.key]: new InternalNodeReference(recordInfo.valueType, recordInfo.address) }, { merge: true, tid, _internal: true, context: options.context });
        parentUpdated = true;
      }
      if (parentUpdated && pathInfo.parentPath !== "") {
        console.assert(this.nodeCache.has(pathInfo.parentPath), "Not cached?!!");
      }
      if (deallocate && deallocate.totalAddresses > 0) {
        deallocate.normalize();
        this.debug.verbose(`Releasing ${deallocate.totalAddresses} addresses (${deallocate.ranges.length} ranges) previously used by node "/${path3}" and/or descendants: ${deallocate}`.colorize(ColorStyle.grey));
        this.FST.release(deallocate.ranges);
      }
      return {
        path: path3,
        list: mutations
      };
    } finally {
      lock.release();
    }
  }
};
var BINARY_TREE_FILL_FACTOR_50 = 50;
var BINARY_TREE_FILL_FACTOR_95 = 95;
var FLAG_KEY_TREE = 64;
var FLAG_VALUE_TYPE = 15;
var StorageAddressRange = class {
  constructor(pageNr, recordNr, length3) {
    this.pageNr = pageNr;
    this.recordNr = recordNr;
    this.length = length3;
  }
};
var StorageAddress = class {
  constructor(pageNr, recordNr) {
    this.pageNr = pageNr;
    this.recordNr = recordNr;
  }
};
var NodeAllocation = class {
  constructor(ranges) {
    this.ranges = ranges;
  }
  get addresses() {
    const addresses = [];
    this.ranges.forEach((range) => {
      for (let i = 0; i < range.length; i++) {
        const address = new StorageAddress(range.pageNr, range.recordNr + i);
        addresses.push(address);
      }
    });
    return addresses;
  }
  get totalAddresses() {
    return this.ranges.map((range) => range.length).reduce((total, nr) => total + nr, 0);
  }
  toChunkTable() {
    const ranges = this.ranges.map((range) => new NodeChunkTableRange(0, range.pageNr, range.recordNr, range.length));
    if (ranges.length === 1 && ranges[0].length === 1) {
      ranges[0].type = 0;
    } else {
      ranges.forEach((range, index) => {
        if (index === 0) {
          range.type = 1;
        } else {
          range.type = 2;
        }
      });
    }
    return new NodeChunkTable(ranges);
  }
  static fromAdresses(records) {
    if (records.length === 0) {
      throw new Error("Cannot create allocation for 0 addresses");
    }
    let range = new StorageAddressRange(records[0].pageNr, records[0].recordNr, 1);
    const ranges = [range];
    for (let i = 1; i < records.length; i++) {
      if (records[i].pageNr !== range.pageNr || records[i].recordNr !== range.recordNr + range.length) {
        range = new StorageAddressRange(records[i].pageNr, records[i].recordNr, 1);
        ranges.push(range);
      } else {
        range.length++;
      }
    }
    return new NodeAllocation(ranges);
  }
  toString() {
    return this.ranges.map((range) => {
      return `${range.pageNr},${range.recordNr}+${range.length - 1}`;
    }).join("; ");
  }
  normalize() {
    const total = this.totalAddresses;
    for (let i = 0; i < this.ranges.length; i++) {
      const range = this.ranges[i];
      let adjRange;
      for (let j = i + 1; j < this.ranges.length; j++) {
        const otherRange = this.ranges[j];
        if (otherRange.pageNr !== range.pageNr) {
          continue;
        }
        if (otherRange.recordNr === range.recordNr + range.length) {
          otherRange.length += range.length;
          otherRange.recordNr = range.recordNr;
          adjRange = otherRange;
          break;
        }
        if (range.recordNr === otherRange.recordNr + otherRange.length) {
          otherRange.length += range.length;
          adjRange = otherRange;
          break;
        }
      }
      if (adjRange) {
        this.ranges.splice(i, 1);
        i--;
      }
    }
    console.assert(this.totalAddresses === total, "the amount of addresses changed during normalization");
  }
};
var NodeChunkTable = class {
  constructor(ranges) {
    this.ranges = ranges;
  }
};
var NodeChunkTableRange = class {
  constructor(type, pageNr, recordNr, length3) {
    this.type = type;
    this.pageNr = pageNr;
    this.recordNr = recordNr;
    this.length = length3;
  }
};
var RecordInfo = class {
  constructor(path3, hasKeyIndex, valueType, allocation, headerLength, lastRecordLength, bytesPerRecord, startData) {
    this.path = path3;
    this.hasKeyIndex = hasKeyIndex;
    this.valueType = valueType;
    this.allocation = allocation;
    this.headerLength = headerLength;
    this.lastRecordLength = lastRecordLength;
    this.bytesPerRecord = bytesPerRecord;
    this.startData = startData;
    this.lastChunkSize = -1;
    this.fileIndex = -1;
    this.timestamp = -1;
  }
  get totalByteLength() {
    if (this.allocation.ranges.length === 1 && this.allocation.ranges[0].length === 1) {
      return this.lastRecordLength;
    }
    const byteLength = (this.allocation.totalAddresses - 1) * this.bytesPerRecord + this.lastRecordLength - this.headerLength;
    return byteLength;
  }
  get address() {
    const firstRange = this.allocation.ranges[0];
    return new BinaryNodeAddress(this.path, firstRange.pageNr, firstRange.recordNr);
  }
};
var AdditionalDataRequest = class extends Error {
  constructor() {
    super("More data needs to be loaded from the source");
  }
};
var CorruptRecordError = class extends Error {
  constructor(record, key, message) {
    super(message);
    this.record = record;
    this.key = key;
  }
};
var NodeReader = class {
  constructor(storage, address, lock, updateCache = false, stack = {}) {
    this.storage = storage;
    this.address = address;
    this.lock = lock;
    this.updateCache = updateCache;
    this.stack = stack;
    this.recordInfo = null;
    if (!(address instanceof BinaryNodeAddress)) {
      throw new TypeError("address argument must be a BinaryNodeAddress");
    }
    const key = `${address.pageNr},${address.recordNr}`;
    if (key in stack) {
      const clash = stack[key];
      const pathInfo = PathInfo.get(address.path);
      const parentAddress = stack[Object.keys(stack).find((key2) => stack[key2].path === pathInfo.parentPath)];
      const error = new CorruptRecordError(parentAddress, pathInfo.key, `CORRUPT RECORD: key "${pathInfo.key}" in "/${parentAddress.path}" (@${parentAddress.pageNr},${parentAddress.recordNr}) refers to address @${clash.pageNr},${clash.recordNr} which was already used to read "/${clash.path}". Recursive or repeated reading has been prevented.`);
      this.storage.debug.error(error.message);
      throw error;
    }
    stack[key] = address;
    this.stack = stack;
    this._assertLock();
  }
  _assertLock() {
    const expired = this.storage.ipc.isMaster ? this.lock.state !== NodeLock.LOCK_STATE.LOCKED : this.lock.expires <= Date.now();
    if (expired) {
      throw new Error(`No lock on node "/${this.address.path}", it may have expired`);
    }
  }
  async getAllocation(includeChildNodes = false) {
    this._assertLock();
    if (!includeChildNodes && this.recordInfo !== null) {
      return this.recordInfo.allocation;
    }
    let allocation = null;
    await this.readHeader();
    allocation = this.recordInfo.allocation;
    if (!includeChildNodes) {
      return [{ path: this.address.path, allocation }];
    }
    const childPromises = [];
    await this.getChildStream().next((child) => {
      const address = child.address;
      if (address) {
        const promise = this.storage.nodeLocker.lock(child.path, this.lock.tid, false, `NodeReader:getAllocation:child "/${child.path}"`).then(async (childLock) => {
          const reader = new NodeReader(this.storage, address, childLock, this.updateCache);
          const childAllocation = await reader.getAllocation(true);
          childLock.release();
          return { path: child.path, allocation: childAllocation };
        });
        childPromises.push(promise);
      }
    });
    const arr = await Promise.all(childPromises);
    arr.forEach((result) => {
      allocation.ranges.push(...result.allocation.ranges);
    });
    return allocation;
  }
  async getAllData() {
    this._assertLock();
    if (this.recordInfo === null) {
      await this.readHeader();
    }
    const allData = new Uint8Array(this.recordInfo.totalByteLength);
    let index = 0;
    await this.getDataStream().next(({ data }) => {
      allData.set(data, index);
      index += data.length;
    });
    return allData;
  }
  async getValue(options = {
    child_objects: true,
    no_cache: false
  }) {
    if (typeof options.include !== "undefined" && !(options.include instanceof Array)) {
      throw new TypeError("options.include must be an array of key names");
    }
    if (typeof options.exclude !== "undefined" && !(options.exclude instanceof Array)) {
      throw new TypeError("options.exclude must be an array of key names");
    }
    if (["undefined", "boolean"].indexOf(typeof options.child_objects) < 0) {
      throw new TypeError("options.child_objects must be a boolean");
    }
    this._assertLock();
    if (this.recordInfo === null) {
      await this.readHeader();
    }
    this.storage.debug.log(`Reading node "/${this.address.path}" from address ${this.address.pageNr},${this.address.recordNr}`.colorize(ColorStyle.magenta));
    switch (this.recordInfo.valueType) {
      case VALUE_TYPES.STRING: {
        const binary = await this.getAllData();
        const str = decodeString4(binary);
        return str;
      }
      case VALUE_TYPES.REFERENCE: {
        const binary = await this.getAllData();
        const path3 = decodeString4(binary);
        return new PathReference(path3);
      }
      case VALUE_TYPES.BINARY: {
        const binary = await this.getAllData();
        return binary.buffer;
      }
      case VALUE_TYPES.ARRAY:
      case VALUE_TYPES.OBJECT: {
        const isArray2 = this.recordInfo.valueType === VALUE_TYPES.ARRAY;
        const convertFilterArray = (arr) => {
          const isNumber2 = (key) => /^[0-9]+$/.test(key);
          return arr.map((path3) => PathInfo.get(isArray2 && isNumber2(path3) ? `[${path3}]` : path3));
        };
        const includeFilter = options.include ? options.include.some((item) => item instanceof PathInfo) ? options.include : convertFilterArray(options.include) : [];
        const excludeFilter = options.exclude ? options.exclude.some((item) => item instanceof PathInfo) ? options.exclude : convertFilterArray(options.exclude) : [];
        const promises = [];
        const isWildcardKey = (key) => typeof key === "string" && (key === "*" || key[0] === "$");
        const hasWildcardInclude = includeFilter.length > 0 && includeFilter.some((pathInfo) => pathInfo.keys.length === 1 && isWildcardKey(pathInfo.keys[0]));
        const hasChildIncludes = includeFilter.length > 0 && includeFilter.some((pathInfo) => pathInfo.keys.length === 1 && !isWildcardKey(pathInfo.keys[0]));
        const isFiltered = includeFilter.length > 0 && !hasWildcardInclude && includeFilter.some((pathInfo) => pathInfo.keys.length === 1) || excludeFilter.length > 0 && excludeFilter.some((pathInfo) => pathInfo.keys.length === 1) || options.child_objects === false;
        const obj = isArray2 ? isFiltered ? new PartialArray() : [] : {};
        const streamOptions = {};
        if (includeFilter.length > 0 && !hasWildcardInclude && hasChildIncludes) {
          const keyFilter = includeFilter.filter((pathInfo) => !isWildcardKey(pathInfo.keys[0])).map((pathInfo) => pathInfo.keys[0]).reduce((keys, key) => (keys.includes(key) || keys.push(key)) && keys, []);
          if (keyFilter.length > 0) {
            streamOptions.keyFilter = keyFilter;
          }
        }
        const loadChildValue = async (child) => {
          let childLock;
          try {
            childLock = await this.storage.nodeLocker.lock(child.address.path, this.lock.tid, false, `NodeReader.getValue:child "/${child.address.path}"`);
            const childOptions = {};
            const getChildFilter = (filter2) => {
              return filter2.filter((pathInfo) => {
                const key = pathInfo.keys[0];
                return pathInfo.keys.length > 1 && (isWildcardKey(key) || isArray2 && key === child.index || !isArray2 && key === child.key);
              }).map((pathInfo) => PathInfo.get(pathInfo.keys.slice(1)));
            };
            if (includeFilter.length > 0) {
              const include = getChildFilter(includeFilter);
              if (include.length > 0) {
                childOptions.include = include;
              }
            }
            if (excludeFilter.length > 0) {
              const exclude = getChildFilter(excludeFilter);
              if (exclude.length > 0) {
                childOptions.exclude = exclude;
              }
            }
            const reader = new NodeReader(this.storage, child.address, childLock, this.updateCache, this.stack);
            const val = await reader.getValue(childOptions);
            obj[isArray2 ? child.index : child.key] = val;
          } catch (reason) {
            this.storage.debug.error("NodeReader.getValue:child error: ", reason);
            throw reason;
          } finally {
            childLock && childLock.release();
          }
        };
        try {
          await this.getChildStream(streamOptions).next((child) => {
            const keyOrIndex = isArray2 ? child.index : child.key;
            if (options.child_objects === false && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(child.type)) {
              return;
            }
            if (includeFilter.some((pathInfo) => pathInfo.keys.length === 1 && !isWildcardKey(pathInfo.keys[0])) && !includeFilter.some((pathInfo) => pathInfo.keys.length === 1 && keyOrIndex === pathInfo.keys[0])) {
              return;
            }
            if (excludeFilter.some((pathInfo) => pathInfo.keys.length === 1 && pathInfo.keys[0] === keyOrIndex)) {
              return;
            }
            if (child.address) {
              const childValuePromise = loadChildValue(child);
              promises.push(childValuePromise);
            } else if (typeof child.value !== "undefined") {
              obj[keyOrIndex] = child.value;
            } else {
              if (isArray2) {
                throw new Error(`Value for index ${child.index} has not been set yet, find out why. Path: ${this.address.path}`);
              } else {
                throw new Error(`Value for key ${child.key} has not been set yet, find out why. Path: ${this.address.path}`);
              }
            }
          });
          await Promise.all(promises);
          return obj;
        } catch (err) {
          this.storage.debug.error(err);
          throw err;
        }
      }
      default: {
        throw new Error(`Unsupported record value type: ${this.recordInfo.valueType}`);
      }
    }
  }
  getDataStream() {
    this._assertLock();
    const bytesPerRecord = this.storage.settings.recordSize;
    const maxRecordsPerChunk = this.storage.settings.pageSize;
    const generator = {
      async next(callback) {
        return read2(callback);
      }
    };
    const read2 = async (callback) => {
      const fileIndex = this.storage.getRecordFileIndex(this.address.pageNr, this.address.recordNr);
      if (this.recordInfo === null) {
        await this.readHeader();
      }
      const recordInfo = this.recordInfo;
      const ranges = recordInfo.allocation.ranges;
      const chunks = [];
      let totalBytes = 0;
      ranges.forEach((range, i) => {
        let chunk = {
          pageNr: range.pageNr,
          recordNr: range.recordNr,
          length: range.length
        };
        let chunkLength = chunk.length * bytesPerRecord;
        if (i === ranges.length - 1) {
          chunkLength -= bytesPerRecord;
          chunkLength += recordInfo.lastRecordLength;
        }
        totalBytes += chunkLength;
        if (i === 0 && chunk.length > 1) {
          const remaining = chunk.length - 1;
          chunk.length = 1;
          chunks.push(chunk);
          chunk = {
            pageNr: chunk.pageNr,
            recordNr: chunk.recordNr + 1,
            length: remaining
          };
        }
        while (chunk.length > maxRecordsPerChunk) {
          const remaining = chunk.length - maxRecordsPerChunk;
          chunk.length = maxRecordsPerChunk;
          chunks.push(chunk);
          chunk = {
            pageNr: chunk.pageNr,
            recordNr: chunk.recordNr + maxRecordsPerChunk,
            length: remaining
          };
        }
        chunks.push(chunk);
      });
      const isLastChunk = chunks.length === 1;
      const firstChunkData = recordInfo.startData;
      let headerBytesSkipped = recordInfo.bytesPerRecord - firstChunkData.length;
      const { valueType, hasKeyIndex, headerLength, lastRecordLength } = recordInfo;
      let proceed = firstChunkData.length === 0 || await callback({
        data: firstChunkData,
        valueType,
        chunks,
        chunkIndex: 0,
        totalBytes,
        hasKeyTree: hasKeyIndex,
        fileIndex,
        headerLength
      }) !== false;
      if (isLastChunk) {
        proceed = false;
      }
      let index = 1;
      while (proceed) {
        const chunk = chunks[index];
        let fileIndex2 = this.storage.getRecordFileIndex(chunk.pageNr, chunk.recordNr);
        let length3 = chunk.length * bytesPerRecord;
        if (headerBytesSkipped < recordInfo.headerLength) {
          const remainingHeaderBytes = recordInfo.headerLength - headerBytesSkipped;
          const skip = Math.min(remainingHeaderBytes, length3);
          fileIndex2 += skip;
          length3 -= skip;
          headerBytesSkipped += skip;
          if (length3 == 0) {
            index++;
            continue;
          }
        }
        const isLastChunk2 = index + 1 === chunks.length;
        if (isLastChunk2) {
          length3 -= bytesPerRecord - lastRecordLength;
        }
        const data = new Uint8Array(length3);
        const bytesRead = await this.storage.readData(fileIndex2, data);
        proceed = await callback({
          data,
          valueType,
          chunks,
          chunkIndex: index,
          totalBytes,
          hasKeyTree: hasKeyIndex,
          fileIndex: fileIndex2,
          headerLength
        }) !== false;
        if (isLastChunk2) {
          proceed = false;
        }
        index++;
      }
      return { valueType, chunks };
    };
    return generator;
  }
  getChildStream(options = {}) {
    this._assertLock();
    let callback;
    let isAsync = false;
    let childCount = 0;
    const generator = {
      async next(cb, useAsync = false) {
        callback = cb;
        isAsync = useAsync;
        return start();
      }
    };
    let isArray2 = false;
    const start = async () => {
      if (this.recordInfo === null) {
        await this.readHeader();
      }
      isArray2 = this.recordInfo.valueType === VALUE_TYPES.ARRAY;
      if (this.recordInfo.hasKeyIndex) {
        return createStreamFromBinaryTree();
      } else if (this.recordInfo.allocation.addresses.length === 1) {
        return createStreamFromLinearData(this.recordInfo.startData, true);
      } else {
        return this.getDataStream().next(({ data, chunks, chunkIndex }) => {
          const isLastChunk = chunkIndex === chunks.length - 1;
          return createStreamFromLinearData(data, isLastChunk);
        });
      }
    };
    const createStreamFromBinaryTree = async () => {
      const tree = new BinaryBPlusTree({
        readFn: this._treeDataReader.bind(this),
        debug: this.storage.debug,
        id: `path:${this.address.path}`
      });
      let canceled = false;
      if (options.keyFilter) {
        const results = await tree.findAll(options.keyFilter, { existingOnly: true });
        let i = 0;
        for (const { key, value } of results) {
          const childInfo = isArray2 ? new BinaryNodeInfo({ path: `${this.address.path}[${key}]`, index: key }) : new BinaryNodeInfo({ path: `${this.address.path}/${key}`, key });
          const res = getValueFromBinary(childInfo, value.recordPointer, 0);
          if (!res.skip) {
            let result = callback(childInfo, i++);
            if (isAsync && result instanceof Promise) {
              result = await result;
            }
            canceled = result === false;
            if (canceled) {
              break;
            }
          }
        }
      } else {
        let leaf = await tree.getFirstLeaf();
        while (leaf) {
          const children = leaf.entries.reduce((nodes, entry) => {
            const child = isArray2 ? new BinaryNodeInfo({ path: `${this.address.path}[${entry.key}]`, index: entry.key }) : new BinaryNodeInfo({ path: `${this.address.path}/${entry.key}`, key: entry.key });
            const res = getValueFromBinary(child, entry.value.recordPointer, 0);
            if (!res.skip) {
              nodes.push(child);
            }
            return nodes;
          }, []);
          for (let i = 0; !canceled && i < children.length; i++) {
            let result = callback(children[i], i);
            if (isAsync && result instanceof Promise) {
              result = await result;
            }
            canceled = result === false;
          }
          leaf = !canceled && leaf.getNext ? await leaf.getNext() : null;
        }
      }
      return !canceled;
    };
    const getValueFromBinary = (child, binary, index) => {
      const assert2 = (bytes) => {
        if (index + bytes > binary.length) {
          throw new AdditionalDataRequest();
        }
      };
      assert2(2);
      child.type = binary[index] >> 4;
      const tinyValue = binary[index] & 15;
      const valueInfo = binary[index + 1];
      const isRemoved = child.type === 0;
      const unusedDataLength = isRemoved ? valueInfo : 0;
      const isTinyValue = (valueInfo & 192) === 64;
      const isInlineValue = (valueInfo & 192) === 128;
      const isRecordValue = (valueInfo & 192) === 192;
      index += 2;
      if (isRemoved) {
        if (!REMOVED_CHILD_DATA_IMPLEMENTED) {
          throw new Error("corrupt: removed child data isn't implemented yet");
        }
        assert2(unusedDataLength);
        index += unusedDataLength;
        child.exists = false;
        return { index, skip: true };
      } else if (isTinyValue) {
        if (child.type === VALUE_TYPES.BOOLEAN) {
          child.value = tinyValue === 1;
        } else if (child.type === VALUE_TYPES.NUMBER) {
          child.value = tinyValue;
        } else if (child.type === VALUE_TYPES.BIGINT) {
          child.value = BigInt(tinyValue);
        } else if (child.type === VALUE_TYPES.STRING) {
          child.value = "";
        } else if (child.type === VALUE_TYPES.ARRAY) {
          child.value = [];
        } else if (child.type === VALUE_TYPES.OBJECT) {
          child.value = {};
        } else if (child.type === VALUE_TYPES.BINARY) {
          child.value = new ArrayBuffer(0);
        } else if (child.type === VALUE_TYPES.REFERENCE) {
          child.value = new PathReference("");
        } else {
          throw new Error(`Tiny value deserialization method missing for value type ${child.type}`);
        }
      } else if (isInlineValue) {
        const length3 = (valueInfo & 63) + 1;
        assert2(length3);
        const bytes = binary.slice(index, index + length3);
        if (child.type === VALUE_TYPES.NUMBER) {
          child.value = bytesToNumber6(bytes);
        } else if (child.type === VALUE_TYPES.BIGINT) {
          child.value = bytesToBigint3(bytes);
        } else if (child.type === VALUE_TYPES.STRING) {
          child.value = decodeString4(bytes);
        } else if (child.type === VALUE_TYPES.DATETIME) {
          const time = bytesToNumber6(bytes);
          child.value = new Date(time);
        } else if (child.type === VALUE_TYPES.ARRAY) {
          throw new Error("Inline array deserialization not implemented");
        } else if (child.type === VALUE_TYPES.OBJECT) {
          throw new Error("Inline object deserialization not implemented");
        } else if (child.type === VALUE_TYPES.BINARY) {
          child.value = new Uint8Array(bytes).buffer;
        } else if (child.type === VALUE_TYPES.REFERENCE) {
          const path3 = decodeString4(bytes);
          child.value = new PathReference(path3);
        } else {
          throw new Error(`Inline value deserialization method missing for value type ${child.type}`);
        }
        index += length3;
      } else if (isRecordValue) {
        assert2(6);
        if (typeof binary.buffer === "undefined") {
          binary = new Uint8Array(binary);
        }
        const view = new DataView(binary.buffer, binary.byteOffset + index, 6);
        const pageNr = view.getUint32(0);
        const recordNr = view.getUint16(4);
        const childPath = isArray2 ? `${this.address.path}[${child.index}]` : this.address.path === "" ? child.key : `${this.address.path}/${child.key}`;
        child.address = new BinaryNodeAddress(childPath, pageNr, recordNr);
        if (this.updateCache) {
          this.storage.updateCache(false, child, false);
        }
        if (child.address && child.address.equals(this.address)) {
          throw new Error("Circular reference in record data");
        }
        index += 6;
      } else {
        throw new Error("corrupt");
      }
      return { index };
    };
    let incompleteData = null;
    const getChildrenFromChunk = (valueType, binary) => {
      if (incompleteData !== null) {
        binary = concatTypedArrays2(incompleteData, binary);
        incompleteData = null;
      }
      const children = [];
      if (valueType === VALUE_TYPES.OBJECT || valueType === VALUE_TYPES.ARRAY) {
        isArray2 = valueType === VALUE_TYPES.ARRAY;
        let index = 0;
        const assert2 = (bytes) => {
          if (index + bytes > binary.length) {
            throw new AdditionalDataRequest();
          }
        };
        while (index < binary.length) {
          const startIndex = index;
          const child = new BinaryNodeInfo({});
          try {
            if (isArray2) {
              const childIndex = childCount;
              child.path = PathInfo.getChildPath(this.address.path, childIndex);
              child.index = childIndex;
            } else {
              assert2(2);
              const keyIndex = (binary[index] & 128) === 0 ? -1 : (binary[index] & 127) << 8 | binary[index + 1];
              if (keyIndex >= 0) {
                child.key = this.storage.KIT.keys[keyIndex];
                child.path = PathInfo.getChildPath(this.address.path, child.key);
                index += 2;
              } else {
                const keyLength = (binary[index] & 127) + 1;
                index++;
                assert2(keyLength);
                const key = decodeString4(binary.slice(index, index + keyLength));
                child.key = key;
                child.path = PathInfo.getChildPath(this.address.path, key);
                index += keyLength;
              }
            }
            const res = getValueFromBinary(child, binary, index);
            index = res.index;
            childCount++;
            if (res.skip) {
              continue;
            } else if (!isArray2 && options.keyFilter && !options.keyFilter.includes(child.key)) {
              continue;
            } else if (isArray2 && options.keyFilter && !options.keyFilter.includes(child.index)) {
              continue;
            }
            children.push(child);
          } catch (err) {
            if (err instanceof AdditionalDataRequest) {
              incompleteData = binary.slice(startIndex);
              break;
            } else {
              throw err;
            }
          }
        }
      }
      return children;
    };
    const createStreamFromLinearData = async (chunkData, isLastChunk) => {
      const children = getChildrenFromChunk(this.recordInfo.valueType, chunkData);
      let canceled = false;
      for (let i = 0; !canceled && i < children.length; i++) {
        const child = children[i];
        let result = callback(child, i);
        if (isAsync && result instanceof Promise) {
          result = await result;
        }
        canceled = result === false;
      }
      if (canceled || isLastChunk) {
        return false;
      }
    };
    return generator;
  }
  async getChildCount() {
    let count = 0;
    await this.getChildStream().next((childInfo) => {
      count++;
      return true;
    });
    return count;
  }
  async getChildInfo(key) {
    let childInfo = null;
    await this.getChildStream({ keyFilter: [key] }).next((info) => {
      childInfo = info;
    });
    if (childInfo) {
      return childInfo;
    }
    const childPath = PathInfo.getChildPath(this.address.path, key);
    return new BinaryNodeInfo({
      path: childPath,
      ...typeof key === "string" && { key },
      ...typeof key === "number" && { index: key },
      exists: false
    });
  }
  async _treeDataWriter(binary, index) {
    if (binary instanceof Array) {
      binary = Buffer.from(binary);
    }
    const length3 = binary.length;
    const recordSize = this.storage.settings.recordSize;
    const headerLength = this.recordInfo.headerLength;
    const startRecord = {
      nr: Math.floor((headerLength + index) / recordSize),
      offset: (headerLength + index) % recordSize
    };
    const endRecord = {
      nr: Math.floor((headerLength + index + length3) / recordSize),
      offset: (headerLength + index + length3) % recordSize
    };
    const writeRecords = this.recordInfo.allocation.addresses.slice(startRecord.nr, endRecord.nr + 1);
    const writeRanges = NodeAllocation.fromAdresses(writeRecords).ranges;
    const writes = [];
    let bOffset = 0;
    for (let i = 0; i < writeRanges.length; i++) {
      const range = writeRanges[i];
      let fIndex = this.storage.getRecordFileIndex(range.pageNr, range.recordNr);
      let bLength = range.length * recordSize;
      if (i === 0) {
        fIndex += startRecord.offset;
        bLength -= startRecord.offset;
      }
      if (bOffset + bLength > length3) {
        bLength = length3 - bOffset;
      }
      const p = this.storage.writeData(fIndex, binary, bOffset, bLength);
      writes.push(p);
      bOffset += bLength;
    }
    return Promise.all(writes);
  }
  async _treeDataReader(index, length3) {
    const recordSize = this.storage.settings.recordSize;
    const headerLength = this.recordInfo.headerLength;
    const startRecord = {
      nr: Math.floor((headerLength + index) / recordSize),
      offset: (headerLength + index) % recordSize
    };
    const endRecord = {
      nr: Math.floor((headerLength + index + length3) / recordSize),
      offset: (headerLength + index + length3) % recordSize
    };
    const readRecords = this.recordInfo.allocation.addresses.slice(startRecord.nr, endRecord.nr + 1);
    if (readRecords.length === 0) {
      throw new Error(`Attempt to read non-existing records of path "/${this.recordInfo.path}": ${startRecord.nr} to ${endRecord.nr + 1} for index ${index} + ${length3} bytes. Node has ${this.recordInfo.allocation.addresses.length} allocated records in the following ranges: ` + this.recordInfo.allocation.toString());
    }
    const readRanges = NodeAllocation.fromAdresses(readRecords).ranges;
    const reads = [];
    const totalLength = readRecords.length * recordSize - startRecord.offset;
    const binary = new Uint8Array(totalLength);
    let bOffset = 0;
    for (let i = 0; i < readRanges.length; i++) {
      const range = readRanges[i];
      let fIndex = this.storage.getRecordFileIndex(range.pageNr, range.recordNr);
      let bLength = range.length * recordSize;
      if (i === 0) {
        fIndex += startRecord.offset;
        bLength -= startRecord.offset;
      }
      const p = this.storage.readData(fIndex, binary, bOffset, bLength);
      reads.push(p);
      bOffset += bLength;
    }
    await Promise.all(reads);
    return Buffer.from(binary.buffer);
  }
  async readHeader() {
    this._assertLock();
    const bytesPerRecord = this.storage.settings.recordSize;
    const fileIndex = this.storage.getRecordFileIndex(this.address.pageNr, this.address.recordNr);
    let data = new Uint8Array(bytesPerRecord);
    const bytesRead = await this.storage.readData(fileIndex, data.buffer);
    if (bytesRead < bytesPerRecord) {
      throw new Error(`Not enough bytes read from file at index ${fileIndex}, expected ${bytesPerRecord} but got ${bytesRead}`);
    }
    const hasKeyIndex = (data[0] & FLAG_KEY_TREE) === FLAG_KEY_TREE;
    const valueType = data[0] & FLAG_VALUE_TYPE;
    let view = new DataView(data.buffer);
    let offset = 1;
    const firstRange = new StorageAddressRange(this.address.pageNr, this.address.recordNr, 1);
    const ranges = [firstRange];
    const allocation = new NodeAllocation(ranges);
    let readingRecordIndex = 0;
    let done = false;
    while (!done) {
      if (offset + 9 + 2 >= data.length) {
        readingRecordIndex++;
        const address = allocation.addresses[readingRecordIndex];
        const fileIndex2 = this.storage.getRecordFileIndex(address.pageNr, address.recordNr);
        const moreData = new Uint8Array(bytesPerRecord);
        await this.storage.readData(fileIndex2, moreData.buffer);
        data = concatTypedArrays2(data, moreData);
        view = new DataView(data.buffer);
      }
      const type = view.getUint8(offset);
      if (type === 0) {
        offset++;
        done = true;
      } else if (type === 1) {
        firstRange.length = view.getUint16(offset + 1);
        offset += 3;
      } else if (type === 2) {
        const pageNr = view.getUint32(offset + 1);
        const recordNr = view.getUint16(offset + 5);
        const length3 = view.getUint16(offset + 7);
        const range = new StorageAddressRange(pageNr, recordNr, length3);
        ranges.push(range);
        offset += 9;
      } else if (type === 3) {
        const pageNr = view.getUint32(offset + 1);
        const totalPages = view.getUint16(offset + 5);
        const range = new StorageAddressRange(pageNr, 0, totalPages * this.storage.settings.pageSize);
        ranges.push(range);
        offset += 7;
      } else {
        throw new TypeError(`Unknown chunk type ${type} while reading record at ${this.address}`);
      }
    }
    const lastRecordDataLength = view.getUint16(offset);
    offset += 2;
    const headerLength = offset;
    const firstRecordDataLength = ranges.length === 1 && ranges[0].length == 1 ? lastRecordDataLength : bytesPerRecord - headerLength;
    this.recordInfo = new RecordInfo(this.address.path, hasKeyIndex, valueType, allocation, headerLength, lastRecordDataLength, bytesPerRecord, data.slice(headerLength, headerLength + firstRecordDataLength));
    return this.recordInfo;
  }
  getChildTree() {
    if (this.recordInfo === null) {
      throw new Error("record info hasn't been read yet");
    }
    if (!this.recordInfo.hasKeyIndex) {
      throw new Error("record has no key index tree");
    }
    return new BinaryBPlusTree({
      readFn: this._treeDataReader.bind(this),
      chunkSize: 1024 * 100,
      writeFn: this._treeDataWriter.bind(this),
      debug: this.storage.debug,
      id: "record@" + this.recordInfo.address.toString()
    });
  }
};
async function _mergeNode(storage, nodeInfo, updates, lock) {
  if (typeof updates !== "object") {
    throw new TypeError("updates parameter must be an object");
  }
  let nodeReader = new NodeReader(storage, nodeInfo.address, lock, false);
  const affectedKeys = Object.keys(updates);
  const changes = new NodeChangeTracker(nodeInfo.path);
  const discardAllocation = new NodeAllocation([]);
  let isArray2 = false;
  let isInternalUpdate = false;
  let recordInfo = await nodeReader.readHeader();
  isArray2 = recordInfo.valueType === VALUE_TYPES.ARRAY;
  nodeInfo.type = recordInfo.valueType;
  let recordMoved = false;
  const done = (newRecordInfo2) => {
    if (newRecordInfo2 !== nodeReader.recordInfo) {
      discardAllocation.ranges.push(...nodeReader.recordInfo.allocation.ranges);
      recordMoved = true;
    }
    storage.updateCache(false, new BinaryNodeInfo({ path: nodeInfo.path, type: nodeInfo.type, address: newRecordInfo2.address, exists: true }), recordMoved);
    return { recordMoved, recordInfo: newRecordInfo2, deallocate: discardAllocation };
  };
  const childValuePromises = [];
  if (isArray2) {
    for (let i = 0; i < affectedKeys.length; i++) {
      if (isNaN(affectedKeys[i])) {
        throw new Error(`Cannot merge existing array of path "${nodeInfo.path}" with an object (properties ${Object.keys(updates).slice(0, 5).map((p) => `"${p}"`).join(",")}...)`);
      }
      affectedKeys[i] = +affectedKeys[i];
    }
  }
  const newKeys = affectedKeys.slice();
  await nodeReader.getChildStream({ keyFilter: affectedKeys }).next((child) => {
    const keyOrIndex = isArray2 ? child.index : child.key;
    newKeys.splice(newKeys.indexOf(keyOrIndex), 1);
    const newValue = updates[keyOrIndex];
    if (child.address) {
      if (newValue instanceof InternalNodeReference) {
        isInternalUpdate = true;
        const oldAddress = child.address;
        const currentValue = new InternalNodeReference(child.type, oldAddress);
        changes.add(keyOrIndex, currentValue, newValue);
        return true;
      }
      const promise = storage.nodeLocker.lock(child.address.path, lock.tid, false, `_mergeNode: read child "/${child.address.path}"`).then(async (childLock) => {
        const childReader = new NodeReader(storage, child.address, childLock, false);
        const allocation = await childReader.getAllocation(true);
        childLock.release();
        discardAllocation.ranges.push(...allocation.ranges);
        const currentChildValue = new InternalNodeReference(child.type, child.address);
        changes.add(keyOrIndex, currentChildValue, newValue);
      });
      childValuePromises.push(promise);
    } else {
      changes.add(keyOrIndex, child.value, newValue);
    }
  });
  await Promise.all(childValuePromises);
  newKeys.forEach((key) => {
    const newValue = updates[key];
    if (newValue !== null) {
      changes.add(key, null, newValue);
    }
  });
  if (changes.all.length === 0) {
    storage.debug.log(`No effective changes to update node "/${nodeInfo.path}" with`.colorize(ColorStyle.yellow));
    return done(nodeReader.recordInfo);
  }
  if (isArray2) {
    const getSequenceInfo = (changes2) => {
      const indice = changes2.map((ch) => ch.keyOrIndex).sort();
      const gaps = indice.map((_, i, arr) => i === 0 ? 0 : arr[i - 1] - arr[i]);
      return { indice, hasGaps: gaps.some((g) => g > 1) };
    };
    const deleteSeqInfo = getSequenceInfo(changes.deletes);
    const insertSeqInfo = getSequenceInfo(changes.inserts);
    let isSparse = deleteSeqInfo.hasGaps || deleteSeqInfo.hasGaps;
    if (!isSparse && changes.deletes.length > 0) {
      const highestIndex = deleteSeqInfo.indice.slice(-1)[0];
      const nextEntryInfo = await nodeReader.getChildInfo(highestIndex + 1);
      if (nextEntryInfo.exists) {
        isSparse = true;
      }
    }
    if (!isSparse && changes.inserts.length > 0) {
      const lowestIndex = insertSeqInfo.indice[0];
      if (lowestIndex > 0) {
        const prevEntryInfo = await nodeReader.getChildInfo(lowestIndex - 1);
        if (!prevEntryInfo.exists) {
          isSparse = true;
        }
      }
    }
    if (isSparse) {
      throw new Error(`Elements cannot be inserted beyond, or removed before the end of an array. Rewrite the whole array at path "${nodeInfo.path}" or change your schema to use an object collection instead`);
    }
  }
  const maxDebugItems = 10;
  storage.debug.log(`Node "/${nodeInfo.path}" being updated:${isInternalUpdate ? " (internal)" : ""} adding ${changes.inserts.length} keys (${changes.inserts.slice(0, maxDebugItems).map((ch) => `"${ch.keyOrIndex}"`).join(",")}${changes.inserts.length > maxDebugItems ? "..." : ""}), updating ${changes.updates.length} keys (${changes.updates.slice(0, maxDebugItems).map((ch) => `"${ch.keyOrIndex}"`).join(",")}${changes.updates.length > maxDebugItems ? "..." : ""}), removing ${changes.deletes.length} keys (${changes.deletes.slice(0, maxDebugItems).map((ch) => `"${ch.keyOrIndex}"`).join(",")}${changes.deletes.length > maxDebugItems ? "..." : ""})`.colorize(ColorStyle.cyan));
  if (!isInternalUpdate) {
    const inv = changes.all.filter((ch) => !(ch.newValue instanceof InternalNodeReference)).reduce((obj, ch) => {
      obj[ch.keyOrIndex] = ch.changeType === NodeChange.CHANGE_TYPE.DELETE ? "delete" : "invalidate";
      return obj;
    }, {});
    storage.invalidateCache(false, nodeInfo.path, inv, "mergeNode");
  }
  let newRecordInfo;
  if (nodeReader.recordInfo.hasKeyIndex) {
    const pathInfo = PathInfo.get(nodeInfo.path);
    const childPromises = [];
    for (const change of changes.all) {
      const childPath = pathInfo.childPath(change.keyOrIndex);
      if (change.oldValue !== null) {
        const kvp = _serializeValue(storage, childPath, change.keyOrIndex, change.oldValue, null);
        if (!(kvp instanceof SerializedKeyValue)) {
          throw new Error("return value must be of type SerializedKeyValue, it cannot be a Promise!");
        }
        const bytes = _getValueBytes(kvp);
        change.oldValue = bytes;
      }
      if (change.newValue !== null) {
        const s = _serializeValue(storage, childPath, change.keyOrIndex, change.newValue, lock.tid);
        const convert = (kvp) => {
          const bytes = _getValueBytes(kvp);
          change.newValue = bytes;
        };
        if (s instanceof Promise) {
          childPromises.push(s.then(convert));
        } else {
          convert(s);
        }
      }
    }
    const operations = [];
    let tree = nodeReader.getChildTree();
    await Promise.all(childPromises);
    changes.deletes.forEach((change) => {
      const op = BinaryBPlusTree.TransactionOperation.remove(change.keyOrIndex, change.oldValue);
      operations.push(op);
    });
    changes.updates.forEach((change) => {
      const oldEntryValue = new BinaryBPlusTree.EntryValue(change.oldValue);
      const newEntryValue = new BinaryBPlusTree.EntryValue(change.newValue);
      const op = BinaryBPlusTree.TransactionOperation.update(change.keyOrIndex, newEntryValue, oldEntryValue);
      operations.push(op);
    });
    changes.inserts.forEach((change) => {
      const op = BinaryBPlusTree.TransactionOperation.add(change.keyOrIndex, change.newValue);
      operations.push(op);
    });
    const opCountsLog = [], fixHistory = [];
    const processOperations = async (retry = 0) => {
      if (retry > 2 && operations.length === opCountsLog[opCountsLog.length - 1]) {
        throw new Error(`DEV: Applied tree fixes did not change ${operations.length} pending operation(s) failing to execute. Debug this, check fixHistory!`);
      }
      opCountsLog.push(operations.length);
      try {
        await tree.transaction(operations);
        storage.debug.log(`Updated tree for node "/${nodeInfo.path}"`.colorize(ColorStyle.green));
        return recordInfo;
      } catch (err) {
        storage.debug.log(`Could not update tree for "/${nodeInfo.path}"${retry > 0 ? ` (retry ${retry})` : ""}: ${err.message}, ${err.codes}`.colorize(ColorStyle.yellow));
        if (err.hasErrorCode && err.hasErrorCode("tree-full-no-autogrow")) {
          storage.debug.verbose("Tree needs more space");
          const growBytes = Math.ceil(tree.info.byteLength * 0.1);
          const bytesRequired = tree.info.byteLength + growBytes;
          fixHistory.push({ err, fix: "grow", from: tree.info.byteLength, to: bytesRequired, growBytes });
          let sourceIndex = 0;
          const originalLength = tree.info.byteLength;
          const reader = async (length3) => {
            let data;
            if (sourceIndex > originalLength) {
              data = new Uint8Array(length3);
            } else {
              const readLength = sourceIndex + length3 < originalLength ? length3 : originalLength - sourceIndex;
              data = await nodeReader._treeDataReader(sourceIndex, readLength);
              if (data.length < length3) {
                data = concatTypedArrays2(new Uint8Array(data), new Uint8Array(length3 - data.length));
              } else if (data.length > length3) {
                data = data.slice(0, length3);
              }
            }
            if (sourceIndex === 0) {
              tree.setAllocationBytes(data, bytesRequired, tree.info.freeSpace + growBytes);
            }
            sourceIndex += data.byteLength;
            return data;
          };
          recordInfo = await _write(storage, nodeInfo.path, nodeReader.recordInfo.valueType, bytesRequired, true, reader, nodeReader.recordInfo);
        } else {
          storage.debug.verbose(`B+Tree for path ${nodeInfo.path} needs rebuild`);
          fixHistory.push({ err, fix: "rebuild" });
          recordInfo = await _rebuildKeyTree(tree, nodeReader, { reserveSpaceForNewEntries: changes.inserts.length - changes.deletes.length });
        }
        if (recordInfo !== nodeReader.recordInfo) {
          discardAllocation.ranges.push(...nodeReader.recordInfo.allocation.ranges);
          recordMoved = true;
        }
        nodeReader = new NodeReader(storage, recordInfo.address, lock, false);
        recordInfo = await nodeReader.readHeader();
        tree = new BinaryBPlusTree({
          readFn: nodeReader._treeDataReader.bind(nodeReader),
          chunkSize: 1024 * 100,
          writeFn: nodeReader._treeDataWriter.bind(nodeReader),
          debug: storage.debug,
          id: "record@" + nodeReader.recordInfo.address.toString()
        });
        return processOperations(retry + 1);
      }
    };
    newRecordInfo = await processOperations();
  } else {
    const mergedValue = isArray2 ? [] : {};
    await nodeReader.getChildStream().next((child) => {
      const keyOrIndex = isArray2 ? child.index : child.key;
      if (child.address) {
        mergedValue[keyOrIndex] = new InternalNodeReference(child.type, child.address);
      } else {
        mergedValue[keyOrIndex] = child.value;
      }
    });
    changes.deletes.forEach((change) => {
      delete mergedValue[change.keyOrIndex];
    });
    changes.updates.forEach((change) => {
      mergedValue[change.keyOrIndex] = change.newValue;
    });
    changes.inserts.forEach((change) => {
      mergedValue[change.keyOrIndex] = change.newValue;
    });
    if (isArray2) {
      mergedValue.length += changes.inserts.length - changes.deletes.length;
    }
    newRecordInfo = await _writeNode(storage, nodeInfo.path, mergedValue, lock, nodeReader.recordInfo);
  }
  return done(newRecordInfo);
}
async function _createNode(storage, nodeInfo, newValue, lock, invalidateCache = true) {
  storage.debug.log(`Node "/${nodeInfo.path}" is being ${nodeInfo.exists ? "overwritten" : "created"}`.colorize(ColorStyle.cyan));
  let currentAllocation = null;
  if (nodeInfo.exists && nodeInfo.address) {
    const nodeReader = new NodeReader(storage, nodeInfo.address, lock, false);
    currentAllocation = await nodeReader.getAllocation(true);
  }
  if (invalidateCache) {
    storage.invalidateCache(false, nodeInfo.path, nodeInfo.exists, "createNode");
  }
  const recordInfo = await _writeNode(storage, nodeInfo.path, newValue, lock);
  return { recordMoved: true, recordInfo, deallocate: currentAllocation };
}
async function _lockAndWriteNode(storage, path3, value, parentTid) {
  const lock = await storage.nodeLocker.lock(path3, parentTid.toString(), true, `_lockAndWrite "${path3}"`);
  try {
    const recordInfo = await _writeNode(storage, path3, value, lock);
    return recordInfo;
  } finally {
    lock.release();
  }
}
async function _writeNode(storage, path3, value, lock, currentRecordInfo) {
  if (lock.path !== path3 || !lock.forWriting) {
    throw new Error(`Cannot write to node "/${path3}" because lock is on the wrong path or not for writing`);
  }
  const write2 = (valueType, buffer, keyTree = false) => {
    let readOffset = 0;
    const reader = (length3) => {
      const slice = buffer.slice(readOffset, readOffset + length3);
      readOffset += length3;
      return slice;
    };
    return _write(storage, path3, valueType, buffer.length, keyTree, reader, currentRecordInfo);
  };
  if (typeof value === "string") {
    return write2(VALUE_TYPES.STRING, encodeString6(value));
  } else if (typeof value === "bigint") {
    return write2(VALUE_TYPES.BIGINT, bigintToBytes5(value));
  } else if (value instanceof PathReference) {
    return write2(VALUE_TYPES.REFERENCE, encodeString6(value.path));
  } else if (value instanceof ArrayBuffer) {
    return write2(VALUE_TYPES.BINARY, new Uint8Array(value));
  } else if (typeof value !== "object") {
    throw new TypeError("Unsupported type to store in stand-alone record");
  }
  const childPromises = [];
  const serialized = [];
  const isArray2 = value instanceof Array;
  if (isArray2) {
    const isExhaustive = Object.keys(value).every((key, i) => +key === i && value[i] !== null);
    if (!isExhaustive) {
      throw new Error("Cannot store arrays with missing entries");
    }
    value.forEach((val, index) => {
      if (typeof val === "function") {
        throw new Error(`Array at index ${index} has invalid value. Cannot store functions`);
      }
      const childPath = `${path3}[${index}]`;
      const s = _serializeValue(storage, childPath, index, val, lock.tid);
      const add = (s2) => {
        serialized[index] = s2;
      };
      if (s instanceof Promise) {
        childPromises.push(s.then(add));
      } else {
        add(s);
      }
    });
  } else {
    Object.keys(value).forEach((key) => {
      if (/[\x00-\x08\x0b\x0c\x0e-\x1f/[\]\\]/.test(key)) {
        throw new Error(`Invalid key "${key}" for object to store at path "${path3}". Keys cannot contain control characters or any of the following characters: \\ / [ ]`);
      }
      if (key.length > 128) {
        throw new Error(`Key "${key}" is too long to store for object at path "${path3}". Max key length is 128`);
      }
      if (key.length === 0) {
        throw new Error(`Child key for path "${path3}" is not allowed be empty`);
      }
      const childPath = PathInfo.getChildPath(path3, key);
      const val = value[key];
      if (typeof val === "function" || val === null) {
        return;
      } else if (typeof val === "undefined") {
        if (storage.settings.removeVoidProperties === true) {
          delete value[key];
          return;
        } else {
          throw new Error(`Property "${key}" has invalid value. Cannot store undefined values. Set removeVoidProperties option to true to automatically remove undefined properties`);
        }
      } else {
        const s = _serializeValue(storage, childPath, key, val, lock.tid);
        const add = (s2) => {
          serialized.push(s2);
        };
        if (s instanceof Promise) {
          childPromises.push(s.then(add));
        } else {
          add(s);
        }
      }
    });
  }
  await Promise.all(childPromises);
  let result;
  const minKeysForTreeCreation = 100;
  if (serialized.length > minKeysForTreeCreation) {
    const fillFactor = isArray2 || serialized.every((kvp) => typeof kvp.key === "string" && /^[0-9]+$/.test(kvp.key)) ? BINARY_TREE_FILL_FACTOR_50 : BINARY_TREE_FILL_FACTOR_95;
    const treeBuilder = new BPlusTreeBuilder(true, fillFactor);
    serialized.forEach((kvp) => {
      const binaryValue = _getValueBytes(kvp);
      treeBuilder.add(isArray2 ? kvp.index : kvp.key, binaryValue);
    });
    const builder = new Uint8ArrayBuilder();
    await treeBuilder.create().toBinary(true, BinaryWriter.forUint8ArrayBuilder(builder));
    result = { keyTree: true, data: builder.data };
  } else {
    const builder = new Uint8ArrayBuilder();
    serialized.forEach((kvp) => {
      if (!isArray2) {
        const keyIndex = storage.KIT.getOrAdd(kvp.key);
        if (keyIndex >= 0) {
          builder.writeByte(128 | keyIndex >> 8 & 127);
          builder.writeByte(keyIndex & 255);
        } else {
          const keyBytes = encodeString6(kvp.key);
          builder.writeByte(keyBytes.byteLength - 1);
          builder.append(keyBytes);
        }
      }
      _writeBinaryValue(kvp, builder);
    });
    result = { keyTree: false, data: builder.data };
  }
  return write2(isArray2 ? VALUE_TYPES.ARRAY : VALUE_TYPES.OBJECT, result.data, result.keyTree);
}
var SerializedKeyValue = class {
  constructor(info) {
    this.key = info.key;
    this.index = info.index;
    this.type = info.type;
    this.bool = info.bool;
    this.ref = info.ref;
    this.binary = info.binary;
    this.record = info.record;
    this.bytes = info.bytes;
  }
};
function _getValueBytes(kvp) {
  return _writeBinaryValue(kvp).data;
}
function _writeBinaryValue(kvp, builder = new Uint8ArrayBuilder(null, 64)) {
  const startIndex = builder.length;
  builder.push(kvp.type << 4);
  let tinyValue = -1;
  if (kvp.type === VALUE_TYPES.BOOLEAN) {
    tinyValue = kvp.bool ? 1 : 0;
  } else if (kvp.type === VALUE_TYPES.NUMBER && kvp.ref >= 0 && kvp.ref <= 15 && Math.floor(kvp.ref) === kvp.ref) {
    tinyValue = kvp.ref;
  } else if (kvp.type === VALUE_TYPES.BIGINT && kvp.ref >= BigInt(0) && kvp.ref <= BigInt(15)) {
    tinyValue = Number(kvp.ref);
  } else if (kvp.type === VALUE_TYPES.STRING && kvp.binary && kvp.binary.length === 0) {
    tinyValue = 0;
  } else if (kvp.type === VALUE_TYPES.ARRAY && kvp.ref.length === 0) {
    tinyValue = 0;
  } else if (kvp.type === VALUE_TYPES.OBJECT && Object.keys(kvp.ref).length === 0) {
    tinyValue = 0;
  } else if (kvp.type === VALUE_TYPES.BINARY && kvp.ref.byteLength === 0) {
    tinyValue = 0;
  }
  if (tinyValue >= 0) {
    builder.data[startIndex] |= tinyValue;
    builder.push(64);
  } else if (kvp.record) {
    builder.push(192);
    builder.writeUint32(kvp.record.pageNr);
    builder.writeUint16(kvp.record.recordNr);
  } else {
    let data = kvp.bytes || kvp.binary;
    const length3 = "byteLength" in data ? data.byteLength : data.length;
    builder.push(128 | length3 - 1);
    if (data instanceof ArrayBuffer) {
      data = new Uint8Array(data);
    }
    builder.append(data);
  }
  return builder;
}
function _serializeValue(storage, path3, keyOrIndex, val, parentTid) {
  const missingTidMessage = "Need to create a new record, but the parentTid is not given";
  const create = (details) => {
    if (typeof keyOrIndex === "number") {
      details.index = keyOrIndex;
    } else {
      details.key = keyOrIndex;
    }
    details.ref = val;
    return new SerializedKeyValue(details);
  };
  if (val instanceof Date) {
    const ms = val.getTime();
    const bytes = numberToBytes6(ms);
    return create({ type: VALUE_TYPES.DATETIME, bytes });
  } else if (val instanceof Array) {
    if (val.length === 0) {
      return create({ type: VALUE_TYPES.ARRAY, bytes: [] });
    }
    console.assert(parentTid, missingTidMessage);
    return _lockAndWriteNode(storage, path3, val, parentTid).then((recordInfo) => {
      return create({ type: VALUE_TYPES.ARRAY, record: recordInfo.address });
    });
  } else if (val instanceof InternalNodeReference) {
    return create({ type: val.type, record: val.address });
  } else if (val instanceof ArrayBuffer) {
    if (val.byteLength > storage.settings.maxInlineValueSize) {
      console.assert(parentTid, missingTidMessage);
      return _lockAndWriteNode(storage, path3, val, parentTid).then((recordInfo) => {
        return create({ type: VALUE_TYPES.BINARY, record: recordInfo.address });
      });
    } else {
      return create({ type: VALUE_TYPES.BINARY, bytes: val });
    }
  } else if (val instanceof PathReference) {
    const encoded = encodeString6(val.path);
    if (encoded.length > storage.settings.maxInlineValueSize) {
      console.assert(parentTid, missingTidMessage);
      return _lockAndWriteNode(storage, path3, val, parentTid).then((recordInfo) => {
        return create({ type: VALUE_TYPES.REFERENCE, record: recordInfo.address });
      });
    } else {
      return create({ type: VALUE_TYPES.REFERENCE, binary: encoded });
    }
  } else if (typeof val === "object") {
    if (Object.keys(val).length === 0) {
      return create({ type: VALUE_TYPES.OBJECT, bytes: [] });
    }
    console.assert(parentTid, missingTidMessage);
    return _lockAndWriteNode(storage, path3, val, parentTid).then((recordInfo) => {
      return create({ type: VALUE_TYPES.OBJECT, record: recordInfo.address });
    });
  } else if (typeof val === "number") {
    const bytes = numberToBytes6(val);
    return create({ type: VALUE_TYPES.NUMBER, bytes });
  } else if (typeof val === "bigint") {
    const bytes = bigintToBytes5(val);
    return create({ type: VALUE_TYPES.BIGINT, bytes });
  } else if (typeof val === "boolean") {
    return create({ type: VALUE_TYPES.BOOLEAN, bool: val });
  } else {
    if (typeof val !== "string") {
      val = val.toString();
    }
    const encoded = encodeString6(val);
    if (encoded.length > storage.settings.maxInlineValueSize) {
      console.assert(parentTid, missingTidMessage);
      return _lockAndWriteNode(storage, path3, val, parentTid).then((recordInfo) => {
        return create({ type: VALUE_TYPES.STRING, record: recordInfo.address });
      });
    } else {
      return create({ type: VALUE_TYPES.STRING, binary: encoded });
    }
  }
}
async function _write(storage, path3, type, length3, hasKeyTree, reader, currentRecordInfo) {
  const bytesPerRecord = storage.settings.recordSize;
  let headerByteLength = 0, totalBytes = 0, requiredRecords = 0, lastChunkSize = 0;
  const calculateStorageNeeds = (nrOfChunks) => {
    headerByteLength = 4;
    totalBytes = length3 + headerByteLength;
    requiredRecords = Math.ceil(totalBytes / bytesPerRecord);
    if (requiredRecords > 1) {
      headerByteLength += 3;
      headerByteLength += (nrOfChunks - 1) * 9;
      totalBytes = length3 + headerByteLength;
      requiredRecords = Math.ceil(totalBytes / bytesPerRecord);
    }
    lastChunkSize = requiredRecords === 1 ? length3 : totalBytes % bytesPerRecord;
    if (lastChunkSize === 0 && length3 > 0) {
      lastChunkSize = bytesPerRecord;
    }
  };
  calculateStorageNeeds(1);
  if (requiredRecords > 1) {
    const wholePages = Math.floor(requiredRecords / storage.settings.pageSize);
    const remainingRecords = requiredRecords % storage.settings.pageSize;
    const maxChunks = Math.max(0, wholePages) + Math.min(storage.FST.maxScraps, remainingRecords);
    calculateStorageNeeds(maxChunks);
  }
  const useExistingAllocation = currentRecordInfo && currentRecordInfo.allocation.totalAddresses === requiredRecords;
  const ranges = useExistingAllocation ? currentRecordInfo.allocation.ranges : await storage.FST.allocate(requiredRecords);
  let allocation = new NodeAllocation(ranges);
  !useExistingAllocation && storage.debug.verbose(`Allocated ${allocation.totalAddresses} addresses for node "/${path3}": ${allocation}`.colorize(ColorStyle.grey));
  calculateStorageNeeds(allocation.ranges.length);
  if (requiredRecords < allocation.totalAddresses) {
    const addresses = allocation.addresses;
    const deallocate = addresses.splice(requiredRecords);
    storage.debug.verbose(`Requested ${deallocate.length} too many addresses to store node "/${path3}", releasing them`.colorize(ColorStyle.grey));
    storage.FST.release(NodeAllocation.fromAdresses(deallocate).ranges);
    allocation = NodeAllocation.fromAdresses(addresses);
    calculateStorageNeeds(allocation.ranges.length);
  }
  const header = new Uint8Array(headerByteLength);
  const headerView = new DataView(header.buffer, 0, header.length);
  header[0] = type;
  if (hasKeyTree) {
    header[0] |= FLAG_KEY_TREE;
  }
  const chunkTable = allocation.toChunkTable();
  let offset = 1;
  chunkTable.ranges.forEach((range) => {
    headerView.setUint8(offset, range.type);
    if (range.type === 0) {
      return;
    } else if (range.type === 1) {
      headerView.setUint16(offset + 1, range.length);
      offset += 3;
    } else if (range.type === 2) {
      headerView.setUint32(offset + 1, range.pageNr);
      headerView.setUint16(offset + 5, range.recordNr);
      headerView.setUint16(offset + 7, range.length);
      offset += 9;
    } else {
      throw "Unsupported range type";
    }
  });
  headerView.setUint8(offset, 0);
  offset++;
  headerView.setUint16(offset, lastChunkSize);
  offset += 2;
  let bytesRead = 0;
  const readChunk = async (length4) => {
    let headerBytes;
    if (bytesRead < header.byteLength) {
      headerBytes = header.slice(bytesRead, bytesRead + length4);
      bytesRead += headerBytes.byteLength;
      length4 -= headerBytes.byteLength;
      if (length4 === 0) {
        return headerBytes;
      }
    }
    let dataBytes = reader(length4);
    if (dataBytes instanceof Promise) {
      dataBytes = await dataBytes;
    }
    if (dataBytes instanceof Array) {
      dataBytes = Uint8Array.from(dataBytes);
    } else if (!(dataBytes instanceof Uint8Array)) {
      throw new Error("bytes must be Uint8Array or plain byte Array");
    }
    bytesRead += dataBytes.byteLength;
    if (headerBytes) {
      dataBytes = concatTypedArrays2(headerBytes, dataBytes);
    }
    return dataBytes;
  };
  try {
    const bytesWritten = await chunkTable.ranges.reduce(async (promise, range) => {
      const fileIndex = storage.getRecordFileIndex(range.pageNr, range.recordNr);
      if (isNaN(fileIndex)) {
        throw new Error("fileIndex is NaN!!");
      }
      let bytesWritten2 = promise ? await promise : 0;
      const data = await readChunk(range.length * bytesPerRecord);
      bytesWritten2 += data.byteLength;
      await storage.writeData(fileIndex, data);
      return bytesWritten2;
    }, null);
    const chunks = chunkTable.ranges.length;
    const address = new BinaryNodeAddress(path3, allocation.ranges[0].pageNr, allocation.ranges[0].recordNr);
    const nodeInfo = new BinaryNodeInfo({ path: path3, type, exists: true, address });
    storage.updateCache(false, nodeInfo, true);
    storage.debug.log(`Node "/${address.path}" saved at address ${address.pageNr},${address.recordNr} - ${allocation.totalAddresses} addresses, ${bytesWritten} bytes written in ${chunks} chunk(s)`.colorize(ColorStyle.green));
    let recordInfo;
    if (useExistingAllocation) {
      recordInfo = currentRecordInfo;
      recordInfo.allocation = allocation;
      recordInfo.hasKeyIndex = hasKeyTree;
      recordInfo.headerLength = headerByteLength;
      recordInfo.lastChunkSize = lastChunkSize;
    } else {
      recordInfo = new RecordInfo(address.path, hasKeyTree, type, allocation, headerByteLength, lastChunkSize, bytesPerRecord);
      recordInfo.fileIndex = storage.getRecordFileIndex(address.pageNr, address.recordNr);
    }
    recordInfo.timestamp = Date.now();
    if (address.path === "") {
      await storage.rootRecord.update(address);
    }
    return recordInfo;
  } catch (reason) {
    storage.debug.error(`Failed to write node "/${path3}": ${reason}`);
    throw reason;
  }
}
async function _rebuildKeyTree(tree, nodeReader, options) {
  const storage = nodeReader.storage;
  const path3 = nodeReader.address.path;
  const tempFilepath = `${storage.settings.path}/${storage.name}.acebase/tree-${ID.generate()}.tmp`;
  let bytesWritten = 0;
  const fd = await pfs.open(tempFilepath, pfs.flags.readAndWriteAndCreate);
  const writer = BinaryWriter.forFunction(async (data, index) => {
    await pfs.write(fd, data, 0, data.length, index);
    bytesWritten += data.length;
  });
  await tree.rebuild(writer, options);
  let readOffset = 0;
  const reader = async (length3) => {
    const buffer = new Uint8Array(length3);
    const { bytesRead } = await pfs.read(fd, buffer, 0, buffer.length, readOffset);
    readOffset += bytesRead;
    if (bytesRead < length3) {
      return buffer.slice(0, bytesRead);
    }
    return buffer;
  };
  const newRecordInfo = await _write(storage, path3, nodeReader.recordInfo.valueType, bytesWritten, true, reader, nodeReader.recordInfo);
  console.assert(newRecordInfo.allocation.totalAddresses * newRecordInfo.bytesPerRecord >= bytesWritten, `insufficient space allocated for tree of path ${path3}: ${newRecordInfo.allocation.totalAddresses} records for ${bytesWritten} bytes`);
  pfs.close(fd).then(() => pfs.rm(tempFilepath)).catch((err) => {
    storage.debug.error(`Can't remove temp rebuild file ${tempFilepath}: `, err);
  });
  return newRecordInfo;
}
var InternalNodeReference = class {
  constructor(type, address) {
    this.type = type;
    this._address = address;
  }
  get address() {
    return this._address;
  }
  get path() {
    return this._address.path;
  }
  get pageNr() {
    return this._address.pageNr;
  }
  get recordNr() {
    return this._address.recordNr;
  }
};

// node_modules/acebase/dist/esm/storage/sqlite/index.js
var SQLiteNodeAddress = class extends NodeAddress {
  constructor(containerPath) {
    super(containerPath);
  }
};
var SQLiteNodeInfo = class extends NodeInfo {
  constructor(info) {
    super(info);
    this.revision = info.revision;
    this.revision_nr = info.revision_nr;
    this.created = info.created;
    this.modified = info.modified;
  }
};
var SQLiteStorageSettings = class extends StorageSettings {
  constructor(options) {
    super(options);
    options = options || {};
  }
};
var SQLiteStorage = class extends Storage {
  constructor(name, settings, env2) {
    settings = new SQLiteStorageSettings(settings);
    super(name, settings, env2);
    try {
      this.sqlite = require("sqlite3").verbose();
    } catch (err) {
      throw new Error(`sqlite3 not found. To use SQLite as storage, add sqlite3 to your project dependencies: npm i sqlite3`);
    }
    this.init();
  }
  _get(sql, params) {
    const stack = new Error("").stack;
    return new Promise((resolve, reject) => {
      this._db.all(sql, params || {}, (err, rows) => {
        if (err) {
          err.stack = stack;
          err.statement = sql;
          err.params = params;
          return reject(err);
        }
        resolve(rows);
      });
    });
  }
  _getOne(sql, params) {
    const stack = new Error("").stack;
    return new Promise((resolve, reject) => {
      this._db.get(sql, params || {}, (err, row) => {
        if (err) {
          err.stack = stack;
          err.statement = sql;
          err.params = params;
          return reject(err);
        }
        resolve(row);
      });
    });
  }
  _exec(sql, params) {
    const stack = new Error("").stack;
    return new Promise((resolve, reject) => {
      this._db.run(sql, params || {}, (err) => {
        if (err) {
          err.stack = stack;
          err.statement = sql;
          err.params = params;
          return reject(err);
        }
        resolve(this);
      });
    });
  }
  _each(sql, params = {}, callback) {
    return new Promise((resolve, reject) => {
      const take = 100;
      let skip = 0;
      let totalRows = 0;
      const nextBatch = async () => {
        try {
          const batchSql = `${sql} LIMIT ${take} OFFSET ${skip}`;
          const rows = await this._get(batchSql, params);
          let cancel = false;
          let i = 0;
          while (i < rows.length && !cancel) {
            const proceed = callback(rows[i]);
            cancel = proceed === false;
            i++;
          }
          if (cancel || rows.length < take) {
            resolve({ rows: totalRows + i, canceled: cancel });
          } else {
            totalRows += rows.length;
            skip += take;
            nextBatch();
          }
        } catch (err) {
          reject(err);
        }
      };
      nextBatch();
    });
  }
  _createTransaction() {
    const queue = [];
    const sqlite = this.sqlite;
    const run = async () => {
      if (!this._transactionConnection) {
        this._transactionConnection = new sqlite.Database(`${this.settings.path}/${this.name}.acebase/data.sqlite`, sqlite.OPEN_READWRITE);
      }
      const results = [];
      const lock = await ThreadSafe.lock("sqlite_transaction", { critical: false, timeout: 3e4 }).catch((err) => {
        throw new Error(`could not get lock to perform transaction on sqlite database: ${err.message}`);
      });
      const db = this._transactionConnection;
      const exec = (sql, params) => {
        return new Promise((resolve, reject) => {
          const callback = function(err) {
            if (err) {
              return reject(err);
            }
            resolve(this);
          };
          const args = [sql, callback];
          params && args.splice(1, 0, params);
          db.run(...args);
        });
      };
      try {
        await exec("BEGIN IMMEDIATE");
        for (const statement of queue) {
          const result = await exec(statement.sql, statement.params);
          results.push(result);
        }
        await exec("COMMIT");
      } catch (err) {
        if (results.length > 0) {
          await exec("ROLLBACK");
        }
        if (err.contains("SQLITE_BUSY")) {
          return run();
        } else {
          throw new Error(`${err} in statement #${results.length} (${queue[results.length].sql})`);
        }
      } finally {
        lock.release();
      }
      return results;
    };
    return {
      add(sql, params) {
        queue.push({ sql, params });
      },
      run
    };
  }
  async init() {
    const sqlite = this.sqlite;
    try {
      const path3 = `${this.settings.path}/${this.name}.acebase`;
      try {
        await pfs.mkdir(path3);
      } catch (err) {
        if (err.code !== "EEXIST") {
          console.error(`Cannot create dir "${path3}": ${err}`);
          throw err;
        }
      }
      this._db = new sqlite.Database(`${path3}/data.sqlite`, sqlite.OPEN_CREATE | sqlite.OPEN_READWRITE);
      this.rootRecord = null;
      const tables = {
        settings: {
          create: "CREATE TABLE settings (name TEXT PRIMARY KEY, value TEXT) WITHOUT ROWID",
          rows: [{ name: "db_schema_version", value: "1" }]
        },
        nodes: {
          create: `CREATE TABLE nodes (
                        path TEXT PRIMARY KEY,
                        type INTEGER NOT NULL,  -- node type (1=object, 2=array, 5=string, 8=binary, 9=reference)
                        text_value TEXT,        -- when type is string or reference (> max inline value length?)
                        binary_value BLOB,      -- when type is binary
                        json_value TEXT,        -- when type is object, only simple/small value children are here (no objects, arrays, large strings)
                        
                        created INTEGER NOT NULL,       -- creation timestamp
                        modified INTEGER NOT NULL,      -- modification timestamp
                        revision_nr INTEGER NOT NULL,   -- nr of times the node's value was updated
                        revision TEXT NOT NULL          -- revision id that is shared with all nested nodes that were updated at the same time, should be time sortable so could be considered as a "transaction timestamp"
                    ) WITHOUT ROWID`,
          rows: [{
            path: "",
            type: VALUE_TYPES.OBJECT,
            json_value: "{}",
            created: Date.now(),
            modified: Date.now(),
            revision_nr: 0,
            revision: ID.generate()
          }]
        },
        logs: {
          create: `CREATE TABLE logs (
                        action TEXT NOT NULL, 
                        success TINYINT NOT NULL, 
                        error TEXT, date INTEGER, 
                        details TEXT
                    )`,
          rows: [{ action: "db_created", success: 1, date: Date.now() }]
        }
      };
      const rows = await this._get(`SELECT name FROM sqlite_master WHERE type='table'`);
      rows.forEach((row) => {
        delete tables[row.name];
      });
      const promises = Object.keys(tables).map(async (name) => {
        const sql = tables[name].create;
        await this._exec(sql);
        if (tables[name].rows) {
          const rows2 = tables[name].rows;
          const promises2 = rows2.map(async (row) => {
            const keys = Object.keys(row);
            const sql2 = `INSERT INTO ${name} (${keys.join(",")}) VALUES (${keys.map((key) => "$" + key).join(",")})`;
            const params = keys.reduce((obj, key) => {
              obj["$" + key] = row[key];
              return obj;
            }, {});
            await this._exec(sql2, params);
          });
          await Promise.all(promises2);
        }
        await tables[name].action?.();
      });
      await Promise.all(promises);
      this.rootRecord = await this.getNodeInfo("");
      this.debug.log(`Database "${this.name}" details:`.colorize(ColorStyle.dim));
      this.debug.log(`- Type: SQLite`.colorize(ColorStyle.dim));
      this.debug.log(`- Max inline value size: ${this.settings.maxInlineValueSize}`.colorize(ColorStyle.dim));
      await this.indexes.load();
      this.emit("ready");
    } catch (err) {
      this.emit("error", err);
    }
  }
  _getTypeFromStoredValue(val) {
    let type;
    if (typeof val === "string") {
      type = VALUE_TYPES.STRING;
    } else if (typeof val === "number") {
      type = VALUE_TYPES.NUMBER;
    } else if (typeof val === "boolean") {
      type = VALUE_TYPES.BOOLEAN;
    } else if (val instanceof Array) {
      type = VALUE_TYPES.ARRAY;
    } else if (typeof val === "object") {
      if ("type" in val) {
        type = val.type;
        val = val.value;
        if (type === VALUE_TYPES.DATETIME) {
          val = new Date(val);
        } else if (type === VALUE_TYPES.REFERENCE) {
          val = new PathReference(val);
        }
      } else {
        type = VALUE_TYPES.OBJECT;
      }
    } else {
      throw new Error(`Unknown value type`);
    }
    return { type, value: val };
  }
  _createJSON(obj) {
    Object.keys(obj).forEach((key) => {
      let child = obj[key];
      if (child instanceof Date) {
        child = { type: VALUE_TYPES.DATETIME, value: child.getTime() };
      } else if (child instanceof PathReference) {
        child = { type: VALUE_TYPES.REFERENCE, value: child.path };
      } else if (child instanceof ArrayBuffer) {
        child = { type: VALUE_TYPES.BINARY, value: ascii85.encode(child) };
      } else if (typeof child === "object") {
        child = this._createJSON(child);
      }
      obj[key] = child;
    });
    return JSON.stringify(obj);
  }
  _deserializeJSON(type, json) {
    let value = JSON.parse(json);
    Object.keys(value).forEach((key) => {
      const val = value[key];
      if (typeof val === "object" && "type" in val) {
        if (val.type === VALUE_TYPES.BINARY) {
          value[key] = ascii85.decode(val.value);
        } else if (val.type === VALUE_TYPES.DATETIME) {
          value[key] = new Date(val.value);
        } else if (val.type === VALUE_TYPES.REFERENCE) {
          value[key] = new PathReference(val.value);
        } else {
          throw new Error(`Unhandled child value type ${val.type}`);
        }
      }
    });
    if (type === VALUE_TYPES.ARRAY) {
      const arr = [];
      Object.keys(value).forEach((index) => {
        arr[parseInt(index)] = value[index];
      });
      value = arr;
    }
    return value;
  }
  async _writeNode(path3, value, options = {
    merge: false,
    revision: null,
    transaction: null
  }) {
    if (this.valueFitsInline(value)) {
      throw new Error(`invalid value to store in its own node`);
    }
    const transaction = options.transaction || this._createTransaction();
    const currentRow = await this._getOne(`SELECT path, type, text_value, binary_value, json_value, revision, revision_nr FROM nodes WHERE path = $path`, { $path: path3 });
    const newRevision = options && options.revision || ID.generate();
    const mainNode = {
      type: VALUE_TYPES.OBJECT,
      value: {},
      storageType: "json"
    };
    const childNodeValues = {};
    if (value instanceof Array) {
      mainNode.type = VALUE_TYPES.ARRAY;
      const obj = {};
      for (let i = 0; i < value.length; i++) {
        obj[i] = value[i];
      }
      value = obj;
    } else if (value instanceof PathReference) {
      mainNode.type = VALUE_TYPES.REFERENCE;
      mainNode.value = value.path;
      mainNode.storageType = "text";
    } else if (value instanceof ArrayBuffer) {
      mainNode.type = VALUE_TYPES.BINARY;
      mainNode.value = Buffer.from(value);
      mainNode.storageType = "binary";
    } else if (typeof value === "string") {
      mainNode.type = VALUE_TYPES.STRING;
      mainNode.value = value;
      mainNode.storageType = "text";
    }
    const currentIsObjectOrArray = currentRow ? [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(currentRow.type) : false;
    const newIsObjectOrArray = [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(mainNode.type);
    const children = {
      current: [],
      new: []
    };
    let currentObject = null;
    if (currentIsObjectOrArray) {
      currentObject = this._deserializeJSON(currentRow.type, currentRow.json_value);
      children.current = Object.keys(currentObject);
      if (newIsObjectOrArray) {
        mainNode.value = currentObject;
      }
    }
    if (newIsObjectOrArray) {
      Object.keys(value).forEach((key) => {
        const val = value[key];
        delete mainNode.value[key];
        if (val === null) {
          return;
        }
        if (this.valueFitsInline(val)) {
          mainNode.value[key] = val;
        } else {
          childNodeValues[key] = val;
        }
      });
    }
    if (currentRow) {
      this.debug.log(`Node "/${path3}" is being ${options.merge ? "updated" : "overwritten"}`.colorize(ColorStyle.cyan));
      const updateMainNode = () => {
        const sql = `UPDATE nodes SET type = $type, text_value = $text_value, binary_value = $binary_value, json_value = $json_value, modified = $modified, revision_nr = revision_nr + 1, revision = $revision
                WHERE path = $path`;
        const params = {
          $path: path3,
          $type: mainNode.type,
          $text_value: mainNode.storageType === "text" ? mainNode.value : null,
          $binary_value: mainNode.storageType === "binary" ? mainNode.value : null,
          $json_value: mainNode.storageType === "json" ? this._createJSON(mainNode.value) : null,
          $modified: Date.now(),
          $revision: newRevision
        };
        transaction.add(sql, params);
      };
      if (currentIsObjectOrArray || newIsObjectOrArray) {
        let childRows = [];
        if (currentIsObjectOrArray) {
          const where = path3 === "" ? `path <> '' AND path NOT LIKE '%/%'` : `(path LIKE '${path3}/%' OR path LIKE '${path3}[%') AND path NOT LIKE '${path3}/%/%' AND path NOT LIKE '${path3}[%]/%' AND path NOT LIKE '${path3}[%][%'`;
          childRows = await this._get(`SELECT path FROM nodes WHERE ${where}`);
        }
        const keys = childRows.map((row) => PathInfo.get(row.path).key);
        children.current = children.current.concat(keys);
        if (newIsObjectOrArray) {
          if (options && options.merge) {
            children.new = children.current.slice();
          }
          Object.keys(value).forEach((key) => {
            if (!children.new.includes(key)) {
              children.new.push(key);
            }
          });
        }
        const changes = {
          insert: children.new.filter((key) => !children.current.includes(key)),
          update: children.new.filter((key) => children.current.includes(key)),
          delete: options && options.merge ? Object.keys(value).filter((key) => value[key] === null) : children.current.filter((key) => !children.new.includes(key))
        };
        const childUpdatePromises = Object.keys(childNodeValues).map((key) => {
          const childPath = PathInfo.getChildPath(path3, key);
          const childValue = childNodeValues[key];
          return this._writeNode(childPath, childValue, { revision: newRevision, merge: false, transaction });
        });
        const movingNodes = keys.filter((key) => key in mainNode.value);
        const deleteDedicatedKeys = changes.delete.concat(movingNodes);
        deleteDedicatedKeys.forEach((key) => {
          const childPath = PathInfo.getChildPath(path3, key);
          this._deleteNode(childPath, { transaction });
        });
        updateMainNode();
        await Promise.all(childUpdatePromises);
      } else {
        updateMainNode();
      }
    } else {
      this.debug.log(`Node "/${path3}" is being created`.colorize(ColorStyle.cyan));
      const childCreatePromises = Object.keys(childNodeValues).map(async (key) => {
        const childPath = PathInfo.getChildPath(path3, key);
        const childValue = childNodeValues[key];
        await this._writeNode(childPath, childValue, { revision: newRevision, merge: false, transaction });
      });
      await Promise.all(childCreatePromises);
      const sql = `INSERT INTO nodes (path, type, text_value, binary_value, json_value, created, modified, revision_nr, revision)
                VALUES ($path, $type, $text_value, $binary_value, $json_value, $created, $modified, $revision_nr, $revision)`;
      const params = {
        $path: path3,
        $type: mainNode.type,
        $text_value: mainNode.storageType === "text" ? mainNode.value : null,
        $binary_value: mainNode.storageType === "binary" ? mainNode.value : null,
        $json_value: mainNode.storageType === "json" ? this._createJSON(mainNode.value) : null,
        $created: Date.now(),
        $modified: Date.now(),
        $revision_nr: 0,
        $revision: newRevision
      };
      transaction.add(sql, params);
    }
    if (!options.transaction) {
      try {
        await transaction.run();
      } catch (err) {
        console.error(err);
        throw err;
      }
    }
  }
  _deleteNode(path3, options = { transaction: null }) {
    const where = path3 === "" ? "" : `WHERE path = '${path3}' OR path LIKE '${path3}/%' OR path LIKE '${path3}[%'`;
    const sql = `DELETE FROM nodes ${where}`;
    if (options && options.transaction) {
      options.transaction.add(sql);
    } else {
      return this._exec(sql);
    }
  }
  getChildren(path3, options = {}) {
    let callback;
    const generator = {
      next(valueCallback) {
        callback = valueCallback;
        return start();
      }
    };
    const start = async () => {
      let canceled = false;
      const tid = options && options.tid || ID.generate();
      const lock = await this.nodeLocker.lock(path3, tid.toString(), false, "getChildren");
      try {
        const row = await this._getOne(`SELECT type, json_value, revision, revision_nr, created, modified FROM nodes WHERE path = $path`, { $path: path3 });
        if (!row) {
          throw new NodeNotFoundError(`Node "/${path3}" does not exist`);
        }
        if (![VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(row.type)) {
          return false;
        }
        const isArray2 = row.type === VALUE_TYPES.ARRAY;
        const value = JSON.parse(row.json_value);
        let keys = Object.keys(value);
        if (options.keyFilter) {
          keys = keys.filter((key) => options.keyFilter.includes(key));
        }
        const pathInfo = PathInfo.get(path3);
        keys.length > 0 && keys.every((key) => {
          const child = this._getTypeFromStoredValue(value[key]);
          const info = new SQLiteNodeInfo({
            path: pathInfo.childPath(key),
            ...!isArray2 && { key },
            ...isArray2 && { index: parseInt(key) },
            type: child.type,
            address: null,
            exists: true,
            value: child.value,
            revision: row.revision,
            revision_nr: row.revision_nr,
            created: row.created,
            modified: row.modified
          });
          canceled = callback(info) === false;
          return !canceled;
        });
        if (canceled) {
          return true;
        }
        const where = path3 === "" ? `path <> '' AND instr(path,'/')=0 AND instr(path,'[')=0` : `path LIKE '${path3}${isArray2 ? "[" : "/"}%' AND path NOT LIKE '${path3}${isArray2 ? "[" : "/"}%/%' AND path NOT LIKE '${path3}${isArray2 ? "[" : "/"}%[%'`;
        const q = `SELECT path, type, revision, revision_nr, created, modified FROM nodes WHERE ${where}`;
        await this._each(q, null, (row2) => {
          const key = PathInfo.get(row2.path).key;
          if (options.keyFilter && !options.keyFilter.includes(key)) {
            return true;
          }
          const info = new SQLiteNodeInfo({
            path: row2.path,
            type: row2.type,
            ...!isArray2 && { key },
            ...isArray2 && { index: key },
            address: new SQLiteNodeAddress(row2.path),
            exists: true,
            value: null,
            revision: row2.revision,
            revision_nr: row2.revision_nr,
            created: row2.created,
            modified: row2.modified
          });
          canceled = callback(info) === false;
          return !canceled;
        });
        return canceled;
      } finally {
        lock.release();
      }
    };
    return generator;
  }
  async getNode(path3, options = { child_objects: true }) {
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), false, "getNode");
    try {
      let where = "";
      if (path3 === "") {
        if (options && options.child_objects === false) {
          where = `WHERE path='' OR type NOT IN (${VALUE_TYPES.OBJECT},${VALUE_TYPES.ARRAY})`;
        }
      } else if (options && options.child_objects === false) {
        where = `WHERE path='${path3}' OR ((path LIKE '${path3}/%' OR path LIKE '${path3}[%') AND type NOT IN (${VALUE_TYPES.OBJECT},${VALUE_TYPES.ARRAY}))`;
      } else {
        where = `WHERE path = '${path3}' OR path LIKE '${path3}/%' OR path LIKE '${path3}[%'`;
      }
      let filtered = false;
      let childRows;
      if (options && (options.include || options.exclude || options.child_objects === false)) {
        filtered = true;
        const rows = await this._get(`SELECT path, type FROM nodes ${where}`);
        const paths = [path3];
        const includeCheck = options.include ? new RegExp("^" + options.include.map((p) => `(?:${p.toString().replace(/\*/g, "[^/\\[]+")})`).join("|") + "(?:$|[/\\[])") : null;
        const excludeCheck = options.exclude ? new RegExp("^" + options.exclude.map((p) => `(?:${p.toString().replace(/\*/g, "[^/\\[]+")})`).join("|") + "(?:$|[/\\[])") : null;
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (row.path === path3) {
            continue;
          }
          let checkPath = row.path.slice(path3.length);
          if (checkPath[0] === "/") {
            checkPath = checkPath.slice(1);
          }
          const match = (includeCheck ? includeCheck.test(checkPath) : true) && (excludeCheck ? !excludeCheck.test(checkPath) : true) && (options.child_objects === false ? row.type !== VALUE_TYPES.OBJECT && !/[/[]/.test(checkPath) : true);
          if (match) {
            paths.push(row.path);
          }
        }
        childRows = await this._get(`SELECT path, type, text_value, binary_value, json_value, revision FROM nodes WHERE path IN (${paths.map((p) => `'${p}'`).join(",")})`);
      } else {
        childRows = await this._get(`SELECT path, type, text_value, binary_value, json_value, revision FROM nodes ${where}`);
      }
      if (childRows.length === 0) {
        if (path3 === "") {
          return { revision: null, value: null };
        }
        lock = await lock.moveToParent();
        const pathInfo = PathInfo.get(path3);
        const parentRow = await this._getOne(`SELECT type, json_value, revision FROM nodes WHERE path = '${pathInfo.parentPath}'`);
        const result2 = {
          revision: parentRow ? parentRow.revision : null,
          value: null
        };
        if (!parentRow) {
          return result2;
        }
        if (![VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(parentRow.type)) {
          return result2;
        }
        const val = this._deserializeJSON(parentRow.type, parentRow.json_value);
        if (!(pathInfo.key in val)) {
          return result2;
        }
        result2.value = val[pathInfo.key];
        return result2;
      }
      this.debug.log(`Read node "/${path3}" and ${filtered ? "(filtered) " : ""}children from ${childRows.length} records`.colorize(ColorStyle.magenta));
      const targetPathKeys = PathInfo.getPathKeys(path3);
      const targetRow = childRows.find((row) => row.path === path3);
      const result = {
        revision: targetRow ? targetRow.revision : null,
        value: null
      };
      if (targetRow.type === VALUE_TYPES.OBJECT || targetRow.type === VALUE_TYPES.ARRAY) {
        const value = this._deserializeJSON(targetRow.type, targetRow.json_value);
        for (let i = 0; i < childRows.length; i++) {
          const otherRow = childRows[i];
          if (otherRow === targetRow) {
            continue;
          }
          const pathKeys = PathInfo.getPathKeys(otherRow.path);
          const trailKeys = pathKeys.slice(targetPathKeys.length);
          let parent = value;
          for (let j = 0; j < trailKeys.length; j++) {
            assert(typeof parent === "object", "parent must be an object/array to have children!!");
            const key = trailKeys[j];
            const isLast = j === trailKeys.length - 1;
            const nodeType = isLast ? otherRow.type : typeof trailKeys[j + 1] === "number" ? VALUE_TYPES.ARRAY : VALUE_TYPES.OBJECT;
            let nodeValue;
            if (!isLast) {
              nodeValue = nodeType === VALUE_TYPES.OBJECT ? {} : [];
            } else if (nodeType === VALUE_TYPES.OBJECT || nodeType === VALUE_TYPES.ARRAY) {
              nodeValue = this._deserializeJSON(otherRow.type, otherRow.json_value);
            } else if (nodeType === VALUE_TYPES.REFERENCE) {
              nodeValue = new PathReference(otherRow.text_value);
            } else if (nodeType === VALUE_TYPES.BINARY) {
              nodeValue = otherRow.binary_value;
            } else {
              nodeValue = otherRow.text_value;
            }
            if (key in parent) {
              assert(typeof parent[key] === typeof nodeValue && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(nodeType), "Merging child values can only be done if existing and current values are both an array or object");
              Object.keys(nodeValue).forEach((childKey) => {
                assert(!(childKey in parent[key]), "child key is in parent value already?! HOW?!");
                parent[key][childKey] = nodeValue[childKey];
              });
            } else {
              parent[key] = nodeValue;
            }
            parent = parent[key];
          }
        }
        result.value = value;
      } else if (childRows.length > 1) {
        throw new Error(`more than 1 record found for non-object value!`);
      } else if (targetRow.type === VALUE_TYPES.REFERENCE) {
        result.value = new PathReference(targetRow.text_value);
      } else if (targetRow.type === VALUE_TYPES.BINARY) {
        const val = targetRow.binary_value;
        result.value = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
      } else {
        result.value = targetRow.text_value;
      }
      if (options.child_objects === false) {
        Object.keys(result.value).forEach((key) => {
          if (typeof result.value[key] === "object" && result.value[key].constructor === Object) {
            assert(Object.keys(result.value[key]).length === 0);
            delete result.value[key];
          }
        });
      }
      if (options.exclude) {
        const process9 = (obj, keys) => {
          if (typeof obj !== "object") {
            return;
          }
          const key = keys[0];
          if (key === "*") {
            Object.keys(obj).forEach((k) => {
              process9(obj[k], keys.slice(1));
            });
          } else if (keys.length > 1) {
            key in obj && process9(obj[key], keys.slice(1));
          } else {
            delete obj[key];
          }
        };
        options.exclude.forEach((path4) => {
          const checkKeys = typeof path4 === "number" ? [path4] : PathInfo.getPathKeys(path4);
          process9(result.value, checkKeys);
        });
      }
      return result;
    } finally {
      lock.release();
    }
  }
  async getNodeInfo(path3, options = {}) {
    const lookupNode = async (path4) => {
      const rows = await this._get(`SELECT type, text_value, binary_value, json_value, created, modified, revision, revision_nr FROM nodes WHERE path='${path4}'`);
      if (rows.length === 0) {
        return null;
      }
      const row = rows[0];
      let value = null;
      if (row.type === VALUE_TYPES.OBJECT || row.type === VALUE_TYPES.ARRAY) {
        value = JSON.parse(row.json_value);
      } else if (row.type === VALUE_TYPES.BINARY) {
        const val = row.binary_value;
        value = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
      } else {
        value = row.text_value;
      }
      return {
        path: path4,
        type: row.type,
        value,
        created: row.created,
        modified: row.modified,
        revision: row.revision,
        revision_nr: row.revision_nr
      };
    };
    const pathInfo = PathInfo.get(path3);
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), false, "getNodeInfo");
    try {
      const node = await lookupNode(path3);
      const info = new SQLiteNodeInfo({
        path: path3,
        key: typeof pathInfo.key === "string" ? pathInfo.key : null,
        index: typeof pathInfo.key === "number" ? pathInfo.key : null,
        type: node ? node.type : 0,
        exists: node !== null,
        address: node ? new SQLiteNodeAddress(path3) : null,
        created: node ? parseInt(node.created) : null,
        modified: node ? parseInt(node.modified) : null,
        revision: node ? node.revision : null,
        revision_nr: node ? node.revision_nr : null
      });
      if (node || path3 === "") {
        return info;
      }
      lock = await lock.moveToParent();
      const parent = await lookupNode(pathInfo.parentPath);
      if (parent && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(parent.type) && pathInfo.key in parent.value) {
        info.exists = true;
        info.value = parent.value[pathInfo.key];
        info.address = null;
        switch (typeof info.value) {
          case "string": {
            info.type = VALUE_TYPES.STRING;
            break;
          }
          case "number": {
            info.type = VALUE_TYPES.NUMBER;
            break;
          }
          case "boolean": {
            info.type = VALUE_TYPES.BOOLEAN;
            break;
          }
          case "object": {
            info.type = info.value.type;
            info.value = info.value.value;
            if (info.type === VALUE_TYPES.DATETIME) {
              info.value = new Date(info.value);
            }
            break;
          }
        }
        info.created = parseInt(parent.created);
        info.modified = parseInt(parent.modified);
        info.revision = parent.revision;
        info.revision_nr = parent.revision_nr;
      } else {
        info.address = null;
      }
      return info;
    } finally {
      lock.release();
    }
  }
  async setNode(path3, value, options = {
    suppress_events: false,
    context: null
  }) {
    if (this.settings.readOnly) {
      throw new Error(`Database is opened in read-only mode`);
    }
    const pathInfo = PathInfo.get(path3);
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), true, "setNode");
    try {
      if (path3 === "") {
        if (value === null || typeof value !== "object" || value instanceof Array || value instanceof ArrayBuffer || "buffer" in value && value.buffer instanceof ArrayBuffer) {
          throw new Error(`Invalid value for root node: ${value}`);
        }
        await this._writeNodeWithTracking("", value, { merge: false, tid, suppress_events: options.suppress_events, context: options.context });
      } else if (options && typeof options.assert_revision !== "undefined") {
        const info = await this.getNodeInfo(path3, { tid: lock.tid });
        if (info.revision !== options.assert_revision) {
          throw new NodeRevisionError(`revision '${info.revision}' does not match requested revision '${options.assert_revision}'`);
        }
        if (info.address && info.address.path === path3 && !this.valueFitsInline(value)) {
          await this._writeNodeWithTracking(path3, value, { merge: false, tid, suppress_events: options.suppress_events, context: options.context });
        } else {
          lock = await lock.moveToParent();
          await this._writeNodeWithTracking(pathInfo.parentPath, { [pathInfo.key]: value }, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
        }
      } else {
        lock = await lock.moveToParent();
        return this.updateNode(pathInfo.parentPath, { [pathInfo.key]: value }, { tid, suppress_events: options.suppress_events, context: options.context });
      }
    } finally {
      lock.release();
    }
  }
  async updateNode(path3, updates, options = {
    suppress_events: false,
    context: null
  }) {
    if (this.settings.readOnly) {
      throw new Error(`Database is opened in read-only mode`);
    }
    if (typeof updates !== "object") {
      throw new Error(`invalid updates argument`);
    }
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), true, "updateNode");
    try {
      const nodeInfo = await this.getNodeInfo(path3, { tid: lock.tid });
      const pathInfo = PathInfo.get(path3);
      if (nodeInfo.exists && nodeInfo.address && nodeInfo.address.path === path3) {
        await this._writeNodeWithTracking(path3, updates, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
      } else if (nodeInfo.exists) {
        const pathInfo2 = PathInfo.get(path3);
        lock = await lock.moveToParent();
        await this._writeNodeWithTracking(pathInfo2.parentPath, { [pathInfo2.key]: updates }, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
      } else {
        lock = await lock.moveToParent();
        await this.updateNode(pathInfo.parentPath, { [pathInfo.key]: updates }, { tid, suppress_events: options.suppress_events, context: options.context });
      }
    } finally {
      lock.release();
    }
  }
};

// node_modules/acebase/dist/esm/storage/mssql/index.js
var MSSQLNodeAddress = class extends NodeAddress {
  constructor(containerPath) {
    super(containerPath);
  }
};
var MSSQLNodeInfo = class extends NodeInfo {
  constructor(info) {
    super(info);
    this.revision = info.revision;
    this.revision_nr = info.revision_nr;
    this.created = info.created;
    this.modified = info.modified;
  }
};
var MSSQLStorageSettings = class extends StorageSettings {
  constructor(options) {
    super(options);
    this.driver = "tedious";
    this.server = "localhost";
    this.port = 1433;
    this.encrypt = true;
    this.appName = "AceBase";
    this.connectionTimeout = 6e4;
    this.requestTimeout = 3e5;
    this.maxConnections = 10;
    this.minConnections = 0;
    this.idleTimeout = 3e5;
    this.trustedConnection = false;
    this.driver = options.driver === "native" ? "native" : "tedious";
    this.domain = options.domain;
    this.user = options.user;
    this.password = options.password;
    this.server = options.server || "localhost";
    this.port = typeof options.port === "number" ? options.port : 1433;
    this.database = options.database;
    this.instance = options.instance;
    this.encrypt = typeof options.encrypt === "boolean" ? options.encrypt : true;
    this.appName = "AceBase";
    this.connectionTimeout = typeof options.connectionTimeout === "number" ? options.connectionTimeout : 60 * 1e3;
    this.requestTimeout = typeof options.requestTimeout === "number" ? options.requestTimeout : 5 * 60 * 1e3;
    this.maxConnections = typeof options.maxConnections === "number" ? options.maxConnections : 10;
    this.minConnections = typeof options.minConnections === "number" ? options.minConnections : 0;
    this.idleTimeout = typeof options.idleTimeout === "number" ? options.idleTimeout : 30 * 1e3;
    this.trustedConnection = options.trustedConnection === true;
    if (this.trustedConnection && this.driver !== "native") {
      throw new Error(`Cannot use trusted connection (windows authentication) when not using the native driver`);
    }
  }
};
var MSSQLStorage = class extends Storage {
  constructor(name, settings, env2) {
    settings = new MSSQLStorageSettings(settings);
    super(name, settings, env2);
    if (this.settings.driver === "native") {
      try {
        this.mssql = require("mssql/msnodesqlv8");
      } catch (err) {
        throw new Error(`Native driver for MSSQL not found. To use Microsoft's native V8 MSSQL driver, add msnodesqlv8 to your project dependencies: npm i msnodesqlv8 (also add mssql package)`);
      }
    }
    try {
      this.mssql = require("mssql");
    } catch (err) {
      throw new Error(`MSSQL not found. To use MSSQL as storage, add mssql to your project dependencies: npm i mssql`);
    }
    this.init();
  }
  async init() {
    const path3 = `${this.settings.path}/${this.name}.acebase`;
    const exists2 = await pfs.exists(path3);
    if (!exists2) {
      try {
        await pfs.mkdir(path3);
      } catch (err) {
        console.error(`Cannot create dir "${path3}": ${err}`);
        throw err;
      }
    }
    const settings = this.settings;
    this._db = new this.mssql.ConnectionPool({
      domain: settings.domain,
      user: settings.user,
      password: settings.password,
      server: settings.server,
      port: settings.port,
      database: settings.database,
      options: {
        encrypt: settings.encrypt,
        appName: settings.appName,
        abortTransactionOnError: true,
        instanceName: settings.instance,
        trustedConnection: settings.trustedConnection
      },
      connectionTimeout: settings.connectionTimeout,
      requestTimeout: settings.requestTimeout,
      pool: {
        max: settings.maxConnections,
        min: settings.minConnections,
        idleTimeoutMillis: settings.idleTimeout
      }
    });
    try {
      await this._db.connect();
      this.rootRecord = null;
      const tables = {
        settings: {
          create: "CREATE TABLE settings (name VARCHAR(50) NOT NULL PRIMARY KEY, value NVARCHAR(250))",
          rows: [{ name: "db_schema_version", value: "1" }]
        },
        nodes: {
          create: `CREATE TABLE nodes (
                        path NVARCHAR(1000) NOT NULL PRIMARY KEY,
                        type TINYINT NOT NULL,  -- node type (1=object, 2=array, 5=string, 8=binary, 9=reference)
                        text_value NVARCHAR(MAX),        -- when type is string or reference (> max inline value length?)
                        binary_value VARBINARY(MAX),      -- when type is binary
                        json_value NVARCHAR(MAX),        -- when type is object, only simple/small value children are here (no objects, arrays, large strings)
                        
                        created BIGINT NOT NULL,       -- creation timestamp
                        modified BIGINT NOT NULL,      -- modification timestamp
                        revision_nr INT NOT NULL,   -- nr of times the node's value was updated
                        revision CHAR(24) NOT NULL  -- revision id that is shared with all nested nodes that were updated at the same time, should be time sortable so could be considered as a "transaction timestamp"
                    )`,
          rows: [{
            path: "",
            type: VALUE_TYPES.OBJECT,
            json_value: "{}",
            created: Date.now(),
            modified: Date.now(),
            revision_nr: 0,
            revision: ID.generate()
          }]
        },
        logs: {
          create: `CREATE TABLE logs (
                        id INT IDENTITY(1,1) NOT NULL PRIMARY KEY,
                        action VARCHAR(25) NOT NULL, 
                        success BIT NOT NULL, 
                        error NVARCHAR(MAX), 
                        date BIGINT, 
                        details NVARCHAR(MAX)
                    )`,
          rows: [{ action: "db_created", success: 1, date: Date.now() }]
        }
      };
      const rows = await this._get(`SELECT TABLE_NAME AS name FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'`);
      rows.forEach((row) => {
        delete tables[row.name];
      });
      const promises = Object.keys(tables).map(async (name) => {
        const sql = tables[name].create;
        const result = await this._exec(sql);
        if (tables[name].rows) {
          const rows2 = tables[name].rows;
          const promises2 = rows2.map(async (row) => {
            const keys = Object.keys(row);
            const sql2 = `INSERT INTO ${name} (${keys.join(",")}) VALUES (${keys.map((key) => "@" + key).join(",")})`;
            const params = keys.reduce((obj, key) => {
              obj[key] = row[key];
              return obj;
            }, {});
            await this._exec(sql2, params);
          });
          await Promise.all(promises2);
        }
        await tables[name].action?.();
      });
      await Promise.all(promises);
      this.rootRecord = await this.getNodeInfo("");
      this.debug.log(`Database "${this.name}" details:`.colorize(ColorStyle.dim));
      this.debug.log(`- Type: MSSQL`.colorize(ColorStyle.dim));
      this.debug.log(`- Server: ${this.settings.server}:${this.settings.port}`.colorize(ColorStyle.dim));
      this.debug.log(`- Database: ${this.settings.database}`.colorize(ColorStyle.dim));
      this.debug.log(`- Max inline value size: ${this.settings.maxInlineValueSize}`.colorize(ColorStyle.dim));
      await this.indexes.load();
      this.emit("ready");
    } catch (err) {
      this.debug.error(`Error initializing MSSQL database: ${err.message}`);
      this.emit("error", err);
    }
  }
  _executeRequest(request2, sql, params) {
    const mssql = this.mssql;
    Object.keys(params ?? {}).forEach((name) => {
      const value = params[name];
      if (value === null) {
        sql = sql.replace(new RegExp(`@${name}`, "g"), "null");
        delete params[name];
        return;
      }
      const type = (() => {
        switch (typeof value) {
          case "string":
            return mssql.NVarChar;
          case "number":
            return mssql.BigInt;
          case "object": {
            if (value instanceof ArrayBuffer || value instanceof Buffer) {
              return mssql.VarBinary(value.byteLength);
            } else {
              throw new Error(`Unknown object parameter`);
            }
          }
          default:
            throw new Error(`Unknown parameter type`);
        }
      })();
      request2.input(name, type, value);
    });
    return request2.query(sql);
  }
  async _get(sql, params) {
    const request2 = new this.mssql.Request(this._db);
    const result = await this._executeRequest(request2, sql, params);
    return result.recordset;
  }
  async _getOne(sql, params) {
    const rows = await this._get(sql, params);
    return rows[0];
  }
  async _exec(sql, params) {
    const request2 = new this.mssql.Request(this._db);
    const result = await this._executeRequest(request2, sql, params);
    return result;
  }
  _each(sql, params = {}, callback) {
    const request2 = new this.mssql.Request(this._db);
    request2.stream = true;
    return new Promise((resolve, reject) => {
      let totalRows = 0;
      let canceled = false;
      request2.on("row", (row) => {
        if (canceled) {
          return;
        }
        totalRows++;
        canceled = callback(row) === false;
        if (canceled) {
          request2.cancel();
          resolve({ rows: totalRows, canceled: true });
        }
      });
      request2.on("error", (err) => {
        if (err.code !== "ECANCEL") {
          reject(err);
        }
      });
      request2.on("done", (result) => {
        resolve({ rows: totalRows, canceled: false });
      });
      this._executeRequest(request2, sql, params);
    });
  }
  _createTransaction() {
    const queue = [];
    const mssql = this.mssql;
    const run = async () => {
      const results = [];
      const transaction = new mssql.Transaction(this._db);
      try {
        await transaction.begin();
        const exec = (sql, params) => {
          const request2 = new mssql.Request(transaction);
          return this._executeRequest(request2, sql, params);
        };
        for (const statement of queue) {
          const result = await exec(statement.sql, statement.params);
          results.push(result);
        }
        await transaction.commit();
        return results;
      } catch (err) {
        const ourErr = new Error(`Error in statement #${results.length} (${queue[results.length].sql}): ${err.message}`);
        ourErr.inner = err;
        throw ourErr;
      }
    };
    return {
      add(sql, params) {
        queue.push({ sql, params });
      },
      run
    };
  }
  _getTypeFromStoredValue(val) {
    let type;
    if (typeof val === "string") {
      type = VALUE_TYPES.STRING;
    } else if (typeof val === "number") {
      type = VALUE_TYPES.NUMBER;
    } else if (typeof val === "boolean") {
      type = VALUE_TYPES.BOOLEAN;
    } else if (val instanceof Array) {
      type = VALUE_TYPES.ARRAY;
    } else if (typeof val === "object") {
      if ("type" in val) {
        type = val.type;
        val = val.value;
        if (type === VALUE_TYPES.DATETIME) {
          val = new Date(val);
        } else if (type === VALUE_TYPES.REFERENCE) {
          val = new PathReference(val);
        }
      } else {
        type = VALUE_TYPES.OBJECT;
      }
    } else {
      throw new Error(`Unknown value type`);
    }
    return { type, value: val };
  }
  _createJSON(obj) {
    Object.keys(obj).forEach((key) => {
      let child = obj[key];
      if (child instanceof Date) {
        child = { type: VALUE_TYPES.DATETIME, value: child.getTime() };
      } else if (child instanceof PathReference) {
        child = { type: VALUE_TYPES.REFERENCE, value: child.path };
      } else if (child instanceof ArrayBuffer) {
        child = { type: VALUE_TYPES.BINARY, value: ascii85.encode(child) };
      } else if (typeof child === "object") {
        child = this._createJSON(child);
      }
      obj[key] = child;
    });
    return JSON.stringify(obj);
  }
  _deserializeJSON(type, json) {
    let value = JSON.parse(json);
    Object.keys(value).forEach((key) => {
      const val = value[key];
      if (typeof val === "object" && "type" in val) {
        if (val.type === VALUE_TYPES.BINARY) {
          value[key] = ascii85.decode(val.value);
        } else if (val.type === VALUE_TYPES.DATETIME) {
          value[key] = new Date(val.value);
        } else if (val.type === VALUE_TYPES.REFERENCE) {
          value[key] = new PathReference(val.value);
        } else {
          throw new Error(`Unhandled child value type ${val.type}`);
        }
      }
    });
    if (type === VALUE_TYPES.ARRAY) {
      const arr = [];
      Object.keys(value).forEach((index) => {
        arr[parseInt(index)] = value[index];
      });
      value = arr;
    }
    return value;
  }
  async _writeNode(path3, value, options = {
    merge: false,
    revision: null,
    transaction: null
  }) {
    if (this.valueFitsInline(value)) {
      throw new Error(`invalid value to store in its own node`);
    }
    const transaction = options.transaction || this._createTransaction();
    const currentRow = await this._getOne(`SELECT path, type, text_value, binary_value, json_value, revision, revision_nr FROM nodes WHERE path = @path`, { path: path3 });
    const newRevision = options && options.revision || ID.generate();
    const mainNode = {
      type: VALUE_TYPES.OBJECT,
      value: {},
      storageType: "json"
    };
    const childNodeValues = {};
    if (value instanceof Array) {
      mainNode.type = VALUE_TYPES.ARRAY;
      const obj = {};
      for (let i = 0; i < value.length; i++) {
        obj[i] = value[i];
      }
      value = obj;
    } else if (value instanceof PathReference) {
      mainNode.type = VALUE_TYPES.REFERENCE;
      mainNode.value = value.path;
      mainNode.storageType = "text";
    } else if (value instanceof ArrayBuffer) {
      mainNode.type = VALUE_TYPES.BINARY;
      mainNode.value = Buffer.from(value);
      mainNode.storageType = "binary";
    } else if (typeof value === "string") {
      mainNode.type = VALUE_TYPES.STRING;
      mainNode.value = value;
      mainNode.storageType = "text";
    }
    const currentIsObjectOrArray = currentRow ? [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(currentRow.type) : false;
    const newIsObjectOrArray = [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(mainNode.type);
    const children = {
      current: [],
      new: []
    };
    let currentObject = null;
    if (currentIsObjectOrArray) {
      currentObject = this._deserializeJSON(currentRow.type, currentRow.json_value);
      children.current = Object.keys(currentObject);
      if (newIsObjectOrArray) {
        mainNode.value = currentObject;
      }
    }
    if (newIsObjectOrArray) {
      Object.keys(value).forEach((key) => {
        const val = value[key];
        delete mainNode.value[key];
        if (val === null) {
          return;
        }
        if (this.valueFitsInline(val)) {
          mainNode.value[key] = val;
        } else {
          childNodeValues[key] = val;
        }
      });
    }
    if (currentRow) {
      this.debug.log(`Node "/${path3}" is being ${options.merge ? "updated" : "overwritten"}`.colorize(ColorStyle.cyan));
      const updateMainNode = () => {
        const sql = `UPDATE nodes SET type = @type, text_value = @text_value, binary_value = @binary_value, json_value = @json_value, modified = @modified, revision_nr = revision_nr + 1, revision = @revision
                    WHERE path = @path`;
        const params = {
          path: path3,
          type: mainNode.type,
          text_value: mainNode.storageType === "text" ? mainNode.value : null,
          binary_value: mainNode.storageType === "binary" ? mainNode.value : null,
          json_value: mainNode.storageType === "json" ? this._createJSON(mainNode.value) : null,
          modified: Date.now(),
          revision: newRevision
        };
        transaction.add(sql, params);
      };
      if (currentIsObjectOrArray || newIsObjectOrArray) {
        let childRows = [];
        if (currentIsObjectOrArray) {
          const where = path3 === "" ? `path <> '' AND path NOT LIKE '%/%'` : `(path LIKE '${path3}/%' OR path LIKE '${path3}[%') AND path NOT LIKE '${path3}/%/%' AND path NOT LIKE '${path3}[%]/%' AND path NOT LIKE '${path3}[%][%'`;
          childRows = await this._get(`SELECT path FROM nodes WHERE ${where}`);
        }
        const keys = childRows.map((row) => PathInfo.get(row.path).key);
        children.current = children.current.concat(keys);
        if (newIsObjectOrArray) {
          if (options && options.merge) {
            children.new = children.current.slice();
          }
          Object.keys(value).forEach((key) => {
            if (!children.new.includes(key)) {
              children.new.push(key);
            }
          });
        }
        const changes = {
          insert: children.new.filter((key) => !children.current.includes(key)),
          update: children.new.filter((key) => children.current.includes(key)),
          delete: options && options.merge ? Object.keys(value).filter((key) => value[key] === null) : children.current.filter((key) => !children.new.includes(key))
        };
        const childUpdatePromises = Object.keys(childNodeValues).map((key) => {
          const childPath = PathInfo.getChildPath(path3, key);
          const childValue = childNodeValues[key];
          return this._writeNode(childPath, childValue, { revision: newRevision, merge: false, transaction });
        });
        const movingNodes = keys.filter((key) => key in mainNode.value);
        const deleteDedicatedKeys = changes.delete.concat(movingNodes);
        deleteDedicatedKeys.forEach((key) => {
          const childPath = PathInfo.getChildPath(path3, key);
          this._deleteNode(childPath, { transaction });
        });
        updateMainNode();
        await Promise.all(childUpdatePromises);
      } else {
        updateMainNode();
      }
    } else {
      this.debug.log(`Node "/${path3}" is being created`.colorize(ColorStyle.cyan));
      const childCreatePromises = Object.keys(childNodeValues).map((key) => {
        const childPath = PathInfo.getChildPath(path3, key);
        const childValue = childNodeValues[key];
        return this._writeNode(childPath, childValue, { revision: newRevision, merge: false, transaction });
      });
      await Promise.all(childCreatePromises);
      const sql = `INSERT INTO nodes (path, type, text_value, binary_value, json_value, created, modified, revision_nr, revision)
                VALUES (@path, @type, @text_value, @binary_value, @json_value, @created, @modified, @revision_nr, @revision)`;
      const params = {
        path: path3,
        type: mainNode.type,
        text_value: mainNode.storageType === "text" ? mainNode.value : null,
        binary_value: mainNode.storageType === "binary" ? mainNode.value : null,
        json_value: mainNode.storageType === "json" ? this._createJSON(mainNode.value) : null,
        created: Date.now(),
        modified: Date.now(),
        revision_nr: 0,
        revision: newRevision
      };
      transaction.add(sql, params);
    }
    if (!options.transaction) {
      try {
        await transaction.run();
      } catch (err) {
        console.error(err);
        throw err;
      }
    }
  }
  _deleteNode(path3, options = { transaction: null }) {
    const where = path3 === "" ? "" : `WHERE path = '${path3}' OR path LIKE '${path3}/%' OR path LIKE '${path3}[%'`;
    const sql = `DELETE FROM nodes ${where}`;
    if (options && options.transaction) {
      options.transaction.add(sql);
    } else {
      return this._exec(sql);
    }
  }
  getChildren(path3, options = {}) {
    let callback;
    const generator = {
      next(valueCallback) {
        callback = valueCallback;
        return start();
      }
    };
    const start = async () => {
      let canceled = false;
      const tid = options && options.tid || ID.generate();
      const lock = await this.nodeLocker.lock(path3, tid.toString(), false, "getChildren");
      try {
        const row = await this._getOne(`SELECT type, json_value, revision, revision_nr, created, modified FROM nodes WHERE path = @path`, { path: path3 });
        if (!row) {
          throw new NodeNotFoundError(`Node "/${path3}" does not exist`);
        }
        if (![VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(row.type)) {
          return false;
        }
        const isArray2 = row.type === VALUE_TYPES.ARRAY;
        const value = JSON.parse(row.json_value);
        let keys = Object.keys(value);
        if (options.keyFilter) {
          keys = keys.filter((key) => options.keyFilter.includes(key));
        }
        const pathInfo = PathInfo.get(path3);
        keys.length > 0 && keys.every((key) => {
          const child = this._getTypeFromStoredValue(value[key]);
          const info = new MSSQLNodeInfo({
            path: pathInfo.childPath(key),
            ...!isArray2 && { key },
            ...isArray2 && { index: parseInt(key) },
            type: child.type,
            address: null,
            exists: true,
            value: child.value,
            revision: row.revision,
            revision_nr: row.revision_nr,
            created: parseInt(row.created),
            modified: parseInt(row.modified)
          });
          canceled = callback(info) === false;
          return !canceled;
        });
        if (canceled) {
          return;
        }
        const where = path3 === "" ? `path <> '' AND instr(path,'/')=0 AND instr(path,'[')=0` : `path LIKE '${path3}${isArray2 ? "[" : "/"}%' AND path NOT LIKE '${path3}${isArray2 ? "[" : "/"}%/%' AND path NOT LIKE '${path3}${isArray2 ? "[" : "/"}%[%'`;
        const q = `SELECT path, type, revision, revision_nr, created, modified FROM nodes WHERE ${where}`;
        await this._each(q, null, (row2) => {
          const key = PathInfo.get(row2.path).key;
          if (options.keyFilter && !options.keyFilter.includes(key)) {
            return;
          }
          const info = new MSSQLNodeInfo({
            path: row2.path,
            type: row2.type,
            ...!isArray2 && { key },
            ...isArray2 && { index: key },
            address: new MSSQLNodeAddress(row2.path),
            exists: true,
            value: null,
            revision: row2.revision,
            revision_nr: row2.revision_nr,
            created: parseInt(row2.created),
            modified: parseInt(row2.modified)
          });
          canceled = callback(info) === false;
          return !canceled;
        });
      } finally {
        lock.release();
      }
      return canceled;
    };
    return generator;
  }
  async getNode(path3, options = { child_objects: true }) {
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), false, "getNode");
    try {
      let where = "";
      if (path3 === "") {
        if (options && options.child_objects === false) {
          where = `WHERE path='' OR type NOT IN (${VALUE_TYPES.OBJECT},${VALUE_TYPES.ARRAY})`;
        }
      } else if (options && options.child_objects === false) {
        where = `WHERE path='${path3}' OR ((path LIKE '${path3}/%' OR path LIKE '${path3}[%') AND type NOT IN (${VALUE_TYPES.OBJECT},${VALUE_TYPES.ARRAY}))`;
      } else {
        where = `WHERE path = '${path3}' OR path LIKE '${path3}/%' OR path LIKE '${path3}[%'`;
      }
      let rows;
      let filtered = false;
      if (options && (options.include || options.exclude || options.child_objects === false)) {
        filtered = true;
        rows = await this._get(`SELECT path, type FROM nodes ${where}`);
        const paths = [path3];
        const includeCheck = options.include ? new RegExp("^" + options.include.map((p) => `(?:${p.toString().replace(/\*/g, "[^/\\[]+")})`).join("|") + "(?:$|[/\\[])") : null;
        const excludeCheck = options.exclude ? new RegExp("^" + options.exclude.map((p) => `(?:${p.toString().replace(/\*/g, "[^/\\[]+")})`).join("|") + "(?:$|[/\\[])") : null;
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (row.path === path3) {
            continue;
          }
          let checkPath = row.path.slice(path3.length);
          if (checkPath[0] === "/") {
            checkPath = checkPath.slice(1);
          }
          const match = (includeCheck ? includeCheck.test(checkPath) : true) && (excludeCheck ? !excludeCheck.test(checkPath) : true) && (options.child_objects === false ? row.type !== VALUE_TYPES.OBJECT && !/[/[]/.test(checkPath) : true);
          if (match) {
            paths.push(row.path);
          }
        }
        rows = await this._get(`SELECT path, type, text_value, binary_value, json_value, revision FROM nodes WHERE path IN (${paths.map((p) => `'${p}'`).join(",")})`);
      } else {
        rows = await this._get(`SELECT path, type, text_value, binary_value, json_value, revision FROM nodes ${where}`);
      }
      if (rows.length === 0) {
        lock = await lock.moveToParent();
        if (path3 === "") {
          return null;
        }
        const pathInfo = PathInfo.get(path3);
        const parentRow = await this._getOne(`SELECT type, json_value, revision FROM nodes WHERE path = '${pathInfo.parentPath}'`);
        const result2 = {
          revision: parentRow ? parentRow.revision : null,
          value: null
        };
        if (!parentRow) {
          return result2;
        }
        if (![VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(parentRow.type)) {
          return result2;
        }
        const val = this._deserializeJSON(parentRow.type, parentRow.json_value);
        if (!(pathInfo.key in val)) {
          return result2;
        }
        result2.value = val[pathInfo.key];
        return result2;
      }
      this.debug.log(`Read node "/${path3}" and ${filtered ? "(filtered) " : ""}children from ${rows.length} records`.colorize(ColorStyle.magenta));
      const targetPathKeys = PathInfo.getPathKeys(path3);
      const targetRow = rows.find((row) => row.path === path3);
      const result = {
        revision: targetRow ? targetRow.revision : null,
        value: null
      };
      if (targetRow.type === VALUE_TYPES.OBJECT || targetRow.type === VALUE_TYPES.ARRAY) {
        const value = this._deserializeJSON(targetRow.type, targetRow.json_value);
        for (let i = 0; i < rows.length; i++) {
          const otherRow = rows[i];
          if (otherRow === targetRow) {
            continue;
          }
          const pathKeys = PathInfo.getPathKeys(otherRow.path);
          const trailKeys = pathKeys.slice(targetPathKeys.length);
          let parent = value;
          for (let j = 0; j < trailKeys.length; j++) {
            assert(typeof parent === "object", "parent must be an object/array to have children!!");
            const key = trailKeys[j];
            const isLast = j === trailKeys.length - 1;
            const nodeType = isLast ? otherRow.type : typeof trailKeys[j + 1] === "number" ? VALUE_TYPES.ARRAY : VALUE_TYPES.OBJECT;
            let nodeValue;
            if (!isLast) {
              nodeValue = nodeType === VALUE_TYPES.OBJECT ? {} : [];
            } else if (nodeType === VALUE_TYPES.OBJECT || nodeType === VALUE_TYPES.ARRAY) {
              nodeValue = this._deserializeJSON(otherRow.type, otherRow.json_value);
            } else if (nodeType === VALUE_TYPES.REFERENCE) {
              nodeValue = new PathReference(otherRow.text_value);
            } else if (nodeType === VALUE_TYPES.BINARY) {
              nodeValue = otherRow.binary_value;
            } else {
              nodeValue = otherRow.text_value;
            }
            if (key in parent) {
              assert(typeof parent[key] === typeof nodeValue && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(nodeType), "Merging child values can only be done if existing and current values are both an array or object");
              Object.keys(nodeValue).forEach((childKey) => {
                assert(!(childKey in parent[key]), "child key is in parent value already?! HOW?!");
                parent[key][childKey] = nodeValue[childKey];
              });
            } else {
              parent[key] = nodeValue;
            }
            parent = parent[key];
          }
        }
        result.value = value;
      } else if (rows.length > 1) {
        throw new Error(`more than 1 record found for non-object value!`);
      } else if (targetRow.type === VALUE_TYPES.REFERENCE) {
        result.value = new PathReference(targetRow.text_value);
      } else if (targetRow.type === VALUE_TYPES.BINARY) {
        const val = targetRow.binary_value;
        result.value = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
      } else {
        result.value = targetRow.text_value;
      }
      if (options.child_objects === false) {
        Object.keys(result.value).forEach((key) => {
          if (typeof result.value[key] === "object" && result.value[key].constructor === Object) {
            assert(Object.keys(result.value[key]).length === 0);
            delete result.value[key];
          }
        });
      }
      if (options.exclude) {
        const process9 = (obj, keys) => {
          if (typeof obj !== "object") {
            return;
          }
          const key = keys[0];
          if (key === "*") {
            Object.keys(obj).forEach((k) => {
              process9(obj[k], keys.slice(1));
            });
          } else if (keys.length > 1) {
            key in obj && process9(obj[key], keys.slice(1));
          } else {
            delete obj[key];
          }
        };
        options.exclude.forEach((path4) => {
          const checkKeys = typeof path4 === "number" ? [path4] : PathInfo.getPathKeys(path4);
          process9(result.value, checkKeys);
        });
      }
      return result;
    } finally {
      lock.release();
    }
  }
  async getNodeInfo(path3, options = {}) {
    const lookupNode = async (path4) => {
      const rows = await this._get(`SELECT type, text_value, binary_value, json_value, created, modified, revision, revision_nr FROM nodes WHERE path=@path`, { path: path4 });
      if (rows.length === 0) {
        return null;
      }
      const row = rows[0];
      let value = null;
      if (row.type === VALUE_TYPES.OBJECT || row.type === VALUE_TYPES.ARRAY) {
        value = JSON.parse(row.json_value);
      } else if (row.type === VALUE_TYPES.BINARY) {
        const val = row.binary_value;
        value = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
      } else {
        value = row.text_value;
      }
      return {
        path: path4,
        type: row.type,
        value,
        created: row.created,
        modified: row.modified,
        revision: row.revision,
        revision_nr: row.revision_nr
      };
    };
    const pathInfo = PathInfo.get(path3);
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), false, "getNodeInfo");
    try {
      const node = await lookupNode(path3);
      const info = new MSSQLNodeInfo({
        path: path3,
        key: typeof pathInfo.key === "string" ? pathInfo.key : null,
        index: typeof pathInfo.key === "number" ? pathInfo.key : null,
        type: node ? node.type : 0,
        exists: node !== null,
        address: node ? new MSSQLNodeAddress(path3) : null,
        created: node ? parseInt(node.created) : null,
        modified: node ? parseInt(node.modified) : null,
        revision: node ? node.revision : null,
        revision_nr: node ? node.revision_nr : null
      });
      if (node || path3 === "") {
        return info;
      }
      lock = await lock.moveToParent();
      const parent = await lookupNode(pathInfo.parentPath);
      if (parent && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(parent.type) && pathInfo.key in parent.value) {
        info.exists = true;
        info.value = parent.value[pathInfo.key];
        info.address = null;
        switch (typeof info.value) {
          case "string": {
            info.type = VALUE_TYPES.STRING;
            break;
          }
          case "number": {
            info.type = VALUE_TYPES.NUMBER;
            break;
          }
          case "boolean": {
            info.type = VALUE_TYPES.BOOLEAN;
            break;
          }
          case "object": {
            info.type = info.value.type;
            info.value = info.value.value;
            if (info.type === VALUE_TYPES.DATETIME) {
              info.value = new Date(info.value);
            }
            break;
          }
        }
        info.created = parseInt(parent.created);
        info.modified = parseInt(parent.modified);
        info.revision = parent.revision;
        info.revision_nr = parent.revision_nr;
      } else {
        info.address = null;
      }
      return info;
    } finally {
      lock.release();
    }
  }
  async setNode(path3, value, options = {
    suppress_events: false,
    context: null
  }) {
    if (this.settings.readOnly) {
      throw new Error(`Database is opened in read-only mode`);
    }
    const pathInfo = PathInfo.get(path3);
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), true, "setNode");
    try {
      if (path3 === "") {
        if (value === null || typeof value !== "object" || value instanceof Array || value instanceof ArrayBuffer || "buffer" in value && value.buffer instanceof ArrayBuffer) {
          throw new Error(`Invalid value for root node: ${value}`);
        }
        await this._writeNodeWithTracking("", value, { merge: false, tid, suppress_events: options.suppress_events, context: options.context });
      } else if (options && typeof options.assert_revision !== "undefined") {
        const info = await this.getNodeInfo(path3, { tid: lock.tid });
        if (info.revision !== options.assert_revision) {
          throw new NodeRevisionError(`revision '${info.revision}' does not match requested revision '${options.assert_revision}'`);
        }
        if (info.address && info.address.path === path3 && !this.valueFitsInline(value)) {
          await this._writeNodeWithTracking(path3, value, { merge: false, tid, suppress_events: options.suppress_events, context: options.context });
        } else {
          lock = await lock.moveToParent();
          await this._writeNodeWithTracking(pathInfo.parentPath, { [pathInfo.key]: value }, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
        }
      } else {
        lock = await lock.moveToParent();
        return this.updateNode(pathInfo.parentPath, { [pathInfo.key]: value }, { tid, suppress_events: options.suppress_events, context: options.context });
      }
    } finally {
      lock.release();
    }
  }
  async updateNode(path3, updates, options = {
    suppress_events: false,
    context: null
  }) {
    if (this.settings.readOnly) {
      throw new Error(`Database is opened in read-only mode`);
    }
    if (typeof updates !== "object") {
      throw new Error(`invalid updates argument`);
    }
    const tid = options && options.tid || ID.generate();
    let lock = await this.nodeLocker.lock(path3, tid.toString(), true, "updateNode");
    try {
      const nodeInfo = await this.getNodeInfo(path3, { tid: lock.tid });
      const pathInfo = PathInfo.get(path3);
      if (nodeInfo.exists && nodeInfo.address && nodeInfo.address.path === path3) {
        await this._writeNodeWithTracking(path3, updates, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
      } else if (nodeInfo.exists) {
        const pathInfo2 = PathInfo.get(path3);
        lock = await lock.moveToParent();
        await this._writeNodeWithTracking(pathInfo2.parentPath, { [pathInfo2.key]: updates }, { merge: true, tid, suppress_events: options.suppress_events, context: options.context });
      } else {
        lock = await lock.moveToParent();
        await this.updateNode(pathInfo.parentPath, { [pathInfo.key]: updates }, { tid, suppress_events: options.suppress_events, context: options.context });
      }
    } finally {
      lock.release();
    }
  }
};

// node_modules/acebase/dist/esm/storage/custom/helpers.js
var CustomStorageHelpers = class {
  static ChildPathsSql(path3, columnName = "path") {
    const where = path3 === "" ? `${columnName} <> '' AND ${columnName} NOT LIKE '%/%'` : `(${columnName} LIKE '${path3}/%' OR ${columnName} LIKE '${path3}[%') AND ${columnName} NOT LIKE '${path3}/%/%' AND ${columnName} NOT LIKE '${path3}[%]/%' AND ${columnName} NOT LIKE '${path3}[%][%'`;
    return where;
  }
  static ChildPathsRegex(path3) {
    return new RegExp(`^${path3}(?:/[^/[]+|\\[[0-9]+\\])$`);
  }
  static DescendantPathsSql(path3, columnName = "path") {
    const where = path3 === "" ? `${columnName} <> ''` : `${columnName} LIKE '${path3}/%' OR ${columnName} LIKE '${path3}[%'`;
    return where;
  }
  static DescendantPathsRegex(path3) {
    return new RegExp(`^${path3}(?:/[^/[]+|\\[[0-9]+\\])`);
  }
  static get PathInfo() {
    return PathInfo;
  }
};

// node_modules/acebase/dist/esm/storage/custom/index.js
var { compareValues: compareValues4 } = utils_exports;
var CustomStorageTransaction = class {
  constructor(target) {
    this.production = false;
    this.target = {
      get originalPath() {
        return target.path;
      },
      path: target.path,
      get write() {
        return target.write;
      }
    };
    this.id = ID.generate();
  }
  async getChildCount(path3) {
    let childCount = 0;
    await this.childrenOf(path3, { metadata: false, value: false }, () => {
      childCount++;
      return false;
    });
    return childCount;
  }
  async getMultiple(paths) {
    const map2 = /* @__PURE__ */ new Map();
    await Promise.all(paths.map((path3) => this.get(path3).then((val) => map2.set(path3, val))));
    return map2;
  }
  async setMultiple(nodes) {
    await Promise.all(nodes.map(({ path: path3, node }) => this.set(path3, node)));
  }
  async removeMultiple(paths) {
    await Promise.all(paths.map((path3) => this.remove(path3)));
  }
  async commit() {
    throw new Error(`CustomStorageTransaction.rollback must be overridden by subclass`);
  }
  async moveToParentPath(targetPath) {
    const currentPath = this._lock && this._lock.path || this.target.path;
    if (currentPath === targetPath) {
      return targetPath;
    }
    const pathInfo = CustomStorageHelpers.PathInfo.get(targetPath);
    if (pathInfo.isParentOf(currentPath)) {
      if (this._lock) {
        this._lock = await this._lock.moveToParent();
      }
    } else {
      throw new Error(`Locking issue. Locked path "${this._lock.path}" is not a child/descendant of "${targetPath}"`);
    }
    this.target.path = targetPath;
    return targetPath;
  }
};
var CustomStorageSettings = class extends StorageSettings {
  constructor(settings) {
    super(settings);
    this.locking = true;
    if (typeof settings !== "object") {
      throw new Error("settings missing");
    }
    if (typeof settings.ready !== "function") {
      throw new Error(`ready must be a function`);
    }
    if (typeof settings.getTransaction !== "function") {
      throw new Error(`getTransaction must be a function`);
    }
    this.name = settings.name;
    this.locking = settings.locking !== false;
    if (this.locking) {
      this.lockTimeout = typeof settings.lockTimeout === "number" ? settings.lockTimeout : 120;
    }
    this.ready = settings.ready;
    const useLocking = this.locking;
    const nodeLocker = useLocking ? new NodeLocker(console, this.lockTimeout) : null;
    this.getTransaction = async ({ path: path3, write: write2 }) => {
      const transaction = await settings.getTransaction({ path: path3, write: write2 });
      assert(typeof transaction.id === "string", `transaction id not set`);
      const rollback = transaction.rollback;
      const commit = transaction.commit;
      transaction.commit = async () => {
        const ret = await commit.call(transaction);
        if (useLocking) {
          await transaction._lock.release("commit");
        }
        return ret;
      };
      transaction.rollback = async (reason) => {
        const ret = await rollback.call(transaction, reason);
        if (useLocking) {
          await transaction._lock.release("rollback");
        }
        return ret;
      };
      if (useLocking) {
        transaction._lock = await nodeLocker.lock(path3, transaction.id, write2, `${this.name}::getTransaction`);
      }
      return transaction;
    };
  }
};
var CustomStorageNodeInfo = class extends NodeInfo {
  constructor(info) {
    super(info);
    this.revision = info.revision;
    this.revision_nr = info.revision_nr;
    this.created = info.created;
    this.modified = info.modified;
  }
};
var CustomStorage = class extends Storage {
  constructor(dbname, settings, env2) {
    super(dbname, settings, env2);
    this._customImplementation = settings;
    this._init();
  }
  async _init() {
    this.debug.log(`Database "${this.name}" details:`.colorize(ColorStyle.dim));
    this.debug.log(`- Type: CustomStorage`.colorize(ColorStyle.dim));
    this.debug.log(`- Path: ${this.settings.path}`.colorize(ColorStyle.dim));
    this.debug.log(`- Max inline value size: ${this.settings.maxInlineValueSize}`.colorize(ColorStyle.dim));
    this.debug.log(`- Autoremove undefined props: ${this.settings.removeVoidProperties}`.colorize(ColorStyle.dim));
    await this._customImplementation.ready();
    const transaction = await this._customImplementation.getTransaction({ path: "", write: true });
    const info = await this.getNodeInfo("", { transaction });
    if (!info.exists) {
      await this._writeNode("", {}, { transaction });
    }
    await transaction.commit();
    if (this.indexes.supported) {
      await this.indexes.load();
    }
    this.emit("ready");
  }
  throwImplementationError(message) {
    throw new Error(`CustomStorage "${this._customImplementation.name}" ${message}`);
  }
  _storeNode(path3, node, options) {
    const getTypedChildValue = (val) => {
      if (val === null) {
        throw new Error(`Not allowed to store null values. remove the property`);
      } else if (["string", "number", "boolean"].includes(typeof val)) {
        return val;
      } else if (val instanceof Date) {
        return { type: VALUE_TYPES.DATETIME, value: val.getTime() };
      } else if (val instanceof PathReference) {
        return { type: VALUE_TYPES.REFERENCE, value: val.path };
      } else if (val instanceof ArrayBuffer) {
        return { type: VALUE_TYPES.BINARY, value: ascii85.encode(val) };
      } else if (typeof val === "object") {
        assert(Object.keys(val).length === 0, "child object stored in parent can only be empty");
        return val;
      }
    };
    const unprocessed = `Caller should have pre-processed the value by converting it to a string`;
    if (node.type === VALUE_TYPES.ARRAY && node.value instanceof Array) {
      console.warn(`Unprocessed array. ${unprocessed}`);
      const obj = {};
      for (let i = 0; i < node.value.length; i++) {
        obj[i] = node.value[i];
      }
      node.value = obj;
    }
    if (node.type === VALUE_TYPES.BINARY && typeof node.value !== "string") {
      console.warn(`Unprocessed binary value. ${unprocessed}`);
      node.value = ascii85.encode(node.value);
    }
    if (node.type === VALUE_TYPES.REFERENCE && node.value instanceof PathReference) {
      console.warn(`Unprocessed path reference. ${unprocessed}`);
      node.value = node.value.path;
    }
    if ([VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(node.type)) {
      const original = node.value;
      node.value = {};
      Object.keys(original).forEach((key) => {
        node.value[key] = getTypedChildValue(original[key]);
      });
    }
    return options.transaction.set(path3, node);
  }
  _processReadNodeValue(node) {
    const getTypedChildValue = (val) => {
      if (val.type === VALUE_TYPES.BINARY) {
        return ascii85.decode(val.value);
      } else if (val.type === VALUE_TYPES.DATETIME) {
        return new Date(val.value);
      } else if (val.type === VALUE_TYPES.REFERENCE) {
        return new PathReference(val.value);
      } else {
        throw new Error(`Unhandled child value type ${val.type}`);
      }
    };
    switch (node.type) {
      case VALUE_TYPES.ARRAY:
      case VALUE_TYPES.OBJECT: {
        const obj = node.value;
        Object.keys(obj).forEach((key) => {
          const item = obj[key];
          if (typeof item === "object" && "type" in item) {
            obj[key] = getTypedChildValue(item);
          }
        });
        node.value = obj;
        break;
      }
      case VALUE_TYPES.BINARY: {
        node.value = ascii85.decode(node.value);
        break;
      }
      case VALUE_TYPES.REFERENCE: {
        node.value = new PathReference(node.value);
        break;
      }
      case VALUE_TYPES.STRING: {
        break;
      }
      default:
        throw new Error(`Invalid standalone record value type`);
    }
  }
  async _readNode(path3, options) {
    const node = await options.transaction.get(path3);
    if (node === null) {
      return null;
    }
    if (typeof node !== "object") {
      this.throwImplementationError(`transaction.get must return an ICustomStorageNode object. Use JSON.parse if your set function stored it as a string`);
    }
    this._processReadNodeValue(node);
    return node;
  }
  _getTypeFromStoredValue(val) {
    let type;
    if (typeof val === "string") {
      type = VALUE_TYPES.STRING;
    } else if (typeof val === "number") {
      type = VALUE_TYPES.NUMBER;
    } else if (typeof val === "boolean") {
      type = VALUE_TYPES.BOOLEAN;
    } else if (val instanceof Array) {
      type = VALUE_TYPES.ARRAY;
    } else if (typeof val === "object") {
      if ("type" in val) {
        const serialized = val;
        type = serialized.type;
        val = serialized.value;
        if (type === VALUE_TYPES.DATETIME) {
          val = new Date(val);
        } else if (type === VALUE_TYPES.REFERENCE) {
          val = new PathReference(val);
        }
      } else {
        type = VALUE_TYPES.OBJECT;
      }
    } else {
      throw new Error(`Unknown value type`);
    }
    return { type, value: val };
  }
  async _writeNode(path3, value, options) {
    if (!options.merge && this.valueFitsInline(value) && path3 !== "") {
      throw new Error(`invalid value to store in its own node`);
    } else if (path3 === "" && (typeof value !== "object" || value instanceof Array)) {
      throw new Error(`Invalid root node value. Must be an object`);
    }
    if (typeof options.diff === "undefined" && typeof options.currentValue !== "undefined") {
      const diff = compareValues4(options.currentValue, value);
      if (options.merge && typeof diff === "object") {
        diff.removed = diff.removed.filter((key) => value[key] === null);
      }
      options.diff = diff;
    }
    if (options.diff === "identical") {
      return;
    }
    const transaction = options.transaction;
    const currentRow = options.currentValue === null ? null : await this._readNode(path3, { transaction });
    if (options.merge && currentRow) {
      if (currentRow.type === VALUE_TYPES.ARRAY && !(value instanceof Array) && typeof value === "object" && Object.keys(value).some((key) => isNaN(parseInt(key)))) {
        throw new Error(`Cannot merge existing array of path "${path3}" with an object`);
      }
      if (value instanceof Array && currentRow.type !== VALUE_TYPES.ARRAY) {
        throw new Error(`Cannot merge existing object of path "${path3}" with an array`);
      }
    }
    const revision = options.revision || ID.generate();
    const mainNode = {
      type: currentRow && currentRow.type === VALUE_TYPES.ARRAY ? VALUE_TYPES.ARRAY : VALUE_TYPES.OBJECT,
      value: {}
    };
    const childNodeValues = {};
    if (value instanceof Array) {
      mainNode.type = VALUE_TYPES.ARRAY;
      const obj = {};
      for (let i = 0; i < value.length; i++) {
        obj[i] = value[i];
      }
      value = obj;
    } else if (value instanceof PathReference) {
      mainNode.type = VALUE_TYPES.REFERENCE;
      mainNode.value = value.path;
    } else if (value instanceof ArrayBuffer) {
      mainNode.type = VALUE_TYPES.BINARY;
      mainNode.value = ascii85.encode(value);
    } else if (typeof value === "string") {
      mainNode.type = VALUE_TYPES.STRING;
      mainNode.value = value;
    }
    const currentIsObjectOrArray = currentRow ? [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(currentRow.type) : false;
    const newIsObjectOrArray = [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(mainNode.type);
    const children = {
      current: [],
      new: []
    };
    let currentObject = null;
    if (currentIsObjectOrArray) {
      currentObject = currentRow.value;
      children.current = Object.keys(currentObject);
      if (newIsObjectOrArray) {
        mainNode.value = currentObject;
      }
    }
    if (newIsObjectOrArray) {
      if (!options.merge) {
        Object.keys(mainNode.value).forEach((key) => {
          if (!(key in value)) {
            value[key] = null;
          }
        });
      }
      Object.keys(value).forEach((key) => {
        const val = value[key];
        delete mainNode.value[key];
        if (val === null) {
          return;
        } else if (typeof val === "undefined") {
          if (this.settings.removeVoidProperties === true) {
            delete value[key];
            return;
          } else {
            throw new Error(`Property "${key}" has invalid value. Cannot store undefined values. Set removeVoidProperties option to true to automatically remove undefined properties`);
          }
        }
        if (this.valueFitsInline(val)) {
          mainNode.value[key] = val;
        } else {
          childNodeValues[key] = val;
        }
      });
    }
    const isArray2 = mainNode.type === VALUE_TYPES.ARRAY;
    if (currentRow) {
      this.debug.log(`Node "/${path3}" is being ${options.merge ? "updated" : "overwritten"}`.colorize(ColorStyle.cyan));
      if (currentIsObjectOrArray || newIsObjectOrArray) {
        const pathInfo = PathInfo.get(path3);
        const keys = [];
        let checkExecuted = false;
        const includeChildCheck = (childPath) => {
          checkExecuted = true;
          if (!transaction.production && !pathInfo.isParentOf(childPath)) {
            this.throwImplementationError(`"${childPath}" is not a child of "${path3}" - childrenOf must only check and return paths that are children`);
          }
          return true;
        };
        const addChildPath = (childPath) => {
          if (!checkExecuted) {
            this.throwImplementationError(`childrenOf did not call checkCallback before addCallback`);
          }
          const key = PathInfo.get(childPath).key;
          keys.push(key.toString());
          return true;
        };
        await transaction.childrenOf(path3, { metadata: false, value: false }, includeChildCheck, addChildPath);
        children.current = children.current.concat(keys);
        if (newIsObjectOrArray) {
          if (options && options.merge) {
            children.new = children.current.slice();
          }
          Object.keys(value).forEach((key) => {
            if (!children.new.includes(key)) {
              children.new.push(key);
            }
          });
        }
        const changes = {
          insert: children.new.filter((key) => !children.current.includes(key)),
          update: [],
          delete: options && options.merge ? Object.keys(value).filter((key) => value[key] === null) : children.current.filter((key) => !children.new.includes(key))
        };
        changes.update = children.new.filter((key) => children.current.includes(key) && !changes.delete.includes(key));
        if (isArray2 && options.merge && (changes.insert.length > 0 || changes.delete.length > 0)) {
          const newArrayKeys = changes.update.concat(changes.insert);
          const isExhaustive = newArrayKeys.every((k, index, arr) => arr.includes(index.toString()));
          if (!isExhaustive) {
            throw new Error(`Elements cannot be inserted beyond, or removed before the end of an array. Rewrite the whole array at path "${path3}" or change your schema to use an object collection instead`);
          }
        }
        const writePromises = Object.keys(childNodeValues).map((key) => {
          const keyOrIndex = isArray2 ? parseInt(key) : key;
          const childDiff = typeof options.diff === "object" ? options.diff.forChild(keyOrIndex) : void 0;
          if (childDiff === "identical") {
            return;
          }
          const childPath = pathInfo.childPath(keyOrIndex);
          const childValue = childNodeValues[keyOrIndex];
          const currentChildValue = typeof options.currentValue === "undefined" ? void 0 : options.currentValue !== null && typeof options.currentValue === "object" && keyOrIndex in options.currentValue ? options.currentValue[keyOrIndex] : null;
          return this._writeNode(childPath, childValue, { transaction, revision, merge: false, currentValue: currentChildValue, diff: childDiff });
        });
        const movingNodes = newIsObjectOrArray ? keys.filter((key) => key in mainNode.value) : [];
        const deleteDedicatedKeys = changes.delete.concat(movingNodes);
        const deletePromises = deleteDedicatedKeys.map((key) => {
          const keyOrIndex = isArray2 ? parseInt(key) : key;
          const childPath = pathInfo.childPath(keyOrIndex);
          return this._deleteNode(childPath, { transaction });
        });
        const promises = writePromises.concat(deletePromises);
        await Promise.all(promises);
      }
      const p = this._storeNode(path3, {
        type: mainNode.type,
        value: mainNode.value,
        revision: currentRow.revision,
        revision_nr: currentRow.revision_nr + 1,
        created: currentRow.created,
        modified: Date.now()
      }, {
        transaction
      });
      if (p instanceof Promise) {
        return await p;
      }
    } else {
      this.debug.log(`Node "/${path3}" is being created`.colorize(ColorStyle.cyan));
      if (isArray2) {
        const arrayKeys = Object.keys(mainNode.value).concat(Object.keys(childNodeValues));
        const isExhaustive = arrayKeys.every((k, index, arr) => arr.includes(index.toString()));
        if (!isExhaustive) {
          throw new Error(`Cannot store arrays with missing entries`);
        }
      }
      const promises = Object.keys(childNodeValues).map((key) => {
        const keyOrIndex = isArray2 ? parseInt(key) : key;
        const childPath = PathInfo.getChildPath(path3, keyOrIndex);
        const childValue = childNodeValues[keyOrIndex];
        return this._writeNode(childPath, childValue, { transaction, revision, merge: false, currentValue: null });
      });
      const p = this._storeNode(path3, {
        type: mainNode.type,
        value: mainNode.value,
        revision,
        revision_nr: 1,
        created: Date.now(),
        modified: Date.now()
      }, {
        transaction
      });
      if (p instanceof Promise) {
        promises.push(p);
      }
      await Promise.all(promises);
    }
  }
  async _deleteNode(path3, options) {
    const pathInfo = PathInfo.get(path3);
    this.debug.log(`Node "/${path3}" is being deleted`.colorize(ColorStyle.cyan));
    const deletePaths = [path3];
    let checkExecuted = false;
    const includeDescendantCheck = (descPath) => {
      checkExecuted = true;
      if (!transaction.production && !pathInfo.isAncestorOf(descPath)) {
        this.throwImplementationError(`"${descPath}" is not a descendant of "${path3}" - descendantsOf must only check and return paths that are descendants`);
      }
      return true;
    };
    const addDescendant = (descPath) => {
      if (!checkExecuted) {
        this.throwImplementationError(`descendantsOf did not call checkCallback before addCallback`);
      }
      deletePaths.push(descPath);
      return true;
    };
    const transaction = options.transaction;
    await transaction.descendantsOf(path3, { metadata: false, value: false }, includeDescendantCheck, addDescendant);
    this.debug.log(`Nodes ${deletePaths.map((p) => `"/${p}"`).join(",")} are being deleted`.colorize(ColorStyle.cyan));
    return transaction.removeMultiple(deletePaths);
  }
  getChildren(path3, options = {}) {
    let callback;
    const generator = {
      next(valueCallback) {
        callback = valueCallback;
        return start();
      }
    };
    const start = async () => {
      const transaction = options.transaction || await this._customImplementation.getTransaction({ path: path3, write: false });
      try {
        let canceled = false;
        await (async () => {
          const node = await this._readNode(path3, { transaction });
          if (!node) {
            throw new NodeNotFoundError(`Node "/${path3}" does not exist`);
          }
          if (![VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(node.type)) {
            return;
          }
          const isArray2 = node.type === VALUE_TYPES.ARRAY;
          const value = node.value;
          let keys = Object.keys(value).map((key) => isArray2 ? parseInt(key) : key);
          if (options.keyFilter) {
            keys = keys.filter((key) => options.keyFilter.includes(key));
          }
          const pathInfo = PathInfo.get(path3);
          keys.length > 0 && keys.every((key) => {
            const child = this._getTypeFromStoredValue(value[key]);
            const info = new CustomStorageNodeInfo({
              path: pathInfo.childPath(key),
              key: isArray2 ? null : key,
              index: isArray2 ? key : null,
              type: child.type,
              address: null,
              exists: true,
              value: child.value,
              revision: node.revision,
              revision_nr: node.revision_nr,
              created: new Date(node.created),
              modified: new Date(node.modified)
            });
            canceled = callback(info) === false;
            return !canceled;
          });
          if (canceled) {
            return;
          }
          let checkExecuted = false;
          const includeChildCheck = (childPath) => {
            checkExecuted = true;
            if (!transaction.production && !pathInfo.isParentOf(childPath)) {
              this.throwImplementationError(`"${childPath}" is not a child of "${path3}" - childrenOf must only check and return paths that are children`);
            }
            if (options.keyFilter) {
              const key = PathInfo.get(childPath).key;
              return options.keyFilter.includes(key);
            }
            return true;
          };
          const addChildNode = (childPath, node2) => {
            if (!checkExecuted) {
              this.throwImplementationError(`childrenOf did not call checkCallback before addCallback`);
            }
            const key = PathInfo.get(childPath).key;
            const info = new CustomStorageNodeInfo({
              path: childPath,
              type: node2.type,
              key: isArray2 ? null : key,
              index: isArray2 ? key : null,
              address: new NodeAddress(childPath),
              exists: true,
              value: null,
              revision: node2.revision,
              revision_nr: node2.revision_nr,
              created: new Date(node2.created),
              modified: new Date(node2.modified)
            });
            canceled = callback(info) === false;
            return !canceled;
          };
          await transaction.childrenOf(path3, { metadata: true, value: false }, includeChildCheck, addChildNode);
        })();
        if (!options.transaction) {
          await transaction.commit();
        }
        return canceled;
      } catch (err) {
        if (!options.transaction) {
          await transaction.rollback(err);
        }
        throw err;
      }
    };
    return generator;
  }
  async getNode(path3, options) {
    options = options || {};
    const transaction = options.transaction || await this._customImplementation.getTransaction({ path: path3, write: false });
    try {
      const node = await (async () => {
        const filtered = options.include && options.include.length > 0 || options.exclude && options.exclude.length > 0 || options.child_objects === false;
        const pathInfo = PathInfo.get(path3);
        const targetNode = await this._readNode(path3, { transaction });
        if (!targetNode) {
          if (path3 === "") {
            return { value: null };
          }
          const lockPath = await transaction.moveToParentPath(pathInfo.parentPath);
          assert(lockPath === pathInfo.parentPath, `transaction.moveToParentPath() did not move to the right parent path of "${path3}"`);
          const parentNode = await this._readNode(pathInfo.parentPath, { transaction });
          if (parentNode && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(parentNode.type) && pathInfo.key in parentNode.value) {
            const childValueInfo = this._getTypeFromStoredValue(parentNode.value[pathInfo.key]);
            return {
              revision: parentNode.revision,
              revision_nr: parentNode.revision_nr,
              created: parentNode.created,
              modified: parentNode.modified,
              type: childValueInfo.type,
              value: childValueInfo.value
            };
          }
          return { value: null };
        }
        const isArray2 = targetNode.type === VALUE_TYPES.ARRAY;
        const convertFilterArray = (arr) => {
          const isNumber2 = (key) => /^[0-9]+$/.test(key);
          return arr.map((path4) => PathInfo.get(isArray2 && isNumber2(path4) ? `[${path4}]` : path4));
        };
        const includeFilter = options.include ? convertFilterArray(options.include) : [];
        const excludeFilter = options.exclude ? convertFilterArray(options.exclude) : [];
        const applyFiltersOnInlineData = (descPath, node2) => {
          if ([VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(node2.type) && includeFilter.length > 0) {
            const trailKeys = PathInfo.getPathKeys(descPath).slice(pathInfo.keys.length);
            const checkPathInfo = new PathInfo(trailKeys);
            const remove = [];
            const includes = includeFilter.filter((info) => info.isDescendantOf(checkPathInfo));
            if (includes.length > 0) {
              const isArray3 = node2.type === VALUE_TYPES.ARRAY;
              remove.push(...Object.keys(node2.value).map((key) => isArray3 ? +key : key));
              for (const info of includes) {
                const targetProp = info.keys[trailKeys.length];
                if (typeof targetProp === "string" && (targetProp === "*" || targetProp.startsWith("$"))) {
                  remove.splice(0);
                  break;
                }
                const index = remove.indexOf(targetProp);
                index >= 0 && remove.splice(index, 1);
              }
            }
            const hasIncludeOnChild = includeFilter.some((info) => info.isChildOf(checkPathInfo));
            const hasExcludeOnChild = excludeFilter.some((info) => info.isChildOf(checkPathInfo));
            if (hasExcludeOnChild && !hasIncludeOnChild) {
              const excludes = excludeFilter.filter((info) => info.isChildOf(checkPathInfo));
              for (let i = 0; i < remove.length; i++) {
                if (!excludes.find((info) => info.equals(remove[i]))) {
                  remove.splice(i, 1);
                  i--;
                }
              }
            }
            for (const key of remove) {
              delete node2.value[key];
            }
          }
        };
        applyFiltersOnInlineData(path3, targetNode);
        let checkExecuted = false;
        const includeDescendantCheck = (descPath, metadata) => {
          checkExecuted = true;
          if (!transaction.production && !pathInfo.isAncestorOf(descPath)) {
            this.throwImplementationError(`"${descPath}" is not a descendant of "${path3}" - descendantsOf must only check and return paths that are descendants`);
          }
          if (!filtered) {
            return true;
          }
          const descPathKeys = PathInfo.getPathKeys(descPath);
          const trailKeys = descPathKeys.slice(pathInfo.keys.length);
          const checkPathInfo = new PathInfo(trailKeys);
          let include = (includeFilter.length > 0 ? includeFilter.some((info) => checkPathInfo.isOnTrailOf(info)) : true) && (excludeFilter.length > 0 ? !excludeFilter.some((info) => info.equals(checkPathInfo) || info.isAncestorOf(checkPathInfo)) : true);
          if (include && options.child_objects === false && (pathInfo.isParentOf(descPath) && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(metadata ? metadata.type : -1) || PathInfo.getPathKeys(descPath).length > pathInfo.pathKeys.length + 1)) {
            include = false;
          }
          return include;
        };
        const descRows = [];
        const addDescendant = (descPath, node2) => {
          if (!checkExecuted) {
            this.throwImplementationError("descendantsOf did not call checkCallback before addCallback");
          }
          if (options.child_objects === false && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(node2.type)) {
            return true;
          }
          applyFiltersOnInlineData(descPath, node2);
          this._processReadNodeValue(node2);
          const row = node2;
          row.path = descPath;
          descRows.push(row);
          return true;
        };
        await transaction.descendantsOf(path3, { metadata: true, value: true }, includeDescendantCheck, addDescendant);
        this.debug.log(`Read node "/${path3}" and ${filtered ? "(filtered) " : ""}descendants from ${descRows.length + 1} records`.colorize(ColorStyle.magenta));
        const result = targetNode;
        const objectToArray = (obj) => {
          const arr = [];
          Object.keys(obj).forEach((key) => {
            const index = parseInt(key);
            arr[index] = obj[index];
          });
          return arr;
        };
        if (targetNode.type === VALUE_TYPES.ARRAY) {
          result.value = objectToArray(result.value);
        }
        if (targetNode.type === VALUE_TYPES.OBJECT || targetNode.type === VALUE_TYPES.ARRAY) {
          const targetPathKeys = PathInfo.getPathKeys(path3);
          const value = targetNode.value;
          for (let i = 0; i < descRows.length; i++) {
            const otherNode = descRows[i];
            const pathKeys = PathInfo.getPathKeys(otherNode.path);
            const trailKeys = pathKeys.slice(targetPathKeys.length);
            let parent = value;
            for (let j = 0; j < trailKeys.length; j++) {
              assert(typeof parent === "object", "parent must be an object/array to have children!!");
              const key = trailKeys[j];
              const isLast = j === trailKeys.length - 1;
              const nodeType = isLast ? otherNode.type : typeof trailKeys[j + 1] === "number" ? VALUE_TYPES.ARRAY : VALUE_TYPES.OBJECT;
              let nodeValue;
              if (!isLast) {
                nodeValue = nodeType === VALUE_TYPES.OBJECT ? {} : [];
              } else {
                nodeValue = otherNode.value;
                if (nodeType === VALUE_TYPES.ARRAY) {
                  nodeValue = objectToArray(nodeValue);
                }
              }
              if (key in parent) {
                const mergePossible = typeof parent[key] === typeof nodeValue && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(nodeType);
                if (!mergePossible) {
                  this.debug.error(`The value stored in node "${otherNode.path}" cannot be merged with the parent node, value will be ignored. This error should disappear once the target node value is updated. See issue #20 for more information`, { path: path3, parent, key, nodeType, nodeValue });
                } else {
                  Object.keys(nodeValue).forEach((childKey) => {
                    if (childKey in parent[key]) {
                      this.throwImplementationError(`Custom storage merge error: child key "${childKey}" is in parent value already! Make sure the get/childrenOf/descendantsOf methods of the custom storage class return values that can be modified by AceBase without affecting the stored source`);
                    }
                    parent[key][childKey] = nodeValue[childKey];
                  });
                }
              } else {
                parent[key] = nodeValue;
              }
              parent = parent[key];
            }
          }
        } else if (descRows.length > 0) {
          this.throwImplementationError(`multiple records found for non-object value!`);
        }
        if (options.child_objects === false) {
          Object.keys(result.value).forEach((key) => {
            if (typeof result.value[key] === "object" && result.value[key].constructor === Object) {
              assert(Object.keys(result.value[key]).length === 0);
              delete result.value[key];
            }
          });
        }
        if (options.include) {
        }
        if (options.exclude) {
          const process9 = (obj, keys) => {
            if (typeof obj !== "object") {
              return;
            }
            const key = keys[0];
            if (key === "*") {
              Object.keys(obj).forEach((k) => {
                process9(obj[k], keys.slice(1));
              });
            } else if (keys.length > 1) {
              key in obj && process9(obj[key], keys.slice(1));
            } else {
              delete obj[key];
            }
          };
          options.exclude.forEach((path4) => {
            const checkKeys = PathInfo.getPathKeys(path4);
            process9(result.value, checkKeys);
          });
        }
        return result;
      })();
      if (!options.transaction) {
        await transaction.commit();
      }
      return node;
    } catch (err) {
      if (!options.transaction) {
        await transaction.rollback(err);
      }
      throw err;
    }
  }
  async getNodeInfo(path3, options = {}) {
    options = options || {};
    const pathInfo = PathInfo.get(path3);
    const transaction = options.transaction || await this._customImplementation.getTransaction({ path: path3, write: false });
    try {
      const node = await this._readNode(path3, { transaction });
      const info = new CustomStorageNodeInfo({
        path: path3,
        key: typeof pathInfo.key === "string" ? pathInfo.key : null,
        index: typeof pathInfo.key === "number" ? pathInfo.key : null,
        type: node ? node.type : 0,
        exists: node !== null,
        address: node ? new NodeAddress(path3) : null,
        created: node ? new Date(node.created) : null,
        modified: node ? new Date(node.modified) : null,
        revision: node ? node.revision : null,
        revision_nr: node ? node.revision_nr : null
      });
      if (!node && path3 !== "") {
        const lockPath = await transaction.moveToParentPath(pathInfo.parentPath);
        assert(lockPath === pathInfo.parentPath, `transaction.moveToParentPath() did not move to the right parent path of "${path3}"`);
        const parent = await this._readNode(pathInfo.parentPath, { transaction });
        if (parent && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(parent.type) && pathInfo.key in parent.value) {
          info.exists = true;
          info.value = parent.value[pathInfo.key];
          info.address = null;
          info.type = parent.type;
          info.created = new Date(parent.created);
          info.modified = new Date(parent.modified);
          info.revision = parent.revision;
          info.revision_nr = parent.revision_nr;
        } else {
          info.address = null;
        }
      }
      if (options.include_child_count) {
        info.childCount = 0;
        if ([VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(info.valueType) && info.address) {
          info.childCount = node.value ? Object.keys(node.value).length : 0;
          info.childCount += await transaction.getChildCount(path3);
        }
      }
      if (!options.transaction) {
        await transaction.commit();
      }
      return info;
    } catch (err) {
      if (!options.transaction) {
        await transaction.rollback(err);
      }
      throw err;
    }
  }
  async setNode(path3, value, options = { suppress_events: false, context: null }) {
    if (this.settings.readOnly) {
      throw new Error(`Database is opened in read-only mode`);
    }
    const pathInfo = PathInfo.get(path3);
    const transaction = options.transaction || await this._customImplementation.getTransaction({ path: path3, write: true });
    try {
      if (path3 === "") {
        if (value === null || typeof value !== "object" || value instanceof Array || value instanceof ArrayBuffer || "buffer" in value && value.buffer instanceof ArrayBuffer) {
          throw new Error(`Invalid value for root node: ${value}`);
        }
        await this._writeNodeWithTracking("", value, { merge: false, transaction, suppress_events: options.suppress_events, context: options.context });
      } else if (typeof options.assert_revision !== "undefined") {
        const info = await this.getNodeInfo(path3, { transaction });
        if (info.revision !== options.assert_revision) {
          throw new NodeRevisionError(`revision '${info.revision}' does not match requested revision '${options.assert_revision}'`);
        }
        if (info.address && info.address.path === path3 && value !== null && !this.valueFitsInline(value)) {
          await this._writeNodeWithTracking(path3, value, { merge: false, transaction, suppress_events: options.suppress_events, context: options.context });
        } else {
          const lockPath = await transaction.moveToParentPath(pathInfo.parentPath);
          assert(lockPath === pathInfo.parentPath, `transaction.moveToParentPath() did not move to the right parent path of "${path3}"`);
          await this._writeNodeWithTracking(pathInfo.parentPath, { [pathInfo.key]: value }, { merge: true, transaction, suppress_events: options.suppress_events, context: options.context });
        }
      } else {
        const lockPath = await transaction.moveToParentPath(pathInfo.parentPath);
        assert(lockPath === pathInfo.parentPath, `transaction.moveToParentPath() did not move to the right parent path of "${path3}"`);
        await this.updateNode(pathInfo.parentPath, { [pathInfo.key]: value }, { transaction, suppress_events: options.suppress_events, context: options.context });
      }
      if (!options.transaction) {
        await transaction.commit();
      }
    } catch (err) {
      if (!options.transaction) {
        await transaction.rollback(err);
      }
      throw err;
    }
  }
  async updateNode(path3, updates, options = { suppress_events: false, context: null }) {
    if (this.settings.readOnly) {
      throw new Error(`Database is opened in read-only mode`);
    }
    if (typeof updates !== "object") {
      throw new Error(`invalid updates argument`);
    } else if (Object.keys(updates).length === 0) {
      return;
    }
    const transaction = options.transaction || await this._customImplementation.getTransaction({ path: path3, write: true });
    try {
      const nodeInfo = await this.getNodeInfo(path3, { transaction });
      const pathInfo = PathInfo.get(path3);
      if (nodeInfo.exists && nodeInfo.address && nodeInfo.address.path === path3) {
        await this._writeNodeWithTracking(path3, updates, { transaction, merge: true, suppress_events: options.suppress_events, context: options.context });
      } else if (nodeInfo.exists) {
        const pathInfo2 = PathInfo.get(path3);
        const lockPath = await transaction.moveToParentPath(pathInfo2.parentPath);
        assert(lockPath === pathInfo2.parentPath, `transaction.moveToParentPath() did not move to the right parent path of "${path3}"`);
        await this._writeNodeWithTracking(pathInfo2.parentPath, { [pathInfo2.key]: updates }, { transaction, merge: true, suppress_events: options.suppress_events, context: options.context });
      } else {
        const lockPath = await transaction.moveToParentPath(pathInfo.parentPath);
        assert(lockPath === pathInfo.parentPath, `transaction.moveToParentPath() did not move to the right parent path of "${path3}"`);
        await this.updateNode(pathInfo.parentPath, { [pathInfo.key]: updates }, { transaction, suppress_events: options.suppress_events, context: options.context });
      }
      if (!options.transaction) {
        await transaction.commit();
      }
    } catch (err) {
      if (!options.transaction) {
        await transaction.rollback(err);
      }
      throw err;
    }
  }
};

// node_modules/acebase/dist/esm/async-task-batch.js
var AsyncTaskBatch = class {
  constructor(limit = 1e3, options) {
    this.limit = limit;
    this.options = options;
    this.added = 0;
    this.scheduled = [];
    this.running = 0;
    this.results = [];
    this.done = false;
  }
  async execute(task, index) {
    try {
      this.running++;
      const result = await task();
      this.results[index] = result;
      this.running--;
      if (this.running === 0 && this.scheduled.length === 0) {
        this.done = true;
        this.doneCallback?.(this.results);
      } else if (this.scheduled.length > 0) {
        const next = this.scheduled.shift();
        this.execute(next.task, next.index);
      }
    } catch (err) {
      this.done = true;
      this.errorCallback?.(err);
    }
  }
  add(task) {
    if (this.done) {
      throw new Error(`Cannot add to a batch that has already finished. Use wait option and start batch processing manually if you are adding tasks in an async loop`);
    }
    const index = this.added++;
    if (this.options?.wait !== true && this.running < this.limit) {
      this.execute(task, index);
    } else {
      this.scheduled.push({ task, index });
    }
  }
  start() {
    while (this.running < this.limit) {
      const next = this.scheduled.shift();
      this.execute(next.task, next.index);
    }
  }
  async finish() {
    if (this.running === 0 && this.scheduled.length === 0) {
      return this.results;
    }
    await new Promise((resolve, reject) => {
      this.doneCallback = resolve;
      this.errorCallback = reject;
    });
    return this.results;
  }
};

// node_modules/acebase/dist/esm/query.js
var noop3 = () => {
};
async function executeQuery(api, path3, query, options = { snapshots: false, include: void 0, exclude: void 0, child_objects: void 0, eventHandler: noop3 }) {
  if (typeof options !== "object") {
    options = {};
  }
  if (typeof options.snapshots === "undefined") {
    options.snapshots = false;
  }
  const context = {};
  if (api.storage.settings.transactions?.log) {
    context.acebase_cursor = ID.generate();
  }
  const queryFilters = query.filters.map((f) => ({ ...f }));
  const querySort = query.order.map((s) => ({ ...s }));
  const sortMatches = (matches) => {
    matches.sort((a, b) => {
      const compare = (i) => {
        const o = querySort[i];
        const trailKeys = PathInfo.getPathKeys(typeof o.key === "number" ? `[${o.key}]` : o.key);
        const left = trailKeys.reduce((val, key) => val !== null && typeof val === "object" && key in val ? val[key] : null, a.val);
        const right = trailKeys.reduce((val, key) => val !== null && typeof val === "object" && key in val ? val[key] : null, b.val);
        if (left === null) {
          return right === null ? 0 : o.ascending ? -1 : 1;
        }
        if (right === null) {
          return o.ascending ? 1 : -1;
        }
        if (left == right) {
          if (i < querySort.length - 1) {
            return compare(i + 1);
          } else {
            return a.path < b.path ? -1 : 1;
          }
        } else if (left < right) {
          return o.ascending ? -1 : 1;
        }
        return o.ascending ? 1 : -1;
      };
      return compare(0);
    });
  };
  const loadResultsData = async (preResults, options2) => {
    if (preResults.length === 0) {
      return [];
    }
    const maxBatchSize = 50;
    const batch = new AsyncTaskBatch(maxBatchSize);
    const results = [];
    preResults.forEach(({ path: path4 }, index) => batch.add(async () => {
      const node = await api.storage.getNode(path4, options2);
      const val = node.value;
      if (val === null) {
        api.storage.debug.warn(`Indexed result "/${path4}" does not have a record!`);
        return;
      }
      const result = { path: path4, val };
      if (stepsExecuted.sorted) {
        results[index] = result;
      } else {
        results.push(result);
        if (!stepsExecuted.skipped && results.length > query.skip + Math.abs(query.take)) {
          sortMatches(results);
          results.pop();
        }
      }
    }));
    await batch.finish();
    return results;
  };
  const pathInfo = PathInfo.get(path3);
  const isWildcardPath = pathInfo.keys.some((key) => key === "*" || key.toString().startsWith("$"));
  const availableIndexes = api.storage.indexes.get(path3);
  const usingIndexes = [];
  let stop = async () => {
  };
  if (isWildcardPath) {
    const vars = pathInfo.keys.filter((key) => typeof key === "string" && key.startsWith("$"));
    const hasExplicitFilterValues = vars.length > 0 && vars.every((v) => query.filters.some((f) => f.key === v && ["==", "in"].includes(f.op)));
    const isRealtime = typeof options.monitor === "object" && [options.monitor?.add, options.monitor?.change, options.monitor?.remove].some((val) => val === true);
    if (hasExplicitFilterValues && !isRealtime) {
      const combinations = [];
      for (const v of vars) {
        const filters2 = query.filters.filter((f) => f.key === v);
        const filterValues = filters2.reduce((values, f) => {
          if (f.op === "==") {
            values.push(f.compare);
          }
          if (f.op === "in") {
            if (!(f.compare instanceof Array)) {
              throw new Error(`compare argument for 'in' operator must be an Array`);
            }
            values.push(...f.compare);
          }
          return values;
        }, []);
        const prevCombinations = combinations.splice(0);
        filterValues.forEach((fv) => {
          if (prevCombinations.length === 0) {
            combinations.push({ [v]: fv });
          } else {
            combinations.push(...prevCombinations.map((c3) => ({ ...c3, [v]: fv })));
          }
        });
      }
      const filters = query.filters.filter((f) => !vars.includes(f.key));
      const paths = combinations.map((vars2) => PathInfo.get(PathInfo.getPathKeys(path3).map((key) => vars2[key] ?? key)).path);
      const loadData = query.order.length > 0;
      const promises = paths.map((path4) => executeQuery(api, path4, { filters, take: 0, skip: 0, order: [] }, {
        snapshots: loadData,
        cache_mode: options.cache_mode,
        include: [...options.include ?? [], ...query.order.map((o) => o.key)],
        exclude: options.exclude
      }));
      const resultSets = await Promise.all(promises);
      let results = resultSets.reduce((results2, set) => (results2.push(...set.results), results2), []);
      if (loadData) {
        sortMatches(results);
      }
      if (query.skip > 0) {
        results.splice(0, query.skip);
      }
      if (query.take > 0) {
        results.splice(query.take);
      }
      if (options.snapshots && (!loadData || options.include?.length > 0 || options.exclude?.length > 0 || !options.child_objects)) {
        const { include, exclude, child_objects } = options;
        results = await loadResultsData(results, { include, exclude, child_objects });
      }
      return { results, context: null, stop };
    } else if (availableIndexes.length === 0) {
      const err = new Error(`Query on wildcard path "/${path3}" requires an index`);
      return Promise.reject(err);
    }
    if (queryFilters.length === 0) {
      const index = availableIndexes.filter((index2) => index2.type === "normal")[0];
      queryFilters.push({ key: index.key, op: "!=", compare: null });
    }
  }
  queryFilters.forEach((filter2) => {
    if (filter2.index) {
      return;
    }
    const indexesOnKey = availableIndexes.filter((index) => index.key === filter2.key).filter((index) => {
      return index.validOperators.includes(filter2.op);
    });
    if (indexesOnKey.length >= 1) {
      const otherFilterKeys = queryFilters.filter((f) => f !== filter2).map((f) => f.key);
      const sortKeys = querySort.map((o) => o.key).filter((key) => key !== filter2.key);
      const beneficialIndexes = indexesOnKey.map((index) => {
        const availableKeys = index.includeKeys.concat(index.key);
        const forOtherFilters = availableKeys.filter((key) => otherFilterKeys.includes(key));
        const forSorting = availableKeys.filter((key) => sortKeys.includes(key));
        const forBoth = forOtherFilters.concat(forSorting.filter((index2) => !forOtherFilters.includes(index2)));
        const points = {
          filters: forOtherFilters.length,
          sorting: forSorting.length * (query.take !== 0 ? forSorting.length : 1),
          both: forBoth.length * forBoth.length,
          get total() {
            return this.filters + this.sorting + this.both;
          }
        };
        return { index, points: points.total, filterKeys: forOtherFilters, sortKeys: forSorting };
      });
      beneficialIndexes.sort((a, b) => a.points > b.points ? -1 : 1);
      const bestBenificialIndex = beneficialIndexes[0];
      filter2.index = bestBenificialIndex.index;
      bestBenificialIndex.filterKeys.forEach((key) => {
        queryFilters.filter((f) => f !== filter2 && f.key === key).forEach((f) => {
          if (!DataIndex.validOperators.includes(f.op)) {
            return;
          }
          f.indexUsage = "filter";
          f.index = bestBenificialIndex.index;
        });
      });
      bestBenificialIndex.sortKeys.forEach((key) => {
        querySort.filter((s) => s.key === key).forEach((s) => {
          s.index = bestBenificialIndex.index;
        });
      });
    }
    if (filter2.index) {
      usingIndexes.push({ index: filter2.index, description: filter2.index.description });
    }
  });
  if (querySort.length > 0 && query.take !== 0 && queryFilters.length === 0) {
    querySort.forEach((sort) => {
      if (sort.index) {
        return;
      }
      sort.index = availableIndexes.filter((index) => index.key === sort.key).find((index) => index.type === "normal");
    });
  }
  const indexDescriptions = usingIndexes.map((index) => index.description).join(", ");
  usingIndexes.length > 0 && api.storage.debug.log(`Using indexes for query: ${indexDescriptions}`);
  const tableScanFilters = queryFilters.filter((filter2) => !filter2.index);
  const specialOpsRegex = /^[a-z]+:/i;
  if (tableScanFilters.some((filter2) => specialOpsRegex.test(filter2.op))) {
    const f = tableScanFilters.find((filter2) => specialOpsRegex.test(filter2.op));
    const err = new Error(`query contains operator "${f.op}" which requires a special index that was not found on path "${path3}", key "${f.key}"`);
    return Promise.reject(err);
  }
  const allowedTableScanOperators = ["<", "<=", "==", "!=", ">=", ">", "like", "!like", "in", "!in", "matches", "!matches", "between", "!between", "has", "!has", "contains", "!contains", "exists", "!exists"];
  for (let i = 0; i < tableScanFilters.length; i++) {
    const f = tableScanFilters[i];
    if (!allowedTableScanOperators.includes(f.op)) {
      return Promise.reject(new Error(`query contains unknown filter operator "${f.op}" on path "${path3}", key "${f.key}"`));
    }
  }
  if (isWildcardPath && tableScanFilters.length > 0) {
    const keys = tableScanFilters.reduce((keys2, f) => {
      if (keys2.indexOf(f.key) < 0) {
        keys2.push(f.key);
      }
      return keys2;
    }, []).map((key) => `"${key}"`);
    const err = new Error(`This wildcard path query on "/${path3}" requires index(es) on key(s): ${keys.join(", ")}. Create the index(es) and retry`);
    return Promise.reject(err);
  }
  const indexScanPromises = [];
  queryFilters.forEach((filter2) => {
    if (filter2.index && filter2.indexUsage !== "filter") {
      let promise = filter2.index.query(filter2.op, filter2.compare).then((results) => {
        options.eventHandler?.({ name: "stats", type: "index_query", source: filter2.index.description, stats: results.stats });
        if (results.hints.length > 0) {
          options.eventHandler?.({ name: "hints", type: "index_query", source: filter2.index.description, hints: results.hints });
        }
        return results;
      });
      const resultFilters = queryFilters.filter((f) => f.index === filter2.index && f.indexUsage === "filter");
      if (resultFilters.length > 0) {
        promise = promise.then((results) => {
          resultFilters.forEach((filter3) => {
            const { key, op, index } = filter3;
            let { compare } = filter3;
            if (typeof compare === "string" && !index.caseSensitive) {
              compare = compare.toLocaleLowerCase(index.textLocale);
            }
            results = results.filterMetadata(key, op, compare);
          });
          return results;
        });
      }
      indexScanPromises.push(promise);
    }
  });
  const stepsExecuted = {
    filtered: queryFilters.length === 0,
    skipped: query.skip === 0,
    taken: query.take === 0,
    sorted: querySort.length === 0,
    preDataLoaded: false,
    dataLoaded: false
  };
  if (queryFilters.length === 0 && query.take === 0) {
    api.storage.debug.warn(`Filterless queries must use .take to limit the results. Defaulting to 100 for query on path "${path3}"`);
    query.take = 100;
  }
  if (querySort.length > 0 && querySort[0].index) {
    const sortIndex = querySort[0].index;
    const ascending = query.take < 0 ? !querySort[0].ascending : querySort[0].ascending;
    if (queryFilters.length === 0 && querySort.slice(1).every((s) => sortIndex.allMetadataKeys.includes(s.key))) {
      api.storage.debug.log(`Using index for sorting: ${sortIndex.description}`);
      const metadataSort = querySort.slice(1).map((s) => {
        s.index = sortIndex;
        return { key: s.key, ascending: s.ascending };
      });
      const promise = sortIndex.take(query.skip, Math.abs(query.take), { ascending, metadataSort }).then((results) => {
        options.eventHandler?.({ name: "stats", type: "sort_index_take", source: sortIndex.description, stats: results.stats });
        if (results.hints.length > 0) {
          options.eventHandler?.({ name: "hints", type: "sort_index_take", source: sortIndex.description, hints: results.hints });
        }
        return results;
      });
      indexScanPromises.push(promise);
      stepsExecuted.skipped = true;
      stepsExecuted.taken = true;
      stepsExecuted.sorted = true;
    }
  }
  return Promise.all(indexScanPromises).then(async (indexResultSets) => {
    let indexedResults = [];
    if (indexResultSets.length === 1) {
      const resultSet = indexResultSets[0];
      indexedResults = resultSet.map((match) => {
        const result = { key: match.key, path: match.path, val: { [resultSet.filterKey]: match.value } };
        match.metadata && Object.assign(result.val, match.metadata);
        return result;
      });
      stepsExecuted.filtered = true;
    } else if (indexResultSets.length > 1) {
      indexResultSets.sort((a, b) => a.length < b.length ? -1 : 1);
      const shortestSet = indexResultSets[0];
      const otherSets = indexResultSets.slice(1);
      indexedResults = shortestSet.reduce((results, match) => {
        const result = { key: match.key, path: match.path, val: { [shortestSet.filterKey]: match.value } };
        const matchedInAllSets = otherSets.every((set) => set.findIndex((m) => m.path === match.path) >= 0);
        if (matchedInAllSets) {
          match.metadata && Object.assign(result.val, match.metadata);
          otherSets.forEach((set) => {
            const otherResult = set.find((r) => r.path === result.path);
            result.val[set.filterKey] = otherResult.value;
            otherResult.metadata && Object.assign(result.val, otherResult.metadata);
          });
          results.push(result);
        }
        return results;
      }, []);
      stepsExecuted.filtered = true;
    }
    if (isWildcardPath || indexScanPromises.length > 0 && tableScanFilters.length === 0) {
      if (querySort.length === 0 || querySort.every((o) => o.index)) {
        stepsExecuted.preDataLoaded = true;
        if (!stepsExecuted.sorted && querySort.length > 0) {
          sortMatches(indexedResults);
        }
        stepsExecuted.sorted = true;
        if (!stepsExecuted.skipped && query.skip > 0) {
          indexedResults = query.take < 0 ? indexedResults.slice(0, -query.skip) : indexedResults.slice(query.skip);
        }
        if (!stepsExecuted.taken && query.take !== 0) {
          indexedResults = query.take < 0 ? indexedResults.slice(query.take) : indexedResults.slice(0, query.take);
        }
        stepsExecuted.skipped = true;
        stepsExecuted.taken = true;
        if (!options.snapshots) {
          return indexedResults;
        }
        const childOptions2 = { include: options.include, exclude: options.exclude, child_objects: options.child_objects };
        return loadResultsData(indexedResults, childOptions2).then((results) => {
          stepsExecuted.dataLoaded = true;
          return results;
        });
      }
      if (options.snapshots || !stepsExecuted.sorted) {
        const loadPartialResults = querySort.length > 0;
        const childOptions2 = loadPartialResults ? { include: querySort.map((order) => order.key) } : { include: options.include, exclude: options.exclude, child_objects: options.child_objects };
        return loadResultsData(indexedResults, childOptions2).then((results) => {
          if (querySort.length > 0) {
            sortMatches(results);
          }
          stepsExecuted.sorted = true;
          if (query.skip > 0) {
            results = query.take < 0 ? results.slice(0, -query.skip) : results.slice(query.skip);
          }
          if (query.take !== 0) {
            results = query.take < 0 ? results.slice(query.take) : results.slice(0, query.take);
          }
          stepsExecuted.skipped = true;
          stepsExecuted.taken = true;
          if (options.snapshots && loadPartialResults) {
            return loadResultsData(results, { include: options.include, exclude: options.exclude, child_objects: options.child_objects });
          }
          return results;
        });
      } else {
        return indexedResults;
      }
    }
    let indexKeyFilter;
    if (indexedResults.length > 0) {
      indexKeyFilter = indexedResults.map((result) => result.key);
    }
    let matches = [];
    let preliminaryStop = false;
    const loadPartialData = querySort.length > 0;
    const childOptions = loadPartialData ? { include: querySort.map((order) => order.key) } : { include: options.include, exclude: options.exclude, child_objects: options.child_objects };
    const batch = {
      promises: [],
      add(promise) {
        this.promises.push(promise);
        if (this.promises.length >= 1e3) {
          return Promise.all(this.promises.splice(0)).then((_) => void 0);
        }
      }
    };
    try {
      await api.storage.getChildren(path3, { keyFilter: indexKeyFilter, async: true }).next((child) => {
        if (child.type !== VALUE_TYPES.OBJECT) {
          return;
        }
        if (!child.address) {
          return;
        }
        if (preliminaryStop) {
          return false;
        }
        const matchNode = async () => {
          const isMatch = await api.storage.matchNode(child.address.path, tableScanFilters);
          if (!isMatch) {
            return;
          }
          const childPath = child.address.path;
          let result;
          if (options.snapshots || querySort.length > 0) {
            const node = await api.storage.getNode(childPath, childOptions);
            result = { path: childPath, val: node.value };
          } else {
            result = { path: childPath };
          }
          matches.push(result);
          if (query.take !== 0 && matches.length > Math.abs(query.take) + query.skip) {
            if (querySort.length > 0) {
              sortMatches(matches);
            } else if (query.take > 0) {
              preliminaryStop = true;
            }
            matches.pop();
          }
        };
        const p = batch.add(matchNode());
        if (p instanceof Promise) {
          return p;
        }
      });
    } catch (reason) {
      if (!(reason instanceof NodeNotFoundError)) {
        api.storage.debug.warn(`Error getting child stream: ${reason}`);
      }
      return [];
    }
    await Promise.all(batch.promises);
    stepsExecuted.preDataLoaded = loadPartialData;
    stepsExecuted.dataLoaded = !loadPartialData;
    if (querySort.length > 0) {
      sortMatches(matches);
    }
    stepsExecuted.sorted = true;
    if (query.skip > 0) {
      matches = query.take < 0 ? matches.slice(0, -query.skip) : matches.slice(query.skip);
    }
    stepsExecuted.skipped = true;
    if (query.take !== 0) {
      matches = query.take < 0 ? matches.slice(query.take) : matches.slice(0, query.take);
    }
    stepsExecuted.taken = true;
    if (!stepsExecuted.dataLoaded) {
      matches = await loadResultsData(matches, { include: options.include, exclude: options.exclude, child_objects: options.child_objects });
      stepsExecuted.dataLoaded = true;
    }
    return matches;
  }).then((matches) => {
    if (!stepsExecuted.sorted && querySort.length > 0) {
      sortMatches(matches);
    }
    if (!options.snapshots) {
      matches = matches.map((match) => match.path);
    }
    if (!stepsExecuted.skipped && query.skip > 0) {
      matches = query.take < 0 ? matches.slice(0, -query.skip) : matches.slice(query.skip);
    }
    if (!stepsExecuted.taken && query.take !== 0) {
      matches = query.take < 0 ? matches.slice(query.take) : matches.slice(0, query.take);
    }
    if (options.monitor === true) {
      options.monitor = { add: true, change: true, remove: true };
    }
    if (typeof options.monitor === "object" && (options.monitor.add || options.monitor.change || options.monitor.remove)) {
      const monitor = options.monitor;
      const matchedPaths = options.snapshots ? matches.map((match) => match.path) : matches.slice();
      const ref = api.db.ref(path3);
      const removeMatch = (path4) => {
        const index = matchedPaths.indexOf(path4);
        if (index < 0) {
          return;
        }
        matchedPaths.splice(index, 1);
      };
      const addMatch = (path4) => {
        if (matchedPaths.includes(path4)) {
          return;
        }
        matchedPaths.push(path4);
      };
      const stopMonitoring = () => {
        api.unsubscribe(ref.path, "child_changed", childChangedCallback);
        api.unsubscribe(ref.path, "child_added", childAddedCallback);
        api.unsubscribe(ref.path, "notify_child_removed", childRemovedCallback);
      };
      stop = async () => {
        stopMonitoring();
      };
      const childChangedCallback = async (err, path4, newValue, oldValue) => {
        const wasMatch = matchedPaths.includes(path4);
        let keepMonitoring = true;
        const checkKeys = [];
        queryFilters.forEach((f) => !checkKeys.includes(f.key) && checkKeys.push(f.key));
        const seenKeys = [];
        typeof oldValue === "object" && Object.keys(oldValue).forEach((key) => !seenKeys.includes(key) && seenKeys.push(key));
        typeof newValue === "object" && Object.keys(newValue).forEach((key) => !seenKeys.includes(key) && seenKeys.push(key));
        const missingKeys = [];
        let isMatch = seenKeys.every((key) => {
          if (!checkKeys.includes(key)) {
            return true;
          }
          const filters = queryFilters.filter((filter2) => filter2.key === key);
          return filters.every((filter2) => {
            if (filter2.index?.textLocaleKey && !seenKeys.includes(filter2.index.textLocaleKey)) {
              missingKeys.push(filter2.index.textLocaleKey);
              return true;
            } else if (allowedTableScanOperators.includes(filter2.op)) {
              return api.storage.test(newValue[key], filter2.op, filter2.compare);
            } else {
              return filter2.index.test(newValue, filter2.op, filter2.compare);
            }
          });
        });
        if (isMatch) {
          missingKeys.push(...checkKeys.filter((key) => !seenKeys.includes(key)));
          if (!wasMatch && missingKeys.length > 0) {
            const filterQueue = queryFilters.filter((f) => missingKeys.includes(f.key));
            const simpleFilters = filterQueue.filter((f) => allowedTableScanOperators.includes(f.op));
            const indexFilters = filterQueue.filter((f) => !allowedTableScanOperators.includes(f.op));
            if (simpleFilters.length > 0) {
              isMatch = await api.storage.matchNode(path4, simpleFilters);
            }
            if (isMatch && indexFilters.length > 0) {
              const keysToLoad = indexFilters.reduce((keys, filter2) => {
                if (!keys.includes(filter2.key)) {
                  keys.push(filter2.key);
                }
                if (filter2.index instanceof FullTextIndex && filter2.index.config.localeKey && !keys.includes(filter2.index.config.localeKey)) {
                  keys.push(filter2.index.config.localeKey);
                }
                return keys;
              }, []);
              const node = await api.storage.getNode(path4, { include: keysToLoad });
              if (node.value === null) {
                return false;
              }
              isMatch = indexFilters.every((filter2) => filter2.index.test(node.value, filter2.op, filter2.compare));
            }
          }
        }
        if (isMatch) {
          if (!wasMatch) {
            addMatch(path4);
          }
          if (options.snapshots) {
            const loadOptions = { include: options.include, exclude: options.exclude, child_objects: options.child_objects };
            const node = await api.storage.getNode(path4, loadOptions);
            newValue = node.value;
          }
          if (wasMatch && monitor.change) {
            keepMonitoring = options.eventHandler({ name: "change", path: path4, value: newValue }) !== false;
          } else if (!wasMatch && monitor.add) {
            keepMonitoring = options.eventHandler({ name: "add", path: path4, value: newValue }) !== false;
          }
        } else if (wasMatch) {
          removeMatch(path4);
          if (monitor.remove) {
            keepMonitoring = options.eventHandler({ name: "remove", path: path4, value: oldValue }) !== false;
          }
        }
        if (keepMonitoring === false) {
          stopMonitoring();
        }
      };
      const childAddedCallback = (err, path4, newValue) => {
        const isMatch = queryFilters.every((filter2) => {
          if (allowedTableScanOperators.includes(filter2.op)) {
            return api.storage.test(newValue[filter2.key], filter2.op, filter2.compare);
          } else {
            return filter2.index.test(newValue, filter2.op, filter2.compare);
          }
        });
        let keepMonitoring = true;
        if (isMatch) {
          addMatch(path4);
          if (monitor.add) {
            keepMonitoring = options.eventHandler({ name: "add", path: path4, value: options.snapshots ? newValue : null }) !== false;
          }
        }
        if (keepMonitoring === false) {
          stopMonitoring();
        }
      };
      const childRemovedCallback = (err, path4, newValue, oldValue) => {
        let keepMonitoring = true;
        removeMatch(path4);
        if (monitor.remove) {
          keepMonitoring = options.eventHandler({ name: "remove", path: path4, value: options.snapshots ? oldValue : null }) !== false;
        }
        if (keepMonitoring === false) {
          stopMonitoring();
        }
      };
      if (options.monitor.add || options.monitor.change || options.monitor.remove) {
        api.subscribe(ref.path, "child_changed", childChangedCallback);
      }
      if (options.monitor.remove) {
        api.subscribe(ref.path, "notify_child_removed", childRemovedCallback);
      }
      if (options.monitor.add) {
        api.subscribe(ref.path, "child_added", childAddedCallback);
      }
    }
    return { results: matches, context, stop };
  });
}

// node_modules/acebase/dist/esm/api-local.js
var LocalApi = class extends Api {
  constructor(dbname = "default", init, readyCallback) {
    super();
    this.db = init.db;
    const storageEnv = { logLevel: init.settings.logLevel };
    if (typeof init.settings.storage === "object") {
      if (SQLiteStorageSettings && init.settings.storage instanceof SQLiteStorageSettings) {
        this.storage = new SQLiteStorage(dbname, init.settings.storage, storageEnv);
      } else if (MSSQLStorageSettings && init.settings.storage instanceof MSSQLStorageSettings) {
        this.storage = new MSSQLStorage(dbname, init.settings.storage, storageEnv);
      } else if (CustomStorageSettings && init.settings.storage instanceof CustomStorageSettings) {
        this.storage = new CustomStorage(dbname, init.settings.storage, storageEnv);
      } else {
        const storageSettings = init.settings.storage instanceof AceBaseStorageSettings ? init.settings.storage : new AceBaseStorageSettings(init.settings.storage);
        this.storage = new AceBaseStorage(dbname, storageSettings, storageEnv);
      }
    } else {
      this.storage = new AceBaseStorage(dbname, new AceBaseStorageSettings(), storageEnv);
    }
    this.storage.on("ready", readyCallback);
  }
  async stats(options) {
    return this.storage.stats;
  }
  subscribe(path3, event, callback) {
    this.storage.subscriptions.add(path3, event, callback);
  }
  unsubscribe(path3, event, callback) {
    this.storage.subscriptions.remove(path3, event, callback);
  }
  async set(path3, value, options = {
    suppress_events: false,
    context: null
  }) {
    const cursor = await this.storage.setNode(path3, value, { suppress_events: options.suppress_events, context: options.context });
    return { ...cursor && { cursor } };
  }
  async update(path3, updates, options = {
    suppress_events: false,
    context: null
  }) {
    const cursor = await this.storage.updateNode(path3, updates, { suppress_events: options.suppress_events, context: options.context });
    return { ...cursor && { cursor } };
  }
  get transactionLoggingEnabled() {
    return this.storage.settings.transactions && this.storage.settings.transactions.log === true;
  }
  async get(path3, options) {
    if (!options) {
      options = {};
    }
    if (typeof options.include !== "undefined" && !(options.include instanceof Array)) {
      throw new TypeError(`options.include must be an array of key names`);
    }
    if (typeof options.exclude !== "undefined" && !(options.exclude instanceof Array)) {
      throw new TypeError(`options.exclude must be an array of key names`);
    }
    if (["undefined", "boolean"].indexOf(typeof options.child_objects) < 0) {
      throw new TypeError(`options.child_objects must be a boolean`);
    }
    const node = await this.storage.getNode(path3, options);
    return { value: node.value, context: { acebase_cursor: node.cursor }, cursor: node.cursor };
  }
  async transaction(path3, callback, options = {
    suppress_events: false,
    context: null
  }) {
    const cursor = await this.storage.transactNode(path3, callback, { suppress_events: options.suppress_events, context: options.context });
    return { ...cursor && { cursor } };
  }
  async exists(path3) {
    const nodeInfo = await this.storage.getNodeInfo(path3);
    return nodeInfo.exists;
  }
  async query(path3, query, options = { snapshots: false }) {
    const results = await executeQuery(this, path3, query, options);
    return results;
  }
  createIndex(path3, key, options) {
    return this.storage.indexes.create(path3, key, options);
  }
  async getIndexes() {
    return this.storage.indexes.list();
  }
  async deleteIndex(filePath) {
    return this.storage.indexes.delete(filePath);
  }
  async reflect(path3, type, args) {
    args = args || {};
    const getChildren2 = async (path4, limit = 50, skip = 0, from = null) => {
      if (typeof limit === "string") {
        limit = parseInt(limit);
      }
      if (typeof skip === "string") {
        skip = parseInt(skip);
      }
      if (["null", "undefined"].includes(from)) {
        from = null;
      }
      const children = [];
      let n = 0, stop = false, more = false;
      await this.storage.getChildren(path4).next((childInfo) => {
        if (stop) {
          more = true;
          return false;
        }
        n++;
        const include = from !== null ? childInfo.key > from : skip === 0 || n > skip;
        if (include) {
          children.push({
            key: typeof childInfo.key === "string" ? childInfo.key : childInfo.index,
            type: childInfo.valueTypeName,
            value: childInfo.value,
            ...typeof childInfo.address === "object" && "pageNr" in childInfo.address && {
              address: {
                pageNr: childInfo.address.pageNr,
                recordNr: childInfo.address.recordNr
              }
            }
          });
        }
        stop = limit > 0 && children.length === limit;
      }).catch((err) => {
        if (!(err instanceof NodeNotFoundError)) {
          throw err;
        }
      });
      return {
        more,
        list: children
      };
    };
    switch (type) {
      case "children": {
        const result = await getChildren2(path3, args.limit, args.skip, args.from);
        return result;
      }
      case "info": {
        const info = {
          key: "",
          exists: false,
          type: "unknown",
          value: void 0,
          address: void 0,
          children: {
            count: 0,
            more: false,
            list: []
          }
        };
        const nodeInfo = await this.storage.getNodeInfo(path3, { include_child_count: args.child_count === true });
        info.key = typeof nodeInfo.key !== "undefined" ? nodeInfo.key : nodeInfo.index;
        info.exists = nodeInfo.exists;
        info.type = nodeInfo.exists ? nodeInfo.valueTypeName : void 0;
        info.value = nodeInfo.value;
        info.address = typeof nodeInfo.address === "object" && "pageNr" in nodeInfo.address ? {
          pageNr: nodeInfo.address.pageNr,
          recordNr: nodeInfo.address.recordNr
        } : void 0;
        const isObjectOrArray = nodeInfo.exists && nodeInfo.address && [VALUE_TYPES.OBJECT, VALUE_TYPES.ARRAY].includes(nodeInfo.type);
        if (args.child_count === true) {
          info.children = { count: isObjectOrArray ? nodeInfo.childCount : 0 };
        } else if (typeof args.child_limit === "number" && args.child_limit > 0) {
          if (isObjectOrArray) {
            info.children = await getChildren2(path3, args.child_limit, args.child_skip, args.child_from);
          }
        }
        return info;
      }
    }
  }
  export(path3, stream4, options = {
    format: "json",
    type_safe: true
  }) {
    return this.storage.exportNode(path3, stream4, options);
  }
  import(path3, read2, options = {
    format: "json",
    suppress_events: false,
    method: "set"
  }) {
    return this.storage.importNode(path3, read2, options);
  }
  async setSchema(path3, schema, warnOnly = false) {
    return this.storage.setSchema(path3, schema, warnOnly);
  }
  async getSchema(path3) {
    return this.storage.getSchema(path3);
  }
  async getSchemas() {
    return this.storage.getSchemas();
  }
  async validateSchema(path3, value, isUpdate) {
    return this.storage.validateSchema(path3, value, { updates: isUpdate });
  }
  async getMutations(filter2) {
    if (typeof this.storage.getMutations !== "function") {
      throw new Error("Used storage type does not support getMutations");
    }
    if (typeof filter2 !== "object") {
      throw new Error("No filter specified");
    }
    if (typeof filter2.cursor !== "string" && typeof filter2.timestamp !== "number") {
      throw new Error("No cursor or timestamp given");
    }
    return this.storage.getMutations(filter2);
  }
  async getChanges(filter2) {
    if (typeof this.storage.getChanges !== "function") {
      throw new Error("Used storage type does not support getChanges");
    }
    if (typeof filter2 !== "object") {
      throw new Error("No filter specified");
    }
    if (typeof filter2.cursor !== "string" && typeof filter2.timestamp !== "number") {
      throw new Error("No cursor or timestamp given");
    }
    return this.storage.getChanges(filter2);
  }
};

// node_modules/acebase/dist/esm/storage/custom/local-storage/settings.js
var LocalStorageSettings = class extends StorageSettings {
  constructor(settings) {
    super(settings);
    this.temp = false;
    this.multipleTabs = false;
    if (typeof settings.temp === "boolean") {
      this.temp = settings.temp;
    }
    if (typeof settings.provider === "object") {
      this.provider = settings.provider;
    }
    if (typeof settings.multipleTabs === "boolean") {
      this.multipleTabs = settings.multipleTabs;
    }
    if (typeof settings.logLevel === "string") {
      this.logLevel = settings.logLevel;
    }
    if (typeof settings.sponsor === "boolean") {
      this.sponsor = settings.sponsor;
    }
    ["type", "ipc", "path"].forEach((prop) => {
      if (prop in settings) {
        console.warn(`${prop} setting is not supported for AceBase LocalStorage`);
      }
    });
  }
};

// node_modules/acebase/dist/esm/storage/custom/local-storage/transaction.js
var LocalStorageTransaction = class extends CustomStorageTransaction {
  constructor(context, target) {
    super(target);
    this.context = context;
    this._storageKeysPrefix = `${this.context.dbname}.acebase::`;
  }
  async commit() {
  }
  async rollback(err) {
  }
  async get(path3) {
    const json = this.context.localStorage.getItem(this.getStorageKeyForPath(path3));
    const val = JSON.parse(json);
    return val;
  }
  async set(path3, val) {
    const json = JSON.stringify(val);
    this.context.localStorage.setItem(this.getStorageKeyForPath(path3), json);
  }
  async remove(path3) {
    this.context.localStorage.removeItem(this.getStorageKeyForPath(path3));
  }
  async childrenOf(path3, include, checkCallback, addCallback) {
    const pathInfo = CustomStorageHelpers.PathInfo.get(path3);
    for (let i = 0; i < this.context.localStorage.length; i++) {
      const key = this.context.localStorage.key(i);
      if (!key.startsWith(this._storageKeysPrefix)) {
        continue;
      }
      const otherPath = this.getPathFromStorageKey(key);
      if (pathInfo.isParentOf(otherPath) && checkCallback(otherPath)) {
        let node;
        if (include.metadata || include.value) {
          const json = this.context.localStorage.getItem(key);
          node = JSON.parse(json);
        }
        const keepGoing = addCallback(otherPath, node);
        if (!keepGoing) {
          break;
        }
      }
    }
  }
  async descendantsOf(path3, include, checkCallback, addCallback) {
    const pathInfo = CustomStorageHelpers.PathInfo.get(path3);
    for (let i = 0; i < this.context.localStorage.length; i++) {
      const key = this.context.localStorage.key(i);
      if (!key.startsWith(this._storageKeysPrefix)) {
        continue;
      }
      const otherPath = this.getPathFromStorageKey(key);
      if (pathInfo.isAncestorOf(otherPath) && checkCallback(otherPath)) {
        let node;
        if (include.metadata || include.value) {
          const json = this.context.localStorage.getItem(key);
          node = JSON.parse(json);
        }
        const keepGoing = addCallback(otherPath, node);
        if (!keepGoing) {
          break;
        }
      }
    }
  }
  getPathFromStorageKey(key) {
    return key.slice(this._storageKeysPrefix.length);
  }
  getStorageKeyForPath(path3) {
    return `${this._storageKeysPrefix}${path3}`;
  }
};

// node_modules/acebase/dist/esm/storage/custom/local-storage/index.js
function createLocalStorageInstance(dbname, init = {}) {
  const settings = new LocalStorageSettings(init);
  const ls = settings.provider ? settings.provider : settings.temp ? localStorage : sessionStorage;
  const storageSettings = new CustomStorageSettings({
    name: "LocalStorage",
    locking: true,
    removeVoidProperties: settings.removeVoidProperties,
    maxInlineValueSize: settings.maxInlineValueSize,
    async ready() {
    },
    async getTransaction(target) {
      const context = {
        debug: true,
        dbname,
        localStorage: ls
      };
      const transaction = new LocalStorageTransaction(context, target);
      return transaction;
    }
  });
  const db = new AceBase(dbname, { logLevel: settings.logLevel, storage: storageSettings, sponsor: settings.sponsor });
  db.settings.ipcEvents = settings.multipleTabs === true;
  return db;
}

// node_modules/acebase/dist/esm/acebase-local.js
var AceBaseLocalSettings = class extends AceBaseBaseSettings {
  constructor(options = {}) {
    super(options);
    if (options.storage) {
      this.storage = options.storage;
      if (options.ipc) {
        this.storage.ipc = options.ipc;
      }
      if (options.transactions) {
        this.storage.transactions = options.transactions;
      }
    }
  }
};
var AceBase = class extends AceBaseBase {
  constructor(dbname, init = {}) {
    const settings = new AceBaseLocalSettings(init);
    super(dbname, settings);
    this.recovery = {
      repairNode: async (path3, options) => {
        await this.ready();
        if (this.api.storage instanceof AceBaseStorage) {
          await this.api.storage.repairNode(path3, options);
        } else if (!this.api.storage.repairNode) {
          throw new Error(`repairNode is not supported with chosen storage engine`);
        }
      },
      repairNodeTree: async (path3) => {
        await this.ready();
        const storage = this.api.storage;
        await storage.repairNodeTree(path3);
      }
    };
    const apiSettings = {
      db: this,
      settings
    };
    this.api = new LocalApi(dbname, apiSettings, () => {
      this.emit("ready");
    });
  }
  async close() {
    await this.api.storage.close();
  }
  get settings() {
    const ipc = this.api.storage.ipc, debug = this.debug;
    return {
      get logLevel() {
        return debug.level;
      },
      set logLevel(level) {
        debug.setLevel(level);
      },
      get ipcEvents() {
        return ipc.eventsEnabled;
      },
      set ipcEvents(enabled) {
        ipc.eventsEnabled = enabled;
      }
    };
  }
  static WithLocalStorage(dbname, settings = {}) {
    const db = createLocalStorageInstance(dbname, settings);
    return db;
  }
  static WithIndexedDB(dbname, init = {}) {
    throw new Error(`IndexedDB storage can only be used in browser contexts`);
  }
};

// src/utils/file.ts
var fs3 = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
function ensureDirectoryExistence(filePath) {
  var dirname = import_path2.default.dirname(filePath);
  if (fs3.existsSync(dirname)) {
    return;
  }
  ensureDirectoryExistence(dirname);
  fs3.mkdirSync(dirname);
}

// src/stores/index.ts
var import_os = __toESM(require("os"));
var import_path3 = __toESM(require("path"));
var storePath = import_path3.default.join(import_os.default.homedir(), ".w3-cli", "store");
ensureDirectoryExistence(import_path3.default.join(storePath, "ballpark.json"));
var storeConfig = {
  logLevel: "error",
  storage: { path: storePath },
  sponsor: true
};
var store = new AceBase("w3-cli-store", storeConfig);

// src/repos/account.ts
var AccountRepo = class {
  constructor(_store) {
    this.node = "global/accounts";
    this.store = _store;
  }
  count() {
    return __async(this, null, function* () {
      return yield this.store.ref(this.node).count();
    });
  }
  getAllAccounts() {
    return __async(this, null, function* () {
      const accounts = (yield this.store.ref(this.node).get()).val();
      return accounts;
    });
  }
  getAccountByIndex(index) {
    return __async(this, null, function* () {
      const accounts = yield this.getAllAccounts();
      return accounts[index];
    });
  }
  getAccountByLabel(label) {
    return __async(this, null, function* () {
      const matchedAccounts = yield this.store.ref(this.node).query().filter("label", "==", label).get();
      if (matchedAccounts.length == 0) {
        throw new Error(`Account with label ${label} not found`);
      }
      const val = matchedAccounts[0].val();
      if (val == null) {
        throw new Error(`Account with label ${label} not found`);
      }
      return val;
    });
  }
  addAccounts(accounts) {
    return __async(this, null, function* () {
      const addedAccounts = yield this.getAllAccounts();
      if (addedAccounts != null) {
        for (const newAccount of accounts) {
          const found = addedAccounts.find((account) => account.label == newAccount.label);
          if (found) {
            throw new Error(`Account with label ${newAccount.label} already exists`);
          }
        }
      }
      yield this.store.ref(this.node).set(accounts);
    });
  }
};

// src/cmds/account/index.ts
var import_ethers = __toESM(require_lib32());
var AccountCmd = class {
  constructor(accountRepo2, spinner2) {
    this.accountRepo = accountRepo2;
    this.spinner = spinner2;
    this.cmd = new Command("account");
    this.cmd.description("Add and remove key accounts");
    this.cmd.command("add").requiredOption("-l, --label <label> Label to the adding account").option("-k, --key <key> Key of the adding account").action((options) => __async(this, null, function* () {
      this.spinner.start(`Adding a new ${options.label} account`);
      let signer;
      if (!options.key) {
        signer = import_ethers.ethers.Wallet.createRandom();
        options.key = signer.privateKey;
      } else {
        signer = new import_ethers.ethers.Wallet(options.key);
      }
      yield this.accountRepo.addAccounts([
        {
          label: options.label,
          address: signer.address,
          key: options.key
        }
      ]);
      this.spinner.succeed(`${options.label} has been added`);
    }));
    this.cmd.command("list").action(() => __async(this, null, function* () {
      const accounts = yield this.accountRepo.getAllAccounts();
      console.table(
        accounts.map((account) => ({
          label: account.label,
          address: account.address,
          key: "*****"
        }))
      );
    }));
  }
  getCmdInstance() {
    return this.cmd;
  }
};

// src/repos/config.ts
var ConfigRepo = class {
  constructor(_store) {
    this.node = "global/configs";
    this.store = _store;
  }
  count() {
    return __async(this, null, function* () {
      return yield this.store.ref(this.node).count();
    });
  }
  getAllConfigs() {
    return __async(this, null, function* () {
      const configs = (yield this.store.ref(this.node).get()).val();
      return configs;
    });
  }
  getConfigByIndex(index) {
    return __async(this, null, function* () {
      const accounts = yield this.getAllConfigs();
      return accounts[index];
    });
  }
  getConfigByKey(key) {
    return __async(this, null, function* () {
      const matchedConfig = yield this.store.ref(this.node).query().filter("key", "==", key).get();
      if (matchedConfig.length == 0) {
        throw new Error(`Config with key ${key} not found`);
      }
      const val = matchedConfig[0].val();
      if (val == null) {
        throw new Error(`Config with key ${key} not found`);
      }
      return val;
    });
  }
  addConfigs(newConfigs) {
    return __async(this, null, function* () {
      const addedConfigs = yield this.getAllConfigs();
      if (addedConfigs != null) {
        for (const newConfig of newConfigs) {
          const found = addedConfigs.find((config) => config.key == newConfig.key);
          if (found) {
            throw new Error(`Config with key ${newConfig.key} already exists`);
          }
        }
      }
      yield this.store.ref(this.node).set(newConfigs);
    });
  }
};

// src/cmds/config/index.ts
var ConfigCmd = class {
  constructor(configRepo2, spinner2) {
    this.configRepo = configRepo2;
    this.spinner = spinner2;
    this.cmd = new Command("config");
    this.cmd.description("Add/remove/list configurations");
    this.cmd.command("add").requiredOption("-k, --key <key> Key of the adding config").requiredOption("-v, --value <value> Value of the adding config").action((options) => __async(this, null, function* () {
      this.spinner.start(`Adding ${options.key} config`);
      yield this.configRepo.addConfigs([
        {
          key: options.key,
          value: options.value
        }
      ]);
      this.spinner.succeed(`${options.key} has been added`);
    }));
    this.cmd.command("list").action(() => __async(this, null, function* () {
      const configs = yield this.configRepo.getAllConfigs();
      console.table(
        configs.map((c3) => ({
          key: c3.key,
          value: c3.value
        }))
      );
    }));
  }
  getCmdInstance() {
    return this.cmd;
  }
};

// src/utils/time.ts
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

// src/entities/chain-info.ts
var import_ethers2 = __toESM(require_lib32());
var chain_info_default = {
  1: {
    name: "mainnet",
    rpcUrl: "https://eth.llamarpc.com",
    jsonRpcProvider: new import_ethers2.ethers.providers.JsonRpcProvider("https://eth.llamarpc.com"),
    nativeSymbol: "ETH"
  },
  42161: {
    name: "arbitrum",
    rpcUrl: "https://arbitrum-one.publicnode.com",
    jsonRpcProvider: new import_ethers2.ethers.providers.JsonRpcProvider("https://arbitrum-one.publicnode.com"),
    nativeSymbol: "ETH"
  },
  421613: {
    name: "arbitrum_goerli",
    rpcUrl: "https://arbitrum-goerli.publicnode.com",
    jsonRpcProvider: new import_ethers2.ethers.providers.JsonRpcProvider("https://arbitrum-goerli.publicnode.com"),
    nativeSymbol: "ETH"
  }
};

// src/cmds/1inch/index.ts
var import_ethers5 = __toESM(require_lib32());

// src/abis/ERC20.json
var abi = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];

// src/wrappers/MulticallWrapper/index.ts
var import_ethers3 = __toESM(require_lib32());

// src/abis/Multicall3.json
var abi2 = [
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate",
    outputs: [
      { internalType: "uint256", name: "blockNumber", type: "uint256" },
      { internalType: "bytes[]", name: "returnData", type: "bytes[]" }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bool", name: "allowFailure", type: "bool" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call3[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bool", name: "allowFailure", type: "bool" },
          { internalType: "uint256", name: "value", type: "uint256" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call3Value[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3Value",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "blockAndAggregate",
    outputs: [
      { internalType: "uint256", name: "blockNumber", type: "uint256" },
      { internalType: "bytes32", name: "blockHash", type: "bytes32" },
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "getBasefee",
    outputs: [{ internalType: "uint256", name: "basefee", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }],
    name: "getBlockHash",
    outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getBlockNumber",
    outputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getChainId",
    outputs: [{ internalType: "uint256", name: "chainid", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockCoinbase",
    outputs: [{ internalType: "address", name: "coinbase", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockDifficulty",
    outputs: [{ internalType: "uint256", name: "difficulty", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockGasLimit",
    outputs: [{ internalType: "uint256", name: "gaslimit", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockTimestamp",
    outputs: [{ internalType: "uint256", name: "timestamp", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "addr", type: "address" }],
    name: "getEthBalance",
    outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastBlockHash",
    outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bool", name: "requireSuccess", type: "bool" },
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryAggregate",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bool", name: "requireSuccess", type: "bool" },
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryBlockAndAggregate",
    outputs: [
      { internalType: "uint256", name: "blockNumber", type: "uint256" },
      { internalType: "bytes32", name: "blockHash", type: "bytes32" },
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  }
];

// src/wrappers/MulticallWrapper/index.ts
var MulticallWrapper = class {
  constructor(_multicallAddress, _signerOrProvider) {
    this.multicallInstance = new import_ethers3.ethers.Contract(_multicallAddress, abi2, _signerOrProvider);
  }
  multiContractCall(calls, contractCallOptions) {
    return __async(this, null, function* () {
      let blockNumber = void 0;
      if (contractCallOptions)
        blockNumber = contractCallOptions.blockNumber;
      return this._multiCall(calls, blockNumber);
    });
  }
  _multiCall(calls, blockNumber) {
    return __async(this, null, function* () {
      try {
        const calldata = calls.map((call) => {
          return {
            target: call.contract.address.toLowerCase(),
            callData: call.contract.interface.encodeFunctionData(call.function, call.params)
          };
        });
        const { returnData } = yield this.multicallInstance.callStatic.aggregate(calldata, {
          blockTag: blockNumber
        });
        const res = returnData.map((call, i) => {
          const result = calls[i].contract.interface.decodeFunctionResult(calls[i].function, call);
          if (result.length === 1)
            return result[0];
          return result;
        });
        return res;
      } catch (error) {
        throw new Error(error);
      }
    });
  }
};

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray2 = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop4 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length3 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length3 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray2,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop4,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path3, key, dots) {
  if (!path3)
    return key;
  return path3.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path3) {
    let arr = value;
    if (value && !path3 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path3, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path3) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path3.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path3,
        exposedHelpers
      );
      if (result === true) {
        build(el, path3 ? path3.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode3(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode3);
  } : encode3;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode4(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode4;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url = __toESM(require("url"), 1);
var URLSearchParams_default = import_url.default.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new node_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path3, helpers) {
      if (node_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path3, value, target, index) {
    let name = path3[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path3.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path3, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: node_default.classes.FormData,
    Blob: node_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_util2 = __toESM(require("util"), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
var import_zlib = __toESM(require("zlib"), 1);

// node_modules/axios/lib/env/data.js
var VERSION = "1.4.0";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || node_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
var import_stream4 = __toESM(require("stream"), 1);

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream = __toESM(require("stream"), 1);

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, args);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp));
    }
  };
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends import_stream.default.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const self2 = this;
    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    const _speedometer = speedometer_default(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle_default(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      const rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred;
      process.nextTick(() => {
        self2.emit("progress", {
          "loaded": bytesTransferred,
          "total": totalBytes,
          "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
          "bytes": progressBytes,
          "rate": rate ? rate : void 0,
          "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
        });
      });
    }, internals.ticksRate);
    const onFinish = () => {
      internals.updateProgress(true);
    };
    this.once("end", onFinish);
    this.once("error", onFinish);
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const self2 = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      if (internals.isCaptured) {
        internals.updateProgress();
      }
      if (self2.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
  setLength(length3) {
    this[kInternals].length = +length3;
    return this;
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
var import_events = __toESM(require("events"), 1);

// node_modules/axios/lib/helpers/formDataToStream.js
var import_util = require("util");
var import_stream2 = require("stream");

// node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = new import_util.TextEncoder();
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
};
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return import_stream2.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream3 = __toESM(require("stream"), 1);
var ZlibHeaderTransformStream = class extends import_stream3.default.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: import_zlib.default.constants.Z_SYNC_FLUSH,
  finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = node_default.protocols.map((protocol) => {
  return protocol + ":";
});
function dispatchBeforeRedirect(options) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = (0, import_proxy_from_env.getProxyForUrl)(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup && utils_default.isAsyncFn(lookup)) {
      lookup = callbackify_default(lookup, (entry) => {
        if (utils_default.isString(entry)) {
          entry = [entry, entry.indexOf(".") < 0 ? 6 : 4];
        } else if (!utils_default.isArray(entry)) {
          throw new TypeError("lookup async function must return an array [ip: string, family: number]]");
        }
        return entry;
      });
    }
    const emitter = new import_events.default();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, "http://localhost");
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = import_stream4.default.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const onDownloadProgress = config.onDownloadProgress;
    const onUploadProgress = config.onUploadProgress;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await import_util2.default.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils_default.isBlob(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = import_stream4.default.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = import_stream4.default.Readable.from(data, { objectMode: false });
      }
      data = import_stream4.default.pipeline([data, new AxiosTransformStream_default({
        length: contentLength,
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", (progress) => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path3;
    try {
      path3 = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path3,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      lookup,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? import_https.default : import_http.default;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream_default({
          length: utils_default.toFiniteNumber(responseLength),
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch (res.headers["content-encoding"]) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default());
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? import_stream4.default.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = import_stream4.default.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = node_default.isStandardBrowserEnv ? function standardBrowserEnv() {
  return {
    write: function write2(name, value, expires, path3, domain, secure) {
      const cookie = [];
      cookie.push(name + "=" + encodeURIComponent(value));
      if (utils_default.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils_default.isString(path3)) {
        cookie.push("path=" + path3);
      }
      if (utils_default.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read2(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write2() {
    },
    read: function read2() {
      return null;
    },
    remove: function remove() {
    }
  };
}();

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = node_default.isStandardBrowserEnv ? function standardBrowserEnv2() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url2) {
    let href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin(requestURL) {
    const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin() {
    return true;
  };
}();

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData)) {
      if (node_default.isStandardBrowserEnv || node_default.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request2 = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    if (node_default.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin_default(fullPath)) && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && node_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length3 } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length3; i++) {
      nameOrAdapter = adapters[i];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c3) {
      cancel = c3;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  mergeConfig: mergeConfig2
} = axios_default;

// src/wrappers/1inchWrapper/index.ts
var import_ethers4 = __toESM(require_lib32());

// src/utils/string.ts
function equalIgnoreCase(str1, str2) {
  return str1.toLowerCase() === str2.toLowerCase();
}

// src/wrappers/1inchWrapper/index.ts
var OneInchWrapper = class {
  constructor(_oneInchApiUrl, _chainId, _multiCallService, _signer, _protocols, _oneInchApiKey) {
    this.oneInchApiUrl = _oneInchApiUrl;
    this.signer = _signer;
    this.chainId = _chainId;
    this.multiCallService = _multiCallService;
    this.protocols = _protocols;
    this.oneInchApiKey = _oneInchApiKey;
  }
  spender() {
    return __async(this, null, function* () {
      const raw = yield axios_default.get(`${this.oneInchApiUrl}/${this.chainId}/approve/spender`, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.oneInchApiKey}`
        }
      });
      return raw.data;
    });
  }
  swapExactTokensForTokens(fromTokenAddress, toTokenAddress, path3, amountWei, slippageBps, confirmation = 3, overrides) {
    return __async(this, null, function* () {
      const fromToken = new import_ethers4.ethers.Contract(fromTokenAddress, abi, this.signer);
      const toToken = new import_ethers4.ethers.Contract(toTokenAddress, abi, this.signer);
      const signerAddress = yield this.signer.getAddress();
      const amountWeiBN = import_ethers4.ethers.BigNumber.from(amountWei);
      let nonce = yield this.signer.getTransactionCount();
      if (overrides && overrides.nonce) {
        nonce = overrides.nonce;
      }
      console.log("-------------");
      console.log("> Getting 1inch router address...");
      const oneInchSpender = yield this.spender();
      console.log("> Delay 1.5 secs...");
      yield sleep(1500);
      console.log("> Loading all tokens info...");
      const [fromTokenSymbol, fromTokenDecimals, fromTokenAllowance, toTokenSymbol, toTokenDecimals, toBefore] = yield this.multiCallService.multiContractCall([
        {
          contract: fromToken,
          function: "symbol"
        },
        {
          contract: fromToken,
          function: "decimals"
        },
        {
          contract: fromToken,
          function: "allowance",
          params: [signerAddress, oneInchSpender.address]
        },
        {
          contract: toToken,
          function: "symbol"
        },
        {
          contract: toToken,
          function: "decimals"
        },
        {
          contract: toToken,
          function: "balanceOf",
          params: [signerAddress]
        }
      ]);
      console.log("> Done.");
      console.log(`> ${import_ethers4.ethers.utils.formatUnits(amountWei, fromTokenDecimals)} ${fromTokenSymbol} -> ${toTokenSymbol}`);
      if (equalIgnoreCase(fromTokenAddress, toTokenAddress)) {
        console.log("> Same asset. No need swap.");
        return [
          {
            txHash: "Same asset. No need swap",
            fromTokenSymbol,
            fromTokenDecimals,
            fromTokenAmount: amountWeiBN,
            toTokenSymbol,
            toTokenDecimals,
            toTokenAmount: 0
          },
          nonce
        ];
      }
      if (amountWeiBN.eq(0)) {
        console.log("> 0 balance. No need swap.");
        return [
          {
            txHash: "0 balance. No need swap",
            fromTokenSymbol,
            fromTokenDecimals,
            fromTokenAmount: amountWeiBN,
            toTokenSymbol,
            toTokenDecimals,
            toTokenAmount: 0
          },
          nonce
        ];
      }
      console.log("> Check if one inch swap contract has allowance");
      if (fromTokenAllowance.lt(amountWei)) {
        console.log("> Approve one inch swap contract");
        const approveTx = yield fromToken.approve(oneInchSpender.address, import_ethers4.ethers.constants.MaxUint256, {
          nonce: nonce++
        });
        yield approveTx.wait(confirmation);
      }
      console.log("> Allowance ok");
      console.log("> Finding best price swap path through 1inch...");
      const oneInchData = (yield axios_default.get(`${this.oneInchApiUrl}/${this.chainId}/swap`, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.oneInchApiKey}`
        },
        params: {
          fromTokenAddress,
          toTokenAddress,
          amount: amountWeiBN.toString(),
          fromAddress: signerAddress,
          slippage: import_ethers4.ethers.utils.formatUnits(slippageBps, 2),
          protocols: this.protocols.length > 0 ? this.protocols.join(",") : null
        }
      })).data;
      console.log("> Delay 1.5 secs...");
      yield sleep(1500);
      const tx = {
        from: oneInchData.tx.from,
        to: oneInchData.tx.to,
        data: oneInchData.tx.data,
        gasLimit: oneInchData.tx.gas,
        gasPrice: parseInt(oneInchData.tx.gasPrice),
        nonce: nonce++
      };
      const swapTx = yield this.signer.sendTransaction(tx);
      console.log("> Sent swap transaction successfully");
      console.log(`> Waiting for ${confirmation} confirmation...`);
      const swapTxReceipt = yield swapTx.wait(confirmation);
      let toAfter = yield toToken.balanceOf(signerAddress);
      if (swapTxReceipt.status === 1) {
        console.log("> \u2705 Swap successfully");
        let receivedAmount = toAfter.sub(toBefore);
        console.log("> \u26D3 Tx hash:", swapTx.hash);
        while (receivedAmount.lt(0)) {
          console.log(`> \u26A0\uFE0F Received amount is less than 0. Retry...`);
          console.log(`> ${toBefore} -> ${toAfter}`);
          toAfter = yield toToken.balanceOf(signerAddress);
          receivedAmount = toAfter.sub(toBefore);
          if (receivedAmount.lt(0)) {
            console.log("> \u23F3 Waiting for 1 second to recalculate received amount");
            sleep(1e3);
          }
        }
        console.log(
          `> ${import_ethers4.ethers.utils.formatUnits(amountWei, fromTokenDecimals)} ${fromTokenSymbol} -> ${import_ethers4.ethers.utils.formatUnits(
            receivedAmount,
            toTokenDecimals
          )} ${toTokenSymbol}`
        );
        return [
          {
            txHash: swapTx.hash,
            fromTokenSymbol,
            fromTokenDecimals,
            fromTokenAmount: amountWeiBN,
            toTokenSymbol,
            toTokenDecimals,
            toTokenAmount: receivedAmount
          },
          nonce
        ];
      }
      throw new Error("Swap failed");
    });
  }
  getSwapData(fromTokenAddress, toTokenAddress, amount, fromAddress, toAddress, slippage) {
    return __async(this, null, function* () {
      const oneInchData = (yield axios_default.get(`${this.oneInchApiUrl}/${this.chainId}/swap`, {
        params: {
          fromTokenAddress,
          toTokenAddress,
          amount: amount.toString(),
          fromAddress,
          toAddress,
          slippage: slippage.toString(),
          disableEstimate: "true"
        }
      })).data;
      return oneInchData;
    });
  }
};

// src/cmds/1inch/index.ts
var OneInchCmd = class {
  constructor(accountRepo2, configRepo2, spinner2) {
    this.accountRepo = accountRepo2;
    this.configRepo = configRepo2;
    this.spinner = spinner2;
    this.cmd = new Command("1inch");
    this.cmd.description("Swap tokens on 1inch");
    this.cmd.command("twap").requiredOption("-c, --chain-id <chainId>", "Chain ID", parseInt).requiredOption("-ft, --fromToken <fromTokenAddress>", "The token to swap from").requiredOption("-tt, --toToken <toTokenAddress>", "The token to swap to").requiredOption("-a, --amount <amount>", "The amount to swap", parseFloat).requiredOption("-s, --signer <signerLabel>", "Signer to execute a transaction").action((opts) => __async(this, null, function* () {
      const chain = chain_info_default[opts.chainId];
      const signer = new import_ethers5.ethers.Wallet(
        (yield this.accountRepo.getAccountByLabel(opts.signer)).key,
        chain.jsonRpcProvider
      );
      const signerAddress = yield signer.getAddress();
      const fromToken = new import_ethers5.ethers.Contract(opts.fromToken, abi, signer);
      const toToken = new import_ethers5.ethers.Contract(opts.toToken, abi, signer);
      const multicallWrapper = new MulticallWrapper("0xcA11bde05977b3631167028862bE2a173976CA11", signer);
      const oneInchKey = (yield this.configRepo.getConfigByKey("1INCH_API_KEY")).value;
      const oneInchWrapper = new OneInchWrapper(
        "https://api.1inch.dev/swap/v5.2",
        opts.chainId,
        multicallWrapper,
        signer,
        [],
        oneInchKey
      );
      const [fromTokenSymbol, fromDecimals, toTokenSymbol, toDecimals] = yield Promise.all([
        fromToken.symbol(),
        fromToken.decimals(),
        toToken.symbol(),
        toToken.decimals()
      ]);
      const amountWei = import_ethers5.ethers.utils.parseUnits(opts.amount.toString(), fromDecimals);
      console.log(`> Twapping ${opts.amount} ${fromTokenSymbol} -> ${toTokenSymbol} per tx`);
      console.log(`> Signer: ${signerAddress}`);
      console.log(`> Running TWAP...`);
      while (1) {
        const [fromTokenBalance] = yield Promise.all([fromToken.balanceOf(signerAddress)]);
        const randFactor = true;
        if (randFactor) {
          const swapAmount = fromTokenBalance.lt(amountWei) ? fromTokenBalance : amountWei;
          try {
            yield oneInchWrapper.swapExactTokensForTokens(fromToken.address, toToken.address, [], swapAmount, 25, 3);
            console.log(`> \u{1F7E2} Done`);
          } catch (e) {
            console.log(`> \u{1F534} Something wrong!`);
            console.error(e);
            console.log(`> \u{1F7E1} Retry in the next execution`);
          }
        } else {
          console.log(`> \u{1F7E1} Skip this execution`);
        }
        console.log(`> \u{1F7E1} Sleep for 15 minutes`);
        yield sleep(9e5);
      }
    }));
  }
  getCmdInstance() {
    return this.cmd;
  }
};

// src/cmds/erc20/index.ts
var import_ethers6 = __toESM(require_lib32());
var Erc20Cmd = class {
  constructor(accountRepo2, spinner2) {
    this.accountRepo = accountRepo2;
    this.spinner = spinner2;
    this.cmd = new Command("erc20");
    this.cmd.description("Interact with ERC20 tokens");
    this.cmd.command("transfer").requiredOption("-c, --chain-id <chainId>", "Chain ID", parseInt).requiredOption("-t, --token <tokenAddress>", "Token address").requiredOption("-a, --amount <amount>", "The amount to transfer", parseFloat).requiredOption("-to, --to <toAddress>", "The address to transfer to").requiredOption("-s, --signer <signerLabel>", "Signer to execute a transaction").action((opts) => __async(this, null, function* () {
      const chain = chain_info_default[opts.chainId];
      const signer = new import_ethers6.ethers.Wallet(
        (yield this.accountRepo.getAccountByLabel(opts.signer)).key,
        chain.jsonRpcProvider
      );
      const multicallWrapper = new MulticallWrapper(
        "0xcA11bde05977b3631167028862bE2a173976CA11",
        chain.jsonRpcProvider
      );
      const token = new import_ethers6.ethers.Contract(opts.token, abi, signer);
      const tokenInfo = yield multicallWrapper.multiContractCall([
        { contract: token, function: "symbol" },
        { contract: token, function: "decimals" }
      ]);
      this.spinner.start(`Transferring ${opts.amount} ${tokenInfo[0]} to ${opts.to}`);
      const tx = yield token.transfer(opts.to, import_ethers6.ethers.utils.parseUnits(opts.amount.toString(), tokenInfo[1]));
      this.spinner.info(`\u26D3\uFE0F Tx hash: ${tx.hash}, waiting for confirmation`);
      yield tx.wait(3);
      this.spinner.succeed(`Transfer ${opts.amount} ${tokenInfo[0]} to ${opts.to} succeeded`);
    }));
  }
  getCmdInstance() {
    return this.cmd;
  }
};

// src/cmds/native/index.ts
var import_ethers7 = __toESM(require_lib32());
var NativeCmd = class {
  constructor(accountRepo2, spinner2) {
    this.accountRepo = accountRepo2;
    this.spinner = spinner2;
    this.cmd = new Command("native");
    this.cmd.description("Interact with a native token");
    this.cmd.command("transfer").requiredOption("-c, --chain-id <chainId>", "Chain ID", parseInt).requiredOption("-a, --amount <amount>", "The amount to transfer", parseFloat).requiredOption("-to, --to <toAddress>", "The address to transfer to").requiredOption("-s, --signer <signerLabel>", "Signer to execute a transaction").action((opts) => __async(this, null, function* () {
      const chain = chain_info_default[opts.chainId];
      const signer = new import_ethers7.ethers.Wallet(
        (yield this.accountRepo.getAccountByLabel(opts.signer)).key,
        chain.jsonRpcProvider
      );
      this.spinner.start(`Transferring ${opts.amount} ${chain.nativeSymbol} to ${opts.to}`);
      const tx = yield signer.sendTransaction({ to: opts.to, value: import_ethers7.ethers.utils.parseEther(opts.amount.toString()) });
      this.spinner.info(`\u26D3\uFE0F Tx hash: ${tx.hash}, waiting for confirmation`);
      yield tx.wait(3);
      this.spinner.succeed(`Transferred ${opts.amount} ${chain.nativeSymbol} to ${opts.to} succeeded`);
    }));
  }
  getCmdInstance() {
    return this.cmd;
  }
};

// src/index.ts
var program2 = new Command();
program2.description("A CLI for interacting with Web3 protocols");
program2.version(package_default.version);
var spinner = new Spinner();
var accountRepo = new AccountRepo(store);
var configRepo = new ConfigRepo(store);
var accountCmd = new AccountCmd(accountRepo, spinner);
var configCmd = new ConfigCmd(configRepo, spinner);
var oneInchCmd = new OneInchCmd(accountRepo, configRepo, spinner);
var erc20Cmd = new Erc20Cmd(accountRepo, spinner);
var nativeCmd = new NativeCmd(accountRepo, spinner);
program2.addCommand(accountCmd.getCmdInstance());
program2.addCommand(configCmd.getCmdInstance());
program2.addCommand(oneInchCmd.getCmdInstance());
program2.addCommand(erc20Cmd.getCmdInstance());
program2.addCommand(nativeCmd.getCmdInstance());
function main2() {
  return __async(this, null, function* () {
    yield store.ready();
    yield program2.parseAsync();
    yield store.close();
  });
}
main2();
process.on("unhandledRejection", (error) => {
  spinner.fail("Something went wrong");
  console.error(error);
});
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
